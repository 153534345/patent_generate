标题title
生成场景图像的方法、设备和存储介质
摘要abst
本申请提供一种生成场景图像的方法、设备和存储介质，方法包括，检测游戏对象的状态；若游戏对象处于运动状态，生成第一类场景图像，第一类场景图像呈现第一范围的游戏场景；若游戏对象处于非运动状态，生成第二类场景图像，第二类场景图像呈现第二范围的游戏场景；第一范围小于第二范围。本方案在游戏对象处于运动状态缩小场景图像所呈现的游戏场景的范围，减少设备生成一帧场景图像的计算量，从而降低游戏对象处于运动状态时设备的负载。
权利要求书clms
1.一种生成场景图像的方法，其特征在于，包括：检测游戏对象的状态；若所述游戏对象处于运动状态，生成第一类场景图像，所述第一类场景图像呈现第一范围的游戏场景；若所述游戏对象处于非运动状态，生成第二类场景图像，所述第二类场景图像呈现第二范围的游戏场景；所述第一范围小于所述第二范围。2.根据权利要求1所述的方法，其特征在于，所述生成第一类场景图像之前，还包括：顺序生成多帧场景图像；所述多帧场景图像所呈现的游戏场景的范围，在所述第一范围至所述第二范围之间按被生成的顺序依次缩小。3.根据权利要求1或2所述的方法，其特征在于，所述生成第一类场景图像包括：获得用于绘制第二类场景图像的对象信息；利用位于所述第一范围内的所述用于绘制第二类场景图像的对象信息，绘制得到第一类场景图像。4.根据权利要求1或2所述的方法，其特征在于，所述检测游戏对象的状态，包括：获得当前的场景绘制命令；所述场景绘制命令为用于绘制场景图像的绘制命令；将所述当前的场景绘制命令与预先获得的运动命令流进行匹配；所述运动命令流为所述游戏对象处于运动状态时获得的场景绘制命令；若所述当前的场景绘制命令与所述运动命令流匹配成功，检测出所述游戏对象处于运动状态；若所述当前的场景绘制命令与所述运动命令流匹配失败，检测出所述游戏对象处于非运动状态。5.根据权利要求1或2所述的方法，其特征在于，所述检测游戏对象的状态，包括：在预设时间段内获得多帧场景绘制命令；根据获得的每一帧所述场景绘制命令中游戏对象与场景图像中央坐标的距离，确定所述游戏对象在所述预设时间段内的速度；若所述游戏对象在所述预设时间段内的速度大于速度阈值，检测出所述游戏对象处于运动状态；若所述游戏对象在所述预设时间段内的速度小于或等于所述速度阈值，检测出所述游戏对象处于非运动状态。6.根据权利要求1或2所述的方法，其特征在于，所述生成第一类场景图像之前，还包括：确定所述游戏对象的速度所属的速度区间；若所述游戏对象的速度属于第一速度区间，执行所述生成第一类场景图像步骤；若所述游戏对象的速度属于第二速度区间，生成第三类场景图像；所述第三类场景图像呈现第三范围的游戏场景；所述第二速度区间的下限，大于所述第一速度区间的上限；所述第三范围小于所述第一范围。7.根据权利要求1至6任意一项所述的生成场景图像的方法，其特征在于，所述生成场景图像的方法应用于电子设备，所述电子设备的软件层包括匹配模块；所述检测游戏对象的状态，包括：所述匹配模块接收一帧场景绘制命令；所述匹配模块从内存读取运动命令流；所述匹配模块将所述运动命令流和所述一帧场景绘制命令进行匹配；若所述运动命令流和所述一帧场景绘制命令匹配成功，所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于运动状态；若所述运动命令流和所述一帧场景绘制命令匹配失败，所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于非运动状态。8.根据权利要求7所述的方法，其特征在于，所述电子设备的软件层还包括拉近模块；所述若所述游戏对象处于运动状态，生成第一类场景图像，包括：所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于运动状态后，所述匹配模块向所述拉近模块发送所述一帧场景绘制命令；所述拉近模块接收所述一帧场景绘制命令；所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像。9.根据权利要求8所述的方法，其特征在于，所述电子设备的软件层还包括送显接口；所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像后，所述拉近模块向所述送显接口发送所述第一类场景图像；所述送显接口在显示屏显示所述第一类场景图像。10.根据权利要求8所述的方法，其特征在于，所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像，包括：所述拉近模块创建临时帧缓冲和视图；所述临时帧缓冲的尺寸和所述视图的尺寸均与所述第一范围匹配；所述拉近模块从所述一帧场景绘制命令读取对象信息；所述拉近模块基于所述对象信息，所述临时帧缓冲和所述视图调用图形处理器，使所述图形处理器绘制得到所述第一类场景图像。11.根据权利要求7所述的方法，其特征在于，所述电子设备的软件层还包括回调模块和图形库；所述若所述游戏对象处于非运动状态，生成第二类场景图像，包括：所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于非运动状态后，所述匹配模块向所述回调模块发送所述一帧场景绘制命令；所述回调模块接收所述一帧场景绘制命令；所述回调模块向所述图形库回调所述一帧场景绘制命令；响应于所述回调模块回调所述一帧场景绘制命令，所述图形库根据所述一帧场景绘制命令生成所述第二类场景图像。12.根据权利要求7所述的方法，其特征在于，所述电子设备的软件层还包括识别模块；所述匹配模块接收一帧场景绘制命令之前，还包括：所述识别模块接收一帧绘制命令流；所述识别模块确定场景帧缓冲后，所述识别模块将所述一帧绘制命令流中存放在所述场景帧缓冲的绘制命令，确定为一帧场景绘制命令；所述识别模块判断所述内存是否存储有运动命令流；所述识别模块判断出所述内存存储有所述运动命令流后，所述识别模块向所述匹配模块发送所述一帧场景绘制命令。13.根据权利要求12所述的方法，其特征在于，所述识别模块确定场景帧缓冲，包括：所述识别模块接收前一帧绘制命令流；所述前一帧绘制命令流，为所述识别模块在所述一帧绘制命令流之前接收的另一帧绘制命令流；所述识别模块统计存放所述前一帧绘制命令流的多个帧缓冲中，除界面帧缓冲以外每一个帧缓冲存放的绘制命令的数量；所述界面帧缓冲，为所述多个帧缓冲中存放用户界面绘制命令的帧缓冲；所述用户界面绘制命令为所述绘制命令流中用于绘制用户界面图像的绘制命令；所述识别模块将所述多个帧缓冲中，除所述界面帧缓冲以外存放的绘制命令的数量最多的帧缓冲确定为所述场景帧缓冲。14.根据权利要求12所述的方法，其特征在于，所述电子设备的软件层还包括检测模块；所述识别模块判断所述内存是否存储有运动命令流之后，还包括：所述识别模块判断出所述内存未存储所述运动命令流后，所述识别模块向所述检测模块发送所述一帧场景绘制命令；所述检测模块接收所述一帧场景绘制命令；所述检测模块计算所述一帧场景绘制命令中游戏对象的速度；所述检测模块判断所述一帧场景绘制命令中游戏对象的速度是否大于预设的速度阈值；所述检测模块判断出所述一帧场景绘制命令中游戏对象的速度大于所述速度阈值后，所述检测模块根据所述一帧场景绘制命令确定所述运动命令流；所述检测模块将所述运动命令流存入所述内存。15.根据权利要求14所述的方法，其特征在于，所述检测模块计算所述一帧场景绘制命令中游戏对象的速度，包括：所述检测模块获取所述一帧场景绘制命令对应的时间戳和距离；所述一帧场景绘制命令对应的距离，为所述一帧场景绘制命令中游戏对象和图像中央坐标的距离；所述检测模块从内存读取前一帧场景绘制命令对应的时间戳和距离；所述前一帧场景绘制命令对应的距离，为所述前一帧场景绘制命令中游戏对象和图像中央坐标的距离；所述前一帧场景绘制命令，为所述识别模块在所述一帧场景绘制命令之前接收的另一帧场景绘制命令；所述检测模块用距离差值除以时间差值，得到所述一帧场景绘制命令中游戏对象的速度；所述距离差值为所述一帧场景绘制命令对应的距离和所述前一帧场景绘制命令对应的距离的差值；所述时间差值为所述一帧场景绘制命令对应的时间戳和所述前一帧场景绘制命令对应的时间戳的差值。16.根据权利要求14所述的方法，其特征在于，所述检测模块根据所述一帧场景绘制命令确定所述运动命令流，包括：所述检测模块从内存读出前N帧场景绘制命令；所述前N帧场景绘制命令中游戏对象的速度均大于所述速度阈值；所述前N帧场景绘制命令，为所述识别模块在所述一帧场景绘制命令之前接收的N帧场景绘制命令；所述N为预设的正整数；所述检测模块将所述一帧场景绘制命令和所述前N帧场景绘制命令均包含的绘制命令序列，确定为所述运动命令流；所述绘制命令序列为连续的多条场景绘制命令的集合。17.根据权利要求12所述的方法，其特征在于，所述电子设备还包括游戏应用和拦截模块；所述识别模块接收一帧绘制命令流之前，还包括：所述游戏应用输出所述一帧绘制命令流；所述拦截模块拦截所述游戏应用输出的所述一帧绘制命令流；所述拦截模块向所述识别模块发送所述一帧绘制命令流。18.一种电子设备，其特征在于，所述电子设备的硬件层包括：一个或多个处理器、存储器和显示屏；所述存储器用于存储一个或多个程序；所述一个或多个处理器用于执行所述一个或多个程序，使得电子设备执行以下动作：检测游戏对象的状态；若所述游戏对象处于运动状态，生成第一类场景图像，所述第一类场景图像呈现第一范围的游戏场景；若所述游戏对象处于非运动状态，生成第二类场景图像，所述第二类场景图像呈现第二范围的游戏场景；所述第一范围小于所述第二范围。19.一种计算机存储介质，其特征在于，用于存储计算机程序，所述计算机程序被执行时，具体用于实现如权利要求1至17任意一项所述的生成场景图像的方法。
说明书desc
技术领域本申请涉及图像处理技术领域，尤其涉及一种生成场景图像的方法、设备和存储介质。背景技术随着计算机技术的发展，终端设备上陆续出现了多种多样的电子游戏。在电子游戏中，用户可以操作游戏对象在游戏场景中活动，终端设备则需要根据用户操作实时地生成特定范围的游戏场景。当游戏场景快速变化时，终端设备就需要以较高频率持续获得并生成新的场景图像，导致终端设备的负载较高。发明内容本申请提供了一种生成场景图像的方法、设备和存储介质，目的在于解决运行电子游戏时设备负载高的问题。为了实现上述目的，本申请提供了以下技术方案：本申请第一方面提供一种生成场景图像的方法，包括：判断游戏对象是否处于运动状态；在游戏对象不处于运动状态时，生成第二类场景图像；在游戏对象处于运动状态时，生成第一类场景图像；第一类场景图像呈现的游戏场景的范围，小于第二类场景图像呈现的游戏场景的范围。上述方法的好处在于，在游戏对象处于运动状态时减小呈现的游戏场景的范围，从而减小电子设备生成场景图像所需的计算量，降低电子设备的负载。在一些可选的实施方式中，生成第一类场景图像之前，先生成呈现的游戏场景范围逐渐变小的多帧场景图像，使得电子设备呈现的游戏场景的范围从第二类场景图像对应的范围平滑变小至第一类场景图像对应的范围。上述实施方式的好处在于，在游戏对象处于运动状态时，平滑地减小电子设备呈现的游戏场景的范围，避免游戏场景的范围突变。在一些可选的实施方式中，生成第一类场景图像的方式为：获得绘制场景图像所用的对象信息；裁剪绘制场景图像所用的对象信息中位于第一范围外的部分，利用绘制场景图像所用的对象信息中位于第一范围内的部分绘制第一类场景图像。在一些可选的实施方式中，检测游戏对象的状态的方式为：获得当前的场景绘制命令；场景绘制命令是指用于绘制场景图像的绘制命令；将当前的场景绘制命令和运动命令流进行匹配；运动命令流为游戏对象处于运动状态时获得的场景绘制命令；若当前的绘制命令流与运动命令流匹配成功，检测出游戏对象处于运动状态；若当前的绘制命令流与运动命令流匹配失败，检测出游戏对象处于非运动状态。在一些可选的实施方式中，检测游戏对象的状态的方式为：获得一定时间内的多帧场景绘制命令；根据获得的每一帧场景绘制命令中游戏对象与游戏场景中物体的距离，计算游戏对象的速度；若游戏对象的速度大于速度阈值，检测出游戏对象处于运动状态；若游戏对象的速度不大于速度阈值，检测出游戏对象处于非运动状态。在一些可选的实施方式中，生成第一类场景图像之前，先确定游戏对象的速度；如果游戏对象的速度较小，继续生成第一类场景图像；如果游戏对象的速度较大，生成第三类场景图像；第三类场景图像呈现的游戏场景的范围，小于第一类场景图像呈现的游戏场景的范围。上述实施方式的好处在于，当游戏对象的速度较大时进一步减小电子设备呈现的游戏场景的范围，从而进一步降低电子设备的负载。在一些可选的实施方式中，所述生成场景图像的方法应用于电子设备，所述电子设备的软件层包括匹配模块；所述检测游戏对象的状态，包括：所述匹配模块接收一帧场景绘制命令；所述匹配模块从内存读取运动命令流；所述匹配模块将所述运动命令流和所述一帧场景绘制命令进行匹配；若所述运动命令流和所述一帧场景绘制命令匹配成功，所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于运动状态；若所述运动命令流和所述一帧场景绘制命令匹配失败，所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于非运动状态。在一些可选的实施方式中，所述电子设备的软件层还包括拉近模块；所述若所述游戏对象处于运动状态，生成第一类场景图像，包括：所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于运动状态后，所述匹配模块向所述拉近模块发送所述一帧场景绘制命令；所述拉近模块接收所述一帧场景绘制命令；所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像。在一些可选的实施方式中，所述电子设备的软件层还包括送显接口；所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像后，所述拉近模块向所述送显接口发送所述第一类场景图像；所述送显接口在显示屏显示所述第一类场景图像。在一些可选的实施方式中，所述拉近模块根据所述一帧场景绘制命令生成所述第一类场景图像，包括：所述拉近模块创建临时帧缓冲和视图；所述临时帧缓冲的尺寸和所述视图的尺寸均与所述第一范围匹配；所述拉近模块从所述一帧场景绘制命令读取对象信息；所述拉近模块基于所述对象信息，所述临时帧缓冲和所述视图调用图形处理器，使所述图形处理器绘制得到所述第一类场景图像。在一些可选的实施方式中，所述电子设备的软件层还包括回调模块和图形库；所述若所述游戏对象处于非运动状态，生成第二类场景图像，包括：所述匹配模块确定所述一帧场景绘制命令中，所述游戏对象处于非运动状态后，所述匹配模块向所述回调模块发送所述一帧场景绘制命令；所述回调模块接收所述一帧场景绘制命令；所述回调模块向所述图形库回调所述一帧场景绘制命令；响应于所述回调模块回调所述一帧场景绘制命令，所述图形库根据所述一帧场景绘制命令生成所述第二类场景图像。在一些可选的实施方式中，所述电子设备的软件层还包括识别模块；所述匹配模块接收一帧场景绘制命令之前，还包括：所述识别模块接收一帧绘制命令流；所述识别模块确定场景帧缓冲后，所述识别模块将所述一帧绘制命令流中存放在所述场景帧缓冲的绘制命令，确定为一帧场景绘制命令；所述识别模块判断所述内存是否存储有运动命令流；所述识别模块判断出所述内存存储有所述运动命令流后，所述识别模块向所述匹配模块发送所述一帧场景绘制命令。在一些可选的实施方式中，所述识别模块确定场景帧缓冲，包括：所述识别模块接收前一帧绘制命令流；所述前一帧绘制命令流，为所述识别模块在所述一帧绘制命令流之前接收的另一帧绘制命令流；所述识别模块统计存放所述前一帧绘制命令流的多个帧缓冲中，除界面帧缓冲以外每一个帧缓冲存放的绘制命令的数量；所述界面帧缓冲，为所述多个帧缓冲中存放用户界面绘制命令的帧缓冲；所述用户界面绘制命令为所述绘制命令流中用于绘制用户界面图像的绘制命令；所述识别模块将所述多个帧缓冲中，除所述界面帧缓冲以外存放的绘制命令的数量最多的帧缓冲确定为所述场景帧缓冲。在一些可选的实施方式中，所述电子设备的软件层还包括检测模块；所述识别模块判断所述内存是否存储有运动命令流之后，还包括：所述识别模块判断出所述内存未存储所述运动命令流后，所述识别模块向所述检测模块发送所述一帧场景绘制命令；所述检测模块接收所述一帧场景绘制命令；所述检测模块计算所述一帧场景绘制命令中游戏对象的速度；所述检测模块判断所述一帧场景绘制命令中游戏对象的速度是否大于预设的速度阈值；所述检测模块判断出所述一帧场景绘制命令中游戏对象的速度大于所述速度阈值后，所述检测模块根据所述一帧场景绘制命令确定所述运动命令流；所述检测模块将所述运动命令流存入所述内存。在一些可选的实施方式中，所述检测模块计算所述一帧场景绘制命令中游戏对象的速度，包括：所述检测模块获取所述一帧场景绘制命令对应的时间戳和距离；所述一帧场景绘制命令对应的距离，为所述一帧场景绘制命令中游戏对象和图像中央坐标的距离；所述检测模块从内存读取前一帧场景绘制命令对应的时间戳和距离；所述前一帧场景绘制命令对应的距离，为所述前一帧场景绘制命令中游戏对象和图像中央坐标的距离；所述前一帧场景绘制命令，为所述识别模块在所述一帧场景绘制命令之前接收的另一帧场景绘制命令；所述检测模块用距离差值除以时间差值，得到所述一帧场景绘制命令中游戏对象的速度；所述距离差值为所述一帧场景绘制命令对应的距离和所述前一帧场景绘制命令对应的距离的差值；所述时间差值为所述一帧场景绘制命令对应的时间戳和所述前一帧场景绘制命令对应的时间戳的差值。在一些可选的实施方式中，所述检测模块根据所述一帧场景绘制命令确定所述运动命令流，包括：所述检测模块从内存读出前N帧场景绘制命令；所述前N帧场景绘制命令中游戏对象的速度均大于所述速度阈值；所述前N帧场景绘制命令，为所述识别模块在所述一帧场景绘制命令之前接收的N帧场景绘制命令；所述N为预设的正整数；所述检测模块将所述一帧场景绘制命令和所述前N帧场景绘制命令均包含的绘制命令序列，确定为所述运动命令流；所述绘制命令序列为连续的多条场景绘制命令的集合。在一些可选的实施方式中，所述电子设备还包括游戏应用和拦截模块；所述识别模块接收一帧绘制命令流之前，还包括：所述游戏应用输出所述一帧绘制命令流；所述拦截模块拦截所述游戏应用输出的所述一帧绘制命令流；所述拦截模块向所述识别模块发送所述一帧绘制命令流。本申请第二方面提供一种电子设备，电子设备的硬件层包括：一个或多个处理器、存储器和显示屏；存储器用于存储一个或多个程序；一个或多个处理器用于执行一个或多个程序，使得电子设备执行以下动作：检测游戏对象的状态；若游戏对象处于运动状态，生成第一类场景图像，第一类场景图像呈现第一范围的游戏场景；若游戏对象处于非运动状态，生成第二类场景图像，第二类场景图像呈现第二范围的游戏场景；第一范围小于第二范围。本申请第三方面提供一种计算机存储介质，用于存储计算机程序，计算机程序被执行时，具体用于实现本申请第一方面任意一项提供的生成场景图像的方法。本申请提供一种生成场景图像的方法、设备和存储介质，方法包括，检测游戏对象的状态；若游戏对象处于运动状态，生成第一类场景图像，第一类场景图像呈现第一范围的游戏场景；若游戏对象处于非运动状态，生成第二类场景图像，第二类场景图像呈现第二范围的游戏场景；第一范围小于第二范围。本方案在游戏对象处于运动状态缩小场景图像呈现的游戏场景的范围，减少设备生成一帧场景图像的计算量，从而降低游戏对象处于运动状态时设备的负载。附图说明图1为本申请实施例公开的一种移动终端的结构示意图；图2为本申请实施例公开的一种生成场景图像的方法的原理示意图；图3为本申请实施例公开的执行生成场景图像的方法的设备硬件层和软件层结构示意图；图4a，图4b和图4c为本申请实施例公开的场景图像的示意图；图5为图3所示的应用框架层中各模块的具体工作过程的示例图；图6为本申请实施例公开的一种将场景图像所呈现场景的范围平滑缩小的方法；图7为本申请实施例公开的一种生成场景图像的方法流程图。具体实施方式本申请说明书和权利要求书及附图说明中的术语“第一”、“第二”和“第三”等是用于区别不同对象，而不是用于限定特定顺序。在本申请实施例中，“示例性的”或者“例如”等词用于表示作例子、例证或说明。本申请实施例中被描述为“示例性的”或者“例如”的任何实施例或设计方案不应被解释为比其它实施例或设计方案更优选或更具优势。确切而言，使用“示例性的”或者“例如”等词旨在以具体方式呈现相关概念。本申请所提供的生成场景图像的方法，可以智能手机，平板电脑，个人台式电脑或笔记本电脑等电子设备。其中，适用该方法的电子设备，其结构可以如图1所示。如图1所示，该电子设备可以包括处理器110，内部存储器120，显示屏130等。可以理解的是，本实施例示意的结构并不构成对该电子设备的具体限定。在另一些实施例中，该电子设备可以包括比图示更多或更少的部件，或者组合某些部件，或者拆分某些部件，或者不同的部件布置。图示的部件可以以硬件，软件或软件和硬件的组合实现。处理器110可以包括一个或多个处理单元，例如：处理器110可以包括应用处理器，调制解调处理器，图形处理器，图像信号处理器，控制器，视频编解码器，数字信号处理器，基带处理器，和/或神经网络处理器等。其中，不同的处理单元可以是独立的器件，也可以集成在一个或多个处理器中。例如，在本申请中，处理器110可以执行内部存储器存储的一个或多个程序，使得电子设备执行本申请实施例提供的生成场景图像的方法。处理器110中还可以设置存储器，用于存储命令和数据。在一些实施例中，处理器110中的存储器为高速缓冲存储器。该存储器可以保存处理器110刚用过或循环使用的命令或数据。如果处理器110需要再次使用该命令或数据，可从所述存储器中直接调用。避免了重复存取，减少了处理器110的等待时间，因而提高了系统的效率。内部存储器120可以用于存储计算机可执行程序代码，所述可执行程序代码包括命令。处理器110通过运行存储在内部存储器120的命令，从而执行该电子设备的各种功能应用以及数据处理。例如，在本实施例中，处理器110可以通过执行存储在内部存储器120中的命令，进行场景编排。内部存储器120可以包括存储程序区和存储数据区。其中，存储程序区可存储操作系统，至少一个功能所需的应用程序等。存储数据区可存储该电子设备使用过程中所创建的数据等。此外，内部存储器120可以包括高速随机存取存储器，还可以包括非易失性存储器，例如至少一个磁盘存储器件，闪存器件，通用闪存存储器等。处理器110通过运行存储在内部存储器120的命令，和/或存储在设置于处理器中的存储器的命令，执行该电子设备的各种功能应用以及数据处理。例如，在本申请中，存储器可以存储一个或多个程序，存储的程序被处理器执行时，能够实现本申请实施例提供的生成场景图像的方法。该电子设备通过GPU，显示屏130，以及应用处理器等实现生成功能。GPU为图像处理的微处理器，连接显示屏130和应用处理器。显示屏130用于生成图像，视频等。GPU用于执行数学和几何计算，用于图形渲染。处理器110可包括一个或多个GPU，其执行程序命令以生成或改变生成信息。该电子设备的显示屏130上可以生成一系列图形用户界面，用户可以通过直接操作图形用户界面与该电子设备交互。例如，在本申请实施例中，显示屏130可以生成虚拟按键。另外，在上述部件之上，运行有操作系统。例如苹果公司所开发的iOS操作系统，谷歌公司所开发的Android开源操作系统，微软公司所开发的Windows操作系统，以及鸿蒙系统等。在该操作系统上可以安装运行应用程序。为了方便理解，下面对本申请方案中的一些专业技术术语进行解释和说明：关于图形库：图形库也称为绘图库，图形库用于定义跨编程语言、跨平台的应用程序编程接口，其中包含许多对图形进行处理的函数，以OpenGL为例，OpenGL定义的API中包括用于绘制二维图像或三维图像的接口)，还包括将绘制函数绘制的图像呈现到显示界面上的接口)等，本申请实施例在此不进行一一举例。其中，OpenGL中的函数可以通过命令调用，例如，通过绘制命令可以调用绘制函数，以绘制二维图像或三维图像。该绘制命令是在游戏应用开发时开发人员根据图形库内的函数编写的命令，用于调用与绘制命令对应的图形库的接口。关于游戏图像：上文中所示，绘制命令调用绘制函数所绘制的二维图像或三维图像可以包括游戏图像，还包括其他类型的图像帧。具体地，游戏应用在运行过程中，是通过对一帧图像进行连续渲染和快速播放显示的。一帧游戏图像是游戏应用所显示的一帧静态图像。每一帧静态图像可以由场景图像和用户界面图像等组成。示例性地，场景图像可以包括游戏内风景、游戏人物、背景物体、特效、技能等，UI图像可以包括渲染控制按钮、小地图、悬浮文字等图像，有的游戏里人物血量条也包含在UI图像内。需要说明的是，不论是场景图像中游戏人物等，还是UI图像中的渲染控制按钮都可以认为是游戏图像帧中的对象，可以理解为，每个游戏图像帧是由一个个对象组成的。对于一帧游戏图像，构成该游戏图像的场景图像和UI图像可以分别存在两个帧缓冲中，例如，绘制好的UI图像存在FB0，绘制好的场景图像存在FB2，最后将FB0的UI图像和FB2的场景图像合并为一帧完整的游戏图像。关于绘制命令：游戏图像中的每个对象都是通过电子设备特定软件或者硬件执行绘制命令绘制获得的。一个对象可以由一条或者多条绘制命令绘制获得，一般情况下，一个对象与绘制命令一一对应。需要说明的是，每条绘制命令还包括其携带的特定参数，特定参数可以包括该绘制命令对应的对象的顶点信息，纹理信息等，顶点信息用于说明构成对应的对象的顶点的数量和位置，纹理信息则用于说明对应的对象表面需要填充的颜色或特定图案。例如顶点信息等。在电子设备执行该绘制命令时，基于其特定参数绘制该绘制命令对应的对象。关于绘制命令流：绘制命令流是由一条或者多条绘制命令组成的命令流，一个绘制命令流一般用于绘制一帧图像，具体地，GPU可以通过运行绘制命令流中的一条或者多条绘制命令，调用图形库的一个或多个接口，来实现对游戏图像中一个或多个对象进行绘制。需要说明的是，绘制命令所绘制的每个对象可以通过存储在内存中的数据表示。示例性地，根据该绘制命令流生成的绘制对象的集合可以组成对应的一帧游戏图像的显示数据。绘制命令流中一般包括三种绘制命令，如场景绘制命令、用户界面绘制命令以及图像送显命令等。场景绘制命令用于绘制前述场景图像，具体用于绘制游戏内风景、人物、特效、技能等图像等，UI绘制命令用于前述UI图像，例如用于绘制控制按钮、小地图、悬浮文字等图像，有的游戏里人物血量条也是由UI绘制命令绘制，需要说明的是，UI绘制命令也可以称为控件绘制命令。图像送显命令用于将绘制完成的图像数据放入系统指定位置，以便完成实际显示。以图1中处理器110包括CPU和GPU为例，对本申请实施例中绘制场景图像的过程进行说明。游戏启动后，CPU可以获得游戏输出的绘制命令流和渲染命令流，并将其中的绘制命令发送给GPU，以便于GPU根据绘制命令绘制对应的对象。作为一种示例，渲染命令中可以包括glBindFramebuffer函数，绘制命令可以包括glDrawElements函数，glDrawElementsInstanced函数。其中，glBindFramebuffer函数可以用于指示当前绑定的帧缓冲。如，glBindFramebuffer可以指示当前绑定的帧缓冲为FB1，即指示GPU在FB1上执行后续的绘制命令glDrawElements/glDrawElementsInstanced。为了便于说明，以下示例中，将绘制命令中，glDrawElement和glDrawElementsInstanced的集合称为绘制操作。图2为本申请提供的生成场景图像的方法的原理示意图。处理器获得第N帧游戏图像的绘制命令流后，识别出其中的场景绘制命令和非场景绘制命令，然后判断第N帧的场景绘制命令中游戏对象否处于运动状态，假设判断出第N帧的场景绘制命令中游戏对象处于非运动状态，于是利用非场景绘制命令绘制非场景图像并将绘制好的非场景图像送显，利用场景绘制命令绘制得到一帧第二类场景图像并送显，随后处理器将第二类场景图像和非场景图像合并得到第N帧游戏图像并显示在屏幕上。游戏对象，是用于表示游戏中受用户控制的人物的对象。之后处理器每获得一帧游戏图像的绘制命令均按上述方式处理，假设第N+1帧的场景绘制命令中游戏对象处于非运动状态，分别用第N+1帧的场景绘制命令绘制第二类场景图像，用非场景绘制命令绘制非场景图像，随后处理器将第二类场景图像和非场景图像合并得到第N+1帧游戏图像并显示在屏幕上。第二类场景图像，为呈现的场景范围为第二范围的场景图像。可以看出，电子设备通过屏幕上显示第N帧至第N+1帧游戏图像，可以向用户呈现第二范围内的游戏场景。当处理器后的第N+2帧的绘制命令流并识别出其中的场景绘制命令后，判断出第N+2帧的场景绘制命令中游戏对象处于运动状态，于是利用第N+2帧的非场景绘制命令绘制非场景图像并将绘制好的非场景图像送显，利用第N+2帧的场景绘制命令绘制得到一帧第一类场景图像并送显。假设第N+2帧的场景绘制命令至第N+X帧的场景绘制命令中游戏对象均处于运动状态，于是处理器依次利用第N+2帧至第N+X帧的场景绘制命令绘制出对应的第一类场景图像，并在屏幕上显示由第一类场景图像和对应的非场景图像合并得到的第N+2帧至第N+X帧游戏图像。第一类场景图像，为呈现的场景范围为第一范围的场景图像。可以看出，电子设备通过屏幕上显示第N+2帧至第N+X帧游戏图像，可以向用户呈现第一范围内的游戏场景。第一范围小于前述第二范围。在处理器获得第N+X+1帧的绘制命令流并识别出场景绘制命令后，判断出第N+X+1帧的场景绘制命令中游戏对象处于非运动状态，于是利用第N+X+1帧的场景绘制命令绘制出第二类场景图像。通过上述方法，电子设备就可以在游戏对象处于非运动状态时，向用户呈现第二范围的游戏内场景，在游戏对象处于运动状态时，向用户呈现第一范围的游戏内场景。参见图3，具体涉及本申请实施例提供的电子设备执行生成场景图像的方法的软件层和硬件层的框架图。本申请实施例提供的生成场景图像的方法的实施过程具体包括：在游戏应用启动后的一定时间内，识别模块根据游戏应用输出的前一帧或前几帧的绘制命令流，将存放场景绘制命令的帧缓冲确定为场景帧缓冲。此后，每获得一帧绘制命令流，识别模块将这一帧绘制命令流中，存放在场景帧缓冲的绘制命令识别为场景绘制命令，并将场景绘制命令送至检测模块。检测模块每收到一帧场景绘制命令，获得这一帧场景绘制命令对应的距离S和时间戳T并存在内存中，然后用这一帧场景绘制命令对应的距离S和时间戳T，以及内存中存储的之前的一帧或几帧场景绘制命令对应的距离S和时间戳T计算出这一帧场景绘制命令中游戏对象的速度并存入内存。场景绘制命令对应的距离，是指，场景绘制命令中，游戏对象和图像中央坐标之间的距离，该距离可以用图像中央坐标的深度表示。在检测出多帧场景绘制命令中游戏对象的速度均大于速度阈值后，检测模块通过比对这几帧场景绘制命令检测出运动命令流，将运动命令流写入内存。在内存中有运动命令流之后，每一帧场景绘制命令不送至检测模块，而送至匹配模块。匹配模块每获得一帧场景绘制命令，将这一帧场景绘制命令和内存中运动命令流匹配，若匹配成功，将这一帧场景绘制命令送至拉近模块，以便用这一帧场景绘制命令绘制出一帧第一类场景图像。下面结合图3对本申请提供的生成场景图像的方法进行具体说明。如图3所示，该电子设备可以包括软件层和硬件层303，软件层包括应用层301和系统框架层302。其中硬件层包括CPU，GPU和内存331。应用层301包括一个或多个可在电子设备上运行的应用，例如游戏应用304。为了方便理解，下文将以游戏应用304为例，对本申请所示方法进行解释和说明。游戏应用304包括游戏引擎341，游戏引擎341可通过图形库接口，调用图形库305内的绘制函数对游戏应用的图像进行绘制。系统框架层302可包括各种图形库305，例如嵌入式开放图形库等。相关技术中，用户打开游戏应用304时，电子设备响应于用户打开游戏的操作，启动游戏应用304。游戏引擎341基于游戏应用下发的游戏图像的绘制命令流，通过图形库接口，调用图形库内的绘制函数来绘制该游戏图像。图形库生成游戏图像的图像数据后，调用送显接口)，将图像数据发送给内存队列。图形库基于用于送显的周期性信号，将内存队列中的图像数据发送给硬件进行合成，最后将合成后的图像数据发送到电子设备的显示屏送显。如图3所示，游戏引擎输出的第N帧的绘制命令流传递到图形库305前，会被拦截模块306拦截，然后由拦截模块306传递至识别模块307，识别模块307则用于识别出绘制命令流中的场景绘制命令和非场景绘制命令，非场景绘制命令可以包括前述的UI绘制命令，还可以包括绘制命令流中除场景绘制命令和送显命令以外的绘制命令。第N帧的绘制命令流，是指，用于绘制第N帧的游戏图像的绘制命令流。拦截模块可以基于钩子技术拦截游戏引擎输出的绘制命令流。拦截模块具体的拦截方式为：游戏应用启动时，拦截模块修改游戏线程的线程本地存储中的函数指针列表，将该列表记录的图形函数指针，替换为替代指针。指向识别模块307的实现函数的指针预先配置在拦截模块中。图形函数指针，为指向图形库305的实现函数的函数指针；替代指针，为指向识别模块307的实现函数的函数指针。完成修改后，绘制命令流中指向图形函数指针的绘制命令，就会指向拦截模块中配置的替代函数指针，由此拦截模块就可以截获绘制命令流。拦截模块截获绘制命令流后，将绘制命令流传递给识别模块307。识别模块307配置的每一个实现函数，均与图形库305的实现函数相对应，下表1为图形库配置的部分实现函数，和识别模块中对应的实现函数的示例。表1其中，MyGlDrawElements和MyGlDrawElementsInstance也属于绘制操作。在一个具体的例子中，拦截模块可以将函数指针列表中指向图形库的实现函数glClear的函数指针glClear，替换为指向实现函数MyGlClear的函数指针MyGlClear。游戏应用输出的绘制命令流中调用函数指针glClear的绘制命令会转为调用函数指针MyGlClear，因此拦截模块就可以拦截到调用函数指针MyGlClear的绘制命令，然后拦截模块根据这条命令调用识别模块的实现函数MyGlClear。可选的，拦截模块拦截的绘制命令流可以用数组的形式记录并向其他模块传递。具体来说，拦截模块替换至函数指针列表中的每一个函数指针，均配置有索引插值功能。配置有索引插值功能的函数指针可以在每次调用对应的实现函数时，将被调用的实现函数的索引添加至一个用于记录绘制命令流的索引数组中，实现函数和索引的对应关系可以预先设置在拦截模块中，或者可以存储在内存331中，这样检测模块向后传递绘制命令流时，只需要传递对应的索引数组即可。例如，下述表2实现函数和索引的对应关系的示例：表2实现函数索引MyGlClear1MyGlActiveTexture2MyGlAlphaFunc3表2可以存储在拦截模块中，或者存储在内存中，存储在内存时，拦截模块在需要时可以从内存读取。拦截模块按表2记录的实现函数和索引的对应关系，将绘制命令流中每一条绘制命令转换为对应的索引，从而获得绘制命令流对应的索引数组，然后将索引数组存储在内存331中。表3游戏命令索引数组Game1MyGlClear/MyGlActiveTexture1，2Game2MyGlClear/MyGlAlphaFunc1，3表3为根据表2的对应关系转换得到的索引数组的示例。表3中，游戏Game1依次输出了调用MyGlClear的命令，以及调用MyGlActiveTexture，这两条命令到达拦截模块后，拦截模块根据表2的对应关系，将这两条命令转换为索引数组，然后将索引数组存储在内存中，同理，游戏Game2依次输出了调用MyGlClear的命令，以及调用MyGlAlphaFunc的命令，拦截模块根据表2的对应关系将这两条命令转换为索引数组，然后将索引数组存储在内存中。识别模块307可以针对图形库的每一个实现函数均配置对应的实现函数，也可以仅针对图形库中部分实现函数配置相对应的实现函数。识别模块307可以按如下方式识别场景绘制命令：在游戏启动后一段时间内，识别模块尚未确定存放场景绘制命令的帧缓冲。此时，识别模块可以直接将绘制命令流全部通过回调模块回调至图形库执行，然后在绘制命令流的命令逐条执行的过程中，统计除UI命令的帧缓冲以外每一个帧缓冲存放的绘制操作的数量，将其中对应的绘制操作的数量最多的帧缓冲确定为存放场景图像的帧缓冲。当识别模块已确定出存放场景绘制命令的帧缓冲时，识别模块可以将这个存放场景绘制命令的帧缓冲内存放的所有绘制操作识别为场景绘制命令。一个帧缓冲存放的绘制操作，是指位于这个帧缓冲对应的绑定命令MyglBindFrameBuffer之后，另一个帧缓冲对应的绑定命令MyglBindFrameBuffer之前的绘制操作。以帧缓冲FB1为例，识别模块确定出场景绘制命令存放在FB1后，可以将MyglBindFrameBuffer之后，MyglBindFrameBuffer之前的所有绘制操作识别为场景绘制命令，其中MyglBindFrameBuffer为FB1对应的绑定命令，MyglBindFrameBuffer为FBx对应的绑定命令，FBx为与FB1不同的另一个帧缓冲。比如，大部分游戏应用默认用FB0存放非场景图像，识别模块可以将MyglBindFrameBuffer及其后的绘制操作识别为非场景绘制命令，然后调用回调模块311将非场景绘制命令回调给图形库。而对于其他绑定帧缓冲的命令，即对于MyglBindFrameBuffer，识别模块识别到一条该命令后，就针对被绑定的帧缓冲建立一个初始值为0的计数器，如识别到MyglBindFrameBuffer后，建立一个FB2对应的初始值为0的计数器。然后，在该命令下每识别到一个绘制操作draw call，就将计数器加1，直至绑定一个新的帧缓冲为止，从而获得该帧缓冲对应的绘制操作的数量。比如识别到MyglBindFrameBuffer后，每识别到一个draw call就对FB2的计数器加1，直至识别到MyglBindFrameBuffer为止，此时FB2的计数器记录的数值，就是帧缓冲FB2对应的绘制操作数量。识别模块识别出场景绘制命令后，判断内存331中是否存有运动命令流，若当前内存331中没有运动命令流，可以将场景绘制命令传递给检测模块308，若当前内存331中已有运动命令流，可以将场景绘制命令传递给匹配模块309。在一个具体示例中，识别模块识别出场景绘制命令后，从内存读取运动命令流，若成功读取到运动命令，则判断出内存中有运动命令流，若未读取到运动命令流，则判断出内存中没有运动命令流。运动命令流，是指，游戏对象处于运动状态的多帧场景绘制命令中，重复出现次数最多的绘制命令序列，或者重复出现次数最多的绘制命令序列对应的索引数组。绘制命令序列，是指场景绘制命令中连续的多条绘制命令的集合，绘制命令序列中每一条绘制命令对应的索引构成的数组，就是绘制命令序列对应的索引数组。例如，一帧场景绘制命令可以包括绘制命令1至绘制命令100，其中绘制命令1至绘制命令4这四条绘制命令，就可以视为一个绘制命令序列。检测模块308每获得一帧的场景绘制命令，将场景绘制命令通过回调模块回调至图形库，在回调过程中获取这一帧的场景绘制命令对应的时间戳T，以及这一帧的场景绘制命令中游戏对象和图像中央坐标的距离S，并将这一帧的时间戳T和距离S存在内存中。所以检测模块308获得第N帧的场景绘制命令后，判断内存中是否存有第N-1帧的距离S和时间戳T，如果内存中有第N-1帧的距离S和时间戳T，检测模块从内存读取第N-1帧的距离S和时间戳T，然后结合第N帧的距离S和时间戳T，计算出第N帧的场景绘制命令中游戏对象的速度。其中，第N-1帧为第N帧之前的一帧。速度的计算方式为：用第N帧的距离S减去第N-1帧的距离S得到距离差值，用第N帧的时间戳T减去第N-1帧的时间戳T得到时间差值，最后用距离差值除以时间差值，得到第N帧的速度。若计算出第N帧的场景绘制命令的速度大于预设的速度阈值，则检测模块确定第N帧的场景绘制命令中游戏对象处于运动状态，若计算出第N帧的场景绘制命令的速度不大于预设的速度阈值，则检测模块确定第N帧的场景绘制命令中游戏对象处于非运动状态。速度阈值可以设定为5米每秒。一帧场景绘制命令对应的速度和状态由检测模块存储在内存331中。任一帧的场景绘制命令的时间戳，可以是根据场景绘制命令开始绘制场景图像时电子设备的系统时间，也可以是根据场景绘制命令绘制完场景图像绘制并送显时电子设备的系统时间。系统时间可以调用如下函数获得：gettimeofday。gettimeofday函数可以将被调用时的系统绝对时间存储在mTimeMyStart，而mTimeMyStart为一个timeval结构体，timeval结构体的形式如下：在调用gettimeofday之后，mTimeMyStart.tv_sec就是调用gettimeofday时的系统时间。所以，对于某一帧的场景绘制命令，可以在根据场景绘制命令开始绘制场景图像时,调用gettimeofday，然后将mTimeMyStart.tv_sec的值确定为这一帧的场景绘制命令的时间戳T。可选的，在第一人称视角射击游戏中，场景图像中游戏对象和图像中央坐标的距离，可以认为等于中央坐标的深度值，而一帧场景图像中央坐标x，y的深度值可以采用以下命令获取：glReadPixels；glReadPixels为电子设备中预先配置的一个用于读取指定范围内像素及其信息的函数，该指定范围为矩形，width和height为该矩形范围的长和宽，x，y为该矩形范围的起始点的坐标，如可以是该矩形范围左上角顶点的坐标或左下角顶点的坐标，通过将width和height均设置为1，就可以通过glReadPixels读取坐标x，y处的像素及其信息。GL_DEPTH_COMPONENT用于指定glReadPixels读取指定范围像素的深度值，在上述例子中，当width和height均设置为1时，读取到的就是坐标x，y处的像素的深度值。在3D游戏中游戏的场景图像的绘制方式是，从预设相机位置将位于三维坐标系的物体投影到二维平面上，从而获得由物体的投影构成的场景图像，因此，场景图像中的像素可以和三维坐标系中物体的特定点一一对应，像素的深度值，就是三维坐标中该像素对应的物体上的点与相机位置的距离。GL_FLOAT用于指定glReadPixels将读取到的深度值转换为浮点型变量，&amp;depth用于指定glReadPixels将读取到的深度值保存在depth这一变量中。因此在调用执行上述命令后，变量depth的值就是坐标x，y的深度值。如前文所述，检测模块每获得一帧场景绘制命令的游戏对象和图像中央坐标的距离S和时间戳T后，将这一帧场景绘制命令对应的距离S和时间戳T存在内存中。某一帧场景绘制命令中游戏对象的速度，还可以用该帧以及该帧之前一定时间内的一帧或多帧场景绘制命令的距离S和时间戳T来计算。例如，检测模块308可以通过第N帧场景绘制命令和第N-2帧场景绘制命令来计算第N帧场景绘制命令中游戏对象的速度。检测模块用第N-2帧场景绘制命令的距离S和第N帧场景绘制命令的距离S做差得到距离差值，然后用距离差值除以第N-2帧场景图像和第N帧场景图像的时间差值，得到第N帧场景图像中游戏对象的速度。第N-2帧场景图像和第N帧场景图像的时间差值，是指，第N-2帧场景图像的时间戳T，和第N帧场景图像的时间戳之间的差值。检测模块每获得一帧场景绘制命令，将这一帧的场景绘制命令复制一份，获得这一帧的两份场景绘制命令，其中的一份用于发送至回调模块或拉近模块，以便绘制出第N帧场景图像，另一份保存在内存331中。若检测模块检测出某一帧场景绘制命令中游戏对象处于非运动状态，就删除内存331中存储的这一帧场景绘制命令。可选的，检测模块在检测出一帧场景绘制命令中游戏对象处于运动状态时，再复制这一帧场景绘制命令并将复制的一帧场景绘制命令存入内存，若检测出这一帧场景绘制命令中游戏对象处于非运动状态，就不需要复制并存入内存，直接将这一帧场景绘制命令送至回调模块即可。检测模块在检测出连续的几帧场景绘制命令中游戏对象均处于运动状态时，从内存读出这几帧场景绘制命令，将这几帧场景绘制命令进行比对，从而识别出一段在这几帧场景绘制命令中均出现的命令序列，将这一段命令序列确定为运动命令流，然后将运动命令流写入内存331。或者，当内存中有每一帧场景绘制命令对应的索引数组时，检测模块可以比对这几帧场景绘制命令对应的索引数组，将几个索引数组中均出现的索引数组确定为运动命令流，然后将运动命令流写入内存331。在一个具体示例中，当检测模块检测出第N-4帧至第N帧场景绘制命令中游戏对象均处于运动状态之后，从内存读取第N-4帧至第N帧的场景绘制命令，然后比对第N-4帧至第N帧的场景绘制命令，通过比对发现第N-4帧至第N帧的场景绘制命令中，每一帧场景绘制命令都包含命令序列：，于是检测模块将确定为运动命令流，并将运动命令流存入内存。匹配模块309获得第N帧的场景绘制命令后，可以从内存331读取运动命令流，然后将运动命令流包含的每一条绘制命令和第N帧的场景绘制命令依次进行匹配。若两者匹配成功，匹配模块309可以判断出第N帧场景绘制命令中游戏对象处于运动状态，此时匹配模块将场景绘制命令传递至拉近模块，以调用拉近模块生成第一类场景图像，若两者匹配失败，匹配模块309可以判断出第N帧场景绘制命令中游戏对象处于非运动状态，此时匹配模块可以通过回调模块将场景绘制命令回调给图形库，通过图形库绘制第二类场景图像。匹配模块匹配运动命令流和第N帧场景绘制命令的方式为：匹配模块判断第N帧场景绘制命令中是否有运动命令流，若第N帧场景绘制命令中有运动命令流，则匹配模块确定运动命令流和第N帧场景绘制命令匹配成功，若第N帧场景绘制命令中没有运动命令流，则匹配模块确定运动命令流和第N帧场景绘制命令匹配失败。回调模块可以通过如下方式，将被拦截的绘制命令回调至图形库：回调模块可以备份前述函数指针列表中被替换的图形库指针。当回调模块获得绘制命令时，就可以通过这些被替换的图形库指针，继续调用图形库中这些图形库指针所指向的实现函数，实现绘制命令的回调。在本实施例中，回调模块可以在收到识别模块发送的UI绘制命令后，通过备份的图形库指针将UI绘制命令回调至图形库，以便用图形库中的实现函数绘制UI图像，或者，可以在收到识别模块发送的图像送显命令后，通过备份的图形库指针将图像送显命令回调至图形库，以便将图形库绘制出的图像送显，或者，回调模块可以在收到检测模块或匹配模块发送的场景绘制命令后，通过备份的图形库指针将场景绘制命令回调至图形库，以便用图形库中的实现函数绘制第二类场景图像。拉近模块生成第一类场景图像后，可以通过送显接口将第一类场景图像写入内存队列，最后由图形库将第一类场景图像和对应的UI图像合成为一帧游戏图像并显示在电子设备的显示屏上。拉近模块在生成第一类场景图像时，可以根据需要调用图形库中的部分实现函数。拉近模块具体可以通过如下方式生成第一类场景图像。拉近模块首先可以在第N帧场景绘制命令中读取用于绘制第N帧场景图像的对象信息，然后创建一个新的帧缓冲，新的帧缓冲可以记为临时帧缓冲FB4，用于存放第N帧场景绘制命令的帧缓冲记为FB2，FB2和FB4均存放在内存331中。FB4的尺寸和FB2的尺寸之比，为预设的比例Z。比如，Z可以设定为90％，则FB4的尺寸就是FB2的尺寸的90％。对象信息，可以包括前述顶点信息和纹理信息，通过调用特定的实现函数可以用对象信息绘制出对应的对象。可选的，上述新的帧缓冲FB4可以预先创建，拉近模块每次生成第一类场景图像时复用帧缓冲FB4，也可以由拉近模块在每次生成第一类场景图像时创建，生成结束后释放该帧缓冲，下次需要生成第一类场景图像时再创建。然后，拉近模块获得第一范围的视图，该视图可以预先创建，或者在使用时实时创建。第二范围的尺寸可以和电子设备的屏幕的尺寸一致，第一范围的尺寸可以是第二范围的尺寸与预设比例Z的乘积，比如比例Z为90％，则第一范围的尺寸就是第二范围的尺寸的90％。获得第一范围的视图后，拉近模块就可以调用GPU，在第一范围的视图内利用绘制原始对象信息绘制得到第一类场景图像。第一类场景图像的绘制过程如下：拉近模块基于FB4和原始对象信息调用GPU，GPU被调用后将对象信息写入FB4。在写入过程中，由于FB4的尺寸小于FB2的尺寸，所以GPU需要按前述第一范围的视图裁剪原始对象信息，然后将裁剪后的对象信息写入FB4中，写入对象信息的过程，就相当于绘制第一类场景图像的过程，写入完成后，FB4中对象信息的集合就相当于一帧第一类场景图像。原始对象信息，是指从第N帧场景绘制命令中读出，用于绘制第N帧场景图像的对象信息。GPU需要按第一范围的视图裁剪原始对象信息的过程是，GPU识别出位于第一范围的视图内的对象信息，保留这些位于第一范围的视图内的对象信息以将其写入FB4，并且，识别出位于第一范围的视图外的对象信息，丢弃这些位于第一范围的视图外的对象信息，也就是不将这些位于第一范围的视图外的对象信息写入FB4。完成FB4的写入后，拉近模块将FB4发送至送显接口送显。绘制好的第一类场景图像的尺寸小于电子设备的显示屏的尺寸，直接将该帧第一类场景图像显示在屏幕上会导致屏幕四周出现空白。所以送显接口送显之前，需要将绘制好的该帧第一类场景图像拉伸至与显示屏一致的尺寸。具体的，送显接口送显之前，将帧缓冲FB4存的第一类场景图像转存至原本用于存放第二类场景图像的帧缓冲FB2中，由于FB2尺寸大于FB4的尺寸，将FB4的场景图像转存到FB2时，送显接口会对FB4存的第一类场景图像进行插值，将FB4的场景图像的尺寸放大至FB2对应的尺寸，即放大至电子设备的显示屏的尺寸，最后将内存在FB2的放大后的第一类场景图像送显，从而在显示屏上显示出一帧与屏幕尺寸一致的第一类场景图像。请参考图4a，图4a为拉近模块获得的对象信息的示意图，图中的虚线框表示前述第一范围的视图，可以看出，对于上述对象信息对应的每一个对象，根据上述对象信息可以判断出该对象是否和第一范围的视图之间的位置关系，该位置关系包括对象全部位于视图内，对象全部位于视图外，对象的一部分位于视图内。如图4a中，对象401位于视图外，对象402和403的一部分位于视图内，对象404完全位于视图内。根据上述位置关系，GPU被拉近模块调用并绘制第一类场景图像时，对需要绘制的对象进行裁剪。请参考图4b，可以看到，在绘制第一类场景图像时，若对象信息对应的对象全部在视图外，则不绘制该对象，若对象信息对应的对象一部分位于视图外，一部分位于视图内，则绘制该对象位于视图内的部分，而不绘制视图外的部分，若对象信息对应的对象全部在视图内，则按对象信息完整绘制该对象，最后，如图4b所示，对象402和对象403位于第一范围内的部分，以及对象404，构成了第一范围的游戏场景，图4b就相当于一帧绘制好的第一类场景图像。图4b中的虚线框表示电子设备的显示屏的尺寸。最后，送显接口对图4b所示的第一类场景图像进行拉伸，从而获得如图4c所示的拉伸后的第一类场景图像，拉伸后的第一类场景图像与电子设备的显示屏的尺寸一致，然后送显接口将拉伸后的第一类场景图像显示在电子设备的显示屏上。为了避免被放大后图像中各对象的轮廓边缘出现明显锯齿，可以在绘制第一类场景图像前开启电子设备的多重采样抗锯齿功能，以便对绘制图像的过程进行优化，使绘制好的第一类场景图像中对象的轮廓边缘更平滑。本申请实施例所提供的生成场景图像的方法具有如下的有益效果：当游戏对象处于运动状态时，游戏对象周围的游戏场景中会快速地出现大量的新物体、这种情况下每绘制一帧游戏图像，特别是每绘制一帧场景图像，都需要将这些新物体投影得到的对象绘制在场景图像中，因此运动状态下绘制一帧场景图像所需的计算量相对高于非运动状态下绘制一帧场景图像的计算量，导致与游戏对象处于非运动状态时相比，游戏对象处于运动状态时电子设备的CPU，GPU和内存等器件均在高负载的状态下运行。而本实施例通过缩小运动状态下场景图像中所呈现场景的范围，可以在运动状态下，减少绘制一帧场景图像时所需要绘制的对象，从而减小绘制一帧场景图像所需的计算量。比如，绘制呈现第二范围场景的图4a时，需要绘制完整的对象401至404，相对的，绘制呈现第一范围场景的图4b，只需要绘制对象402和403的一部分和完整的对象404即可，显然绘制图4b所需的计算量小于绘制图4a所需的计算量。随着绘制一帧场景图像所需的计算量的降低，运动状态下电子设备各硬件的负载也能对应降低，从而避免电子设备的各器件持续在高负载下运行引起的设备卡顿、耗电过快等问题。进一步的，当游戏对象处于非运动状态时，本实施例提供的方法又可以将场景图像恢复为画面质量较高的第二类场景图像，给用户带来更好的用户体验。下面结合图5对本申请实施例提供的生成场景图像的方法进行进一步说明，图5为图3中系统框架层各模块的具体工作过程的示例图。游戏开始后，游戏应用输出绘制第一帧游戏画面的绘制命令流，拦截模块截获该绘制命令流并传递给识别模块。此时识别模块还未确定用于存放场景绘制命令的帧缓冲，所以识别模块将第1帧的绘制命令流传递至回调模块，通过回调模块回调图形库中绘制命令对应的实现函数，分别绘制出场景图像和非场景图像，同时，识别模块在第1帧的绘制命令流回调至图形库的过程中识别场景绘制命令所属的帧缓冲。图形库用第1帧的绘制命令流绘制场景图像和非场景图像，然后将场景图像和非场景图像送至送显接口，送显接口将场景图像和非场景图像合成为第1帧游戏图像，然后屏幕上显示第1帧游戏图像。为了方便起见，将构成第1帧游戏图像的场景图像记为第1帧场景图像，构成第1帧游戏图像的非场景图像记为第1帧非场景图像，下同。第1帧场景图像绘制完成后，检测模块可以在内存中存储第1帧场景图像中游戏对象和图像中央坐标的距离S，以及时间戳T，T为开始绘制第1帧场景图像时的系统时间。第1帧场景图像为第二类场景图像。游戏应用输出第1帧游戏画面的绘制命令流后，继续输出第2帧的绘制命令流。需要指出，游戏应用输出第2帧的绘制命令流时，第1帧游戏画面可能已经生成并显示，也可能还未显示。第2帧的绘制命令流被拦截模块截获并传递至识别模块时，识别模块根据场景绘制命令所属的帧缓冲，在第2帧的绘制命令流中识别场景绘制命令。随后，识别模块判断出内存中没有运动命令流，将第2帧的非场景绘制命令传递至回调模块，将第2帧的场景绘制命令传递至检测模块。检测模块获得第2帧的场景绘制命令后，将第2帧的场景绘制命令传递至回调模块。由此，图形库利用第2帧的非场景绘制命令绘制第2帧非场景图像，利用第2帧场景绘制命令绘制出第2帧场景图像，进而通过送显接口合成第2帧游戏图像并在屏幕显示。第2帧场景图像为第二类场景图像。检测模块在回调第2帧的场景绘制命令的过程中，获得并在内存中存储第2帧的场景绘制命令的距离S和时间戳T，利用S和T，以及内存中前一帧的距离和时间戳，即S和T计算游戏对象的速度。第2帧的场景绘制命令，距离S，时间戳T和游戏对象的速度均可以存在内存中。此后，拦截模块实时的拦截游戏应用输出的每一帧的绘制命令流，并通过识别模块将其中的场景绘制命令送至检测模块，以触发检测模块获得并存储每一帧的场景绘制命令的距离，时间戳和游戏对象的速度。检测模块在获得第N帧的场景绘制命令后，计算出第N帧的场景绘制命令中游戏对象的速度大于速度阈值，并且包括第N帧在内的连续5帧的场景绘制命令均大于速度阈值，于是检测模块从内存读取这5帧场景绘制命令，基于这5帧场景绘制命令提取并存储运动命令流。运动命令流存储在内存中。在拦截模块拦截的第N+1帧的绘制命令流到达识别模块时，识别模块判断出内存中有运动命令流，于是直接将第N+1帧的场景绘制命令送至匹配模块，匹配模块获得第N+1帧的场景绘制命令后，将第N+1帧的场景绘制命令与运动命令流匹配。第N+1帧的场景绘制命令与运动命令流匹配成功，匹配模块判断出第N+1帧场景绘制命令中游戏对象处于运动状态，于是将第N+1帧场景绘制命令送至拉近模块。拉近模块获得第N+1帧的场景绘制命令后，利用第N+1帧的场景绘制命令绘制第一类场景图像。拉近模块基于第N+1帧的场景绘制命令绘制的图像，为第N+1帧场景图像。拉近模块将绘制好的第N+1帧场景图像传递至送显接口，随后，送显接口将第N+1帧场景图像和第N+1帧非场景图像合并得到第N+1帧游戏图像，随后第N+1帧游戏图像在屏幕上显示。随后第N+2帧至第N+K-1帧的场景绘制命令均在匹配模块中与运动命令流匹配，且均匹配成功，因此第N+2帧至第N+K-1帧的场景绘制命令均送至拉近模块，由拉近模块按第一范围绘制得到的第一类场景图像。第N+K帧的场景绘制命令到达匹配模块后，匹配模块将第N+K帧的场景绘制命令与运动命令流匹配，结果为匹配失败，于是匹配模块将第N+K帧的场景绘制命令发送至回调模块，由回调模块将第N+K帧的场景绘制命令回调至图形库，通过图形库绘制出第N+K帧的场景图像，此时绘制出的第N+K帧的场景图像属于第二类场景图像。第N+K帧场景图像再和第N+K帧非场景图像合并得到第N+K帧游戏图像，并显示在屏幕上。可见，在图5所示的交互流程中，电子设备在游戏开始后显示的第1帧至第N帧游戏图像，呈现第二范围的场景，而显示的第N+1帧至第N+K-1帧游戏图像，由于游戏对象处于运动状态，所以游戏图像呈现第一范围的场景，显示第N+K帧游戏图像时，游戏对象又进入非运动状态，于是游戏图像呈现第二范围的场景。在第N+K帧绘制命令流之后，游戏应用每输出一帧的绘制命令流，其中的场景绘制命令就会被识别模块识别出来并传递至匹配模块，匹配模块根据匹配后的结果将这一帧场景绘制命令送至拉近模块或回调模块，从而在游戏对象处于运动状态时绘制并显示第一类场景画面，在游戏对象处于非运动状态时绘制并显示第二类场景画面。直至本次游戏结束。在一种可选的实现方式中，当内存中还未存储运动命令流时，检测模块也可以在每次获得绘制一帧场景图像的场景绘制命令后，判断前一帧绘制好的场景图像中游戏对象的速度是否大于速度阈值，若大于就将该场景绘制命令送至拉近模块，使拉近模块按第一范围绘制该帧场景图像，若不大于就将该场景绘制命令送至回调模块。在另一种可选的实现方式中，也可以不设置匹配模块，每一帧的场景绘制命令均发送至检测模块。在该实现方式中，每有一帧场景图像由图形库或拉近模块绘制完成，检测模块就按前述方法计算该帧场景图像中游戏对象的速度，然后在下一帧的场景绘制命令传递到检测模块时，检测模块就可以根据刚绘制好的前一帧场景图像中游戏对象的速度是否大于速度阈值，而将该帧的场景绘制命令送至回调模块或拉近模块。可选的，检测模块还可以用于检测停止运动命令序列和开始运动命令序列。具体的，对于某一帧场景图像的场景绘制命令，可以在识别出其中的运动命令流后，从运动命令流结束后出现的第一条命令开始，直到下一条draw call之间的若干条命令构成的序列确定为停止运动命令序列。另外，对于某一帧场景图像的场景绘制命令，可以在识别出其中的运动命令流后，从运动命令流的前一条命令开始，直到上一条draw call之间的若干条命令构成的序列确定为开始运动命令序列。比如，对于某一帧场景图像的场景绘制命令，检测模块先确定出其中命令k至命令k+n为运动命令流，然后，检测模块可以从命令k+n+1开始往后读取，直到读取到第一条drawcall，将读取到的这些命令确定为停止运动命令序列。另外，检测模块可以从命令k-1开始往前读取，直到读取到第一条draw call，将读取到的这些命令确定为开始运动命令序列。内存331中的运动命令流可以通过以下方式获得：一是按前述实施例的方法，检测模块通过比对多帧游戏对象处于运动状态的场景绘制命令获得运动命令流，并将运动命令流写入内存331。二是在游戏开始运行后，由CPU从存储器中读取当前运行的游戏对应的运动命令流到内存中。存储器可以是电子设备固有的磁盘，也可以是通过电子设备的USB接口接入的外部存储设备，如U盘，安全数据存储卡等。三是在游戏开始运行后，电子设备通过网络从指定的服务器下载运动命令流并写入内存331中。第二种方式的存储器中存储的运动命令流，可以由电子设备的厂商预先按第一种方式对该游戏进行测试而获得，然后通过系统更新或软件更新的方式下发到相应的电子设备中。另外，若该游戏在本次运行之前已经在该电子设备上运行过一次以上，CPU可以在该游戏的前几次运行中，将通过第一种方式获得的运动命令流从内存转存到存储器中。第三种方式的服务器存储的运动命令流，可以由电子设备的厂商通过预先测试的方式获得并存在服务器，另外，已经使用过该游戏的电子设备，可以将自身通过第一种方式获得的运动命令流上传到服务器，供其他电子设备下载。当游戏对象从非运动状态进入运动状态时，游戏图像呈现的场景突然从第二范围缩小至第一范围可能会被用户察觉，进而给用户带来较差的视觉体验。为了解决这一问题，本申请的一些可选的实施例中，本申请所提供的生成场景图像的方法，可以通过如下平滑缩小方法，按较小的幅度逐步调整生成的场景图像的范围，直至最后生成第一类场景图像为止。具体的，拉近模块获得第K帧的场景绘制命令时，判断已经绘制好的前一帧场景图像呈现的场景的范围是否大于第一范围，若否，则K帧的场景绘制命令按第一范围进行绘制，得到第一类场景图像。K为任意的正整数。若K-1帧场景图像呈现的场景的范围大于第一范围，就将K-1帧呈现的范围下调一个较小的幅度，若下调后的范围比第一范围小，就将K帧呈现的范围设定为第一范围，若下调后的范围大于第一范围，就将K帧呈现的范围设定为下调后的范围。然后利用K帧的场景绘制命令，按设定好的K帧呈现的范围进行绘制，得到K帧场景图像，绘制好的K帧场景图像呈现的场景的范围，大于第一范围，且小于第二范围。上述较小的幅度，可以动态调节，也可以是一个固定的步长，比如，step可以设定为第二范围的1％。上述步长可以是电子设备中预置的参数，也可以根据用户的设定而调整。请参考图6，图6为本实施例提供的平滑缩小的方法的示意图，以step为第二范围的1％，设定的比例Z为90％，即第一范围为第二范围的90％为例，上述平滑缩小方法的执行过程可以是：假设绘制好的第K帧场景图像为第二类场景图像，该帧场景图像中游戏对象处于非运动状态。匹配模块获得第K+1帧的场景绘制命令，并判断出第K+1帧场景图像中游戏对象处于运动状态，于是将第K+1帧的场景绘制命令传至拉近模块。拉近模块读取第K帧场景图像呈现的范围，即第二范围，由于第二范围大于第一范围，所以拉近模块在第二范围的基础上下调1％，获得第二范围的99％，该下调后的范围大于第一范围，于是，拉近模块按第二范围的99％，绘制得到第K+1帧场景图像。随后，拉近模块获得第K+2帧的场景绘制命令，继续在第K+1帧场景图像呈现的范围的基础上下调1％，得到第二范围的98％，仍大于第一范围，于是拉近模块按第二范围的98％，绘制得到第K+2帧场景图像。以此类推，每一帧场景图像呈现的范围均比前一帧的范围小第二范围的1％，最终，拉近模块按第二范围的90％绘制得到第K+10帧场景图像，即绘制出呈现第一范围场景的场景图像。在第K+10帧场景图像之后的每一帧场景图像，由于前一帧场景图像呈现的范围等于第一范围，所以第K+10帧场景图像之后的每一帧场景图像均按第一范围进行绘制，直至游戏对象又进入非运动状态为止。上述过程中第二范围的99％的场景图像，第二范围的97％的场景图像等的绘制方法，均可以参照前文生成第一类场景图像的方法，只要按对应的比例调整新的帧缓冲的大小和视图的范围即可。比如，绘制第二范围的97％的场景图像，则新建的帧缓冲的大小可以设置为原本存放第二类场景图像的帧缓冲的97％，视图对应设置为第二范围的97％大小。上述方法相当于在游戏对象从非运动状态进入运动状态时，先顺序生成多帧呈现的范围在第二范围到第一范围之间逐步缩小的场景图像，直至缩小至第一范围时，再持续的生成第一类场景图像。在上述方法的一些变形中，在生成第一类场景图像之前顺序生成的这些场景图像，其所呈现场景的范围也可以不逐帧变小，而是每隔几帧变小一次。比如，在上述实施例中，在绘制完第K帧场景图像后，先绘制连续的几帧范围为第二范围的99％的场景图像，然后再绘制连续几帧范围为第二范围的98％的场景图像，以此类推，最终绘制出所需的第一类场景图像。图6仅仅是为了说明本申请中将游戏场景的范围平滑缩小的方式的一个例子，在实际的应用场景中，各帧场景图像中显示的游戏场景可以不相同，比如图6场景图像从601渐变至604的过程中，游戏场景中小车的位置可以逐渐发生变化，从而表现出小车沿道路行驶的场景。通过上述方法，本实施例可以在用户无感知的前提下，平滑地缩小游戏图像中呈现的场景的范围，给用户带来更好的使用体验。可选的，上述平滑缩小的方法也可以反过来应用于呈现的范围从第一范围变回第二范围的场景。具体的，检测模块获得某一帧的场景绘制命令，并判断出第M帧场景图像中游戏对象处于非运动状态后，可以判断绘制好的前一帧场景图像所呈现的范围，判断已经绘制好的前一帧场景图像呈现的场景的范围是否小于第二范围，若否，将第M帧的场景绘制命令送至回调模块，从而通过图形库直接绘制呈现第二范围的场景的第M帧场景图像。若M-1帧场景图像呈现的场景的范围小于第二范围，就将M-1帧呈现的范围上调一个较小的幅度，若上调后的范围比第二范围大，将第M帧的场景绘制命令发送至回调模块，从而通过图形库直接绘制呈现第二范围的场景的第M帧场景图像。若上调后的范围小于第二范围，则可以将第M帧的场景绘制命令，和一条范围设定命令一并发送至拉近模块，范围设定命令携带有上述上调后的范围，从而触发拉近模块利用第M帧的场景绘制命令，按上调后的范围绘制得到第M帧场景图像，这样绘制好的第M帧场景图像所呈现场景的范围，就是上述上调后的范围。上调过程中每次调整的幅度，同样可以动态调节，即每次上调的幅度不同，或者设定为一个固定的步长，即每次上调的幅度均为该步长，比如，step可以设定为第二范围的1％。上述步长可以是电子设备中预置的参数，也可以根据用户的设定而调整。上述方法相当于在游戏对象从运动状态进入非运动状态时，先顺序生成多帧呈现的范围在第一范围到第二范围之间逐步扩大的场景图像，直至扩大至时，再持续的生成第二类场景图像。与平滑缩小的方法类似，通过上述方法，本实施例可以在用户无感知的前提下，在游戏对象从运动状态变为非运动状态时，平滑地扩大游戏图像中呈现的场景的范围，给用户带来更好的使用体验。在另一些可选的实施例中，本申请提供的生成场景图像的方法，还可以将游戏对象的运动状态根据速度的不同进一步划分出多种运动状态，比如可以划分第一速度区间和第二速度区间，第二速度区间的下限高于第一速度区间的上限，第一速度区间对应第一运动状态，第二速度区间对应第二运动状态。在一些具体的应用场景中，游戏对象可以在游戏中跑动和使用游戏场景中的交通工具，相应的，可以将跑动时游戏对象的速度范围作为第一速度区间，第一运动状态就是跑动状态，将使用交通工具时游戏对象的速度范围作为第二速度区间，第二运动状态就是使用交通工具的状态。根据上述运动状态的划分，检测模块在获得一帧的场景绘制命令，并判断出该帧中游戏对象处于运动状态后，可以进一步区分该游戏对象的运动状态是第一运动状态还是第二运动状态。在具体实施时，检测模块可以通过之前的一帧或几帧绘制好的场景图像中游戏对象的速度来区分运动状态，若速度在第一速度区间内，则判断出游戏对象处于第一运动状态，若速度在第二速度内，则判断出游戏对象处于第二运动状态。匹配模块则可以分别用不同运动状态对应的不同运动命令流分别和获得的场景绘制命令，若获得的场景绘制命令与第一运动状态的运动命令流匹配度更高，则判断出游戏对象处于第一运动状态，若获得的场景绘制命令与第二运动状态的运动命令流匹配度更高，则判断出游戏对象处于第二运动状态。检测模块可以在判断出某一帧绘制好的场景图像中游戏对象的速度位于第一速度区间时，将绘制这一帧场景图像的场景绘制命令作为第一运动状态的运动命令流写入内存。同理，检测模块可以在判断出某一帧绘制好的场景图像中游戏对象的速度位于第二速度区间时，将绘制这一帧场景图像的场景绘制命令作为第二运动状态的运动命令流写入内存。检测模块判断出游戏对象处于第一运动状态或者第二运动状态后，可以将场景绘制命令和判断结果一并发送给拉近模块。若游戏对象处于第一运动状态，则拉近模块按第一范围绘制场景绘制命令对应的场景图像，从而获得第一类场景图像，即所呈现场景的范围为第一范围的场景图像，若游戏对象处于第二运动状态，则拉近模块按第三范围绘制场景绘制命令对应的场景图像,从而获得第三类场景图像，即所呈现场景的范围为第三范围的场景图像。第三范围小于第一范围。比如，第一范围可以是第二范围的90％，而第三范围可以是第二范围的80％。绘制第三类场景图像的方法，与前述绘制第一类场景图像的方法一致，只需要在创建新的帧缓冲时和设置视图时根据第三范围进行对应调整即可，具体过程不再赘述。通过在电子设备上应用上述方法，在游戏开始后，若游戏对象处于非运动状态，则电子设备根据游戏中场景的变化，实时的生成第二类场景图像并显示由第二类场景图像构成的游戏图像，若用户操控其游戏对象开始跑动，则设备判断出此时游戏对象处于第一运动状态，进而将呈现给用户的场景缩小至第一范围，也就是实时的生成第一类场景图像并显示由第一类场景图像构成的游戏图像，若用户操控其游戏对象使用交通工具，则设备判断出此时游戏对象处于第二运动状态，进而将呈现给用户的场景缩小至第三范围，也就是实时的生成第三类场景图像并显示由第三类场景图像构成的游戏图像。通过实施上述实施例所提供的方法，可以获得如下的有益效果：根据游戏对象速度的不同动态调整呈现的场景的范围，可以更好的缓解前述维持较高画质的场景图像和降低负载的矛盾。具体来说，本实施例提供的生成场景图像的方法，可以随着游戏对象移动速度的提高逐渐缩小生成的场景图像所呈现场景的范围，从而减小生成一帧场景图像所需的计算量，控制电子设备的负载始终在一个可接受的负载范围内，避免电子设备负载过高。另外本实施例提供的方法可以在游戏对象处于非运动状态，或者速度较低的运动状态时呈现较大范围的场景，在避免电子设备负载过高的同时，尽可能向用户呈现质量较高的游戏图像。请参考图7，图7为本申请实施例提供的一种生成场景图像的方法的流程图，该方法可以包括如下步骤：S701、检测游戏对象的状态。若游戏对象处于运动状态，执行步骤S702，若游戏对象处于非运动状态，执行步骤S703。S702、若游戏对象处于运动状态，生成第一类场景图像。S703、若游戏对象处于非运动状态，生成第二类场景图像。根据图5所示的交互示意图，可以理解，如图7所示的实施例提供的生成场景图像的方法，可以在游戏开始后实时运行，具体的，可以在每次绘制一帧游戏图像之前判断该帧游戏图像中游戏对象是否处于运动状态，若否，则绘制该帧的场景图像时按第二范围绘制，得到第二类场景图像，若是，则绘制该帧的场景图像时按第一范围绘制，得到第一类场景图像。上述实施例中的步骤S701可以由图3所示的应用框架层的检测模块或匹配模块实施，步骤S702可以由图3所示的拉近模块实施，步骤S703可以由图3所示的图形库实施，以上各步骤具体实施方式均可参见前文，此处不再赘述。本申请实施例还提供一种计算机存储介质，用于存储计算机程序，计算机程序被执行时，具体用于实现本申请任一实施例提供的生成场景图像的方法。本申请实施例还提供一种计算机程序产品，包括多条可执行的计算机命令，该产品的计算机命令被执行时，具体用于实现本申请任一实施例提供的生成场景图像的方法。

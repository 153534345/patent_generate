标题title
渲染时通过区域测试进行几何图形高效多GPU渲染的系统和方法
摘要abst
一种用于图形处理的方法。该方法包括使用多个图形处理单元为应用渲染图形。该方法包括基于多个屏幕区域在多个GPU之间划分渲染图形的几何图形的责任，每个GPU具有多个GPU已知的对应责任划分。该方法包括在第二GPU处为图像渲染一个几何图形的同时，生成关于该几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息。该方法包括使用该信息在第一GPU处渲染该几何图形。
权利要求书clms
1.一种用于图形处理的方法，其包括：使用多个图形处理单元为应用渲染图形；基于多个屏幕区域在所述多个GPU之间划分渲染所述图形的几何图形的责任，每个GPU具有所述多个GPU已知的对应责任划分；在第二GPU处为图像渲染一个几何图形的同时，生成关于所述几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息；以及使用所述信息在所述第一GPU处渲染所述几何图形。2.根据权利要求1所述的方法，其中所述信息指示所述第一GPU应当完全跳过对所述几何图形的渲染。3.根据权利要求1所述的方法，其中所述信息是对所述第一GPU的提示，从而如果在所述第一GPU开始渲染第一几何图形之前接收到所述信息，则考虑所述信息，其中在开始渲染所述第一几何图形后接收到所述信息时在所述第一GPU处完全渲染所述第一几何图形。4.根据权利要求1所述的方法，其中所述多个屏幕区域被配置为减少所述多个GPU之间的渲染时间的不平衡。5.根据权利要求1所述的方法，其中所述多个屏幕区域中的每一个在大小上不统一。6.根据权利要求1所述的方法，其中所述多个屏幕区域动态地改变。7.根据权利要求1所述的方法，其中所述几何图形对应于由绘制调用使用或生成的几何图形。8.根据权利要求1所述的方法，其中由绘制调用使用或生成的几何图形被细分为多个几何图形，其中在所述第二GPU处生成关于所述多个几何图形中的至少一个相对于所述多个屏幕区域的对应信息。9.根据权利要求1所述的方法，其中关于所述几何图形的所述信息是在所述第二GPU处针对各个图元生成的。10.根据权利要求1所述的方法，其中关于所述几何图形的所述信息包括顶点计数或图元计数。11.根据权利要求1所述的方法，其中生成的关于所述几何图形的所述信息包括用于渲染的一组特定图元或用于渲染的一组特定顶点。12.根据权利要求1所述的方法，其还包括：为所述第一GPU和所述第二GPU使用公共渲染命令缓冲区；以及将所述公共渲染命令缓冲区中的命令的执行限制为所述第一GPU和所述第二GPU中的一个。13.根据权利要求1所述的方法，其中所述第一屏幕区域是所述第一GPU具有所述第一责任划分的第一组屏幕区域的一部分，其中所述第二GPU对包括第二屏幕区域的第二组屏幕区域具有第二责任划分。14.根据权利要求1所述的方法，其中所述多个GPU中的每一个负责在对应的一组屏幕区域中渲染几何图形，其中所述对应的一组屏幕区域包括一个或多个屏幕区域。15.根据权利要求1所述的方法，其中所述第一GPU和所述第二GPU是被配置为包括所述多个GPU的更大GPU的部分。16.根据权利要求1所述的方法，其中所述多个GPU中的一个或多个是被配置为多个虚拟GPU的更大GPU的部分。17.根据权利要求1所述的方法，其中所述信息可以根据所述几何图形的性质生成或不生成。18.根据权利要求1所述的方法，其还包括：在光栅化级使用扫描转换器来生成所述信息。19.根据权利要求1所述的方法，其还包括：在几何图形处理级使用至少一个着色器来生成所述信息。20.根据权利要求19所述的方法，其中所述至少一个着色器使用至少一个专用指令来加速所述信息的生成。21.根据权利要求1所述的方法，其还包括：在第二渲染阶段中使用在第一渲染阶段中生成的所述信息。22.一种计算机系统，其包括：处理器；存储器，所述存储器耦合到所述处理器并且其中存储有指令，所述指令如果由所述计算机系统执行，则致使所述计算机系统执行用于实现图形流水线的方法，所述方法包括：使用多个图形处理单元为应用渲染图形；基于多个屏幕区域在所述多个GPU之间划分渲染所述图形的几何图形的责任，每个GPU具有所述多个GPU已知的对应责任划分；在第二GPU处为图像渲染一个几何图形的同时，生成关于所述几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息；以及使用所述信息在所述第一GPU处渲染所述几何图形。23.根据权利要求22所述的计算机系统，其中在所述方法中，所述第一屏幕区域是所述第一GPU具有所述第一责任划分的第一组屏幕区域的一部分，其中在所述方法中，所述第二GPU对包括第二屏幕区域的第二组屏幕区域具有第二责任划分。24.根据权利要求22所述的计算机系统，其中在所述方法中，所述多个GPU中的每一个负责在对应的一组屏幕区域中渲染几何图形，其中在所述方法中，所述对应的一组屏幕区域包括一个或多个屏幕区域。25.根据权利要求22所述的计算机系统，其中在所述方法中，所述信息指示所述第一GPU应当完全跳过对所述几何图形的渲染。26.根据权利要求22所述的计算机系统，其中在所述方法中，所述信息是给所述第一GPU的提示，使得如果在所述第一GPU处开始渲染第一几何图形之前接收到所述信息，则考虑所述信息，其中在所述方法中，当在所述第一几何图形的渲染开始之后接收到所述信息时，在所述第一GPU处完全渲染所述第一几何图形。27.一种用于图形处理的方法，其包括：使用多个图形处理单元为应用渲染图形；基于多个屏幕区域在所述多个GPU之间划分渲染所述图形的几何图形的责任，每个GPU具有所述多个GPU已知的对应责任划分；在第一GPU处为图像进行一个几何图形的渲染的预通过阶段期间确定所述几何图形的Z值，其中所述几何图形与所述第一GPU具有责任划分的第一屏幕区域重叠；将所述Z值与所述几何图形的Z缓冲区值进行比较；以及生成信息，所述信息包括将所述Z值与所述Z缓冲区值进行所述比较的结果，以供所述GPU在渲染的完整渲染阶段期间渲染所述几何图形时使用。28.根据权利要求27所述的方法，其还包括：当所述几何图形基于所述信息未被遮挡时，所述第一GPU在渲染的所述完整渲染阶段期间为所述几何图形渲染多个像素。29.根据权利要求27所述的方法，其中将所述Z值与所述Z缓冲区值进行比较包括：确定所述Z值小于或等于所述Z缓冲区值，指示所述几何图形未被遮挡，其中所述信息指示所述几何图形未被遮挡。30.根据权利要求27所述的方法，其还包括：在所述预通过阶段期间将所述几何图形的一个或多个图元光栅化成多个像素；通过将所述多个像素的多个Z值与所述Z缓冲区值进行比较来执行深度测试，其中所述深度测试的结果包括在所述信息中；以及基于所述信息渲染所述多个像素中的从所述深度测试幸存的像素。31.根据权利要求30所述的方法，其还包括：当所述多个像素中没有一个像素从所述深度测试幸存时，跳过所述几何图形的渲染。32.根据权利要求27所述的方法，其还包括：将所述几何图形的一个或多个图元光栅化成多个像素；检查所述多个像素的纹理的α值；以及杀死所述多个像素中具有低于阈值的α值的像素，其中检查所述α值的结果包括在所述信息中。33.根据权利要求32所述的方法，其还包括：当所述多个像素中没有一个像素具有等于或高于所述阈值的对应α值时，跳过所述几何图形的渲染。34.根据权利要求27所述的方法，其中所述多个GPU中的一个或多个是被配置为多个GPU的更大GPU的部分。35.一种用于执行方法的非暂时性计算机可读介质，所述计算机可读介质包括：用于使用多个图形处理单元为应用渲染图形的程序指令；用于基于多个屏幕区域在所述多个GPU之间划分渲染所述图形的几何图形的责任的程序指令，每个GPU具有所述多个GPU已知的对应责任划分；用于在第一GPU处为图像进行一个几何图形的渲染的预通过阶段期间确定所述几何图形的Z值的程序指令，其中所述几何图形与所述第一GPU具有责任划分的第一屏幕区域重叠；用于将所述Z值与所述几何图形的Z缓冲区值进行比较的程序指令；和用于生成信息的程序指令，所述信息包括将所述Z值与所述Z缓冲区值进行所述比较的结果，以供所述GPU在渲染的完整渲染阶段期间渲染所述几何图形时使用。36.根据权利要求35所述的非暂时性计算机可读介质，其还包括：用于当所述几何图形基于所述信息未被遮挡时由所述第一GPU在渲染的所述完整渲染阶段期间为所述几何图形渲染多个像素的程序指令。37.根据权利要求35所述的非暂时性计算机可读介质，其中用于将所述Z值与所述Z缓冲区值进行比较的所述程序指令包括：用于确定所述Z值小于或等于所述Z缓冲区值，指示所述几何图形未被遮挡的程序指令，其中所述信息指示所述几何图形未被遮挡。38.根据权利要求35所述的非暂时性计算机可读介质，其还包括：用于在所述预通过阶段期间将所述几何图形的一个或多个图元光栅化成多个像素的程序指令；用于通过将所述多个像素的多个Z值与所述Z缓冲区值进行比较来执行深度测试的程序指令，其中所述深度测试的结果包括在所述信息中；和用于基于所述信息渲染所述多个像素中的从所述深度测试幸存的像素的程序指令。39.根据权利要求38所述的非暂时性计算机可读介质，其还包括：用于当所述多个像素中没有一个像素从所述深度测试幸存时，跳过所述几何图形的渲染的程序指令。40.根据权利要求35所述的非暂时性计算机可读介质，其还包括：用于将所述几何图形的一个或多个图元光栅化成多个像素的程序指令；用于检查所述多个像素的纹理的α值的程序指令；和用于杀死所述多个像素中具有低于阈值的α值的像素的程序指令，其中检查所述α值的结果包括在所述信息中。41.根据权利要求40所述的非暂时性计算机可读介质，其还包括：用于当所述多个像素中没有一个像素具有等于或高于所述阈值的对应α值时，跳过所述几何图形的渲染的程序指令。42.根据权利要求35所述的非暂时性计算机可读介质，其中在所述方法中，所述多个GPU中的一个或多个是被配置为多个GPU的更大GPU的部分。43.一种计算机系统，其包括：处理器；存储器，所述存储器耦合到所述处理器并且其中存储有指令，所述指令如果由所述计算机系统执行，则致使所述计算机系统执行用于实现图形流水线的方法，所述方法包括：使用多个图形处理单元为应用渲染图形；基于多个屏幕区域在所述多个GPU之间划分渲染所述图形的几何图形的责任，每个GPU具有所述多个GPU已知的对应责任划分；在第一GPU处为图像进行一个几何图形的渲染的预通过阶段期间确定所述几何图形的Z值，其中所述几何图形与所述第一GPU具有责任划分的第一屏幕区域重叠；将所述Z值与所述几何图形的Z缓冲区值进行比较；以及生成信息，所述信息包括将所述Z值与所述Z缓冲区值进行所述比较的结果，以供所述GPU在渲染的完整渲染阶段期间渲染所述几何图形时使用。44.根据权利要求43所述的计算机系统，所述方法还包括：当所述几何图形基于所述信息未被遮挡时，所述第一GPU在渲染的所述完整渲染阶段期间为所述几何图形渲染多个像素。45.根据权利要求43所述的计算机系统，其中在所述方法中，将所述Z值与所述Z缓冲区值进行比较包括：确定所述Z值小于或等于所述Z缓冲区值，指示所述几何图形未被遮挡，其中所述信息指示所述几何图形未被遮挡。46.根据权利要求43所述的计算机系统，所述方法还包括：在所述预通过阶段期间将所述几何图形的一个或多个图元光栅化成多个像素；通过将所述多个像素的多个Z值与所述Z缓冲区值进行比较来执行深度测试，其中所述深度测试的结果包括在所述信息中；以及基于所述信息渲染所述多个像素中的从所述深度测试幸存的像素。47.根据权利要求46所述的计算机系统，所述方法还包括：当所述多个像素中没有一个像素从所述深度测试幸存时，跳过所述几何图形的渲染。48.根据权利要求43所述的计算机系统，所述方法还包括：将所述几何图形的一个或多个图元光栅化成多个像素；检查所述多个像素的纹理的α值；以及杀死所述多个像素中具有低于阈值的α值的像素，其中检查所述α值的结果包括在所述信息中。49.根据权利要求48所述的计算机系统，所述方法还包括：当所述多个像素中没有一个像素具有等于或高于所述阈值的对应α值时，跳过所述几何图形的渲染。
说明书desc
技术领域本公开涉及图形处理，并且更具体地涉及在为应用渲染图像时的多GPU协作。背景技术近年来，在线服务不断推动，允许在云游戏服务器和通过网络连接的客户端之间以流式传输格式进行在线游戏或云游戏。由于按需提供游戏名称、执行更复杂游戏的能力、玩家之间联网以进行多玩家游戏的能力、玩家之间的资产共享、玩家和/或观众之间的即时体验共享、允许朋友观看朋友玩视频游戏、让朋友加入朋友正在进行的游戏进行等等，流式传输格式越来越受欢迎。云游戏服务器可以被配置为向一个或多个客户端和/或应用提供资源。也就是说，云游戏服务器可以配置有能够高吞吐量的资源。例如，单个图形处理单元可以达到的性能是有限的。为了在生成场景时渲染更复杂的场景或使用更复杂的算法，可能需要使用多个GPU来渲染单个图像。然而，这些图形处理单元的同等使用是难以实现的。此外，即使有多个GPU使用传统技术为应用处理图像，也无法支持对应增加的屏幕像素计数和几何密度。正是在这种背景下，出现了本公开的实施方案。发明内容本公开的实施方案涉及协作使用多个GPU来渲染单个图像，诸如在渲染时通过区域测试来对应用的几何图形进行多GPU渲染。本公开的实施方案公开了一种用于图形处理的方法。该方法包括使用多个图形处理单元为应用渲染图形。该方法包括基于多个屏幕区域在多个GPU之间划分渲染图形的几何图形的责任，每个GPU具有多个GPU已知的对应责任划分。该方法包括在第二GPU处为图像渲染一个几何图形的同时，生成关于该几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息。该方法包括使用该信息在第一GPU处渲染该几何图形。本公开的其他实施方案公开了一种用于执行方法的非暂时性计算机可读介质。计算机可读介质包括程序指令，所述程序指令用于使用多个图形处理单元为应用渲染图形。计算机可读介质包括程序指令，所述程序指令用于基于多个屏幕区域在多个GPU之间划分渲染图形的几何图形的责任，每个GPU具有多个GPU已知的对应责任划分。计算机可读介质包括程序指令，所述程序指令用于在第二GPU处为图像渲染一个几何图形的同时，生成关于该几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息。计算机可读介质包括程序指令，所述程序指令用于使用该信息在第一GPU处渲染该几何图形。本公开的另外其他实施方案公开了一种计算机系统，其包括处理器和存储器，所述存储器耦合到处理器并且其中存储有指令，所述指令如果由计算机系统执行，则致使计算机系统执行方法。该方法包括使用多个图形处理单元为应用渲染图形。该方法包括基于多个屏幕区域在多个GPU之间划分渲染图形的几何图形的责任，每个GPU具有多个GPU已知的对应责任划分。该方法包括在第二GPU处为图像渲染一个几何图形的同时，生成关于该几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息。该方法包括使用该信息在第一GPU处渲染该几何图形。本公开的实施方案公开了一种用于图形处理的方法。该方法包括使用多个图形处理单元为应用渲染图形。该方法包括基于屏幕区域在GPU之间划分渲染图形的几何图形的责任，每个GPU具有GPU已知的对应责任划分。该方法包括在第一GPU处为图像进行渲染的预通过阶段期间确定一个几何图形的Z值，其中该几何图形与第一GPU具有责任划分的第一屏幕区域重叠。该方法包括将Z值与该几何图形的Z缓冲区值进行比较。该方法包括生成信息，该信息包括将Z值与Z缓冲区值进行比较的结果，以供GPU在渲染的完整渲染阶段期间渲染该几何图形时使用。本公开的其他实施方案公开了一种用于执行方法的非暂时性计算机可读介质。计算机可读介质包括程序指令，所述程序指令用于使用多个图形处理单元为应用渲染图形。计算机可读介质包括程序指令，所述程序指令用于基于屏幕区域在GPU之间划分渲染图形的几何图形的责任，每个GPU具有GPU已知的对应责任划分。计算机可读介质包括程序指令，所述程序指令用于在第一GPU处为图像进行渲染的预通过阶段期间确定一个几何图形的Z值，其中该几何图形与第一GPU具有责任划分的第一屏幕区域重叠。计算机可读介质包括程序指令，所述程序指令用于将Z值与该几何图形的Z缓冲区值进行比较。计算机可读介质包括程序指令，所述程序指令用于生成信息，该信息包括将Z值与Z缓冲区值进行比较的结果，以供GPU在渲染的完整渲染阶段期间渲染该几何图形时使用。本公开的另外其他实施方案公开了一种计算机系统，其包括处理器和存储器，所述存储器耦合到处理器并且其中存储有指令，所述指令如果由计算机系统执行，则致使计算机系统执行方法。该方法包括使用多个图形处理单元为应用渲染图形。该方法包括基于屏幕区域在GPU之间划分渲染图形的几何图形的责任，每个GPU具有GPU已知的对应责任划分。该方法包括在第一GPU处为图像进行渲染的预通过阶段期间确定一个几何图形的Z值，其中该几何图形与第一GPU具有责任划分的第一屏幕区域重叠。该方法包括将Z值与该几何图形的Z缓冲区值进行比较。该方法包括生成信息，该信息包括将Z值与Z缓冲区值进行比较的结果，以供GPU在渲染的完整渲染阶段期间渲染该几何图形时使用。根据以下结合附图理解的具体实施方式，本公开的其他方面将变得显而易见，所述附图以示例的方式示出了本公开的原理。附图说明通过参考结合附图的以下描述，可以最好地理解本公开，在附图中：图1是根据本公开的一个实施方案的用于通过网络在一个或多个云游戏服务器之间提供游戏的系统的示意图，该云游戏服务器被配置为实现多个GPU协作以渲染单个图像，包括在渲染时通过区域测试为应用进行几何图形的多GPU渲染。图2是根据本公开的一个实施方案的其中多个GPU协作以渲染单个图像的多GPU架构的示意图。图3是根据本公开的一个实施方案的被配置用于在渲染时通过区域测试为应用进行几何图形的多GPU渲染的多个图形处理单元资源的示意图。图4是根据本公开的一个实施方案的实现被配置用于多GPU处理以使得多个GPU协作以渲染单个图像的图形流水线的渲染架构的示意图。图5是图示了根据本公开的一个实施方案的用于图形处理的方法的流程图，该方法包括在渲染时通过区域测试为应用进行几何图形的多GPU渲染。图6A是根据本公开的一个实施方案在执行多GPU渲染时被细分为象限的屏幕的示意图。图6B是根据本公开的一个实施方案在执行多GPU渲染时被细分为多个交错区域的屏幕的示意图。图7A是根据本公开的一个实施方案的由协作以渲染单个图像的多个GPU共享的渲染命令缓冲区的示意图。图7B-1图示了根据本公开的一个实施方案的包括由多个GPU渲染的四个对象的图像，并且示出了在渲染图像的对象时每个GPU的屏幕区域责任。图7B-2是图示了根据本公开的一个实施方案的当渲染图7B-1的四个对象时由每个GPU执行的渲染的表格。图7C是图示了根据本公开的一个实施方案的在通过多个GPU的协作来渲染图像帧时由每个GPU执行的每个对象的渲染的示意图。图8A图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时针对屏幕区域的对象测试。图8B图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时针对屏幕区域的对对象的多部分的测试。图9A-图9C图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时用于将屏幕区域分配给对应GPU的各种策略。图10A是图示了根据本公开的一个实施方案的在渲染时通过区域测试为应用执行几何图形的多GPU渲染时的多通过渲染的示意图。图10B是图示了根据本公开的一个实施方案的用于图形处理的方法的流程图，该方法包括执行渲染的仅Z预通过阶段以供同一GPU稍后在渲染时使用。图11图示了可用于执行本公开的各种实施方案的各方面的示例装置的部件。具体实施方式虽然出于说明目的，以下详细说明包含许多具体细节，但是本领域的普通技术人员将会了解，以下细节的许多变化和更改在本公开的范围内。因此，阐明以下所描述的本公开的各个方面，而本说明书的随附权利要求书的概括性没有任何损失，并且不对此权利要求书施加任何限制。一般来说，单个GPU可以达到的性能是有限制的，例如从GPU可以有多大的限制中得出。在本公开的实施方案中，为了渲染更加复杂的场景或使用更加复杂的算法，希望使用多个GPU来渲染单个图像。特别地，本公开的各种实施方案描述了被配置用于在渲染时通过区域测试为应用执行几何图形的多GPU渲染的方法和系统。具体而言，多个GPU协作以生成应用的图像。基于对应的屏幕区域在多个GPU之间划分应用的图形渲染的责任。在为图像渲染几何图形时，多个GPU中的每一个生成关于几何图形及其与其他GPU可能负责的屏幕区域的关系的信息；此信息允许其他GPU更高效地渲染几何图形或完全避免渲染它。作为一个优势，例如，这允许多个GPU在相同的时间量内渲染更复杂的场景和/或图像。借助对各种实施方案的上述一般理解，现在将参考各种附图来描述实施方案的示例细节。贯穿本说明书，对“应用”或“游戏”或“视频游戏”或“游戏应用”的引用意在表示通过执行输入命令来引导的任何类型的交互式应用。仅出于说明目的，交互式应用包括用于游戏、文字处理、视频处理、视频游戏处理等的应用。此外，上面介绍的术语是可互换的。在整个说明书中，针对使用具有四个GPU的示例性架构对应用的几何图形多GPU处理或渲染来描述本公开的各种实施方案。然而，应当理解，在为应用渲染几何图形时，任何数量的GPU可以协作。图1是根据本公开的一个实施方案的用于在为应用渲染图像时执行多GPU处理的系统的示意图。根据本公开的实施方案，该系统被配置为通过网络在一个或多个云游戏服务器之间提供游戏，并且更具体地被配置用于多个GPU的协作以渲染应用的单个图像。云游戏包括在服务器上执行视频游戏以生成游戏渲染的视频帧，然后将其发送到客户端进行显示。特别地，系统100被配置用于在渲染时通过区域测试为应用进行几何图形的高效多GPU渲染。虽然图1图示了在云游戏系统的一个或多个云游戏服务器之间的几何图形的多GPU渲染的实现，但本公开的其他实施方案提供了在单独系统内进行渲染时通过执行区域测试为应用进行几何图形的高效多GPU渲染。还应理解，在各种实施方案中，几何图形的多GPU渲染可以使用物理GPU或虚拟GPU或两者的组合来执行。例如，虚拟机可以使用利用硬件层的一个或多个部件的主机硬件的管理程序创建。这些物理资源可以布置在机架中，诸如CPU机架、GPU机架、存储器机架等，其中机架中的物理资源可以使用架顶交换机访问，该架顶交换机促进用于组装和访问用于实例的部件的结构。通常，管理程序可以呈现配置有虚拟资源的多个实例的多个客户操作系统。即，每个操作系统可以配置有由一个或多个硬件资源支持的对应的一组虚拟化资源。例如，每个操作系统可以由一个虚拟CPU、多个虚拟GPU、虚拟存储器、虚拟化通信部件等支持。此外，一个实例的配置可以从一个数据中心转移到另一个数据中心以减少延时。为用户或游戏定义的GPU利用率可以在保存用户的游戏会话时使用。GPU利用率可以包括本文所述的任何数量的配置，以优化游戏会话的视频帧的快速渲染。在一个实施方案中，为游戏或用户定义的GPU利用率可以作为可配置设置在数据中心之间传输。传输GPU利用率设置的能力可以在用户连接到不同地理位置玩游戏的情况下，有效地将游戏进行从数据中心迁移到数据中心。根据本公开的一个实施方案，系统100经由云游戏网络190提供游戏，其中远离正在玩游戏的对应用户的客户端装置110执行游戏。系统100可以经由网络150以单玩家或多玩家模式通过云游戏网络190向玩一个或多个游戏的一个或多个用户提供游戏控制。在一些实施方案中，云游戏网络190可以包括在主机的管理程序上运行的多个虚拟机，其中一个或多个虚拟机被配置为利用对主机的管理程序可用的硬件资源来执行游戏处理器模块。网络150可包括一种或多种通信技术。在一些实施方案中，网络150可以包括具有先进无线通信系统的第五代网络技术。在一些实施方案中，可使用无线技术来促进通信。此类技术可以包括例如5G无线通信技术。5G是第五代蜂窝网络技术。5G网络是数字蜂窝网络，其中提供商覆盖的服务区域被划分为称为小区的小地理区域。代表声音和图像的模拟信号在电话中被数字化、由模数转换器转换并作为比特流传输。通过从其他小区中重复使用的频率池中由收发器分配的频率信道，小区中的所有5G无线装置通过无线电波与小区中的本地天线阵列和小功率自动收发器通信。本地天线通过高带宽光纤或无线回程连接与电话网络和互联网连接。与在其他小区网络中一样，从一个小区跨到另一小区的移动装置会自动转到新的小区。应当理解，5G网络只是通信网络的示例类型，并且本公开的实施方案可以利用更早一代的无线或有线通信，以及5G之后的更新一代的有线或无线技术。如图所示，云游戏网络190包括提供对多个视频游戏的访问的游戏服务器160。游戏服务器160可以是云中可用的任何类型的服务器计算装置，并且可以被配置为在一个或多个主机上执行的一个或多个虚拟机。例如，游戏服务器160可管理支持为用户实例化游戏实例的游戏处理器的虚拟机。这样，与多个虚拟机相关联的游戏服务器160的多个游戏处理器被配置为执行与多个用户的游戏进行相关联的一个或多个游戏的多个实例。以这种方式，后端服务器支持向多个对应用户提供多个游戏应用的游戏进行的媒体的流式传输。也就是说，游戏服务器160被配置为通过网络150将数据流式传输回对应客户端装置110。以该方式，计算上复杂的游戏应用可响应于由客户端装置110接收和转发的控制器输入而在后端服务器处执行。每个服务器能够渲染图像和/或帧，然后将其编码并流式传输到对应的客户端装置以供显示。例如，多个用户可使用被配置用于接收流式传输媒体的对应客户端装置110经由通信网络150访问云游戏网络190。在一个实施方案中，客户端装置110可被配置为瘦客户端，所述瘦客户端提供与被配置用于提供计算功能性的后端服务器的介接。在另一实施方案中，客户端装置110可配置有用于视频游戏的至少一些本地处理的游戏名称处理引擎和游戏逻辑，并且还可被利用来接收由在后端服务器处执行的视频游戏生成的流式传输内容，或由后端服务器支持提供的其他内容。对于本地处理，游戏名称处理引擎包括用于执行视频游戏和与视频游戏相关联的服务的基于基本处理器的功能。在这种情况下，游戏逻辑可以存储在本地客户端装置110上并用于执行视频游戏。每个客户端装置110可以请求访问来自云游戏网络的不同游戏。例如，云游戏网络190可以执行一个或多个游戏逻辑，这些逻辑建立在游戏名称处理引擎111上，如使用游戏服务器160的CPU资源163和GPU资源365执行的。例如，与游戏名称处理引擎111合作的游戏逻辑115a可以在用于一个客户端的游戏服务器160上执行，与游戏名称处理引擎111合作的游戏逻辑115b可以在用于第二客户端的游戏服务器160上执行，……并且与游戏名称处理引擎111合作的游戏逻辑115n可以在用于第N客户端的游戏服务器160上执行。特别地，对应用户的客户端装置110被配置用于通过诸如互联网的通信网络150请求访问游戏，并且用于渲染由游戏服务器160执行的视频游戏生成的显示图像，其中，编码图像被传送到客户端装置110以与对应的用户相关联地显示。例如，用户可以通过客户端装置110与在游戏服务器160的游戏处理器上执行的视频游戏的实例进行交互。更具体地，视频游戏的实例由游戏名称处理引擎111执行。实现视频游戏的对应游戏逻辑115被存储并可通过数据存储区访问，并用于执行视频游戏。游戏名称处理引擎111能够使用多个游戏逻辑来支持多个视频游戏，每个游戏逻辑都可由用户选择。例如，客户端装置110被配置为与和对应用户的游戏进行相关联的游戏名称处理引擎111交互，诸如通过用于驱动游戏进行的输入命令。特别地，客户端装置110可以接收来自各种类型的输入装置的输入，诸如游戏控制器、平板计算机、键盘、由摄像机捕获的手势、鼠标、触摸板等。客户端装置110可以是任何类型的至少具有存储器和能够通过网络150连接到游戏服务器160的处理器模块的计算装置。后端游戏名称处理引擎111被配置用于生成渲染图像，该渲染图像通过网络150传送以在与客户端装置110相关联的对应显示器处显示。例如，通过基于云的服务，游戏渲染图像可以由在游戏服务器160的游戏执行引擎111上执行的对应游戏的实例来传送。也就是说，客户端装置110被配置用于接收编码图像，并且用于在显示器11上显示渲染的图像。在一个实施方案中，显示器11包括HMD。在一些实施方案中，渲染图像可以以无线或有线方式、直接从基于云的服务或经由客户端装置110流式传输到智能手机或平板电脑。在一个实施方案中，游戏服务器160和/或游戏名称处理引擎111包括用于执行游戏和与游戏应用相关联的服务的基于基本处理器的功能。例如，游戏服务器160包括中央处理单元资源163和图形处理单元资源365，它们被配置用于执行基于处理器的功能，包括2D或3D渲染、物理模拟、脚本化、音频、动画、图形处理、照明、着色、光栅化、光线追踪、阴影、剔除、变换、人工智能等。另外，CPU和GPU组可以实现用于游戏应用的服务，部分地包括存储器管理、多线程管理、服务质量、带宽测试、社交网络、社交好友管理、与朋友的社交网络通信、通信渠道、发短信、即时消息、聊天支持等。在一个实施方案中，一个或多个应用共享特定的GPU资源。在一个实施方案中，可以组合多个GPU装置来为在对应CPU上执行的单个应用执行图形处理。在一个实施方案中，云游戏网络190是分布式游戏服务器系统和/或架构。特别地，执行游戏逻辑的分布式游戏引擎被配置为对应游戏的对应实例。通常，分布式游戏引擎采用游戏引擎的每个功能并将这些功能分布以供多个处理实体执行。单独的功能可以进一步分布在一个或多个处理实体上。处理实体可以被配置为不同的配置，包括物理硬件，和/或作为虚拟部件或虚拟机，和/或作为虚拟容器，其中容器不同于虚拟机，因为它虚拟化正在虚拟化操作系统上运行的游戏应用的实例。处理实体可以利用和/或依赖云游戏网络190的一个或多个服务器上的服务器及其底层硬件，其中服务器可以位于一个或多个机架上。对各种处理实体执行这些功能的协调、分配和管理由分布同步层执行。以这种方式，这些功能的执行由分布同步层控制，以响应于玩家的控制器输入为游戏应用生成媒体。分布同步层能够跨分布式处理实体有效地执行这些功能，以使得关键的游戏引擎部件/功能被分布和重新组装以进行更有效的处理。图2是根据本公开的一个实施方案的其中多个GPU协作以渲染对应应用的单个图像的示例性多GPU架构200的示意图。应当理解，在本公开的各种实施方案中，许多架构是可能的，其中多个GPU协作以渲染单个图像，尽管没有明确地描述或示出。例如，在渲染时通过执行区域测试来为应用进行几何图形的多GPU渲染可以在云游戏系统的一个或多个云游戏服务器之间实现，或者可以在独立系统内实现，等等。多GPU架构200包括CPU 163和多个GPU，其被配置用于为应用的单个图像和/或应用的图像序列中的每个图像进行多GPU渲染。特别地，CPU 163和GPU资源365被配置用于执行基于处理器的功能，包括2D或3D渲染、物理模拟、脚本化、音频、动画、图形处理、照明、着色、光栅化、光线追踪、阴影、剔除、变换、人工智能等，如前所述。例如，在多GPU架构200的GPU资源365中示出了四个GPU，尽管在为应用渲染图像时可以使用任意数量的GPU。每个GPU经由高速总线220连接到对应的专用存储器，诸如随机存取存储器。特别地，GPU-A经由总线220连接到存储器210A，GPU-B经由总线220连接到存储器210B，GPU-C经由总线220连接到存储器210C，和GPU-D经由总线220连接到存储器210D。此外，每个GPU经由总线240彼此连接，取决于架构，总线240在速度上可能大约等于或慢于用于对应GPU与其对应存储器之间的通信的总线220。例如，GPU-A经由总线240连接到GPU-B、GPU-C和GPU-D中的每一个。同样，GPU-B经由总线240连接到GPU-A、GPU-C和GPU-D中的每一个。此外，GPU-C经由总线240连接到GPU-A、GPU-B和GPU-D中的每一个。进一步，GPU-D经由总线240连接到GPU-A、GPU-B和GPU-C中的每一个。CPU 163经由较低速度的总线230连接到每个GPU。具体地，CPU 163连接到GPU-A、GPU-B、GPU-C和GPU-D中的每一个。在一些实施方案中，四个GPU是分立的GPU，每个都在它们自己的硅片上。在其他实施方案中，四个GPU可以共享一个裸片，以便利用裸片上的高速互连和其他单元。在其他实施方案中，有一个物理GPU 250可以被配置为用作单个更强大的GPU或用作四个不太强大的“虚拟”GPU。也就是说，GPU-A、GPU-B、GPU-C和GPU-D每个都有足够的功能来操作一个图形流水线，芯片作为一个整体可以操作一个图形流水线，并且配置可以在两种配置之间灵活切换。图3是根据本公开的一个实施方案的被配置用于在渲染时通过区域测试为应用在渲染单个图像时进行几何图形的多GPU渲染的图形处理单元资源365的示意图。例如，游戏服务器160可以被配置为在图1的云游戏网络190中包括GPU资源365。如图所示，GPU资源365包括多个GPU，诸如GPU 365a、GPU 365b……GPU 365n。如前所述，各种架构可能包括多个GPU协作以通过在渲染时通过区域测试为应用执行几何图形的多GPU渲染来渲染单个图像，诸如在云游戏系统的一个或多个云游戏服务器之间实现几何图形的多GPU渲染，或在独立系统内实现几何图形的多GPU渲染，等等。特别地，在一个实施方案中，游戏服务器160被配置为在渲染应用的单个图像时执行多GPU处理，使得多个GPU协作以渲染单个图像，和/或在执行应用时渲染图像序列的一个或多个图像中的每一个。例如，在一个实施方案中，游戏服务器160可以包括CPU和GPU组，其被配置为对应用的图像序列中的一个或多个图像中的每一个执行多GPU渲染，其中一个CPU和GPU组可以实现应用的图形和/或渲染流水线。CPU和GPU组可以被配置为一个或多个处理装置。如前所述，GPU和GPU组可以包括CPU 163和GPU资源365，其被配置用于执行基于处理器的功能，包括2D或3D渲染、物理模拟、脚本化、音频、动画、图形处理、照明、着色、光栅化、光线追踪、阴影、剔除、变换、人工智能等。GPU资源365负责和/或配置用于渲染对象和执行同步计算内核；要执行的同步计算和要渲染的对象由包含在GPU将执行的多个渲染命令缓冲区325中的命令指定。特别地，GPU资源365被配置为在执行来自渲染命令缓冲区325的命令时渲染对象并执行同步计算，其中命令和/或操作可以依赖于其他操作，使得它们依次执行。例如，GPU资源365被配置为使用一个或多个渲染命令缓冲区325来执行同步计算和/或对象的渲染。在一个实施方案中，GPU资源365中的每个GPU可以具有它们自己的命令缓冲区。替代地，当每个GPU正在渲染基本上相同的一组对象时，GPU资源365中的GPU可以使用相同的命令缓冲区或相同的一组命令缓冲区。此外，GPU资源365中的每个GPU可以支持命令由一个GPU执行而不是由另一个GPU执行的能力。例如，绘制命令上的标志或渲染命令缓冲区中的预测允许单个GPU执行对应命令缓冲区中的一个或多个命令，而其他GPU将忽略这些命令。例如，渲染命令缓冲区325a可以支持标志330a，渲染命令缓冲区325b可以支持标志330b……渲染命令缓冲区325n可以支持标志330n。同步计算的性能和对象的渲染是整体渲染的一部分。例如，如果视频游戏以60Hz运行，则图像帧的所有对象渲染和同步计算内核的执行通常必须在大约16.67毫秒内完成。如前所述，渲染对象和/或执行同步计算内核时执行的操作是有序的，使得操作可能依赖于其他操作。特别地，每个渲染命令缓冲区325包含各种类型的命令，包括影响对应GPU配置的命令，以及渲染对象和/或执行同步计算内核的命令。为了说明的目的，执行同步计算内核时执行的同步计算可以包括当对象全部被渲染到一个或多个对应多渲染目标时执行全屏效果。此外，当GPU资源365为图像帧渲染对象，和/或在生成图像帧时执行同步计算内核时，GPU资源365经由每个GPU 365a、365b……365n的寄存器进行配置。例如，GPU 365a经由其寄存器340配置为以某种方式执行该渲染或计算内核执行。也就是说，当执行渲染命令缓冲区325中的命令用于渲染对象和/或执行图像帧的同步计算内核时，存储在寄存器340中的值定义用于GPU 365a的硬件背景。GPU资源365中的每个GPU可以被类似地配置，使得GPU 365b经由其寄存器350被配置为以某种方式执行该渲染或计算内核执行；……并且GPU 365n经由其寄存器370被配置为以某种方式执行该渲染或计算内核执行。GPU配置的一些示例包括渲染目标的位置和格式。此外，GPU配置的其他示例包括操作程序。例如，在渲染对象时，可以通过各种方式将对象的每个像素的Z值与Z缓冲区进行比较。例如，仅当对象Z值与Z缓冲区中的值匹配时才写入对象像素，表示对象像素未被遮挡。替代地，仅当对象Z值等于或小于Z缓冲区中的值时才可以写入对象像素，表明对象像素未被遮挡。正在执行的测试类型在GPU配置中定义。图4是根据本公开的一个实施方案的实现被配置用于多GPU处理以使得多个GPU协作以渲染单个图像的图形流水线400的渲染架构的简化图。图形流水线400说明了使用3D多边形渲染过程来渲染图像的一般过程。用于渲染图像的图形流水线400为显示器中的每个像素输出对应的颜色信息，其中颜色信息可以表示纹理和着色。图形流水线400可以在图1和图3的客户端装置110、游戏服务器160、游戏名称处理引擎111和/或GPU资源365内实现。也就是说，各种架构可能包括多个GPU协作以通过在渲染时通过区域测试为应用执行几何图形的多GPU渲染来渲染单个图像，诸如在云游戏系统的一个或多个云游戏服务器之间实现几何图形的多GPU渲染，或在独立系统内实现几何图形的多GPU渲染，等等。如图所示，图形流水线接收输入几何图形405。例如，几何图形处理级410接收输入几何图形405。例如，输入几何图形405可以包括3D游戏世界内的顶点，以及对应于每个顶点的信息。游戏世界中的给定对象可以使用由顶点定义的多边形来表示，其中对应多边形的表面然后通过图形流水线400进行处理以实现最终效果。顶点属性可以包括法线、颜色，以及纹理坐标/映射信息。几何图形处理级410负责顶点处理和图元处理两者。特别地，几何图形处理级410可以输出定义图元的顶点集合并将它们传递到图形流水线400的下一级，以及输出这些顶点的位置和各种其他参数。这些位置被放置在位置高速缓存450中以供后面的着色器级访问。其他参数被放置在参数高速缓存460中，再次供后面的着色器级访问。几何图形处理级410可以执行各种操作，诸如对图元和/或多边形执行光照和阴影计算。在一个实施方案中，由于几何图形级能够处理图元，它可以执行背面剔除和/或剪裁，从而减少下游级的负载。在另一实施方案中，几何图形级可以生成图元。几何图形处理级410输出的图元被馈送到光栅化级420，光栅化级420将图元转换成由像素组成的光栅图像。特别地，光栅化级420被配置为将场景中的对象投影到由3D游戏世界中的观看位置定义的二维图像平面。在简单的级别上，光栅化级420查看每个图元并确定哪些像素受到对应图元的影响。特别地，光栅化器420将图元分割成像素大小的片段，其中每个片段对应于显示器中的一个像素。重要的是要注意，在显示图像时，一个或多个片段可能会影响对应像素的颜色。如前所述，光栅化级420还可以执行附加操作，诸如针对观看位置裁剪和剔除。关于裁剪，几何图形处理级410和/或光栅化级420可以被配置为识别和忽略在由游戏世界中的观看位置定义的视锥体之外的图元。像素处理级430使用由几何图形处理级创建的参数以及其他数据来生成诸如像素的得到的颜色之类的值。特别地，像素处理级430在其核心对片段执行着色操作以确定图元的颜色和亮度如何随可用照明而变化。例如，像素处理级430可以确定每个片段的深度、颜色、法线和纹理坐标，并且可以进一步确定片段的适当的明度、暗度和颜色水平。特别地，像素处理级430计算每个片段的特征，包括颜色和其他属性。此外，像素处理级430基于影响对应片段的可用照明将照明效果应用到片段。此外，像素处理级430可以为每个片段应用阴影效果。像素处理级430的输出包括处理后的片段并被传递到图形流水线400的下一个级中的输出合并级440。输出合并级440使用像素处理级430的输出以及诸如已经在存储器中的值等其他数据为像素生成最终颜色。例如，输出合并级440可以对从像素处理级430确定的片段和/或像素之间的值与已经写入该像素的MRT的值进行可选的混合。显示器中每个像素的颜色值可以存储在帧缓冲区中。当显示场景的对应图像时，这些值被扫描到对应的像素。特别是，显示器逐行地从左到右或从右到左、从上到下或从下到上、或以任何其他模式从每个像素的帧缓冲区中读取颜色值，并在显示图像时使用这些像素值照亮像素。利用图1-图3的云游戏网络190和GPU资源365的详细描述，图5的流程图500图示了根据本公开的一个实施方案的在渲染时通过区域测试为应用实现几何图形的多GPU渲染时的图形处理方法。以这种方式，多个GPU资源用于在执行应用时执行对象的渲染和/或同步计算操作。如前所述，各种架构可能包括多个GPU协作以通过在渲染时通过区域测试为应用执行几何图形的多GPU渲染来渲染单个图像，诸如在云游戏系统的一个或多个云游戏服务器内，或在独立系统内，等等。在510，该方法包括使用协作生成图像的多个图形处理单元为应用渲染图形。特别地，当为实时应用渲染单个图像和/或图像序列中的一个或多个图像中的每一个时，执行多GPU处理。在520，该方法包括基于多个屏幕区域划分多个GPU之间的渲染图形的几何图形的责任。也就是说，每个GPU都有对所有GPU都已知的对应的责任划分。GPU同时渲染对应的图像。在渲染几何图形时，GPU会生成有关几何图形及其与其他GPU负责的屏幕区域的关系的信息。这允许其他GPU更有效地渲染几何图形，和/或完全避免渲染该几何图形。换句话说，在渲染方面“领先”于其他GPU的GPU可以向其他GPU提供信息，从而加速它们的处理。特别地，在530，该方法包括在第二GPU处为图像渲染一个几何图形的同时，生成关于该几何图形相对于第一GPU具有第一责任划分的第一屏幕区域的信息。更具体地，每个GPU负责在多个屏幕区域的对应的一组屏幕区域中渲染几何图形，其中对应的一组屏幕区域包括一个或多个屏幕区域。例如，第一GPU具有在第一组屏幕区域中渲染对象的第一责任划分。此外，第二GPU具有在第二组屏幕区域中渲染对象的第二责任划分。这样，每个GPU同时开始渲染对象，其中在渲染对象方面领先的一个GPU可以生成关于一个几何图形的提示，该提示有助于另一个可能负责或可能不负责渲染该几何图形的GPU。例如，在渲染几个几何图形时，GPU会相对于其他GPU负责的屏幕区域测试几何图形。测试结果被发送到那些其他GPU。特别地，在渲染时，第二GPU会测试图像的几何图形。第二GPU生成关于几何图形相对于第一GPU被分配负责的一个或多个屏幕区域的信息用于第一GPU。例如，该测试可以包括一个几何图形是否与第一GPU被分配负责的一个或多个屏幕区域重叠。在540，该方法包括使用该信息在第一GPU处渲染该几何图形。具体来说，在某些架构中，如果对应的渲染GPU及时接收到对应的信息以使用它，则该GPU在决定渲染对应图像中的哪个几何图形时将使用该信息。也就是说，该信息可以作为提示。否则，渲染GPU将像往常一样处理该几何图形。使用其中信息可以指示几何图形是否与被分配给第一GPU的一个或多个屏幕区域重叠的示例，如果信息指示几何图形没有重叠，则第一GPU可以完全跳过渲染该几何图形。此外，如果信息指示只有几个几何图形不重叠，则第一GPU可以跳过那些不与第一GPU被分配负责的一个或多个屏幕区域重叠的几何图形。另一方面，该信息可能指示几何图形存在重叠，在这种情况下，第一GPU将渲染该几何图形。此外，该信息可以指示某些几何图形与第一GPU被分配负责的一个或多个屏幕区域重叠。在这种情况下，第一GPU将只渲染那些重叠的几何图形。在又一实施方案中，如果没有信息，或者如果没有及时生成或接收信息，则第一GPU将正常执行渲染。因此，如果作为提示提供的信息被及时接收到，可以提高图形处理系统的整体效率。在一个实施方案中，如果没有及时接收到信息，图形处理系统在没有这种信息的情况下仍将正常运行。图6A-图6B示出对被细分为区域的屏幕的渲染，纯粹是为了说明的目的。应当理解，为了对图像和/或图像序列中的一个或多个图像中的每一个进行有效的多GPU处理，可以选择细分区域的数量。也就是说，多个细分区域可以包括两个或更多区域。在本公开的一个实施方案中，屏幕被细分为四个象限，如图6A所示。在本公开的另一个实施方案中，屏幕被细分为更大数量的交错区域，如图6B所示。下面的图6A-图6B的讨论旨在说明在对分配有多个GPU的多个屏幕区域执行多GPU渲染时出现的低效率；图7A-图7C和图8A-图8B示出了根据本发明的一些实施方案的更有效的渲染。特别地，图6A是在执行多GPU渲染时被细分为象限的屏幕610A的示意图。如图所示，屏幕610A被细分为四个象限。每个象限以一对一的关系分配给四个GPU之一。例如，GPU-A分配给象限A，GPU-B分配给象限B，GPU-C分配给象限C，和GPU-D分配给象限D。几何图形可以被剔除。例如，CPU 163可以检查每个象限的平截头体的边界框，并请求每个GPU仅渲染与其对应平截头体重叠的对象。结果是每个GPU只负责渲染几何图形的一部分。出于说明的目的，屏幕610示出几个几何图形，其中每个都是对应的对象，其中屏幕610示出对象611-617。GPU-A将不渲染任何对象，因为没有对象与象限A重叠。GPU-B将渲染对象615和616。GPU-C将渲染对象611和612。GPU-D将渲染对象612、613、614、615和617。如图6A所示，当屏幕610A被划分为象限A-D时，每个GPU必须执行的工作量可能非常不同，因为在某些情况下，不成比例的几何图形量可能在一个象限中。例如，象限A没有任何几何图形，而象限D具有五个几何图形，或至少五个几何图形的至少一部分。因此，分配给象限A的GPU-A将处于空闲状态，而分配给象限D的GPU-D在渲染对应图像中的对象时会异常繁忙。图6B图示了将屏幕细分为区域时的另一种技术。特别地，屏幕610B不是细分为象限，而是在对单个图像或图像序列中的一个或多个图像中的每一个执行多GPU渲染时细分为多个交错区域。在那种情况下，屏幕610B被细分为更大数量的交错区域，同时使用相同数量的GPU进行渲染。屏幕610A中所示的对象也显示在屏幕610B中相同的对应位置。特别地，四个GPU用于为对应的应用渲染图像。每个GPU负责渲染与对应区域重叠的几何图形。也就是说，每个GPU都被分配到一组对应的区域。例如，GPU-A负责对应组中标记为A的每个区域，GPU-B负责对应组中标记为B的每个区域，GPU-C负责对应组中标记为C的每个区域，和GPU-D负责对应组中标记为D的每个区域。此外，这些区域以特定模式交错。由于区域的交错，每个GPU必须执行的工作量可能会更加平衡。例如，屏幕610B的交错模式包括交替行，包括区域A-B-A-B等，以及区域C-D-C-D等。在本公开的实施方案中支持交错区域的其他模式。例如，模式可以包括重复的区域序列、均匀分布的区域、区域的不均匀分布、区域序列的重复行、随机的区域序列、区域序列的随机行等。选择区域的数量很重要。例如，如果区域的分布太细，则每个GPU仍必须处理大几何图形的部分或所有。例如，可能很难针对GPU负责的所有区域检查对象边界框。此外，即使可以及时检查边界框，由于区域大小较小，结果将是每个GPU可能必须处理几何图形的大部分，因为图像中的每个对象都与每个GPU的至少一个区域重叠。因此，选择区域数量、交错模式等很重要。选择太少或太多的区域、或者太少或太多的区域用于交错、或者选择用于交错的低效模式可能导致在执行GPU处理时效率低下。在这些情况下，即使有多个GPU用于渲染图像，由于GPU效率低下，也无法支持对应增加的屏幕像素计数和几何图形密度。以下实施方案针对剔除策略和剔除粒度的改进以及其他进步。图7A-图7C是图示在本公开的实施方案中使用多个GPU来渲染单个图像和/或图像序列中的至少一个或多个图像中的每一个的示意图。选择四个GPU纯粹是为了便于说明在执行应用时渲染图像时的多GPU渲染，并且可以理解，在各种实施方案中，任何数量的GPU都可以用于多GPU渲染。特别地，图7A是根据本公开的一个实施方案的由协作以渲染单个图像的多个GPU共享的渲染命令缓冲区700A的示意图。也就是说，在本示例中，多个GPU各自使用相同的渲染命令缓冲区，并且每个GPU执行渲染命令缓冲区中的所有命令。多个命令被加载到渲染命令缓冲区700A中，并且用于渲染对应的图像。可以理解，一个或多个渲染命令缓冲区可用于生成对应的图像。在一个示例中，CPU为图像帧生成一个或多个绘制调用，其中绘制调用包括放置在一个或多个渲染命令缓冲区中以供图3的GPU资源365的一个或多个GPU在执行对应图像的多GPU渲染时执行的命令。在一些实施方式中，CPU163可以请求一个或多个GPU来生成用于渲染对应图像的绘制调用的所有或一些。此外，整个命令集可以在图7A中示出，并且全部包含在渲染命令缓冲区700A中，或图7A可以示出包含在渲染命令缓冲区700A内的整个命令集的一部分。当对图像或图像序列中的一个或多个图像中的每一个执行多GPU渲染时，GPU会同时进行渲染。图像的渲染可以分为多个阶段。在每个阶段中，GPU都需要被同步，使得较快的GPU必须等到较慢的GPU完成。图7A中所示的用于渲染命令缓冲区700A的命令示出了一个阶段，其中渲染命令缓冲区700A可以包括用于渲染图像时的一个或多个阶段的命令。在图7A所示的图示了一个阶段的渲染命令缓冲区700A中，有四个要被渲染的对象，如图7B-1所示。如图所示，图7A中所示的渲染命令缓冲区700A包括用于渲染对象的命令和用于配置正在执行来自渲染命令缓冲区700A的命令的一个或多个渲染GPU的状态的命令。命令可以进一步分成命令段，其中每个段包括一个或多个命令。用于对象渲染和/或同步计算的命令作为对应图像的渲染的一部分来执行。在一些实施方式中，必须在帧周期内执行该图像的对象渲染和/或同步计算内核的执行。仅出于说明的目的，图7A中所示的渲染命令缓冲区700A包括八个命令段，这些命令段用于在为对应应用渲染对应图像时渲染对象和/或执行同步计算内核。例如，图7A中所示的渲染命令缓冲区700A包括四个命令段710、712、714和716，每个命令段用于配置正在执行渲染命令缓冲区700A中的命令的一个或多个渲染GPU的状态。如前所述，当执行渲染命令缓冲区700A中的用于为对应图像渲染对象和/或执行同步计算内核的命令时，存储在寄存器中的值定义了对应GPU的硬件背景。如图所示，GPU状态可以在渲染命令缓冲区700A中的命令处理的整个过程中被修改，每个后续的命令段可以用于配置GPU状态。此外，图7A所示的渲染命令缓冲区700A包括用于渲染对应对象的命令段711、713、715和717。例如，段711中的一个或多个命令用于绘制和/或渲染对象0，段713中的一个或多个命令用于绘制和/或渲染对象1，段715中的一个或多个命令用于绘制和/或渲染对象2，并且段717中的一个或多个命令用于绘制和/或渲染对象3。虽然图7A示出了用于配置GPU状态的段在用于对象渲染的命令段中的每一个之前，但应当理解，GPU状态可以被配置为渲染一个或多个对象。多个GPU共享信息以帮助确定哪些对象需要由对应的GPU渲染。每个GPU可以负责在屏幕的特定区域内渲染，其中对应GPU渲染完全和/或部分重叠该区域或该组区域的对象。在渲染期间，第二GPU可以生成有关对象及其在屏幕内的位置的提示。如图所示，提示721可以由第二GPU在针对对象0执行渲染操作时生成，并且可以提供给其他GPU中的每一个。类似地，提示723可以由第二GPU在针对对象1执行渲染操作时生成，并且可以提供给其他GPU中的每一个。此外，提示725可以由第二GPU在针对对象2执行渲染操作时生成。同样，提示727可以由第二GPU在针对对象3执行渲染操作时生成。特别地，在渲染期间，第二GPU可以相对于其他GPU具有渲染责任的屏幕区域测试图像中的对象的至少一个。可以将包括测试结果的信息发送到那些其他GPU，以便那些其他GPU可以使用该信息来减少它们自己对对象的测试和/或有效地渲染这些对象。例如，该信息可以指示第一GPU应该完全跳过渲染一个几何图形。在另一示例中，该信息作为提示被提供给第一GPU，使得如果在第一GPU处的该第一几何图形的渲染开始之前接收到该信息，则第一GPU考虑该信息。在一个实施方案中，如果没有及时接收到信息，则第一几何图形由第一GPU完全渲染。仅出于说明目的，四个GPU在它们之间将对应的屏幕划分为区域。箭头示出区域测试的其他GPU的通知。例如，在渲染期间生成提示的第二GPU将该提示提供给其他GPU。如前所述，每个GPU负责在对应的一组区域中渲染对象，其中对应的一组包括一个或多个区域。在一个实施方案中，渲染命令缓冲区700A由协作渲染单个图像的多个GPU共享。也就是说，用于单个图像或图像序列中的一个或多个图像中的每一个的多GPU渲染的GPU共享一个公共命令缓冲区。以这种方式，向可能渲染或可能不渲染相同对象的另一个GPU提供对象提示的第二GPU各自共享相同的命令缓冲区。在另一个实施方案中，每个GPU可能具有其自己的命令缓冲区。替代地，在又一个实施方案中，每个GPU可能正在渲染稍微不同的几组对象。这可能是当可以确定特定GPU不需要渲染特定对象时的情况，因为它不与对应组中的其对应屏幕区域重叠。多个GPU仍然可以使用相同的命令缓冲区，只要命令缓冲区支持命令由一个GPU而不是另一个GPU执行的能力，如前所述。例如，共享渲染命令缓冲区700A中的命令的执行可以限于渲染GPU之一。这可以通过多种方式实现。在另一个示例中，可以在对应的命令上使用标志来指示哪些GPU应该执行它。此外，可以在渲染命令缓冲区中使用位来实现预测，以说明哪个GPU在什么条件下做什么。预测的示例包括——“如果这是GPU-A，则跳过以下X命令”。在又一个实施方案中，由于每个GPU正在渲染基本上相同的一组对象，因此多个GPU仍可以使用相同的命令缓冲区。例如，当区域相对较小时，每个GPU仍可以渲染所有对象，如前所述。图7B-1图示了根据本公开的一个实施方案的屏幕700B，其示出了包括由多个GPU使用图7A的渲染命令缓冲区700A渲染的四个对象的图像。几何图形的多GPU渲染是在对应图像中的几何图形的渲染过程中通过区域测试为应用执行的。特别地，几何图形的渲染责任在多个GPU之间通过屏幕区域划分，其中多个屏幕区域被配置为减少多个GPU之间的渲染时间不平衡。例如，屏幕700B示出了在渲染图像对象时每个GPU的屏幕区域责任。四个GPU用于渲染屏幕700B中所示的图像中的对象。屏幕700B比如图6A所示通过象限被更精细地划分，努力平衡GPU之间的像素和顶点负载。此外，屏幕700B被划分为交错的区域。例如，交错包括多行区域。行731和733中的每一行包括与区域B交替的区域A。行732和734中的每一行包括与区域D交替的区域C。更具体地，在一个模式中，包括区域A和B的行与包括区域C和区域D的行交替。如前所述，为了实现GPU处理效率，可以在将屏幕划分为区域时使用各种技术，诸如增加或减少区域的数量、交错区域、增加或减少用于交错的区域的数量、在交错区域时选择特定模式等。在一个实施方案中，多个屏幕区域中的每个屏幕区域的大小是统一的。在一个实施方案中，多个屏幕区域中的每一个在大小上是不统一的。在又一个实施方案中，多个屏幕区域的数量和大小动态地改变。GPU中的每一个负责在对应的一组区域中渲染对象，其中每组可以包括一个或多个区域。因此，GPU-A负责在对应组的每个A区域中渲染对象，GPU-B负责在对应组中每个B区域中渲染对象，GPU-C负责在对应组中每个C区域中渲染对象，和GPU-D负责在对应组中每个D区域中渲染对象。也可能有具有其他责任的GPU，使得它们可能不执行渲染。对于每个GPU，要执行的渲染量是不同的。图7B-2图示了根据本公开的一个实施方案的示出当渲染图7B-1的四个对象时由每个GPU执行的渲染的表格。如表格所示，GPU A渲染对象2；GPU B渲染对象0、2和3；GPU C渲染对象1和3；和GPU D渲染对象1、2和3。可能仍然存在某一不平衡的渲染，因为GPU A只需要渲染对象2，而GPU D需要渲染对象1、2和3。但是，总体而言，通过屏幕区域的交错，图像内对象的渲染在用于图像的多GPU渲染或图像序列中的一个或多个图像中的每一个的渲染的多个GPU之间得到合理平衡。图7C是图示了根据本公开的一个实施方案的在多个GPU协作以渲染图7B-1所示的单个图像时由每个GPU执行的对每个对象的渲染的示意图。特别地，图7C示出了由四个GPU中的每一个使用图7A的共享渲染命令缓冲区700A执行的对象0-3的渲染过程。特别地，相对于时间线740示出了两个渲染时序图。渲染时序图700C-1示出了在一个渲染阶段中对应图像的对象0-3的多GPU渲染，其中每个GPU在没有关于对象0-3和屏幕区域之间的重叠的任何提示的情况下执行渲染。渲染时序图700C-2示出了在相同渲染阶段中对应图像的对象0-3的多GPU渲染，其中在每个GPU的关于对象0-3和屏幕区域之间的重叠进行渲染期间共享提示。渲染时序图700C-1和700C-2中的每一个示出了每个GPU处理每个几何图形所花费的时间。在一个实施方案中，一个几何图形是一个完整的对象。在另一个实施方案中，一个几何图形可以是对象的一部分。为了说明的目的，图7C的示例示出了几个几何图形的渲染，其中每个几何图形对应于一个对象。在渲染时序图700C-1和700C-2中的每一个中，不具有与对应GPU的至少一个屏幕区域重叠的几何图形的对象由用虚线绘制的框表示。另一方面，具有与对应GPU的至少一个屏幕区域重叠的几何图形的对象由用实线绘制的框表示。渲染时序图700C-1示出了使用四个GPU渲染对象0-3。竖直线755a指示对象的渲染阶段的开始，而竖直线755b示出渲染时序图700C-1中对象的渲染阶段的结束。沿时间线740所示的渲染阶段的开始点和结束点表示同步点，其中四个GPU中的每一个在执行对应的GPU流水线时被同步。例如，在指示渲染阶段结束的竖直线755b处，所有GPU必须等待最慢的GPU通过对应的图形流水线完成对象0-3的渲染，然后才能进入下一个渲染阶段。在渲染渲染时序图700C-1中所示的对象时不提供提示。因此，每个GPU必须通过对应的图形流水线处理每个对象。如果在分配给对应GPU以进行对象渲染的区域没有要为对象绘制的像素，则GPU可能通过图形流水线不完全渲染对象。例如，当一个对象不重叠时，只执行图形流水线的几何图形处理级。但是，在没有提示的情况下，这仍然需要一些时间来处理。特别是，GPU-A不会完全渲染对象0、1和3，因为它们不会与分配给GPU-A以进行对象渲染的任何屏幕区域重叠。这三个对象的渲染显示在虚线框中，表示至少执行了几何图形处理级，但没有完全执行图形流水线。GPU-A完全渲染对象2，因为该对象与分配给GPU-A用于渲染的至少一个屏幕区域重叠。对象2的渲染显示在实线框中，表示对应图形流水线的所有级都执行。类似地，GPU-B不会完全渲染对象1，但会完全渲染对象0、2和3，因为那些对象与分配给GPU-B用于渲染的至少一个屏幕区域重叠。同样，GPU-C不会完全渲染对象0和2，但会完全渲染对象，因为那些对象与分配给GPU-C用于渲染的至少一个屏幕区域重叠。此外，GPU-D不会完全渲染对象0，但会完全渲染对象1、2和3，因为那些对象与分配给GPU-D用于渲染的至少一个屏幕区域重叠。渲染时序图700C-2示出了在共享提示执行多GPU渲染时对象0-3的渲染。具体而言，提示在每个GPU之间共享，并在通过对应的GPU流水线渲染对象0-3时被考虑。竖直线750a指示对象的渲染阶段的开始，而竖直线750b示出渲染时序图700C-2中对象的渲染阶段的结束。时序图700C-2中沿时间线740所示的渲染阶段的开始点和结束点表示同步点，其中四个GPU中的每一个在执行对应的GPU流水线时被同步，如前所述。例如，在指示渲染阶段结束的竖直线750b处，所有GPU必须等待最慢的GPU通过对应的图形流水线完成对象0-3的渲染，然后才能进入下一个渲染阶段。竖直线750a与竖直线755a对齐，使得渲染时序图700C-1和700C-2中的每一个同时开始以渲染对象0-1。然而，渲染时序图700C-2中所示的对象0-3的渲染比渲染时序图700C-1中所示的渲染在更短的时间内执行。也就是说，指示下部时序图700C-2的渲染阶段结束的竖直线750b出现早于如竖直线755b所指示的上部时序图700C-1的渲染阶段结束。具体地，当执行区域测试并为那些测试的结果提供提示时，当为应用执行图像的几何图形的多GPU渲染时，实现了渲染对象0-3时的速度增加745。如图所示，速度增加745是时序图700C-2的竖直线750b和时序图700C-1的竖直线755b之间的时间差。速度增加是通过提示的生成和共享来实现的。特别是，当GPU通过图形流水线处理对象时，每个GPU都会检查对象并向其他GPU发送有关对象如何关联这些GPU的屏幕责任的信息作为提示。例如，在渲染时序图700C-2中提供了三个提示761-763，这减少了用于渲染对象0-3的总时间。提示可以被表示为箭头，其中对应的箭头示出一个GPU通知第二GPU它可以跳过一个对象，并且第二GPU成功地跳过那个对象。可以在渲染期间的任何时间点生成提示，使得即使GPU没有完全渲染对象，该GPU仍然可以生成关于该对象的提示并将该提示提供给其他GPU用于渲染。例如，GPU-A对对象1执行几何图形处理，并确定对象1可以被GPU-B跳过，因为对象1不与分配给GPU-B以用于对象渲染的任何区域重叠。此外，对象1没有完全由GPU-A渲染，因为它不与分配给GPU-A以用于对象渲染的任何区域重叠。由于在GPU-B开始对对象1进行几何图形处理之前确定对象1没有与被分配给GPU-B的区域重叠，因此GPU-B跳过对象1的渲染。特别是，GPU-A开始渲染对象1并得知对象1不与分配给GPU-B以用于对象渲染的任何区域重叠。这样，GPU-A可以生成并传递带有指示GPU-B不需要渲染对象1的信息的提示761。及时传递提示761，即在GPU-B开始渲染对象1之前。作为参考，甚至在上部时序图700C-1中的GPU-B执行对象1的渲染之前提供提示761。在这种情况下，GPU-B可以完全跳过对象1的渲染过程，从而不为该对象执行对应图形流水线的任何级。继续渲染时序图700C-2的示例，GPU-B完全渲染对象2。在对象2的渲染期间，GPU-B确定对象2不与分配给GPU-C以用于对象渲染的任何区域重叠。因为这个确定是在GPU-C开始对对象2进行几何图形处理之前做出的，所以GPU-C能够跳过对象2的渲染。例如，GPU-B可以生成并传递带有指示GPU-C不需要渲染对象2的信息的提示762。提示762被及时传递，即在GPU-C开始渲染对象2之前。作为参考，甚至在上部时序图700C-1中的GPU-C执行对象2的渲染之前提供提示762。在这种情况下，GPU-C可以完全跳过对象2的渲染过程，从而不为该对象执行对应图形流水线的任何级。GPU-B还完全渲染对象3。在渲染期间，GPU-B确定对象3不与分配给GPU-A以用于对象渲染的任何区域重叠。因为这个确定是在GPU-A开始对对象3进行几何图形处理之前做出的，所以GPU-A能够跳过对象3的渲染。例如，GPU-B可以生成并传递带有指示GPU-A不需要渲染对象3的信息的提示763。提示763被及时传递，即在GPU-A开始渲染对象3之前。在这种情况下，GPU-A可以完全跳过对象3的渲染过程，从而不为该对象执行对应图形流水线的任何级。图8A-图8B示出了针对屏幕区域820A和820B的对象测试，其中屏幕区域可以是交错区域。具体而言，在屏幕中渲染对象时，通过区域测试对单个图像或图像序列中的一个或多个图像中的每一个执行对象的多GPU渲染。GPU-A被分配负责在屏幕区域820A中渲染对象。GPU-B被分配负责在屏幕区域820B中渲染对象。为“几个几何图形”生成信息，其中这些几何图形可以是整个对象或对象的一部分。例如，一个几何图形可以是对象810，或对象810的几部分。图8A图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时针对屏幕区域的对象测试。如前所述，几个几何图形可以是对象，使得这几个几何图形对应于由对应的绘制调用使用或生成的几何图形。在测试期间，可以确定对象810与区域820A重叠。也就是说，对象810的部分810A与区域820A重叠。在这种情况下，GPU-A的任务是渲染对象810。同样，在测试期间，可以确定对象810与区域820B重叠。也就是说，对象810的部分810B与区域820B重叠。在这种情况下，GPU-B的任务也是渲染对象810。图8B图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时针对屏幕区域的对对象的多部分的测试。也就是说，这几个几何图形可以是对象的一部分。例如，对象810可以被分割成几片，使得由绘制调用使用或生成的几何图形被细分成更小的几何图形。在一个实施方案中，几何图形的每一个大致是为其分配的位置高速缓存和/或参数高速缓存的大小。在那种情况下，为那些更小的几何图形生成信息，其中该信息由渲染GPU使用，如前所述。例如，对象810被分割成多个对象，使得用于区域测试和提示的几个几何图形对应于这些更小的对象。如图所示，对象810被分割成几个几何图形“a”、“b”、“c”、“d”、“e”和“f”。在区域测试之后，GPU-A只渲染几个几何图形“a”、“b”、“c”、“d”和“e”。也就是说，GPU-A可以跳过渲染几何图形“f”。同样，在区域测试之后，GPU-B仅渲染几个几何图形“d”、“e”和“f”。也就是说，GPU-B可以跳过渲染几何图形“a”、“b”和“c”。在一个实施方案中，由于几何图形处理级被配置为执行顶点处理和图元处理，因此可能在几何图形处理级中使用的着色器中执行一个几何图形的测试。例如，几何图形处理级生成信息，诸如通过针对GPU屏幕区域测试几何图形的边界平截头体，这可以由软件着色器操作执行。在一个实施方案中，通过使用专用指令或通过硬件实现的指令来加速该测试，从而实现软件/硬件解决方案。也就是说，一个或多个专用指令用于加速关于几何图形及其与屏幕区域的关系的信息的生成。例如，几何图形的图元顶点的齐次坐标作为输入提供给几何图形处理级的区域测试指令。该测试可以为每个GPU生成布尔返回值，该布尔返回值指示图元是否与分配给该GPU的任何屏幕区域重叠。这样，关于对应几何图形及其与屏幕区域的关系的信息由几何图形处理级中的着色器生成。在另一个实施方案中，可以在硬件光栅化级执行对一个几何图形的测试。例如，硬件扫描转换器可以被配置为执行多GPU区域测试。特别是，由于GPU必须针对其自己的屏幕区域测试几何图形，因此可以修改硬件，以便扫描转换器为其他GPU的屏幕区域生成信息。这样，硬件扫描转换器可以被配置为在光栅化级中生成关于对应的几何图形及其与渲染GPU负责的屏幕区域的关系的信息。在又一个实施方案中，几何图形可以是图元。也就是说，用于区域测试的对象部分可以是图元。因此，由一个GPU作为提示生成的信息指示是否需要由另一个渲染GPU渲染各个三角形。在一个实施方案中，作为提示提供的信息包括与分配给对应GPU以用于对象渲染的屏幕区域重叠的图元数。该信息还可以包括用于构建或定义这些图元的顶点数量。也就是说，该信息包括幸存顶点计数。因此，在渲染时，对应的渲染GPU可以使用提供的顶点计数来分配位置高速缓存和参数高速缓存中的空间。例如，在一个实施方案中，不需要的顶点没有任何分配的空间，这可以提高渲染效率。在其他实施方案中，作为提示提供的信息包括与分配给对应GPU以用于对象渲染的屏幕区域重叠的特定图元。也就是说，为渲染GPU生成的信息包括一组特定的用于渲染的图元。该信息还可以包括用于构建或定义这些图元的特定顶点。也就是说，为渲染GPU生成的信息包括一组特定的用于渲染的顶点。例如，此信息可以在渲染几何图形时在其几何图形处理级期间节省其他渲染GPU的时间。在其他实施方案中，可能存在与生成信息相关联的处理开销。在这种情况下，跳过生成信息作为针对某些几何图形的提示可能是有益的。也就是说，作为提示提供的信息是为某些对象生成的，而不是为其他对象生成的。例如，表示天空盒或大片地形的几何图形可以包括大的三角形。在这种情况下，用于图像或图像序列中的一个或多个图像中的每一个的多GPU渲染的每个GPU都可能需要渲染这些几何图形。也就是说，可以根据对应的几何图形的性质来生成或不生成信息。图9A-图9C图示了根据本公开的一个实施方案的当多个GPU协作渲染单个图像时用于将屏幕区域分配给对应GPU的各种策略。为了实现GPU处理效率，可以在将屏幕划分为区域时使用各种技术，诸如增加或减少区域的数量、交错区域、增加或减少用于交错的区域的数量、在交错区域时选择特定模式等。例如，多个GPU被配置为在渲染对应图像中的对象时通过区域测试为应用执行几何图形的多GPU渲染。图9A-图9C中的屏幕区域的配置被设计用于减少多个GPU之间的任何渲染时间不平衡。测试的复杂性根据屏幕区域如何分配给GPU而变化。如图9A-图9C中示出的示意图中所示，粗体框910是在渲染图像时使用的对应屏幕或显示器的轮廓。在一个实施方案中，多个屏幕区域或多个区域中的每一个都具有统一的大小。在一个实施方案中，多个屏幕区域中的每一个在大小上是不统一的。在又一个实施方案中，多个屏幕区域的数量和大小动态地改变。特别是，图9A图示了屏幕910的简单模式900A。每个屏幕区域的大小都是统一的。例如，每个区域的大小可以是尺寸为2像素的幂的矩形。例如，每个区域的大小可以是256x256像素。如图所示，区域分配是一个棋盘模式，其中一行A和B区域与另一行B和C区域交替。可以容易地测试模式900A。但是，可能存在一些渲染效率低下。例如，分配给每个GPU的屏幕面积基本上不同，这可能导致每个GPU的渲染时间不平衡。图9B图示了屏幕910的屏幕区域的模式900B。屏幕或子区域的大小每个都是统一的。屏幕区域被分配和分布，以减少GPU之间渲染时间的不平衡。例如，以模式900B将GPU分配给屏幕区域会导致跨屏幕910分配给每个GPU的屏幕像素量几乎相等。也就是说，屏幕区域被分配给GPU以使屏幕910中的屏幕面积或覆盖范围均等。例如，如果每个区域的大小为256x256像素，则每个区域在屏幕910中具有大致相同的覆盖范围。具体来说，屏幕区域A的集合覆盖6x256x256像素大小的面积，屏幕区域B的集合覆盖5.75x256x256像素大小的面积，屏幕区域C的集合覆盖5.5x256x256像素大小的面积，并且屏幕区域D的集合覆盖5.5x256x256像素大小的面积。图9C图示了屏幕910的屏幕区域的模式900C。每个屏幕区域的大小都不统一。也就是说，分配给GPU负责的用于渲染对象的屏幕区域的大小可能不统一。特别地，屏幕910被划分使得每个GPU被分配给相同数量的像素。例如，如果将4K显示器竖直平均分为四个区域，则每个区域的高度为520个像素。但是，通常GPU在32x32像素块中执行许多操作，并且520个像素不是32个像素的倍数。因此，在一个实施方案中，模式900C可以包括高度为512个像素的块，以及高度为544个像素的其他块。其他实施方案可以使用不同大小的块。模式900C通过使用非统一屏幕区域示出分配给每个GPU的等量屏幕像素。在又一个实施方案中，应用在执行图像渲染时的需求随时间变化，并且屏幕区域是动态选择的。例如，如果已知大部分渲染时间都花在屏幕的下半部分，那么以这样一种方式分配区域是有利的，即显示器下半部分中的几乎相等数量的屏幕像素被分配给用于渲染对应图像的每个GPU。也就是说，分配给用于渲染对应图像的每个GPU的区域可以动态地改变。例如，可以基于游戏模式、不同的游戏、屏幕大小、为区域选择的模式等应用改变。图10A是图示了根据本公开的一个实施方案的在渲染时通过区域测试为应用执行几何图形的多GPU渲染时的多通过渲染的示意图。每个GPU执行的第一通过是仅Z预通过1000A，并且类似于图7C的渲染时序图700C-2。第一通过可以被认为是第一渲染阶段。由每个GPU执行的第二通过是渲染通过1000B，其中GPU完全渲染对象，同时考虑到每个对应的GPU生成和使用的内部提示。第二通过可以被认为是第二渲染阶段。特别地，在一个渲染阶段中生成的几何图形的信息在另一个渲染阶段中使用。也就是说，一个GPU为一个渲染阶段生成的内部提示被同一GPU用于另一个渲染阶段。因此，同一个几何图形被处理两次：一次在仅Z预通过阶段1000A中，一次在完整渲染阶段1000B中。具体而言，预通过阶段1000A仅写入所有几何图形的Z值。然后在完整渲染阶段1000B期间，将像素Z值与先前存储的Z缓冲区中的值进行比较，如前所述。在一种实施方式中，如果存在精确匹配，则针对该像素执行像素着色器。与图7C不同，其中一个GPU为其他GPU生成信息，在这种情况下，GPU也可以为自己生成信息以供下一个通过使用。也就是说，GPU使用自己的信息，以便GPU为自己提供提示，以便在下一个通过中使用。尽管知道几何图形是否与它负责的至少一个对应的屏幕区域重叠是有用的，但在一些实施方案中，GPU有可能生成可由其自身在后期的渲染阶段中使用的更广泛的信息。在一个实施方案中，在仅Z预通过1000A期间，对应的GPU对几何图形处理级输出的图元进行光栅化，并执行深度测试。在深度测试中，GPU将其像素的Z值与对应的Z缓冲区进行比较。GPU生成关于几何图形中的任何像素是否在第一阶段期间的深度测试中幸存下来的信息。如果没有像素在第一阶段的测试中幸存下来，则可以在第二阶段跳过该几何图形的所有渲染。在另一实施方案中，在仅Z预通过阶段1000A期间，执行像素着色器。例如，检查纹理的α值，然后杀死α值过低的像素。特别是，GPU生成关于几何图形中的任何像素是否在第一阶段期间被写入的信息，以便这些像素在深度测试和像素杀死测试两者中幸存。如果在第一阶段1000A中没有写入像素，则在第二阶段1000B中可以跳过几何图形的所有渲染。例如，箭头1020示出GPU-C将关于对象3的信息传递给它自己。该信息指示GPU-C在完整渲染阶段1000B中可以跳过对象3的渲染。此外，箭头1030示出GPU-D将关于对象1的信息传递给它自己。该信息指示GPU-D在完整渲染阶段1000B中可以跳过对象1的渲染。注意，该示例关注GPU将在一个阶段中生成的信息传递给它自己以在后续阶段中使用；在其他实施方案中，GPU也可以将在一个阶段中生成的信息传递给其他GPU，以便它们可以在后续阶段中使用。利用图1-图3的云游戏网络190和GPU资源365的详细描述，以及图4-图9的支持描述，图10B的流程图1050图示了根据本公开的一个实施方案的图形处理方法，包括在渲染时通过区域测试为应用实现几何图形的多GPU渲染时的多通过渲染。在一个实施方案中，流程图1050是一种用于实现图10A所示的多通过渲染的方法。另外，流程图1050可以包含图5的流程图500的一种或多种操作。如前所述，各种架构可能包括多个GPU协作以通过在渲染时通过区域测试为应用执行几何图形的多GPU渲染来渲染单个图像，例如在云游戏系统的一个或多个云游戏服务器内，或在独立系统内，等等。在1060，该方法包括使用协作生成图像的多个GPU为应用渲染图形。具体而言，当为实时应用渲染单个图像和/或图像序列中的一个或多个图像中的每一个时，执行多GPU处理。在1065，该方法包括基于多个屏幕区域在多个GPU之间划分渲染图形的几何图形的责任。也就是说，每个GPU都有对所有GPU都已知的对应的责任划分。每个GPU执行图像的几何图形的多通过渲染，包括作为仅Z预通过渲染阶段的第一通过和作为渲染的完整渲染阶段的第二通过。当由同一GPU渲染该几何图形时，GPU在第一通过中生成的几何图形的信息可以在第二通过中使用。更具体地，在1070，该方法包括在GPU处对图像的几何图形的预通过渲染阶段期间确定几何图形的Z值。可以确定该几何图形与GPU对其具有渲染对象的责任划分的屏幕区域重叠。在1075，该方法包括将Z值与该几何图形的Z缓冲区值进行比较。如前所述，GPU可以光栅化几何图形的图元。执行深度测试，其中将几何图形的像素的Z值与对应的Z缓冲区值进行比较。例如，在比较时可以确定该几何图形的Z值小于或等于Z缓冲区值，这指示该几何图形未被遮挡。在这种情况下，下面生成的任何信息都可以指示该几何图形未被遮挡。在1080，该方法包括生成信息，该信息包括将Z值与Z缓冲区值进行比较的结果，以供GPU在渲染的完整渲染阶段期间渲染该几何图形时使用。具体而言，该信息可以指示几何图形中的任何像素是否从深度测试幸存。如果没有像素从深度测试幸存，则可以在第二通过中跳过该几何图形。例如，该方法可以包括在预通过阶段期间将几何图形的一个或多个图元光栅化成多个像素。通过将多个像素的多个Z值与一个或多个对应的Z缓冲区值进行比较来执行深度测试，其中深度测试的结果包括在信息中。基于信息不渲染多个像素中未从深度测试幸存的像素。在一个实施方式中，当多个像素中没有一个像素从深度测试幸存时，可以跳过对几何图形的渲染。另一方面，如果几何图形中的任何像素从深度测试幸存，则几何图形在第二通过中由GPU渲染。在又一实施方案种，该方法可以包括在预通过阶段期间将几何图形的一个或多个图元光栅化成多个像素。检查多个像素的纹理的α值。杀死多个像素中具有低于阈值的α值的像素，使得检查的结果包括在信息中。在一种实施方式中，当多个像素中没有一个像素具有等于或高于阈值的对应α值时，可以跳过几何图形的渲染。在一些实施方案中，GPU还生成关于几何图形及其与其他GPU负责的屏幕区域的关系的信息，并且该信息用于后续阶段。在其他实施方案中，通过将Z值与Z缓冲区进行比较不生成任何信息，而是GPU仅生成关于几何图形及其与所有GPU负责的屏幕区域的关系的信息，并且该信息用于后续阶段。图11示出了可以用于执行本公开的各种实施方案的各方面的示例性装置1100的部件。例如，图11图示了根据本公开的实施方案的示例性硬件系统，该硬件系统适用于在为图像渲染对象的同时通过区域测试为应用进行几何图形的多GPU渲染。该框图示出了装置1100，所述装置可并入或可能是个人计算机、服务器计算机、游戏控制台、移动装置或其他数字装置，它们中的每个适合于实践本发明的实施方案。装置1100包括用于运行软件应用和可选地操作系统的中央处理单元1102。CPU 1102可以由一个或多个同构或异构处理核心构成。根据各种实施方案中，CPU 1102是具有一个或多个处理核心的一个或多个通用微处理器。另外的实施方案可使用一个或多个CPU来实现，所述一个或多个CPU具有特别适用于诸如媒体和交互式娱乐应用等高度平行和计算密集的应用的微处理器架构，所述应用被配置用于游戏的执行期间的图形处理。存储器1104存储应用和数据以供CPU 1102和GPU 1116使用。存储装置1106为应用和数据提供非易失性存储装置和其他计算机可读介质并且可以包括固定磁盘驱动器、可移除磁盘驱动器、快闪存储器装置和CD-ROM、DVD-ROM、蓝光光碟、HD-DVD或其他光学存储装置，以及信号传输和存储介质。用户输入装置1108将用户输入从一个或多个用户传达到装置1100，所述装置的示例可包括键盘、鼠标、操纵杆、触摸板、触摸屏、静态或视频记录器/相机和/或传声器。网络接口1109允许装置1100经由电子通信网络与其他计算机系统通信，并且可以包括在局域网和诸如互联网的广域网上的有线或无线通信。音频处理器1112适于从由CPU 1102、存储器1104和/或存储装置1106提供的指令和/或数据生成模拟或数字音频输出。装置1100的部件，包括CPU 1102、包括GPU 1116的图形子系统、存储器1104、数据存储装置1106、用户输入装置1108、网络接口1109和音频处理器1112，经由一根或多根数据总线1122连接。图形子系统1114还与数据总线1122和装置1100的部件连接。图形子系统1114包括至少一个图形处理单元1116和图形存储器1118。图形存储器1118包括显示存储器，所述显示存储器用于存储输出图像的每个像素的像素数据。图形存储器1118可以集成在与GPU 1116相同的装置中、作为单独的装置与GPU 1116连接和/或实现在存储器1104内。像素数据可以直接从CPU 1102提供给图形存储器1118。替代地，CPU 1102向GPU1116提供定义期望输出图像的数据和/或指令，GPU 1116根据所述数据和/或指令生成一个或多个输出图像的像素数据。定义期望输出图像的数据和/或指令可以存储在存储器1104和/或图形存储器1118中。在实施方案中，GPU 1116包括3D渲染能力，所述3D渲染能力用于根据指令和数据生成输出图像的像素数据，所述指令和数据定义场景的几何图形、照明、着色、纹理化、动作和/或相机参数。GPU 1116还可以包括能够执行着色器程序的一个或多个可编程执行单元。图形子系统1114周期性地从图形存储器1118输出图像的像素数据，以在显示装置1110上显示或由投影系统进行投影。显示装置1110可以是能够响应于来自装置1100的信号来显示视觉信息的任何装置，包括CRT、LCD、等离子体和OLED显示器。装置1100可以向显示装置1110提供例如模拟或数字信号。用于优化图形子系统1114的其他实施方案可以包括在为图像渲染对象的同时通过区域测试为应用进行几何图形的多GPU渲染。图形子系统1114可被配置为一个或多个处理装置。例如，在一个实施方案中，图形子系统1114可被配置成在渲染时通过区域测试为应用执行几何图形的多GPU渲染，其中多个图形子系统可为单个应用实现图形和/或渲染流水线。也就是说，图形子系统1114包括多个GPU，用于在执行应用时渲染图像或图像序列中的一个或多个图像中的每一个。在其他实施方案中，图形子系统1114包括多个GPU装置，它们被组合以为在对应的CPU上执行的单个应用执行图形处理。例如，多个GPU可以在为图像渲染对象时通过区域测试为应用执行几何图形的多GPU渲染。在其他示例中，多个GPU可执行交替形式的帧渲染，其中以顺序的帧周期，GPU 1渲染第一帧，并且GPU 2渲染第二帧，依此类推，直到到达最后一个GPU为止，于是初始GPU渲染下一个视频帧。那就是渲染帧时GPU旋转。渲染操作可重叠，其中GPU 2可在GPU 1完成渲染第一帧之前开始渲染第二帧。在另一实施方式中，可以在渲染和/或图形流水线中为多个GPU装置分配不同的着色器操作。主GPU正在执行主渲染和合成。例如，在包括三个GPU的组中，主GPU 1可以执行主渲染和合成来自从属GPU 2和从属GPU 3的输出，其中从属GPU 2可以执行第二着色器操作，从属GPU 3可以执行第三着色器操作，其中主GPU 1合成来自GPU 1、GPU 2和GPU 3中的每一个的结果。以这种方式，可以分配不同的GPU来执行不同的着色器操作以渲染视频帧。在又一个实施方案中，三个GPU中的每一个可以被分配给不同的对象和/或对应于视频帧的场景的部分。在以上实施方案和实施方式中，可在同一帧周期或在不同帧周期中执行这些操作。因此，本公开描述了被配置用于在执行应用时为图像或图像序列中的一个或多个图像中的每一个渲染对象的同时通过区域测试为应用进行几何图形的多GPU渲染的方法和系统。应理解，可使用本文公开的各种特征将本文定义的各种实施方案组合或组装成具体的实施方式。因此，所提供的示例只是一些可能的示例，而不限于通过组合各种元素来定义更多的实施方式而可能的各种实施方式。在一些示例中，一些实施方式可以包括更少的元素，而不背离所公开的或等效实施方式的精神。本公开的实施方案可以用包括手持式装置、微处理器系统、基于微处理器的或可编程的消费电子产品、小型计算机、大型计算机等的各种计算机系统配置来实践。还可以在分布式计算环境中实践本公开的实施方案，在所述分布式计算环境中，通过基于有线或无线网络链接的远程处理装置执行任务。考虑到以上实施方案，应理解，本公开的实施方案可以采用涉及存储在计算机系统中的数据的各种计算机实现的操作。这些操作是需要对物理量的物理操纵的那些操作。本文描述的形成本公开的实施方案的一部分的任何操作都是有用的机器操作。本公开的实施方案还涉及用于执行这些操作的装置或设备。可以针对所需目的专门构造所述设备，或者所述设备可以是由存储在计算机中的计算机程序选择性地激活或配置的通用计算机。具体地，各种通用机器可以与根据本文的教导编写的计算机程序一起使用，或者构造更专门的设备来执行所需的操作可能更方便。本公开还可以实施为计算机可读介质上的计算机可读代码。计算机可读介质是可以存储数据的任何数据存储装置，该数据随后可以由计算机系统读取。计算机可读介质的示例包括硬盘驱动器、网络附接存储装置、只读存储器、随机存取存储器、CD-ROM、CD-R、CD-RW、磁带以及其他光学和非光学数据存储装置。所述计算机可读介质可以包括分布在网络耦合的计算机系统上的计算机可读有形介质，使得以分布式方式存储和执行计算机可读代码。尽管以具体的顺序描述了方法操作，但应理解，可在操作之间执行其他内务操作，或者可以调整操作，使得它们在略微不同的时间发生，或者可以分布在允许以与处理相关联的各种间隔发生处理操作的系统中，只要覆盖操作的处理以期望的方式执行即可。虽然出于清楚理解的目的相当详细地描述了前述公开内容，但显而易见的是，可在所附权利要求的范围内实践某些改变和修改。因此，本发明的实施方案被认为是说明性的而非限制性的，并且本公开的实施方案不限于本文给出的细节，而可以在所附权利要求的范围和等效物内进行修改。

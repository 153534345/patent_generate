标题title
PFC死锁的处理方法及装置
摘要abst
本申请提供一种PFC死锁的处理方法及装置，所述方法应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述方法包括：在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；判断所述差值是否等于第二值；若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，不再对所述PFC XOFF帧处理，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。
权利要求书clms
1.一种PFC死锁的处理方法，其特征在于，所述方法应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述方法包括：在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；判断所述差值是否等于第二值；若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，不再对所述PFC XOFF帧处理，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。2.根据权利要求1所述的方法，其特征在于，所述判断所述缓存队列的硬件状态是否处于PFC死锁状态，具体包括：获取所述缓存队列的逻辑标记位；当所述逻辑标记位为第三值时，确定所述缓存队列的硬件状态处于PFC死锁状态；当所述逻辑标记位为第四值时，确定所述缓存队列的硬件状态未处于PFC死锁状态。3.根据权利要求1所述的方法，其特征在于，所述方法还包括：若否，则获取所述当前检测次数，并将所述当前检测次数重置为预设值，等待进入下一个硬件检测周期。4.根据权利要求1所述的方法，其特征在于，所述向上层软件发送第一通知报文之后，所述方法还包括：遍历所述第一端口内设置的缓存队列；判断所述缓存队列是否已出现过PFC死锁上报且所述PFC死锁恢复时间是否已达到恢复阈值；若所述缓存队列已出现过PFC死锁上报且所述PFC死锁恢复时间已达到恢复阈值，则在所述第一端口处启动所述PFC死锁硬件检测，并向所述上层软件发送第二通知报文，以使得所述缓存队列再次接收到所述PFC XOFF帧后，缓存所述PFC XOFF帧，所述上层软件根据所述第二通知报文记录已再次启动所述PFC死锁硬件检测。5.根据权利要求1所述的方法，其特征在于，所述方法还包括：若所述第一端口已配置PFC死锁软件检测，则判断当前是否已达到软件检测时间；若已达到，则获取所述缓存队列对应的第一PFC死锁上报次数以及在上一次软件检测时间到达后所述缓存队列对应的第二PFC死锁上报次数；判断所述第一PFC死锁上报次数与所述第二PFC死锁上报次数之间的差值是否大于差值阈值；若大于，则关闭所述第一端口已配置的PFC死锁软件检测，并解除所述缓存队列的PFC死锁状态。6.根据权利要求5所述的方法，其特征在于，所述方法还包括：若所述第一端口未配置所述PFC死锁软件检测，则判断所述第一端口是否已关闭所述PFC死锁软件检测；若已关闭，则在所述第一端口处启动所述PFC死锁软件检测。7.一种PFC死锁的处理装置，其特征在于，所述装置应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述装置包括：第一判断单元，用于在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；计算单元，用于若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；第二判断单元，用于判断所述差值是否等于第二值；中断处理单元，用于若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，丢弃所述PFCXOFF帧，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。8.根据权利要求7所述的装置，其特征在于，所述第一判断单元具体用于，获取所述缓存队列的逻辑标记位；当所述逻辑标记位为第三值时，确定所述缓存队列的硬件状态处于PFC死锁状态；当所述逻辑标记位为第四值时，确定所述缓存队列的硬件状态未处于PFC死锁状态。9.根据权利要求7所述的装置，其特征在于，所述装置还包括：重置单元，用于若否，则获取所述当前检测次数，并将所述当前检测次数重置为预设值，等待进入下一个硬件检测周期。10.根据权利要求7所述的装置，其特征在于，所述装置还包括：遍历单元，用于遍历所述第一端口内设置的缓存队列；第三判断单元，用于判断所述缓存队列是否已出现过PFC死锁上报且所述PFC死锁恢复时间是否已达到恢复阈值；第一启动单元，用于若所述缓存队列已出现过PFC死锁上报且所述PFC死锁恢复时间已达到恢复阈值，则在所述第一端口处启动所述PFC死锁硬件检测，并向所述上层软件发送第二通知报文，以使得所述缓存队列再次接收到所述PFC XOFF帧后，缓存所述PFC XOFF帧，所述上层软件根据所述第二通知报文记录已再次启动所述PFC死锁硬件检测。11.根据权利要求7所述的装置，其特征在于，所述装置还包括：第四判断单元，用于若所述第一端口已配置PFC死锁软件检测，则判断当前是否已达到软件检测时间；获取单元，用于若已达到，则获取所述缓存队列对应的第一PFC死锁上报次数以及在上一次软件检测时间到达后所述缓存队列对应的第二PFC死锁上报次数；第五判断单元，用于判断所述第一PFC死锁上报次数与所述第二PFC死锁上报次数之间的差值是否大于差值阈值；关闭解除单元，用于若大于，则关闭所述第一端口已配置的PFC死锁软件检测，并解除所述缓存队列的PFC死锁状态。12.根据权利要求11所述的装置，其特征在于，所述装置还包括：第六判断单元，用于若所述第一端口未配置所述PFC死锁软件检测，则判断所述第一端口是否已关闭所述PFC死锁软件检测；第二启动单元，用于若已关闭，则在所述第一端口处启动所述PFC死锁软件检测。
说明书desc
技术领域本申请涉及通信技术领域，尤其涉及一种基于优先级的流量控制死锁的处理方法及装置。背景技术PFC是一种基于优先级的流量控制技术。根据报文的优先级，网络设备创建8个队列缓冲区。在对报文进行转发时，根据报文的优先级，网络设备将报文分发至对应的队列缓冲区中进行调度转发。当某一优先级报文的发送速率超过接收速率时，使得出端口拥塞。为了防止拥塞丢包，后续待发送的报文将根据自身优先级缓存至对应的队列缓冲区中。但是，每个优先级对应的队列缓冲区的存储空间有限，若出端口长时间拥塞，队列缓冲区的buffer占用将持续增长。当buffer空间使用完后，将导致丢弃报文。为了避免出现队列缓冲区资源使用完丢包的情况，网络设备通过PFC技术解决上述问题。网络设备向上一跳网络设备发送PFC停止帧，以通知上一跳网络设备某一优先级报文对应的队列缓冲区资源不足。上一跳网络设备接收到PFC XOFF帧后，即刻停止发送该优先级的报文。当队列缓冲区资源恢复时，网络设备再次向上一跳网络设备发送PFC启动帧，以通知上一跳网络设备该优先级对应的队列缓冲区资源恢复，上一跳网络设备即可恢复该优先级的报文发送。通过使用PFC技术，使得某一优先级报文的拥塞不会影响其他优先级报文的正常转发，从而达到同一链路上不同优先级报文的发送互不影响。如图1所示，图1为现有组网内出现PFC死锁示意图。当指定优先级的报文形成环路时，网络设备间反复发送和接收PFC XOFF帧，导致对应的队列缓冲区资源一直被占用无法释放，此时，网络设备进入PFC死锁状态。在图1中，指定优先级报文的转发路径为网络设备A-网络设备B-网络设备C-网络设备A。当网络设备C内该优先级对应的队列缓冲区资源不足时，网络设备C向网络设备A发送PFC XOFF帧。网络设备A继续向网络设备B发送PFC XOFF帧。网络设备B向网络设备C发送PFC XOFF帧，如此形成PFC死锁状态。为了解决实际组网中PFC死锁导致网络设备无法正常转发报文的问题。目前，通常的方法是采用软件检测PFC死锁。在检测时间内，某一队列缓冲区持续接收PFC XOFF帧，但没有任何报文转发，则确定网络设备发生了PFC死锁。此时，设置该队列缓冲区忽略接收到的PFC XOFF帧，使得该队列缓冲区继续转发报文即可解除网络设备的PFC死锁。上述软件检测PFC死锁的方法虽然可以检测PFC死锁，但仍具有一定的局限性：1)秒级检测时间内持续接收PFC XOFF帧却无报文转发，将造成大量丢包；2)一次满足死锁判断条件则确定发生PFC死锁，检测准确度低；3)若网络设备故障，端口没有报文转发却持续接收PFC XOFF帧，造成PFC死锁误报；4)实际组网中，可能存在某些端口、队列缓冲区并未使用PFC功能，对此类端口、队列缓冲区检测PFC死锁将耗费大量的硬件资源；5)检测方式单一，实际组网中存在频繁发生PFC死锁的情况，此时，无法通过人工干预排除PFC死锁。发明内容有鉴于此，本申请提供了一种PFC死锁的处理方法及装置，用以解决现有软件检测PFC死锁方式出现的大量丢包、检测准确度低、PFC死锁误报、耗费硬件资源以及检测方式单一的问题。第一方面，本申请提供了一种PFC死锁的处理方法，所述方法应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述方法包括：在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；判断所述差值是否等于第二值；若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，不再对所述PFC XOFF帧处理，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。第二方面，本申请提供了一种PFC死锁的处理装置，所述装置应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述装置包括：第一判断单元，用于在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；计算单元，用于若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；第二判断单元，用于判断所述差值是否等于第二值；中断处理单元，用于若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，不再对所述PFC XOFF帧处理，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。第三方面，本申请提供了一种网络设备，包括处理器和机器可读存储介质，机器可读存储介质存储有能够被处理器执行的机器可执行指令，处理器被机器可执行指令促使执行本申请第一方面所提供的方法。因此，通过应用本申请提供的PFC死锁的处理方法及装置，在硬件检测周期内，若第一端口已配置PFC死锁硬件检测，则网络设备判断缓存队列的硬件状态是否处于PFC死锁状态；若是，则网络设备获取当前检测次数，并计算当前检测次数与第一值的差值；网络设备判断差值是否等于第二值；若等于，则网络设备关闭第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得缓存队列再次接收到PFC XOFF帧后，不再对PFC XOFF帧处理，上层软件根据第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。如此，解决了现有软件检测PFC死锁方式出现的大量丢包、检测准确度低、PFC死锁误报、耗费硬件资源以及检测方式单一的问题。实现了PFC死锁快速智能检测以及软件连续多次检测PFC死锁后关闭PFC功能，上述检测方式更完善，根据组网的实际需求灵活选择多种功能，从而更大范围地应用于组网中。附图说明图1为现有组网内出现PFC死锁示意图；图2为本申请实施例提供的PFC死锁的处理方法的流程图；图3为本申请实施例提供的PFC死锁的处理装置结构图；图4为本申请实施例提供的网络设备硬件结构体。具体实施方式这里将详细地对示例性实施例进行说明，其示例表示在附图中。下面的描述涉及附图时，除非另有表示，不同附图中的相同数字表示相同或相似的要素。以下示例性实施例中所描述的实施例并不代表与本申请相一致的所有实施例。相反，它们仅是与如所附权利要求书中所详述的、本申请的一些方面相一致的装置和方法的例子。在本申请使用的术语是仅仅出于描述特定实施例的目的，而非旨在限制本申请。在本申请和所附权利要求书中所使用的单数形式的“一种”、“所述”和“该”也旨在包括多数形式，除非上下文清楚地表示其他含义。还应当理解，本文中使用的术语“和/或”是指并包含一个或多个相对应的列出项目的任何或所有可能组合。应当理解，尽管在本申请可能采用术语第一、第二、第三等来描述各种信息，但这些信息不应限于这些术语。这些术语仅用来将同一类型的信息彼此区分开。例如，在不脱离本申请范围的情况下，第一信息也可以被称为第二信息，类似地，第二信息也可以被称为第一信息。取决于语境，如在此所使用的词语“如果”可以被解释成为“在……时”或“当……时”或“响应于确定”。下面对本申请实施例提供的PFC死锁的处理方法进行详细地说明。参见图2，图2为本申请实施例提供的PFC死锁的处理方法的流程图。该方法应用于网络设备。本申请实施例提供的PFC死锁的处理方法可包括如下所示步骤。步骤210、在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；具体地，网络设备配置PFC死锁的硬件检测周期以及检测次数，进入死锁检测流程。其中，硬件检测周期是指多长时间检测1次。例如，硬件检测周期可具体为1ms、10ms、100ms。硬件检测周期为1ms，则每隔1ms检测1次端口是否已配置死锁硬件检测。网络设备判断是否已达到硬件检测周期，若已达到硬件检测周期，则网络设备遍历自身端口，并判断端口是否已配置PFC死锁硬件检测。本申请实施例以网络设备包括的第一端口为例进行说明。若第一端口已配置PFC死锁硬件检测，则网络设备判断第一端口内设置的缓存队列的硬件状态是否处于PFC死锁状态。进一步地，网络设备判断缓存队列的硬件状态是否处于PFC死锁状态，具体过程为：网络设备获取缓存队列的逻辑标记位，并识别该逻辑标记位的值。当逻辑标记位为第三值时，网络设备确定缓存队列的硬件状态处于PFC死锁状态；当逻辑标记位为第四值时，网络设备确定缓存队列的硬件状态未处于PFC死锁状态。若缓存队列的硬件状态处于PFC死锁状态，则执行步骤220；若缓存队列的硬件状态未处于PFC死锁状态，则网络设备获取当前检测次数，并将当前检测次数重置为预设值，重复前述判断是否已达到硬件检测周期，等待进入下一个硬件检测周期。其中，预设值的配置范围可具体为2-15。例如，当前检测次数为5，预设值为10，若缓存队列的硬件状态未处于PFC死锁状态，则网络设备获取当前检测次数为5，并将当前检测次数5重置为预设值10。若未达到硬件检测周期，则网络设备等待进入下一个硬件检测周期。若第一端口未配置PFC死锁硬件检测，则网络设备继续遍历自身包括的其他端口，并重复前述判断端口是否已配置PFC死锁硬件检测的步骤。步骤220、若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；具体地，根据步骤210的判断，若缓存队列的硬件状态处于PFC死锁状态，则网络设备获取当前检测次数，并计算当前检测次数与第一值的差值。例如，若当前检测次数为1，则当前检测次数与第一值的差值为0。若当前检测次数为5，则当前检测次数与第一值的差值为4。步骤230、判断所述差值是否等于第二值；具体地，根据步骤220的描述，网络设备判断差值是否等于第二值。若差值等于第二值，则执行步骤240；若差值不等于第二值，则网络设备再次配置PFC死锁的硬件检测周期以及检测次数，进入死锁硬件检测流程，并重复前述判断是否已达到硬件检测周期的步骤，等待进入下一个硬件检测周期。步骤240、若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，不再对所述PFC XOFF帧处理，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。具体地，根据步骤230的判断，若差值等于第二值，则网络设备关闭第一端口已配置的PFC死锁硬件检测，生成并向上层软件发送第一通知报文。可以理解的是，网络设备关闭第一端口已配置的PFC死锁硬件检测后，缓存队列再次接收到PFC XOFF帧后，忽略该PFC XOFF帧。上层软件接收到第一通知报文后，根据第一通知报文记录已出现连续PFC死锁，上层软件生成并显示告警提示，以使得用户确定网络设备已处于连续PFC死锁状态。因此，通过应用本申请提供的PFC死锁的处理方法，在硬件检测周期内，若第一端口已配置PFC死锁硬件检测，则网络设备判断缓存队列的硬件状态是否处于PFC死锁状态；若是，则网络设备获取当前检测次数，并计算当前检测次数与第一值的差值；网络设备判断差值是否等于第二值；若等于，则网络设备关闭第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得缓存队列再次接收到PFC XOFF帧后，不再对PFC XOFF帧处理，上层软件根据第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。如此，解决了现有软件检测PFC死锁方式出现的大量丢包、检测准确度低、PFC死锁误报、耗费硬件资源以及检测方式单一的问题。实现了PFC死锁快速智能检测以及软件连续多次检测PFC死锁后关闭PFC功能，上述检测方式更完善，根据组网的实际需求灵活选择多种功能，从而更大范围地应用于组网中。可选地，在本申请实施例中，网络设备向上层软件发送第一通知报文之后，网络设备进入死锁恢复阶段。具体地，网络设备遍历第一端口内设置的缓存队列。网络设备判断缓存队列是否已出现过PFC死锁上报且PFC死锁恢复时间是否已达到恢复阈值。其中，PFC死锁恢复时间也即是关闭PFC死锁检测的时间；恢复阈值可具体为200ms。若缓存队列已出现过PFC死锁上报且PFC死锁恢复时间已达到恢复阈值，则网络设备在第一端口处再次启动PFC死锁硬件检测，生成并向上层软件发送第二通知报文。网络设备向上层软件发送第二通知报文后，再次配置PFC死锁的硬件检测周期以及检测次数，进入死锁硬件检测流程，并重复前述判断是否已达到硬件检测周期的步骤，等待进入下一个硬件检测周期。可以理解的是，网络设备再次启动第一端口已配置的PFC死锁硬件检测后，缓存队列再次接收到PFC XOFF帧后，缓存该PFC XOFF帧。上层软件接收到第二通知报文后，根据第二通知报文记录已再次启动PFC死锁检测。若缓存队列未出现过PFC死锁上报，或者，若PFC死锁恢复时间未达到恢复阈值，则网络设备再次遍历端口内设置的其他缓存队列，并重复前述判断缓存队列是否已出现过PFC死锁上报且PFC死锁恢复时间是否已达到恢复阈值的步骤。可选地，在本申请实施例中，还包括通过软件检测方式检测PFC死锁的过程。具体地，网络设备判断第一端口是否已配置PFC死锁软件检测。若第一端口已配置PFC死锁软件检测，则网络设备判断当前是否已达到软件检测时间；若当前已达到软件检测时间，则网络设备获取缓存队列对应的第一PFC死锁上报次数以及在上一次软件检测时间到达后所述缓存队列对应的第二PFC死锁上报次数。网络设备判断第一PFC死锁上报次数与第二PFC死锁上报次数之间的差值是否大于差值阈值。其中，差值阈值的配置范围可具体为1-500。若差值大于差值阈值，则网络设备关闭第一端口已配置的PFC死锁软件检测，并解除缓存队列的PFC死锁状态。网络设备重复前述判断第一端口是否已配置PFC死锁软件检测，等待进入下一个软件检测周期。若当前未达到软件检测时间，则网络设备等待预设时长后，再次判断当前是否已达到软件检测时间。若差值不大于差值阈值，则网络设备遍历第一端口内配置的其他缓存队列，并再次执行获取其他缓存队列对应的第一PFC死锁上报次数以及第二PFC死锁上报次数的步骤。进一步地，若第一端口未配置PFC死锁软件检测，则网络设备遍历第一端口内配置的缓存队列。网络设备判断第一端口是否已关闭PFC死锁软件检测。若第一端口已关闭PFC死锁软件检测，则网络设备在第一端口处启动PFC死锁软件检测。网络设备重复前述判断第一端口是否已配置PFC死锁软件检测，等待进入下一个软件检测周期。若第一端口未关闭PFC死锁软件检测，则网络设备等待预设时长后，再次遍历第一端口，并重复前述判断第一端口是否已关闭PFC死锁软件检测的步骤。基于同一发明构思，本申请实施例还提供了与PFC死锁的处理方法对应的PFC死锁的处理装置。参见图3，图3为本申请实施例提供的PFC死锁的处理装置，所述装置应用于网络设备，所述网络设备包括第一端口，所述第一端口内设置缓存队列，所述装置包括：第一判断单元310，用于在硬件检测周期内，若所述第一端口已配置PFC死锁硬件检测，则判断所述缓存队列的硬件状态是否处于PFC死锁状态；计算单元320，用于若是，则获取当前检测次数，并计算所述当前检测次数与第一值的差值；第二判断单元330，用于判断所述差值是否等于第二值；中断处理单元340，用于若等于，则关闭所述第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得所述缓存队列再次接收到PFC XOFF帧后，丢弃所述PFC XOFF帧，所述上层软件根据所述第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。可选地，所述第一判断单元310具体用于，获取所述缓存队列的逻辑标记位；当所述逻辑标记位为第三值时，确定所述缓存队列的硬件状态处于PFC死锁状态；当所述逻辑标记位为第四值时，确定所述缓存队列的硬件状态未处于PFC死锁状态。可选地，所述装置还包括：重置单元，用于若否，则获取所述当前检测次数，并将所述当前检测次数重置为预设值，等待进入下一个硬件检测周期。可选地，所述装置还包括：遍历单元，用于遍历所述第一端口内设置的缓存队列；第三判断单元，用于判断所述缓存队列是否已出现过PFC死锁上报且所述PFC死锁恢复时间是否已达到恢复阈值；第一启动单元，用于若所述缓存队列已出现过PFC死锁上报且所述PFC死锁恢复时间已达到恢复阈值，则在所述第一端口处启动所述PFC死锁硬件检测，并向所述上层软件发送第二通知报文，以使得所述缓存队列再次接收到所述PFC XOFF帧后，缓存所述PFC XOFF帧，所述上层软件根据所述第二通知报文记录已再次启动所述PFC死锁硬件检测。可选地，所述装置还包括：第四判断单元，用于若所述第一端口已配置PFC死锁软件检测，则判断当前是否已达到软件检测时间；获取单元，用于若已达到，则获取所述缓存队列对应的第一PFC死锁上报次数以及在上一次软件检测时间到达后所述缓存队列对应的第二PFC死锁上报次数；第五判断单元，用于判断所述第一PFC死锁上报次数与所述第二PFC死锁上报次数之间的差值是否大于差值阈值；关闭解除单元，用于若大于，则关闭所述第一端口已配置的PFC死锁软件检测，并解除所述缓存队列的PFC死锁状态。可选地，所述装置还包括：第六判断单元，用于若所述第一端口未配置所述PFC死锁软件检测，则判断所述第一端口是否已关闭所述PFC死锁软件检测；第二启动单元，用于若已关闭，则在所述第一端口处启动所述PFC死锁软件检测。因此，通过应用本申请提供的PFC死锁的处理装置，在硬件检测周期内，若第一端口已配置PFC死锁硬件检测，则网络设备判断缓存队列的硬件状态是否处于PFC死锁状态；若是，则网络设备获取当前检测次数，并计算当前检测次数与第一值的差值；网络设备判断差值是否等于第二值；若等于，则网络设备关闭第一端口已配置的PFC死锁硬件检测，并向上层软件发送第一通知报文，以使得缓存队列再次接收到PFC XOFF帧后，不再对PFC XOFF帧处理，上层软件根据第一通知报文记录已出现连续PFC死锁，并向用户显示告警提示。如此，解决了现有软件检测PFC死锁方式出现的大量丢包、检测准确度低、PFC死锁误报、耗费硬件资源以及检测方式单一的问题。实现了PFC死锁快速智能检测以及软件连续多次检测PFC死锁后关闭PFC功能，上述检测方式更完善，根据组网的实际需求灵活选择多种功能，从而更大范围地应用于组网中。基于同一发明构思，本申请实施例还提供了一种网络设备，如图4所示，包括处理器410、收发器420和机器可读存储介质430，机器可读存储介质430存储有能够被处理器410执行的机器可执行指令，处理器410被机器可执行指令促使执行本申请实施例所提供的PFC死锁的处理方法。前述图3所示的PFC死锁的处理装置，可采用如图4所示的网络设备硬件结构实现。上述计算机可读存储介质430可以包括随机存取存储器，也可以包括非易失性存储器，例如至少一个磁盘存储器。可选的，计算机可读存储介质430还可以是至少一个位于远离前述处理器410的存储装置。上述处理器410可以是通用处理器，包括中央处理器、网络处理器等；还可以是数字信号处理器、专用集成电路、现场可编程门阵列或者其他可编程逻辑器件、分立门或者晶体管逻辑器件、分立硬件组件。本申请实施例中，处理器410通过读取机器可读存储介质430中存储的机器可执行指令，被机器可执行指令促使能够实现处理器410自身以及调用收发器420执行前述本申请实施例描述的PFC死锁的处理方法。另外，本申请实施例提供了一种机器可读存储介质430，机器可读存储介质430存储有机器可执行指令，在被处理器410调用和执行时，机器可执行指令促使处理器410自身以及调用收发器420执行前述本申请实施例描述的PFC死锁的处理方法。上述装置中各个单元的功能和作用的实现过程具体详见上述方法中对应步骤的实现过程，在此不再赘述。对于装置实施例而言，由于其基本对应于方法实施例，所以相关之处参见方法实施例的部分说明即可。以上所描述的装置实施例仅仅是示意性的，其中所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部模块来实现本申请方案的目的。本领域普通技术人员在不付出创造性劳动的情况下，即可以理解并实施。对于PFC死锁的处理装置以及机器可读存储介质实施例而言，由于其涉及的方法内容基本相似于前述的方法实施例，所以描述的比较简单，相关之处参见方法实施例的部分说明即可。以上所述仅为本申请的较佳实施例而已，并不用以限制本申请，凡在本申请的精神和原则之内，所做的任何修改、等同替换、改进等，均应包含在本申请保护的范围之内。

标题title
一种用于联邦学习的数据点乘运算方法
摘要abst
本发明公开了一种用于联邦学习的数据点乘运算方法。该方法包括以下步骤：第一方对数据列向量v进行预处理，之后进行同态加密得到加密数据矩阵V1并发送到第二方；第二方对数据矩阵w进行预处理，之后进行同态加密得到若干个加密子数据矩阵F1，生成与每个加密子数据矩阵F1对应的随机数向量Z，并进行同态加密得到加密随机数向量Z1；第二方计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和再与对应的加密随机数向量Z1相加得到向量Q，并发送给第一方；第一方根据每个向量Q提取对应的数据之和u组成点乘结果。本发明能够快速的计算出数据矩阵与数据列向量的点乘结果，且保护了数据隐私。
权利要求书clms
1.一种用于联邦学习的数据点乘运算方法，第一方持有s维的数据列向量v，第二方持有g行s列的数据矩阵w，其特征在于，包括以下步骤：S1：第二方根据数据矩阵w的行数、列数确定预处理参数，第一方根据预处理参数对数据列向量v进行预处理，得到数据矩阵V，第二方根据预处理参数对数据矩阵w进行预处理，得到若干个子数据矩阵F；S2：第一方生成公钥pk和私钥sk，采用公钥pk对数据矩阵V进行同态加密，得到加密数据矩阵V1，将公钥pk和加密数据矩阵V1发送到第二方；S3：第二方给每个子数据矩阵F生成对应的随机数向量Z，由预处理参数决定随机数向量Z内指定位置的随机数之和为0；S4：第二方采用公钥pk对每个子数据矩阵F进行同态加密，得到对应的加密子数据矩阵F1，采用公钥pk对每个随机数向量Z进行同态加密，得到对应的加密随机数向量Z1；S5：第二方计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和得到对应的向量R，将向量R与对应的加密随机数向量Z1相加得到向量Q，将计算出的所有向量Q发送给第一方；S6：第一方采用私钥sk对每个向量Q进行解密得到对应的向量q，根据预处理参数从向量q提取对应的数据之和u组成点乘结果。2.根据权利要求1所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S6中根据预处理参数从向量q提取对应的数据之和u组成点乘结果的方法包括以下步骤：根据预处理参数将每个向量q内对应位置的数据进行求和得到每个向量q对应的若干个数据之和u，根据预处理参数提取对应的数据之和u组成s维的数据列向量p，数据列向量p就是数据矩阵w与数据列向量v的点乘结果。3.根据权利要求2所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S1中第二方根据数据矩阵w的行数、列数确定预处理参数的方法如下：第二方计算出预处理参数k、h，公式如下：，/＞，其中，表示向上取整。4.根据权利要求3所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S1中第一方根据预处理参数对数据列向量v进行预处理，得到数据矩阵V的方法如下：M1：第一方计算出参数n，n=h*k，如果s=n，则将数据列向量v转置得到数据行向量v1；如果s≠n，则将数据列向量v进行补零操作直到维数达到n，之后转置得到数据行向量v1；v1=，1≤f≤n，af表示数据行向量v1内的第f个数据；M2：根据预处理参数k、h以及数据行向量v1计算出数据矩阵V，公式如下：，其中，1≤i≤k，Ai,1、Ai,2、Ai,3……Ai,k为相同的行向量，都为。5.根据权利要求3或4所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S1中第二方根据预处理参数对数据矩阵w进行预处理，得到若干个子数据矩阵F的方法如下：N1：第二方计算出参数m，m=k2，如果g≠m，则将数据矩阵w进行按行补零操作直到行数达到m；N2：第二方计算出参数n，n=h*k，如果s≠n，则将数据矩阵w进行按列补零操作直到列数达到n，最终得到m*n的数据矩阵L；N3：将数据矩阵L按行等分为k个k*n的子数据矩阵W，，其中，1≤i≤k，1≤f≤n，bi,f表示子数据矩阵W第i行第f列的数据；N4：根据预处理参数k、h将每个子数据矩阵W转换为子数据矩阵F，共得到k个子数据矩阵F；将子数据矩阵W转换为子数据矩阵F的方法如下：将子数据矩阵W的每一行数据等分成k个行向量，每个行向量内有h个数据，得到如下公式：，其中，1≤i≤k，1≤j≤k，Bi,j表示子数据矩阵W第i行第j列的行向量，Bi,j=，将公式进行转置，得到子数据矩阵F，。6.根据权利要求5所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S3中第二方给子数据矩阵F生成对应的随机数向量Z的方法如下：第二方生成随机数向量Z，Z=，随机数向量Z内的每个随机数都不为0，，其中，1≤f≤n，0≤d≤k-1，Zf表示随机数向量Z内的第f个随机数。7.根据权利要求6所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S5中将向量R与对应的加密随机数向量Z1相加得到向量Q的公式如下：Q=R+Z1=，1≤f≤n，Rf表示向量R中的第f个值，Z1f表示加密随机数向量Z1中的第f个加密随机数。8.根据权利要求7所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S6中第一方采用私钥sk对向量Q进行解密得到对应的向量q的公式如下：q=DEC=，其中，DEC 表示将私钥sk作为解密密钥采用同态加密算法对向量Q进行解密，1≤f≤n，rf表示将私钥sk作为解密密钥采用同态加密算法对Rf进行解密的结果，Zf表示将私钥sk作为解密密钥采用同态加密算法对Z1f进行解密的结果。9.根据权利要求8所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S6中第一方根据预处理参数将向量q内对应位置的数据进行求和得到向量q对应的若干个数据之和u的方法如下：第一方计算出k个数据之和u，分别记为u1、u2……uk，1≤i≤k，ui=。10.根据权利要求9所述的一种用于联邦学习的数据点乘运算方法，其特征在于，所述步骤S6中根据预处理参数提取对应的数据之和u组成s维的数据列向量p的方法如下：将数据矩阵L按行等分出的k个子数据矩阵W分别记为W1、W2……Wk，，子数据矩阵Wi转换为的子数据矩阵F记为Fi，子数据矩阵Fi对应的向量Q记为Qi，向量Qi经过解密得到的向量q记为qi，向量qi对应的k个数据之和u分别记为u1、u2……uk，将所有数据之和u按顺序排列成数据列向量y，，/＞，将数据列向量y中最后的t个值删除得到数据列向量p，t=m-s。
说明书desc
技术领域本发明涉及联邦学习技术领域，尤其涉及一种用于联邦学习的数据点乘运算方法。背景技术随着国内的互联网行业和隐私保护的高速发展，现实生活中越来越多的机构采用联邦学习进行模型训练。基于对数据的隐私保护，需要各方参与训练的数据为加密后的密态数据，基于加密数据和联邦学习自身训练的特性，训练过程中会涉及到大量的矩阵乘以向量的密态运算，然而，这种矩阵乘以向量的密态运算会花费较大的计算时间，进而导致大数据和大模型场景下的联邦学习训练变得十分困难。目前，联邦学习常采用同态加密算法对待训练的明文数据进行加密计算，同态加密是指这样一种加密函数，对明文进行环上的加法和乘法运算再加密，与加密后对密文进行相应的运算，结果是等价的。对于CKKS、BFV等会使用SIMD加速计算的同态加密算法，SIMD加速计算会将多个明文数据打包加密到同一个密文中，基于这种情况如果需要计算矩阵乘以列向量的密态运算，现有方法是将列向量进行同态加密，将矩阵的每一行进行同态加密，计算密文矩阵每一行与密文列向量之间的点乘结果，过程中需要进行旋转操作，而同态加密后的密文旋转操作需要花费大量的计算时间，当矩阵维度较大时，密文旋转操作所带来的计算开销是难以接受的。发明内容本发明为了解决上述技术问题，提供了一种用于联邦学习的数据点乘运算方法，其能够快速的计算出第二方持有的数据矩阵与第一方持有的数据列向量的点乘结果，且不会泄漏双方的数据，无需进行旋转操作，解决了CKKS、BFV等使用SIMD加速计算的同态加密算法用于计算矩阵乘以向量的点乘结果时因进行旋转操作占用极高计算时间的问题，提高了计算效率。为了解决上述问题，本发明采用以下技术方案予以实现：本发明的一种用于联邦学习的数据点乘运算方法，第一方持有s维的数据列向量v，第二方持有g行s列的数据矩阵w，包括以下步骤：S1：第二方根据数据矩阵w的行数、列数确定预处理参数，第一方根据预处理参数对数据列向量v进行预处理，得到数据矩阵V，第二方根据预处理参数对数据矩阵w进行预处理，得到若干个子数据矩阵F；S2：第一方生成公钥pk和私钥sk，采用公钥pk对数据矩阵V进行同态加密，得到加密数据矩阵V1，将公钥pk和加密数据矩阵V1发送到第二方；S3：第二方给每个子数据矩阵F生成对应的随机数向量Z，由预处理参数决定随机数向量Z内指定位置的随机数之和为0；S4：第二方采用公钥pk对每个子数据矩阵F进行同态加密，得到对应的加密子数据矩阵F1，采用公钥pk对每个随机数向量Z进行同态加密，得到对应的加密随机数向量Z1；S5：第二方计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和得到对应的向量R，将向量R与对应的加密随机数向量Z1相加得到向量Q，将计算出的所有向量Q发送给第一方；S6：第一方采用私钥sk对每个向量Q进行解密得到对应的向量q，根据预处理参数从向量q提取对应的数据之和u组成点乘结果。在本方案中，每个子数据矩阵F的行数、列数分别与数据矩阵V的行数、列数一致。随机数向量Z的维数与子数据矩阵F的列数一致。随机数向量Z内的每个随机数都不为0。第一方持有s维的数据列向量v，第二方持有g行s列的数据矩阵w。第一方进行预处理将数据列向量v转换为数据矩阵V，第二方进行预处理将数据矩阵w转换为若干个子数据矩阵F，接着，第一方、第二方将同样的公钥pk作为加密密钥，采用同样的同态加密算法对各自持有的明文的数据矩阵进行加密，得到对应的加密数据矩阵，第二方还给每个子数据矩阵F生成对应的随机数向量Z，将同样的公钥pk作为加密密钥，采用同样的同态加密算法对随机数向量Z进行加密，得到加密随机数向量Z1。这样，根据同态加密算法原理，计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和得到对应的向量R，将向量R与对应的加密随机数向量Z1相加得到向量Q，向量Q经过私钥sk解密得到的向量q，根据预处理参数将每个向量q内对应位置的数据进行求和得到每个向量q对应的若干个数据之和u，由于预处理参数决定随机数向量Z内指定位置的随机数之和为0，所以数据之和u就是数据列向量v与数据矩阵w对应行的点乘结果。本方案的整个计算过程中没有进行旋转操作，不会因旋转操作占用极高的计算时间，解决了CKKS、BFV等使用SIMD加速计算的同态加密算法用于计算矩阵与列向量的点乘结果时因进行旋转操作占用极高计算时间的技术问题，大大提高了计算效率，便于实现大数据和大模型场景下的联邦学习训练，同时保护了双方的数据隐私。作为优选，所述步骤S6中根据预处理参数从向量q提取对应的数据之和u组成点乘结果的方法包括以下步骤：根据预处理参数将每个向量q内对应位置的数据进行求和得到每个向量q对应的若干个数据之和u，根据预处理参数提取对应的数据之和u组成s维的数据列向量p，数据列向量p就是数据矩阵w与数据列向量v的点乘结果。作为优选，所述步骤S1中第二方根据数据矩阵w的行数、列数确定预处理参数的方法如下：第二方计算出预处理参数k、h，公式如下：,/＞,其中，表示向上取整。作为优选，所述步骤S1中第一方根据预处理参数对数据列向量v进行预处理，得到数据矩阵V的方法如下：M1：第一方计算出参数n，n=h*k，如果s=n，则将数据列向量v转置得到数据行向量v1；如果s≠n，则将数据列向量v进行补零操作直到维数达到n，之后转置得到数据行向量v1；v1=，1≤f≤n，af表示数据行向量v1内的第f个数据；M2：根据预处理参数k、h以及数据行向量v1计算出数据矩阵V，公式如下：,其中，1≤i≤k，Ai,1、Ai,2、Ai,3……Ai,k为相同的行向量，都为。作为优选，所述步骤S1中第二方根据预处理参数对数据矩阵w进行预处理，得到若干个子数据矩阵F的方法如下：N1：第二方计算出参数m，m=k2，如果g≠m，则将数据矩阵w进行按行补零操作直到行数达到m；N2：第二方计算出参数n，n=h*k，如果s≠n，则将数据矩阵w进行按列补零操作直到列数达到n，最终得到m*n的数据矩阵L；N3：将数据矩阵L按行等分为k个k*n的子数据矩阵W，,其中，1≤i≤k，1≤f≤n，bi,f表示子数据矩阵W第i行第f列的数据；N4：根据预处理参数k、h将每个子数据矩阵W转换为子数据矩阵F，共得到k个子数据矩阵F；将子数据矩阵W转换为子数据矩阵F的方法如下：将子数据矩阵W的每一行数据等分成k个行向量，每个行向量内有h个数据，得到如下公式：，其中，1≤i≤k，1≤j≤k，Bi,j表示子数据矩阵W第i行第j列的行向量，Bi,j=，将公式进行转置，得到子数据矩阵F，。作为优选，所述步骤S3中第二方给子数据矩阵F生成对应的随机数向量Z的方法如下：第二方生成随机数向量Z，Z=，随机数向量Z内的每个随机数都不为0，，其中，1≤f≤n，0≤d≤k-1，Zf表示随机数向量Z内的第f个随机数。作为优选，所述步骤S5中将向量R与对应的加密随机数向量Z1相加得到向量Q的公式如下：Q=R+Z1=，1≤f≤n，Rf表示向量R中的第f个值，Z1f表示加密随机数向量Z1中的第f个加密随机数。作为优选，所述步骤S6中第一方采用私钥sk对向量Q进行解密得到对应的向量q的公式如下：q=DEC=，其中，DEC 表示将私钥sk作为解密密钥采用同态加密算法对向量Q进行解密，1≤f≤n，rf表示将私钥sk作为解密密钥采用同态加密算法对Rf进行解密的结果，Zf表示将私钥sk作为解密密钥采用同态加密算法对Z1f进行解密的结果。作为优选，所述步骤S6中第一方根据预处理参数将向量q内对应位置的数据进行求和得到向量q对应的若干个数据之和u的方法如下：第一方计算出k个数据之和u，分别记为u1、u2……uk，1≤i≤k，ui=。作为优选，所述步骤S6中根据预处理参数提取对应的数据之和u组成s维的数据列向量p的方法如下：将数据矩阵L按行等分出的k个子数据矩阵W分别记为W1、W2……Wk，，子数据矩阵Wi转换为的子数据矩阵F记为Fi，子数据矩阵Fi对应的向量Q记为Qi，向量Qi经过解密得到的向量q记为qi，向量qi对应的k个数据之和u分别记为u1、u2……uk，将所有数据之和u按顺序排列成数据列向量y，，/＞，将数据列向量y中最后的t个值删除得到数据列向量p，t=m-s。本发明的有益效果是：能够快速的计算出第二方持有的数据矩阵与第一方持有的数据列向量的点乘结果，且不会泄漏双方的明文数据，保护了双方的数据隐私，无需进行旋转操作，解决了CKKS、BFV等使用SIMD加速计算的同态加密算法用于计算矩阵乘以向量的点乘结果时因进行旋转操作占用极高计算时间的问题，提高了计算效率，便于实现大数据和大模型场景下的联邦学习训练。附图说明图1是实施例的流程图；图2是举例说明中数据列向量v转换为数据矩阵V、数据矩阵w转换为子数据矩阵F的示意图；图3是举例说明中矩阵E1、矩阵E2的示意图。具体实施方式下面通过实施例，并结合附图，对本发明的技术方案作进一步具体的说明。实施例：本实施例的一种用于联邦学习的数据点乘运算方法，第一方持有s维的数据列向量v，第二方持有g行s列的数据矩阵w，如图1所示，包括以下步骤：S1：第二方根据数据矩阵w的行数、列数确定预处理参数k、h，公式如下：，/＞，其中，表示向上取整；第一方根据预处理参数k、h对数据列向量v进行预处理，得到数据矩阵V，具体步骤如下：M1：第一方计算出参数n，n=h*k，如果s=n，则将数据列向量v转置得到数据行向量v1；如果s≠n，则将数据列向量v进行补零操作直到维数达到n，之后转置得到数据行向量v1；v1=，1≤f≤n，af表示数据行向量v1内的第f个数据；M2：根据预处理参数k、h以及数据行向量v1计算出数据矩阵V，公式如下：，其中，1≤i≤k，Ai,1、Ai,2、Ai,3……Ai,k为相同的行向量，都为；第二方根据预处理参数对数据矩阵w进行预处理，得到若干个子数据矩阵F，每个子数据矩阵F的行数、列数分别与数据矩阵V的行数、列数一致，具体步骤如下：N1：第二方计算出参数m，m=k2，如果g≠m，则将数据矩阵w进行按行补零操作直到行数达到m；N2：第二方计算出参数n，n=h*k，如果s≠n，则将数据矩阵w进行按列补零操作直到列数达到n，最终得到m*n的数据矩阵L；N3：将数据矩阵L按行等分为k个k*n的子数据矩阵W，，其中，1≤i≤k，1≤f≤n，bi,f表示子数据矩阵W第i行第f列的数据；N4：根据预处理参数k、h将每个子数据矩阵W转换为子数据矩阵F，共得到k个子数据矩阵F；将子数据矩阵W转换为子数据矩阵F的方法如下：将子数据矩阵W的每一行数据等分成k个行向量，每个行向量内有h个数据，得到如下公式：，其中，1≤i≤k，1≤j≤k，Bi,j表示子数据矩阵W第i行第j列的行向量，Bi,j=，将公式进行转置，得到子数据矩阵F，；S2：第一方生成公钥pk和私钥sk，采用公钥pk对数据矩阵V进行同态加密，得到加密数据矩阵V1，将公钥pk和加密数据矩阵V1发送到第二方；S3：第二方给每个子数据矩阵F生成对应的随机数向量Z，随机数向量Z的维数与子数据矩阵F的列数一致，随机数向量Z内的每个随机数都不为0，由预处理参数k、h决定随机数向量Z内指定位置的随机数之和为0；第二方给子数据矩阵F生成对应的随机数向量Z的方法如下：第二方生成随机数向量Z，Z=，随机数向量Z内的每个随机数都不为0，，其中，1≤f≤n，0≤d≤k-1，Zf表示随机数向量Z内的第f个随机数；S4：第二方采用公钥pk对每个子数据矩阵F进行同态加密，得到对应的加密子数据矩阵F1，采用公钥pk对每个随机数向量Z进行同态加密，得到对应的加密随机数向量Z1；S5：第二方计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和得到对应的向量R，将向量R与对应的加密随机数向量Z1相加得到向量Q，将计算出的所有向量Q按顺序发送给第一方；将向量R与对应的加密随机数向量Z1相加得到向量Q的公式如下：Q=R+Z1=，1≤f≤n，Rf表示向量R中的第f个值，Z1f表示加密随机数向量Z1中的第f个加密随机数；S6：第一方采用私钥sk对每个向量Q进行解密得到对应的向量q，根据预处理参数k、h将每个向量q内对应位置的数据进行求和得到每个向量q对应的若干个数据之和u，根据预处理参数k、h提取对应的数据之和u组成s维的数据列向量p，数据列向量p就是数据矩阵w与数据列向量v的点乘结果；第一方采用私钥sk对向量Q进行解密得到对应的向量q的公式如下：q=DEC=，其中，DEC 表示将私钥sk作为解密密钥采用同态加密算法对向量Q进行解密，1≤f≤n，rf表示将私钥sk作为解密密钥采用同态加密算法对Rf进行解密的结果，Zf表示将私钥sk作为解密密钥采用同态加密算法对Z1f进行解密的结果；第一方根据预处理参数k、h将向量q内对应位置的数据进行求和得到向量q对应的若干个数据之和u的方法如下：第一方计算出k个数据之和u，分别记为u1、u2……uk，1≤i≤k，ui=。步骤S6中根据预处理参数k、h提取对应的数据之和u组成s维的数据列向量p的方法如下：将数据矩阵L按行等分出的k个子数据矩阵W分别记为W1、W2……Wk，，子数据矩阵Wi转换为的子数据矩阵F记为Fi，子数据矩阵Fi对应的向量Q记为Qi，向量Qi经过解密得到的向量q记为qi，向量qi对应的k个数据之和u分别记为u1、u2……uk，将所有数据之和u按顺序排列成数据列向量y，，/＞，将数据列向量y中最后的t个值删除得到数据列向量p，t=m-s。在本方案中，第二方根据数据矩阵w的行数、列数计算出预处理参数k、h，并计算出参数m、n，m=k2，n=h*k，如果g=m，则行数不变，否则数据矩阵w进行按行补零操作直到行数达到m，如果s=n，则列数不变，否则将数据矩阵w进行按列补零操作直到列数达到n，最终得到m*n的矩阵，记为数据矩阵L，将数据矩阵L按行等分为k个k*n的子数据矩阵W，将每个子数据矩阵W转换为子数据矩阵F，共得到k个子数据矩阵F。第一方计算出参数n，如果s=n，则直接将数据列向量v转置得到数据行向量v1；如果s≠n，则将数据列向量v进行补零操作直到维数达到n，之后转置得到数据行向量v1，根据预处理参数k、h以及数据行向量v1计算出k行n列的数据矩阵V，即子数据矩阵F的行数、列数分别与数据矩阵V的行数、列数一致。第一方、第二方将同样的公钥pk作为加密密钥，采用同样的同态加密算法对各自持有的明文的数据矩阵进行加密，得到对应的加密数据矩阵，第二方还给每个子数据矩阵F生成对应的随机数向量Z，将同样的公钥pk作为加密密钥，采用同样的同态加密算法对随机数向量Z进行加密，得到加密随机数向量Z1，随机数向量Z内的每个随机数都不为0，随机数向量Z内从前至后每h个随机数的和为0。之后，第二方计算每个加密子数据矩阵F1与加密数据矩阵V1的哈达玛积得到对应的矩阵E，将每个矩阵E按列求和得到对应的向量R，将向量R与对应的加密随机数向量Z1相加得到向量Q，将计算出的所有向量Q按顺序发送给第一方，第一方采用私钥sk对每个向量Q进行解密得到对应的向量q，每个向量q内从前至后每h个值进行一次求和得到一个对应的数据之和u，每个向量q内对应位置的数据进行求和共得到k个数据之和u，向量q内的k个数据之和u从前至后与对应的子数据矩阵W与数据列向量v的点积得到的列向量内的k个值一致。由于初始时，数据矩阵w经过行列补零操作得到数据矩阵L，所以数据矩阵L中所有值为0的行与数据列向量v的点积的值是0，而将所有数据之和u按顺序排列成数据列向量y后，数据列向量y中最后的t个值对应的是补零行与数据列向量v的点积的值，t=m-s，直接将数据列向量y中最后的t个值删除得到数据列向量p，数据列向量p就是数据矩阵w与数据列向量v的点乘结果。本方案的整个计算过程中没有进行旋转操作，不会因旋转操作占用极高的计算时间，解决了CKKS、BFV等使用SIMD加速计算的同态加密算法用于计算矩阵与列向量的点乘结果时因进行旋转操作占用极高计算时间的技术问题，大大提高了计算效率，便于实现大数据和大模型场景下的联邦学习训练，同时保护了双方的数据隐私。本方案中，采用CKKS、BFV等使用SIMD加速计算的同态加密算法加密矩阵时是按行加密的，也就是说第一方将加密数据矩阵V1发送到第二方时是发了k个密文，第二方将计算出的k个向量Q发送给第一方时是发了k个密文，即加密计算部分通讯共2k个密文，而采用现有算法，由于数据矩阵w有g行，第二方发送给第一方的密文至少有g个，因为，所以本方法的通信量也远低于现有算法。/＞举例说明：第一方、第二方进行联邦学习模型训练，如图2所示，第二方持有4行4列数据矩阵w，数据矩阵w的第一列特征值为年龄数据，第二列特征值为性别数据，第三列特征值为个人收入数据，第四列特征值为家庭整体收入数据；第一方持有4维的数据列向量v，第一个数据为年龄特征参数，第二个数据为性别特征参数，第三个数据为个人收入特征参数，第四个数据为家庭整体收入特征参数。第二方计算出k=2，h=2，m=4，n=4，由于数据矩阵w为4行4列，数据列向量v的维数为4，所以数据矩阵w、数据列向量v无需进行补零操作。如图2所示，第一方对数据列向量v进行预处理，得到数据矩阵V，第二方对数据矩阵w进行预处理，先将数据矩阵w等分成子数据矩阵W1、W2，再将子数据矩阵W1、W2转换为子数据矩阵F1、F2。第一方生成公钥pk和私钥sk，采用公钥pk对数据矩阵V进行同态加密，得到加密数据矩阵V1，V1=enc，enc表示对数据矩阵V进行同态加密，将公钥pk和加密数据矩阵V1发送到第二方。第二方给子数据矩阵F1生成对应的随机数向量Z1，给子数据矩阵F2生成对应的随机数向量Z2，Z1=，Z1,1+Z1,2=0，Z1,3+ Z1,4=0，Z1,1，Z1,2，Z1,3，Z1,4都不为0；Z2=，Z2,1+Z2,2=0，Z2,3+Z2,4=0，Z2,1，Z2,2，Z2,3，Z2,4都不为0。第二方采用公钥pk对子数据矩阵F1、F2进行同态加密，得到对应的加密子数据矩阵F11、F12，F11=enc，F12=enc，采用公钥pk对随机数向量Z1、Z2进行同态加密，得到对应的加密随机数向量Z11、Z12，Z11=enc，Z12=enc。第二方计算加密子数据矩阵F11与加密数据矩阵V1的哈达玛积得到对应的矩阵E1，第二方计算加密子数据矩阵F12与加密数据矩阵V1的哈达玛积得到对应的矩阵E2。矩阵E1、矩阵E2如图3所示，矩阵E1中的enc表示数据矩阵V中的a1的同态加密密文与子数据矩阵W1中的d1,1的同态加密密文的乘积的值。第二方将矩阵E1按列求和得到对应的向量R1，将向量R1与对应的加密随机数向量Z11相加得到向量Q1，Q1=，将矩阵E2按列求和得到对应的向量R2，将向量R2与对应的加密随机数向量Z12相加得到向量Q2，Q2=，将计算出的向量Q1、Q2发送给第一方。第一方采用私钥sk对向量Q1、Q2进行解密得到对应的向量q1、q2，q1=，q2=，由于h=2，第一方将向量q1内从前至后每2个值进行一次求和，得到u1、u2，将向量q2内从前至后每2个值进行一次求和，得到u1、u2，u1= a1*d1,1+a3*d1,3+Z1,1+a2*d1,2+a4*d1,4+Z1,2，u2= a1*d2,1+a3*d2,3+Z1,3+a2*d2,2+a4*d2,4+Z1,4，u1= a1*d3,1+a3*d3,3+Z2,1+a2*d3,2+a4*d3,4+Z2,2，u2= a1*d4,1+a3*d4,3+Z2,3+a2*d4,2+a4*d4,4+Z2,4，由于Z1,1+Z1,2=0，Z1,3+ Z1,4=0，Z2,1+Z2,2=0，Z2,3+Z2,4=0，u1= a1*d1,1+a2*d1,2+a3*d1,3+a4*d1,4，u2= a1*d2,1+a2*d2,2+a3*d2,3+a4*d2,4，u1= a1*d3,1+a2*d3,2+a3*d3,3+a4*d3,4，u2= a1*d4,1+a2*d4,2+a3*d4,3+a4*d4,4，所以，u1、u2、u1、u2组成4维的数据列向量p就是数据矩阵w与数据列向量v的点乘结果，与数据矩阵w与数据列向量v的明文点乘结果一致。计算出的数据列向量p作为逻辑回归中本批次训练样本，用于后续计算损失函数并梯度反向传播更新联邦学习模型。

标题title
用于掩码张量转换的方法、计算设备和存储介质
摘要abst
本发明的实施例涉及一种用于掩码张量转换的方法、计算设备和存储介质。该方法包括：基于预定转换规则，将原始掩码张量转换成第一中间掩码张量，其中第一中间掩码张量中的数据为比特型数据；在第一维度上，对第一中间掩码张量的数据进行分组，以获取多个初始数据块；以及对多个初始数据块中的数据进行重排，以得到第二中间掩码张量，其中第二中间掩码张量包括多个重排后的数据块，其中每个重排后的数据块包括每个初始数据块中的一部分数据。本发明的实施例能够对原始掩码张量的大小进行压缩，减小数据计算过程中对板卡带宽的压力，并且避免数据堵塞在数据加载阶段，极大提高板卡上数据计算的执行性能。
权利要求书clms
1.一种用于掩码张量转换的方法，其特征在于，包括：基于预定转换规则，将原始掩码张量转换成第一中间掩码张量，其中所述第一中间掩码张量中的数据为比特型数据；在第一维度上，对所述第一中间掩码张量的数据进行分组，以获取多个初始数据块；以及对所述多个初始数据块中的数据进行重排，以得到第二中间掩码张量，其中所述第二中间掩码张量包括多个重排后的数据块，其中每个重排后的数据块包括每个初始数据块中的一部分数据。2. 根据权利要求1所述的方法，其特征在于，所述原始掩码张量中的数据为布尔型数据，基于所述预定转换规则将所述原始掩码张量转换成所述第一中间掩码张量包括：将所述原始掩码张量中取值为“真”的布尔型数据转换为具有第一数值的比特型数据；以及将所述原始掩码张量中取值为“假”的布尔型数据转换为具有第二数值的比特型数据。3. 根据权利要求1所述的方法，其特征在于，在所述第一维度上对所述第一中间掩码张量的数据进行分组以获取多个初始数据块包括：确定用于分组的数据长度；以及基于所确定的用于分组的数据长度，在所述第一维度上对所述第一中间掩码张量的数据进行分组，以便经分组后得到的所述多个初始数据块的大小相同。4.根据权利要求3所述的方法，其特征在于，所述用于分组的数据长度与所要得到的结果掩码张量中的数据的类型有关。5.根据权利要求3所述的方法，其特征在于，在所述第一维度上对所述第一中间掩码张量的数据进行分组以获取多个初始数据块还包括：响应于所述第一中间掩码张量在所述第一维度上的数据长度不能被所述用于分组的数据长度整除，在所述第一维度上对所述第一中间掩码张量的数据进行补位，以使得所述第一维度上经补位后的第一中间掩码张量的数据长度能被所述用于分组的数据长度整除。6.根据权利要求1所述的方法，其特征在于，对所述多个初始数据块中的数据进行重排以得到所述第二中间掩码张量包括：针对每个初始数据块，确定初始数据块在所述第一维度上的第一索引值和在第二维度上的第二索引值；针对所述初始数据块中的每个数据，确定数据在所述初始数据块中的第三索引值；以及至少基于所述初始数据块的第一索引值和第二索引值，以及所述数据在所述初始数据块中的第三索引值，确定所述数据在所述第二中间掩码张量中的位置，以便将所述数据搬移至相应的重排后的数据块的相应位置处。7. 根据权利要求6所述的方法，其特征在于，确定所述数据在所述第二中间掩码张量中的位置包括：基于所述数据在所述初始数据块中的第三索引值以及所述初始数据块的第二索引值，确定与所述数据对应的重排后的数据块；以及基于所述初始数据块的第一索引值和第二索引值，确定所述数据在所确定的重排后的数据块的位置。8.根据权利要求1所述的方法，其特征在于，还包括：对所述第二中间掩码张量进行压缩，以使得所述第二中间掩码张量中的数据转换成整数型数据或浮点型数据，以便得到结果掩码张量。9.一种用于数据计算的方法，其特征在于，包括：接收输入参数，所述输入参数包括：输入张量、原始掩码张量和填充值；根据权利要求1-8中任一项所述的方法对所述原始掩码张量进行转换，以得到结果掩码张量；以及基于所述输入张量、所述结果掩码张量和所述填充值，确定输出张量。10. 一种计算设备，其特征在于，包括：至少一个处理器；以及与所述至少一个处理器通信连接的存储器；所述存储器存储有可被所述至少一个处理器执行的指令，所述指令被所述至少一个处理器执行，以使所述至少一个处理器执行权利要求1-9中任一项所述的方法。11.一种存储有计算机指令的非瞬时计算机可读存储介质，其特征在于，所述计算机指令用于使计算机执行权利要求1-9中任一项所述的方法。12.一种计算机程序产品，其特征在于，所述计算机程序产品被有形地存储在非瞬态计算机可读介质上并且包括机器可执行指令，所述机器可执行指令在被执行时使机器执行根据权利要求1-9中任一项所述的方法中的步骤。
说明书desc
技术领域本发明的实施例总体涉及数据计算领域，并且更具体地涉及一种用于掩码张量转换的方法，计算设备和存储介质。背景技术在针对Transformer模型进行训练的过程中，基于注意力机制，需要多次基于masked_fill函数进行数据计算。现有的基于masked_fill函数进行数据计算的方法包括：接收输入张量、掩码张量和填充值；以及基于输入张量、掩码张量和填充值，经由masked_fill函数确定输出张量。然而，在上述现有技术中，接收并加载输入张量和掩码张量、以及输出并存储输出张量在数据计算过程中的性能占比很大，而确定输出张量中的元素的值在数据计算过程中的性能占比很小，使得对执行数据计算的板卡的带宽构成比较严重的压力，从而导致数据计算的执行性能不佳。综上，传统的基于masked_fill函数进行数据计算的方法对执行数据计算的板卡的带宽构成比较严重的压力，致使数据计算的执行性能不佳。发明内容针对上述问题，本发明提供了一种用于掩码张量转换的方法、计算设备和存储介质，使得能够对要进行数据计算的掩码张量的大小进行压缩，从而减小数据计算过程中对板卡带宽的压力，并提高数据计算的执行性能。根据本发明的第一方面，提供了一种用于掩码张量转换的方法，包括：基于预定转换规则，将原始掩码张量转换成第一中间掩码张量，其中第一中间掩码张量中的数据为比特型数据；在第一维度上，对第一中间掩码张量的数据进行分组，以获取多个初始数据块；以及对多个初始数据块中的数据进行重排，以得到第二中间掩码张量，其中第二中间掩码张量包括多个重排后的数据块，其中每个重排后的数据块包括每个初始数据块中的一部分数据。在一些实施例中，原始掩码张量中的数据为布尔型数据。在这些实施例中，基于预定转换规则将原始掩码张量转换成第一中间掩码张量包括：将原始掩码张量中取值为“真”的布尔型数据转换为具有第一数值的比特型数据；以及将原始掩码张量中取值为“假”的布尔型数据转换为具有第二数值的比特型数据。。在一些实施例中，在第一维度上对第一中间掩码张量的数据进行分组以获取多个初始数据块包括：确定用于分组的数据长度；以及基于所确定的用于分组的数据长度，在第一维度上对第一中间掩码张量的数据进行分组，以便经分组后得到的多个初始数据块的大小相同。在一些实施例中，用于分组的数据长度与所要得到的结果掩码张量中的数据的类型有关。在一些实施例中，在第一维度上对第一中间掩码张量的数据进行分组以获取多个初始数据块还包括：响应于第一中间掩码张量在第一维度上的数据长度不能被用于分组的数据长度整除，在第一维度上对第一中间掩码张量的数据进行补位，以使得第一维度上经补位后的第一中间掩码张量的数据长度能被用于分组的数据长度整除。在一些实施例中，对多个初始数据块中的数据进行重排以得到第二中间掩码张量包括：针对每个初始数据块，确定初始数据块在第一维度上的第一索引值和在第二维度上的第二索引值；针对初始数据块中的每个数据，确定数据在初始数据块中的第三索引值；以及至少基于初始数据块的第一索引值和第二索引值，以及数据在初始数据块中的第三索引值，确定数据在第二中间掩码张量中的位置，以便将数据搬移至相应的重排后的数据块的相应位置处。在一些实施例中，确定数据在第二中间掩码张量中的位置包括：基于数据在初始数据块中的第三索引值以及初始数据块的第二索引值，确定与数据对应的重排后的数据块；以及基于初始数据块的第一索引值和第二索引值，确定数据在所确定的重排后的数据块的位置。在一些实施例中，用于掩码张量转换的方法还包括：对第二中间掩码张量进行压缩，以使得第二中间掩码张量中的数据转换成整数型数据或浮点型数据，以便得到结果掩码张量。根据本发明的第二方面，提供了一种用于数据计算的方法，包括：接收输入参数，输入参数包括：输入张量、原始掩码张量和填充值；根据本发明的第一方面的方法对原始掩码张量进行转换，以得到结果掩码张量；以及基于输入张量、结果掩码张量和填充值，确定输出张量。根据本发明的第三方面，提供了一种计算设备，包括：至少一个处理器；以及与至少一个处理器通信连接的存储器；存储器存储有可被至少一个处理器执行的指令，指令被至少一个处理器执行，以使至少一个处理器能够执行本发明的第一方面的方法。根据本发明的第四方面，提供了一种存储有计算机指令的非瞬时计算机可读存储介质，其中计算机指令用于使计算机执行本发明的第一方面的方法。根据本发明的第五方面，提供了一种计算机程序产品，其中计算机程序产品被有形地存储在非瞬态计算机可读介质上并且包括机器可执行指令，机器可执行指令在被执行时使机器执行本发明的第一方面的方法中的步骤。应当理解，本部分所描述的内容并非旨在标识本发明的实施例的关键或重要特征，也不用于限制本发明的范围。本发明的其它特征将通过以下的说明书而变得容易理解。附图说明结合附图并参考以下详细说明，本发明各实施例的上述和其他特征、优点及方面将变得更加明显。在附图中，相同或相似的附图标注表示相同或相似的元素。图1示出了根据本发明的实施例的用于掩码张量转换的系统的示意图。图2示出了根据本发明的实施例的用于掩码张量转换的方法的流程图。图3a示出了根据本发明的实施例的第一中间掩码张量的示意图。图3b示出了根据本发明的实施例的对第一中间掩码张量中的数据进行重排以得到第二中间掩码张量的原理的示意图。图4示出了根据本发明的实施例的对第二中间掩码张量进行压缩以得到结果掩码张量的原理的示意图。图5示出了根据本发明的实施例的用于数据计算的系统的示意图。图6示出了根据本发明的实施例的用于数据计算的方法的流程图。图7示出了根据本发明的实施例的将原始掩码张量转换为结果掩码张量的示例性示意图。图8示意性示出了适于用来实现本发明的实施例的计算设备的框图。具体实施方式以下结合附图对本发明的示范性实施例做出说明，其中包括本发明实施例的各种细节以助于理解，应当将它们认为仅仅是示范性的。因此，本领域普通技术人员应当认识到，可以对这里描述的实施例做出各种改变和修改，而不会背离本发明的范围和精神。同样，为了清楚和简明，以下的描述中省略了对公知功能和结构的描述。在本文中使用的术语“包括”及其变形表示开放性包括，即“包括但不限于”。除非特别申明，术语“或”表示“和/或”。术语“基于”表示“至少部分地基于”。术语“一个示例实施例”和“一个实施例”表示“至少一个示例实施例”。术语“另一实施例”表示“至少一个另外的实施例”。术语“第一”、“第二”等等可以指代不同的或相同的对象。下文还可能包括其他明确的和隐含的定义。在针对Transformer模型进行训练的过程中，基于注意力机制，需要多次使用masked_fill函数，以实现对输入张量中的至少部分元素的替换。通常，masked_fill函数的输入参数包括：输入张量、掩码张量和填充值。其中，掩码张量为与输入张量形状、大小均相同的布尔型张量，其可以用于指示输入张量中要替换的元素的位置；填充值可以是标量，用于指示替换后的元素值。现有的基于masked_fill函数进行数据计算的方案包括：接收输入参数，输入参数包括输入张量、掩码张量和填充值；以及基于输入张量、掩码张量和填充值，经由masked_fill函数确定输出张量。例如，若掩码张量中的某一元素的布尔值为“真”，则确定与该元素在掩码张量中的索引位置对应的输出张量中的元素的值取填充值；若掩码张量中的某一元素的布尔值为“假”，则确定与该元素在掩码张量中的索引位置对应的输出张量中的元素的值取输入张量中的相应元素的值。然而，在上述基于masked_fill函数进行数据计算的方案中，接收并加载输入张量和掩码张量、以及输出并存储输出张量在数据计算过程中的性能占比很大，而确定输出张量中的元素的值在数据计算过程中的性能占比很小，使得对执行数据计算的板卡或者并行的多个图形处理单元）的带宽构成比较严重的压力，从而导致数据计算的执行性能不佳。为了至少部分地解决上述问题以及其他潜在问题中的一个或者多个，本发明的示例实施例提出了一种用于掩码张量转换的方案。在该方案中，通过基于预定转换规则，将原始掩码张量转换成第一中间掩码张量，其中第一中间掩码张量中的数据为比特型数据；在第一维度上，对第一中间掩码张量的数据进行分组，以获取多个初始数据块；以及对多个初始数据块中的数据进行重排，以得到第二中间掩码张量，其中第二中间掩码张量包括多个重排后的数据块，其中每个重排后的数据块包括每个初始数据块中的一部分数据，使得能够对原始掩码张量的大小进行压缩，减小数据计算过程中对板卡带宽的压力。本发明的示例实施例还提出了一种基于转换后的掩码张量进行数据计算的方案，使得能够避免数据堵塞在数据加载阶段，极大提高板卡上数据计算的执行性能。下面将结合图1至图4详细描述根据本发明的实施例的用于掩码张量转换的方案。方法200可由如图8所示的计算设备800处执行。应当理解，方法200还可以包括未示出的附加动作和/或可以省略所示出的动作，本发明的范围在此方面不受限制。图1示出了根据本发明的实施例的用于掩码张量转换的系统100的示意图。应当理解，系统100还可以包括未示出的附加模块和/或可以省略所示出的模块，本发明的范围在此方面不受限制。如图1所示，系统100包括：原始掩码张量接收模块110、转换模块120、分组模块130、重排模块140、压缩模块150和结果掩码张量输出模块160。关于原始掩码张量接收模块110，其可以被配置为接收原始掩码张量。根据本发明的实施例，原始掩码张量通常为布尔型张量，即原始掩码张量中的数据的类型为布尔型。关于转换模块120，其可以被配置为将原始掩码张量转换为第一中间张量，其中第一中间掩码张量中的数据为比特型数据。关于分组模块130，其可以被配置为对第一中间张量中的数据进行分组。根据本发明的实施例，在第一维度上对第一中间张量中的数据进行分组，以得到多个初始数据块。关于重排模块140，其可以被配置为对第一中间张量中多个初始数据块中的数据进行重新排列，以得到第二中间掩码张量。根据本发明的实施例，第二中间掩码张量包括多个重排后的数据块，并且每个重排后的数据块包括每个初始数据块中的一部分数据。关于压缩模块150，其可以被配置为对第二中间掩码张量进行压缩，以使得第二中间掩码张量中的数据转换成整数型数据或浮点型数据，以便得到结果掩码张量。关于结果掩码张量输出模块160，其可以被配置为输出结果掩码张量，以便于随后将结果掩码张量加载到例如masked_fill函数中，以执行相应的数据计算。图2示出了根据本发明的实施例的用于掩码张量转换的方法200的流程图。在步骤202，由系统100基于预定转换规则，将原始掩码张量转换成第一中间掩码张量，其中第一中间掩码张量中的数据为比特型数据。关于预定转换规则，其可以是用于指示将具有不同布尔值的布尔型数据转换为特定的比特型数据的规则。根据本发明的实施例，原始掩码张量中取值为“真”的布尔型数据和取值为“假”的布尔型数据被分别转换为具有不同数值的比特型数据。例如，在一些实施例中，可以将取值为“真”的布尔型数据转换为值为1的比特型数据，将取值为“假”的布尔型数据转换为值为0的比特型数据。在又一些实施例中，可以将取值为“真”的布尔型数据转换为值为0的比特型数据，将取值为“假”的布尔型数据转换为值为1的比特型数据。在步骤204，由系统100在第一维度上对第一中间掩码张量的数据进行分组，以获取多个初始数据块。关于第一维度，其可以是指宽度维度。根据本发明的实施例，在第一维度上对第一中间掩码张量的数据进行分组可以是指，在第一中间掩码张量的宽度维度上，将连续的多个比特型数据归为一组，从而实现对第一中间掩码张量的数据的分组。关于对第一中间掩码张量的数据进行分组，根据本发明的实施例，其可以包括：确定用于分组的数据长度；以及基于所确定的用于分组的数据长度，在第一维度上对第一中间掩码张量的数据进行分组，以便经分组后得到的多个初始数据块的大小相同。关于用于分组的数据长度，其可以与所要得到的结果掩码张量中的数据的类型有关。在一示例中，若结果掩码张量中的数据的类型为例如单精度浮点型，则确定用于分组的数据长度为32比特。在又一示例中，结果掩码张量中的数据的类型为例如64位整数型，则确定用于分组的数据长度为64比特。在本发明的一示例中，第一中间掩码张量在宽度维度上的数据长度为512比特，并且基于结果掩码张量中的数据的类型确定用于分组的数据长度为32比特，则可以在第一中间掩码张量的宽度维度上，将第一中间掩码张量中每连续的32比特的数据归为一组，从而得到16个大小相同的初始数据块。在本发明的一些实施例中，第一中间掩码张量在宽度维度上的数据长度可能不能被用于分组的数据长度整除，在这种情况下，需要先在宽度维度上对第一中间掩码张量的数据进行补位，再针对经补位后的第一中间掩码张量进行分组。具体地，根据本发明的实施例，在所述第一维度上对所述第一中间掩码张量的数据进行分组以获取多个初始数据块可以包括：确定第一中间掩码张量在第一维度上的数据长度是否能被用于分组的数据长度整除；以及响应于第一中间掩码张量在第一维度上的数据长度不能被用于分组的数据长度整除，在第一维度上对第一中间掩码张量的数据进行补位，以使得第一维度上经补位后的第一中间掩码张量的数据长度能被用于分组的数据长度整除。例如，在本发明的一示例中，第一中间掩码张量在第一维度上的数据长度为508比特，若基于结果掩码张量中的数据的类型确定用于分组的数据长度为32比特，则确定第一中间掩码张量在第一维度上的数据长度不能被用于分组的数据长度整除。在这种情况下，可以通过在第一维度上对第一中间掩码张量的数据进行补位，例如通过在末尾处填0，以使第一中间掩码张量在第一维度上的数据长度补齐至能被用于分组的数据长度整除的长度。例如，在上述示例中，可以通过在末尾处填0使第一中间掩码张量在第一维度上的数据长度补齐至诸如512比特，以便基于经补位后的第一中间掩码张量进行分组。在步骤206，由系统100对多个初始数据块中的数据进行重排，以得到第二中间掩码张量。关于第二中间掩码张量，其可以包括多个重排后的数据块，其中每个重排后的数据块包括每个初始数据块中的一部分数据。此外，根据本发明的实施例，第二中间掩码张量中的重排后的数据块的数量可以与第一中间掩码张量中的初始数据块的数量相同。根据本发明的实施例，通过将初始数据块中的数据进行重新排列并搬移以得到重排后的数据块，使得基于由重排后的数据块构成的第二中间掩码张量得到的结果掩码张量更容易被加载至masked_fill函数进行数据计算，从而能够在板卡上高性能实现masked_fill函数。关于对多个初始数据块中的数据进行重排以得到第二中间掩码张量，根据本发明的实施例，其可以包括：针对每个初始数据块，确定初始数据块在第一维度上的第一索引值和在第二维度上的第二索引值；针对初始数据块中的每个数据，确定数据在初始数据块中的第三索引值；以及至少基于初始数据块的第一索引值和第二索引值，以及数据在初始数据块中的第三索引值，确定数据在第二中间掩码张量中的位置，以便将数据搬移至相应的重排后的数据块的相应位置处。进一步地，确定数据在第二中间掩码张量中的位置可以包括：基于数据在初始数据块中的第三索引值以及初始数据块的第二索引值，确定与数据对应的重排后的数据块；以及基于初始数据块的第一索引值和第二索引值，确定数据在所确定的重排后的数据块的位置。下面将结合图3a和图3b详细描述，这里先不赘述。根据本发明的实施例，方法200还可以包括：在步骤208，由系统100对第二中间掩码张量进行压缩，以使得第二中间掩码张量中的数据转换成整数型数据或浮点型数据，以便得到结果掩码张量。关于整数型数据，其可以是诸如16位整数型数据、32位整数型数据、64位整数型数据等。关于浮点型数据，其可以是诸如半精度浮点型数据、单精度浮点型数据、双精度浮点型数据、大脑浮点型数据等。关于对第二中间掩码张量进行压缩，其是指针对第二中间掩码张量中的每个重排后的数据块进行压缩，以将重排后的数据块转换成相应的整数型数据或浮点型数据，以便得到结果掩码张量。下面将结合图4详细描述，这里先不赘述。下面将结合图3a和图3b详细描述，根据本方面的实施例的将第一中间掩码张量经重排转换为第二中间掩码张量的示例实现方式。图3a示出了根据本发明的实施例的第一中间掩码张量310的示意图。图3b示出了根据本发明的实施例的对第一中间掩码张量310中的数据进行重排以得到第二中间掩码张量320的原理的示意图。如图3a所示，第一中间掩码张量310在第一维度）上的数据长度为512比特，在第二维度）上的大小为2。也就是说，图3a所示的第一中间掩码张量310为512比特×2行的张量。根据本发明的实施例，针对第一中间掩码张量310中的每一行数据，在第一维度上，以32比特作为用于分组的数据长度对第一中间掩码张量310的数据进行分组。如图3a所示，第一中间掩码张量310共包括32个初始数据块，其中，第一中间掩码张量310中的每一行数据被划分成16个大小为32比特的初始数据块。进一步地，每个初始数据块中的每个比特型数据的位置可以由第三索引值表示。根据本发明的实施例，初始数据块中的比特型数据的索引可以从诸如0开始计算，即初始数据块中的第n个比特型数据对应的第三索引值bit_in_block_idx_original = n-1，其中n为正整数。例如，初始数据块中的第1个比特型数据的第三索引值为0，初始数据块中的第2个比特型数据的第三索引值为1，以此类推。关于初始数据块，其在第一中间掩码张量310中的位置可以由位置索引指示，其中位置索引可以包括：在第一维度上的第一索引值和在第二维度上的第二索引值。第二索引值可以用于指示初始数据块在第一中间掩码张量310的哪一行，而第一索引值可以用于指示初始数据块为所在行的第几个数据块。以第一中间掩码张量310中的初始数据块312为例，若各索引从0开始计算，如图3a所示，初始数据块312在第二维度上的第二索引值H_original = 0，在第一维度上的第一索引值block_idx_original = 0，由此可知初始数据块312为第一中间掩码张量310中第一行的第1个数据块。相应地，对于初始数据块314，其在第二维度上的第二索引值H_original =1，在第一维度上的第一索引值block_idx_original = 15，表示初始数据块314为第一中间掩码张量310中第二行的第16个数据块。如图3b所示，第一中间掩码张量310中的每个初始数据块中的比特型数据被重排至第二中间掩码张量320中的不同重排后的数据块中。具体地，可以基于比特型数据在初始数据块中的第三索引值，以及比特型数据所在的初始数据块的第一索引值和第二索引值，确定比特型数据被重排至第二中间掩码张量320中的哪一重排后的数据块以及在该重排后的数据块的具体位置。根据本发明的实施例，可以基于例如下述换算公式，计算得到重排后的数据块的宽度索引值和高度索引值，以及比特型数据在重排后的数据块中的新第三索引值。具体地，换算公式可以包括如下公式至公式：H_transferred = H_original // 2 block_idx_transferred = bit_in_block_idx_original bit_in_block_idx_transferred = 15 - block_idx_original + H_original %2×16 由上述公式可知，可以基于初始数据块在第二维度上的第二索引值确定重排后的数据块的高度索引值，其中“//”为整除运算符，用于获取除法运算的整数部分。例如，在如图3b所示的实施例中，可以将初始数据块在第二维度上的第二索引值H_original整除2，以得到重排后的数据块的高度索引值H_transferred。由上述公式可知，可以基于比特型数据在初始数据块中的第三索引值确定重排后的数据块的宽度索引值。例如，在如图3b所示的实施例中，重排后的数据块的宽度索引值block_idx_transferred等于比特型数据在初始数据块中的第三索引值bit_in_block_idx_original。由上述公式可知，可以基于比特型数据所在的初始数据块在在第一维度上的第一索引值和在第二维度上的第二索引值确定比特型数据在重排后的数据块中的新第三索引值，其中“%”为取模运算符，用于除法运算的余数。例如，在如图3b所示的实施例中，比特型数据在重排后的数据块中的新第三索引值bit_in_block_idx_transferred可以通过将初始数据块在第二维度上的第二索引值H_original与2相除的余数与16相乘，并将该乘法运算的结果与初始数据块在第一维度上的第一索引值block_idx_original进行相应的加减法运算来确定。例如，以初始数据块312中的第1个比特型数据为例。如上所述，初始数据块312在第一维度上的第一索引值block_idx_original = 0，在第二维度上的第二索引值H_original = 0 // 2=0，初始数据块312中的第1个比特型数据的第三索引值为bit_in_block_idx_original = 0。根据如上所述的换算公式可知，该比特型数据将搬移至的重排后的数据块的高度索引值H_transferred = 0，宽度索引值block_idx_transferred = 0，并且该比特型数据在重排后的数据块中的新第三索引值bit_in_block_idx_transferred= 15 - 0 + 0 % 2×16 = 15。在又一示例中，以初始数据块314中的第16个比特型数据为例。如上所述，初始数据块314在第一维度上的第一索引值block_idx_original = 15，在第二维度上的第二索引值H_original = 1，初始数据块314中的第32个比特型数据的第三索引值为bit_in_block_idx_original = 31。根据如上所述的换算公式可知，该比特型数据将搬移至的重排后的数据块的高度索引值H_transferred = 1 // 2=0，宽度索引值block_idx_transferred =31，并且该比特型数据在重排后的数据块中的新索引值bit_in_block_idx_transferred =15 - 15 + 1 % 2×16 = 16。由上可知，根据本发明的上述重排操作，第一中间掩码张量310可以被转换为第二中间掩码张量320。如图3a和图3b所示，经重排转换得到的第二中间掩码张量320相对于第一中间掩码张量310在第二维度上被压缩为原来的1/2，也就是说，第二中间掩码张量320相对于原始掩码张量在第二维度上可以被压缩为原来的1/2。图4示出了根据本发明的实施例的对第二中间掩码张量320进行压缩以得到结果掩码张量330的原理的示意图。如上所述，根据本发明的实施例，可以针对第二中间掩码张量中的每个重排后的数据块进行压缩，以将重排后的数据块转换成相应的整数型数据或浮点型数据，以便得到结果掩码张量。如图4所示，第二中间掩码张量320包括32个重排后的数据块。以第二中间掩码张量320中的第一重排后的数据块322为例，针对第一重排后的数据块322进行压缩，使得该第一重排后的数据块322转换为浮点型数据或整数型数据，该经转换得到的数据即为结果掩码张量330中的第一数据。进一步地，根据本发明的实施例，可以将图4中的第二中间掩码张量320中的32个重排后的数据块分别转换成相应的浮点型数据或整数型数据，并基于转换得到的32个浮点型数据或整数型数据构成结果掩码张量330。以浮点型数据为例，在本发明的一些实施例中，可以将第二中间掩码张量320包括32个重排后的数据块分别转换成相应的浮点型数据，并基于转换得到的32个浮点型数据构成结果掩码张量330。由上可知，根据本发明的上述压缩操作，结果掩码张量330相对于第二中间掩码张量320在第一维度上被压缩为原来的1/16。也就是说，结果掩码张量330可以被进一步地压缩为原始掩码张量1/32。根据本发明的上述用于掩码张量转换的方案，通过将原始掩码张量中的布尔型数据转换为比特型数据，并针对转换后的比特型数据进行重排压缩以得到结果掩码张量，使得能够减小掩码张量加载过程中对板卡带宽的压力，并且基于所得到的结果掩码张量进行数据计算能够充分扩大改善板卡带宽压力后带来的性能收益，极大提高板卡上数据计算的执行性能。此外，进一步地，基于上述转换公式重排压缩得到的结果张量可以在加载至硬件后直接进行例如masked_fill函数的运算，从而提高运算效率。下面将结合图5至图7详细描述，在上述对掩码张量进行转换的方案的基础上，基于经转换得到的结果掩码张量进行数据计算的方案。图5示出了根据本发明的实施例的用于数据计算的系统500的示意图。应当理解，系统500还可以包括未示出的附加单元和/或可以省略所示出的单元，本发明的范围在此方面不受限制。如图5所示，系统500包括：参数接收单元510、原始掩码张量转换单元520、计算单元530和输出单元540。关于参数接收单元510，其可以被配置为接收要用于数据计算的输入参数。根据本发明的实施例，参数接收单元510可以被配置为接受输入张量、原始掩码张量和填充值。关于输入张量，其可以是要用于大模型训练的张量。根据本发明的实施例，输入张量可以为常用于大模型训练的浮点型张量或整数型张量，即输入张量中的数据的类型可以为浮点型或整数型。关于原始掩码张量，如上所示，其可以是布尔型张量，并且用于指示输入张量中要替换的元素的位置。根据本发明的实施例，原始掩码张量的形状和大小与输入张量相同。关于填充值，其可以用于确定输出张量中的部分元素的值。关于原始掩码张量转换单元520，其可以被配置为根据如上所述的用于掩码张量转换的方法，对原始掩码张量进行转换，以得到结果掩码张量。关于结果掩码张量，其可以是浮点型张量或整数型张量，即输入张量中的数据的类型可以为浮点型或整数型。关于计算单元530，其可以被配置为执行例如masked_fill函数运算。根据本发明的实施例，计算单元530可以将输入张量、结果掩码张量和填充值加载至masked_fill函数中进行运算，以便确定输出张量。关于输出单元540，其可以被配置为输出由计算单元530计算得到的输出张量。图6示出了根据本发明的实施例的用于数据计算的方法600的流程图。方法600可由如图8所示的电子设备800处执行。应当理解，方法600还可以包括未示出的附加动作和/或可以省略所示出的动作，本发明的范围在此方面不受限制。在步骤602，由系统500的参数接收单元510接收输入参数，其中输入参数包括：输入张量、原始掩码张量和填充值。在本发明的实施例中，可以用例如注意力机制中常用的形式来表示张量的形状，其中N表示批量大小、H表示高度、W表示宽度。在此基础上，输入张量可以具有例如表示为的第一张量形状。原始掩码张量可以具有例如表示为的第二张量形状。根据本发明的实施例，输入张量的形状与原始掩码张量的形状相同，即第一张量形状与第二张量形状相同。也就是说，N_input = N_original，H_input = H_original，W_input= W_original。在步骤604，由系统500的原始掩码张量转换单元520对原始掩码张量进行转换，以得到结果掩码张量。关于对原始掩码张量进行转换以得到结果掩码张量，其可以参照如上结合图1至图4所述的用于掩码张量转换的方案，这里不再赘述。进一步地，结果掩码张量可以具有例如表示为的第三张量形状。如上所述，根据本发明的实施例得到的结果掩码张量，相对于原始掩码张量，在高度维度和宽度维度可以被不同程度的压缩，使得在加载结果掩码张量的过程中可以减小对板卡带宽的压力。例如，在本发明的一实施例中，假设原始掩码张量具有表示为的第二张量形状，即N_original = 1，H_original = 2，W_original = 512，并且假设结果掩码张量是fp32型张量，则结果掩码张量的第三张量形状与原始掩码张量的第二张量形状可以具有如下的关系：N_transferred = N_original = 1；H_transferred =  // 2 = 1；W_transferred =  // 512 × 32 = 32。由上可知，相比于原始掩码张量，结果掩码张量在高度维度上被压缩了2倍，在宽度维度上被压缩了16倍。在本发明的又一些实施例中，若原始掩码张量在宽度维度上的数据长度超过512比特，可以例如以512比特为粒度，将原始掩码张量切分为在宽度维度上的数据长度为512比特的多个子原始掩码张量，并针对每个子原始掩码张量进行如图3a、图3b和图4中所述的重排压缩操作以得到相应的子结果掩码张量，再将所得到的子结果掩码张量顺序拼接起来，以得到最终结果掩码张量，这一过程可参见图7所示的示意图。图7示出了根据本发明的实施例的将原始掩码张量转换为结果掩码张量的示例性示意图。如图7所示，原始掩码张量710在宽度维度上的数据长度为1024，在高度维度上的数据长度为1024，也就是说，原始掩码张量710的H_original = 1024，并且W_original =1024。这里，原始掩码张量710中的数据为布尔型数据。如图7所示，原始掩码张量710被切分为4个子原始掩码张量，即子原始掩码张量720a、子原始掩码张量720b、子原始掩码张量720c和子原始掩码张量720d。每个子原始掩码张量在宽度维度上的数据长度为512，在高度维度上的数据长度为512。也就是说，子原始掩码张量720的H_sub-original = 512，并且W_sub-original =512。如图7所示，每个子原始掩码张量720经重排压缩操作后，转换为相应的子结果掩码张量730，其中，每个子结果掩码张量730在宽度维度上的数据长度为32，在高度维度上的数据长度为256。也就是说，子结果掩码张量730的H_sub-transferred = 256，并且W_sub-transferred = 32。应注意，子结果掩码张量730中的数据可以为fp32型数据或int32型数据。如图7所示，子结果掩码张量730经顺序拼接后得到最终结果掩码张量740，其中，最终结果掩码张量740在宽度维度上的数据长度为64，在高度维度上的数据长度为512。也就是说，最终结果掩码张量740的H_transferred = 512，并且W_transferred = 64。这里，最终结果掩码张量740中的数据的数据类型与子结果掩码张量730中的数据的数据类型相同。例如，子结果掩码张量730中的数据为fp32型数据，相应地，最终结果掩码张量740中的数据同样为fp32型数据。由上可知，根据本发明的实施例，当原始掩码张量具有较大的张量形状时，可以先对原始掩码张量进行切割，然后针对切割后的子原始掩码张量分别执行根据本发明的用于掩码张量转换的方案，同样可以实现对原始掩码张量的大小进行压缩以减小对板卡带宽的压力的技术效果。此外，经顺序拼接得到的最终结果掩码张量740在加载至硬件后可以直接进行运算，例如加载至系统500的计算单元530中进行基于masked_fill函数的数据计算，提高了数据计算的效率。在步骤606，由系统500的计算单元530基于输入张量、结果掩码张量和填充值，确定输出张量。关于确定输出张量，其可以是指基于masked_fill函数进行数据计算以确定输出张量。例如，可以将输入张量、结果掩码张量和填充值加载至masked_fill函数，通过执行基于masked_fill函数的数据计算来确定输出张量。具体地，当结果掩码张量加载至硬件后，可以通过例如基于比特的数据选择/替换运算，以针对输入张量数据执行关于masked_fill函数的运算。在这种情况下，针对输入张量，每做完一次数据选择/替换运算后，需要将当前运算位置处的比特数据通过移位操作丢弃掉，并将后续未使用的比特数据移位至当前运算位置处，以便针对后续的比特数据进行诸如选择/替换运算，从而确定输出张量。也就是说，基于输入张量、结果掩码张量和填充值，可以通过执行sel指令和shl指令的组合来确定输出张量，并存储所确定的输出张量。在步骤608，由系统500的输出单元540输出输出张量。由上可知，根据本发明的实施例的用于数据计算的方案，通过在执行数据计算之前先将原始掩码张量重排、压缩并转换为结果掩码张量，再加载至计算单元进行数据计算，使得能够避免数据堵塞在数据加载阶段，极大提高板卡上数据计算的执行性能。并且，经转换得到的结果掩码张量在加载至计算单元后可以直接进行数据计算，提高了数据计算的效率。图8示意性示出了适于用来实现本发明实施例的计算设备800的框图。设备800可以是用于实现执行图2所示的方法200和图6所示的方法600的设备。如图8所示，设备800包括处理单元801、图形处理器、通用图形处理器及前述任何组合），其可以根据存储在只读存储器802中的计算机程序指令或者从存储单元808加载到随机访问存储器803中的计算机程序指令，来执行各种适当的动作和处理。在RAM 803中，还可存储设备800操作所需的各种程序和数据。处理单元801、ROM 802以及RAM 803通过总线804彼此相连。输入/输出接口805也连接至总线804。设备800中的多个部件连接至I/O接口805，包括：输入单元806、输出单元807、存储单元808，处理单元801执行上文所描述的各个方法和处理，例如执行方法200或方法600。例如，在一些实施例中，方法300、400或600可被实现为计算机软件程序，其被存储于机器可读介质，例如存储单元808。在一些实施例中，计算机程序的部分或者全部可以经由ROM 802和/或通信单元809而被载入和/或安装到设备800上。当计算机程序加载到RAM 803并由处理单元801执行时，可以执行上文描述的方法200或方法600中的一个或多个操作。备选地，在其他实施例中，处理单元801可以通过其他任何适当的方式而被配置为执行方法200和/或方法600的一个或多个动作。这里所描述的计算机可读程序指令可以从计算机可读存储介质下载到各个计算/处理设备，或者通过网络、例如因特网、局域网、广域网和/或无线网下载到外部计算机或外部存储设备。网络可以包括铜传输电缆、光纤传输、无线传输、路由器、防火墙、交换机、网关计算机和/或边缘服务器。每个计算/处理设备中的网络适配卡或者网络接口从网络接收计算机可读程序指令，并转发该计算机可读程序指令，以供存储在各个计算/处理设备中的计算机可读存储介质中。用于执行本发明操作的计算机程序指令可以是汇编指令、指令集架构指令、机器指令、机器相关指令、微代码、固件指令、状态设置数据、或者以一种或多种编程语言的任意组合编写的源代码或目标代码，该编程语言包括面向对象的编程语言—诸如Smalltalk、C++等，以及常规的过程式编程语言—诸如“C”语言或类似的编程语言。计算机可读程序指令可以完全地在用户计算机上执行、部分地在用户计算机上执行、作为一个独立的软件包执行、部分在用户计算机上部分在远程计算机上执行、或者完全在远程计算机或服务器上执行。在涉及远程计算机的情形中，远程计算机可以通过任意种类的网络—包括局域网或广域网—连接到用户计算机，或者，可以连接到外部计算机。在一些实施例中，通过利用计算机可读程序指令的状态信息来个性化定制电子电路，例如可编程逻辑电路、现场可编程门阵列或可编程逻辑阵列，该电子电路可以执行计算机可读程序指令，从而实现本发明的各个方面。这些计算机可读程序指令可以提供给语音交互装置中的处理器、通用计算机、专用计算机或其它可编程数据处理装置的处理单元，从而生产出一种机器，使得这些指令在通过计算机或其它可编程数据处理装置的处理单元执行时，产生了实现流程图和/或框图中的一个或多个方框中规定的功能/动作的装置。也可以把这些计算机可读程序指令存储在计算机可读存储介质中，这些指令使得计算机、可编程数据处理装置和/或其他设备以特定方式工作。以上已经描述了本发明的各实施例，上述说明是示例性的，并非穷尽性的，并且也不限于所披露的各实施例。在不偏离所说明的各实施例的范围和精神的情况下，对于本技术领域的普通技术人员来说许多修改和变更都是显而易见的。本文中所用术语的选择，旨在最好地解释各实施例的原理、实际应用或对市场中的技术改进，或者使本技术领域的其它普通技术人员能理解本文披露的各实施例。以上仅为本发明的可选实施例，并不用于限制本发明，对于本领域的技术人员来说，本发明可以有各种更改和变化。凡在本发明的精神和原则之内，所作的任何修改、等效替换、改进等，均应包含在本发明的保护范围之内。

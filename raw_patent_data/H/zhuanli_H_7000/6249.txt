标题title
一种远程控制方法、装置、计算设备及存储介质
摘要abst
本发明公开了一种远程控制方法、装置、计算设备及存储介质，远程控制方法，在受控计算设备中执行，受控计算设备通过第一通信协议显示信息，该方法包括：接收来自主控计算设备的控制请求，控制请求基于第二通信协议生成；获取控制请求指向的响应函数的函数指针；将函数指针的指向转换为目标函数，目标函数与响应函数具有相同功能，且基于第一通信协议生成；利用转换指向地址后的函数指针，生成控制请求的模拟请求；响应模拟请求，在受控计算设备中模拟出控制请求的响应结果。该方法基于第一通信协议的模拟请求替换基于第二通信协议的控制请求，能够使得使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求。
权利要求书clms
1.一种远程控制方法，在受控计算设备中执行，所述受控计算设备通过第一通信协议显示信息，其特征在于，该方法包括：接收来自主控计算设备的控制请求，所述控制请求基于第二通信协议生成；获取所述控制请求指向的响应函数的函数指针；将所述函数指针的指向转换为目标函数，所述目标函数与所述响应函数具有相同功能，且基于第一通信协议生成；利用转换指向地址后的函数指针，生成所述控制请求的模拟请求；响应所述模拟请求，在所述受控计算设备中模拟出所述控制请求的响应结果。2.如权利要求1所述的方法，其特征在于，所述受控计算设备中驻留有兼容层，所述兼容层适于在基于第一通信协议的计算设备上运行基于第二通信协议的应用；获取所述控制请求指向的响应函数的函数指针，包括：将所述控制请求发送至所述兼容层；利用所述兼容层解析所述控制请求，以获取所述函数指针。3.如权利要求2所述的方法，其特征在于，利用所述兼容层解析所述控制请求，以获取所述函数指针，包括：确定所述控制请求的请求类型，所述请求类型指示操作事件，所述操作事件包括鼠标移动事件、鼠标键入事件和键盘键入事件；基于所述操作事件，确定所述函数指针。4.如权利要求3所述的方法，其特征在于，所述利用所述兼容层解析所述控制请求，以获取所述函数指针，还包括：解析所述控制请求，获取所述操作事件对应的操作数据。5.如权利要求4所述的方法，其特征在于，利用转换指向地址后的函数指针，生成所述控制请求的模拟请求，包括：利用所述第一通信协议，将指示操作事件的函数指针和对应操作数据进行封装，以生成所述模拟请求。6.如权利要求4所述的方法，其特征在于，响应所述模拟请求，在所述受控计算设备中模拟出所述控制请求的响应结果，包括：基于所述模拟请求所包含的函数指针，确定出所述目标函数；将所述操作数据作为函数参数，运行所述目标函数，以得到所述响应结果。7.如权利要求4所述的方法，其特征在于，获取所述操作事件对应的操作数据，包括：若鼠标键入事件为鼠标滚轮输入，则获取鼠标滚轮的滚动方向和滚动圈数；基于所述滚动方向和滚动圈数，计算鼠标滚轮的滚动增值，作为该鼠标键入事件的操作数据。8.如权利要求2所述的方法，其特征在于：所述兼容层为允许在第一通信协议的环境中运行使用第二通信协议编写的应用程序模块。9.如权利要求1-7任一项所述的方法，其特征在于，所述第一通信协议为Wayland协议，所述第二通信协议为X11协议。10.一种远程控制装置，驻留在受控计算设备中，所述受控计算设备通过第一通信协议显示信息，其特征在于，该装置包括：接收模块，适于接收来自主控计算设备的控制请求，所述控制请求基于第二通信协议生成；获取模块，适于获取所述控制请求指向的响应函数的函数指针；转换模块，适于将所述函数指针的指向转换为目标函数，所述目标函数与所述响应函数具有相同功能，且基于第一通信协议生成；生成模块，适于利用转换指向地址后的函数指针，生成所述控制请求的模拟请求；响应模块，适于响应所述模拟请求，在所述受控计算设备中模拟出所述控制请求的响应结果。11.一种计算设备，其特征在于，包括：至少一个处理器；和存储有程序指令的存储器，其中，所述程序指令被配置为适于由所述至少一个处理器执行，所述程序指令包括用于执行如权利要求1-9中任一项所述方法的指令。12.一种存储有程序指令的可读存储介质，其特征在于，当所述程序指令被计算设备读取并执行时，使得所述计算设备执行如权利要求1-9中任一项所述的方法。
说明书desc
技术领域本发明涉及计算机技术领域，具体涉及一种远程控制方法、装置、计算设备及存储介质。背景技术Linux中显示服务器是一个程序，其主要任务是协调客户端图形显示以及彼此之间的输入输出。显示服务器通过显示服务协议与其客户端进行通信。目前这种显示技术栈主要分为X11和Wayland两种。目前，依赖X11编写的应用软件占据了绝大部分的市场，而移植这些应用程序到Wayland平台之前，需要一个“胶合层”让其在Wayland中正常运行以达到过渡的目的，为此组织编写了XWayland模块，它可以被理解为是一个运行在Wayland服务器之上的X11服务器，其允许在Wayland会话中运行X客户端。通过XWayland的胶合功能，之前基于X11编写的程序可以运行在Wayland中，但涉及到远程控制时，由于服务器的输入由Wayland Compositor在进行接管，远程控制在XWayland中并无具体的底层实现，导致这些基于X11编写的应用失去了远程控制能力。发明内容鉴于上述问题，提出了本发明以便提供一种克服上述问题或者至少部分地解决上述问题的一种远程控制方法、装置、计算设备及存储介质。根据本发明的一个方面，提供一种远程控制方法，在受控计算设备中执行，受控计算设备通过第一通信协议显示信息，该方法包括：接收来自主控计算设备的控制请求，控制请求基于第二通信协议生成；获取控制请求指向的响应函数的函数指针；将函数指针的指向转换为目标函数，目标函数与响应函数具有相同功能，且基于第一通信协议生成；利用转换指向地址后的函数指针，生成控制请求的模拟请求；响应模拟请求，在受控计算设备中模拟出控制请求的响应结果。可选地，在根据本发明的远程控制方法中，其中，受控计算设备中驻留有兼容层，兼容层适于在基于第一通信协议的计算设备上运行基于第二通信协议的应用；获取控制请求指向的响应函数的函数指针，包括：将控制请求发送至兼容层；利用兼容层解析控制请求，以获取函数指针。可选地，在根据本发明的远程控制方法中，其中，利用兼容层解析控制请求，以获取函数指针，包括：确定控制请求的请求类型，请求类型指示操作事件，操作事件包括鼠标移动事件、鼠标键入事件和键盘键入事件；基于操作事件，确定函数指针。可选地，在根据本发明的远程控制方法中，其中，利用兼容层解析控制请求，以获取函数指针，还包括：解析控制请求，获取操作事件对应的操作数据。可选地，在根据本发明的远程控制方法中，其中，利用转换指向地址后的函数指针，生成控制请求的模拟请求，包括：利用第一通信协议，将指示操作事件的函数指针和对应操作数据进行封装，以生成模拟请求。可选地，在根据本发明的远程控制方法中，其中，响应模拟请求，在受控计算设备中模拟出控制请求的响应结果，包括：基于模拟请求所包含的函数指针，确定出所述目标函数；将操作数据作为函数参数，运行目标函数，以得到响应结果。可选地，在根据本发明的远程控制方法中，其中，获取所述操作事件对应的操作数据，包括：若鼠标键入事件为鼠标滚轮输入，则获取鼠标滚轮的滚动方向和滚动圈数；基于滚动方向和滚动圈数，计算鼠标滚轮的滚动增值，作为该鼠标键入事件的操作数据。可选地，在根据本发明的远程控制方法中，其中：兼容层为允许在第一通信协议的环境中运行使用第二通信协议编写的应用程序模块。可选地，在根据本发明的远程控制方法中，其中，第一通信协议为Wayland协议，第二通信协议为X11协议。根据本发明的又一个方面，提供一种远程控制装置，驻留在受控计算设备中，受控计算设备通过第一通信协议显示信息，该装置包括：接收模块，适于接收来自主控计算设备的控制请求，控制请求基于第二通信协议生成；获取模块，适于获取控制请求指向的响应函数的函数指针；转换模块，适于将函数指针的指向转换为目标函数，目标函数与响应函数具有相同功能，且基于第一通信协议生成；生成模块，适于利用转换指向地址后的函数指针，生成控制请求的模拟请求；响应模块，适于响应模拟请求，在受控计算设备中模拟出控制请求的响应结果。根据本发明的又一个方面，提供一种计算设备，包括：至少一个处理器；和存储有程序指令的存储器，其中，所述程序指令被配置为适于由所述至少一个处理器执行，所述程序指令包括用于执行上述方法的指令。根据本发明的又一个方面，提供一种存储有程序指令的可读存储介质，当所述程序指令被计算设备读取并执行时，使得所述计算设备执行上述的方法。根据本发明的方案，通过生成基于第一通信协议的模拟请求替换基于第二通信协议的控制请求，能够使得使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求。根据本发明的方案，通过生成第二通信协议的函数指针与第一通信协议的目标函数的关联关系，实现基于第二通信协议下开发的含有远程功能的软件在第一通信协议环境下，远程控制功能能的无缝兼容，具有代码修改量小、通用性强、适用面广等有点，极大的降低了含有远程控制功能的软件厂商在第一通信协议下兼容性适配的工作量和成本。上述说明仅是本发明技术方案的概述，为了能够更清楚了解本发明的技术手段，而可依照说明书的内容予以实施，并且为了让本发明的上述和其它目的、特征和优点能够更明显易懂，以下特举本发明的具体实施方式。附图说明通过阅读下文优选实施方式的详细描述，各种其他的优点和益处对于本领域普通技术人员将变得清楚明了。附图仅用于示出优选实施方式的目的，而并不认为是对本发明的限制。而且在整个附图中，用相同的参考符号表示相同的部件。在附图中：图1示出现有技术中在Wayland环境中响应X11远程控制指令的方法流程图；图2示出了根据本发明一个实施例的计算设备的示意图；图3示出了根据本发明一个实施例的远程控制方法的流程图；图4示出了根据本发明一个实施例的远程控制装置的结构示意图。具体实施方式下面将参照附图更详细地描述本公开的示例性实施例。虽然附图中显示了本公开的示例性实施例，然而应当理解，可以以各种形式实现本公开而不应被这里阐述的实施例所限制。相反，提供这些实施例是为了能够更透彻地理解本公开，并且能够将本公开的范围完整的传达给本领域的技术人员。X11是一个最初于1987年开发的窗口系统协议，被广泛用于Linux和其他UNIX系统上,它使用了传统的客户端-服务器模型，其中应用程序向X11服务器发送请求，服务器处理这些请求并将应用程序的图形显示在屏幕上。然而，X11存在一些问题，例如难以调试、设计不安全和性能问题等。为此，提出了Wayland，Wayland是一个现代的窗口系统协议，于2008年首次公布，旨在取代X11。X11是一个老牌的图形系统，虽然一直在努力地演进，但由于它在设计上较为复杂，一个普通的X11图形环境，至少要包含“X Server”、“Window Manager”、“X Client”三个角色，这三者之间都需要频繁的交互，这一方面会影响图形性能，另一方面是结构的复杂性极大的限制了它扩展功能的能力，使得难以快速迭代。同时，对于桌面环境而言，“XServer”是一个不可控制的角色，不同的桌面环境难以实现差异化功能，这掣肘了桌面环境的发展。而Wayland则是为了解决以上问题所诞生的一套新的图形环境，它更简单也更容易扩展，可以由桌面环境开发者完全把控，大大地提高桌面环境的上限。Wayland相较于X11，采用了全新的设计，它使用了更简单、更现代的协议和技术，可以提供更好的性能和安全性，并能更好地支持现代图形硬件。然而，由于很多应用程序还是基于X11协议编写的，为了使它们能够在Wayland环境中运行，XWayland作为一个兼容层被开发出来，当需要运行使用X11协议编写的应用程序时，Wayland服务器会启动XWayland进程，然后将这些应用程序的窗口显示在Wayland的窗口管理器中，这样，用户就可以在Wayland环境中使用X11协议编写的应用程序了。但涉及到远程控制时，由于服务器的输入由Wayland Compositor在进行接管，远程控制在XWayland中并无具体的底层实现，导致这些基于X11写的应用失去了远程控制能力。在Wayland显示协议，X应用程序想要实现桌面控制，需要针对Wayland显示协议对接远程控制功能，从而将X的远程控制请求在Wayland server中做实际的底层实现，如图1所示，图1示出现有技术中在Wayland环境中响应X11远程控制指令的方法流程图。XApp通过XHook将基于XTEST协议的远程控制请求发送至XWayland，XWayland通过Wayland fake-input协议将该远程控制请求发送至Wayland Server，由Wayland Server上传至libinput，从而实现远程控制。使用该方法可以无缝的兼容完整的X11程序远程控制功能，但由于XTEST协议是统一的， 而Wayland端的远程控制协议实现方式各有不同，在实现远程控制时，需要根据其不同平台的Wayland协议内容修改XWayland代码再适配，通用性较差。为了解决上述存在的技术问题，本发明提供了一种远程控制方法。该方法通过生成基于第一通信协议的模拟请求替换基于第二通信协议的控制请求，能够使得使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求。该方法可以实现为应用程序，安装于计算设备200中。上述的计算设备200可以实现为服务器，例如应用服务器、Web服务器等；也可以实现为桌面电脑、笔记本电脑、处理器芯片、平板电脑等，但不限于此。图2示出了根据本发明一个实施例的计算设备200的示意图。在基本配置中，计算设备200包括至少一个处理单元202和系统存储器204。根据一个方面，取决于计算设备的配置和类型，系统存储器204包括但不限于易失性存储、非易失性存储、闪速存储器、或者这样的存储器的任何组合。根据一个方面，系统存储器204包括操作系统205。系统存储器204还包括程序模块250。根据一个方面，操作系统205，例如，适合于控制计算设备200的操作。此外，示例结合图形库、其他操作系统、或任何其他应用程序而被实践，并且不限于任何特定的应用或系统。在图2中通过在虚线208内的那些组件示出了该基本配置。根据一个方面，计算设备200具有额外的特征或功能。例如，根据一个方面，计算设备200包括额外的数据存储设备，例如磁盘、光盘、或者磁带。这样额外的存储在图2中是由可移动存储设备209和不可移动存储设备210示出的。如在上文中所陈述的，根据一个方面，在系统存储器204中存储有程序模块。根据一个方面，程序模块可以包括一个或多个应用程序，本发明不限制应用程序的类型，例如应用程序可以包括：电子邮件和联系人应用程序、文字处理应用程序、电子表格应用程序、数据库应用程序、幻灯片展示应用程序、绘画或计算机辅助应用程序、网络浏览器应用程序等。在根据本发明的实施例中，程序模块中的应用程序可以为远程控制装置400，远程控制装置400被配置为执行本发明的远程控制方法300。根据一个方面，可以在包括分立电子元件的电路、包含逻辑门的封装或集成的电子芯片、利用微处理器的电路、或者在包含电子元件或微处理器的单个芯片上实践示例。例如，可以经由其中在图2中所示出的每个或许多组件可以集成在单个集成电路上的片上系统来实践示例。根据一个方面，这样的SOC设备可以包括一个或多个处理单元、图形单元、通信单元、系统虚拟化单元、以及各种应用功能，其全部作为单个集成电路而被集成到芯片基底上。当经由SOC进行操作时，可以经由在单个集成电路上与计算设备200的其他组件集成的专用逻辑来对在本文中所描述的功能进行操作。还可以使用能够执行逻辑操作的其他技术来实践本发明的实施例，所述其他技术包括但不限于机械、光学、流体、和量子技术。另外，可以在通用计算机内或在任何其他任何电路或系统中实践本发明的实施例。根据一个方面，计算设备200还可以具有一个或多个输入设备212，例如键盘、鼠标、笔、语音输入设备、触摸输入设备等。还可以包括输出设备214，例如显示器、扬声器、打印机等。前述设备是示例并且也可以使用其他设备。计算设备200可以包括允许与其他计算设备218进行通信的一个或多个通信连接216，其他计算设备218可以为打印设备，打印设备例如打印机。合适的通信连接216的示例包括但不限于：RF发射机、接收机和/或收发机电路；通用串行总线、并行和/或串行端口。如在本文中所使用的术语计算机可读介质包括计算机存储介质。计算机存储介质可以包括以任何用于存储信息的方法或技术来实现的易失性的和非易失性的、可移动的和不可移动的介质。系统存储器204、可移动存储设备209、和不可移动存储设备210都是计算机存储介质的示例。计算机存储介质可以包括随机存取存储器 、只读存储器 、电可擦只读存储器、闪速存储器或其他存储器技术、CD-ROM、数字通用盘或其他光存储、盒式磁带、磁带、磁盘存储器或其他磁存储设备、或者可用于存储信息并且可以由计算机设备200访问的任何其他制品。根据一个方面，任何这样的计算机存储介质都可以是计算设备200的一部分。计算机存储介质不包括载波或其他经传播的数据信号。根据一个方面，通信介质是由计算机可读指令、数据结构、程序模块、或者经调制的数据信号中的其他数据实施的，并且包括任何信息传递介质。根据一个方面，术语“经调制的数据信号”描述了具有一个或多个特征集或者以将信息编码在信号中的方式改变的信号。作为示例而非限制，通信介质包括诸如有线网络或直接有线连接之类的有线介质，以及诸如声学、射频、红外线的、以及其他无线介质之类的无线介质。在根据本发明的实施例中，计算设备200被配置为执行根据本发明的应用远程控制方法300。计算设备200包括一个或多个处理器、以及存储有程序指令的一个或多个可读存储介质，当程序指令被配置为由一个或多个处理器执行时，使得计算设备执行本发明实施例中的应用远程控制方法300。根据本发明的一个实施例，计算设备200的远程控制装置400被配置为执行根据本发明的应用远程控制方法300。其中，远程控制装置400中包含用于执行本发明的应用远程控制方法300的多条程序指令，这些程序指令可以指示处理器执行根据本发明的应用远程控制方法300，计算设备200通过执行本发明的应用远程控制方法300，来实现通过使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求。图3示出了根据本发明一个实施例的远程控制方法300的流程图。远程控制方法300适于在受控计算设备中执行，受控计算设备通过第一通信协议显示信息，在本实施例中，第一通信协议可以为Wayland协议。如图3所示，远程控制方法300的目的是提供一种通过生成基于第一通信协议的模拟请求替换基于第二通信协议的控制请求，能够使得使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求的方法。远程控制方法300始于步骤302，在步骤302中，接收来自主控计算设备的控制请求，控制请求基于第二通信协议生成。主控计算设备中驻留有远程控制应用，用户可以通过XApp向受控计算设备发送远程控制请求，该控制请求一般基于第二通信协议生成。在一些实施例中，控制请求至少包括操作事件和操作事件对应的操作数据。具体地，操作事件为鼠标移动事件、鼠标键入事件和键盘键入事件等，操作数据为这些操作事件的具体数据，例如，对于鼠标移动事件，鼠标从显示界面的A点移动至B点产生的绝对位移或相对位移，为该鼠标移动事件的操作数据。对于鼠标键入事件，左键键入、右键键入、滚轮滚动方向和滚动圈数等，为鼠标键入事件的操作数据等等。在一个具体示例中，示出部分控制请求的生成伪代码。#include＜X11/extensions/XTest.h＞// X应用通过X11协议发送模拟键盘按下和松开事件XTestFakeKeyEvent{XExtDisplayInfo *info = find_display ;register xXTestFakeInputReq *req;XTestCheckExtension ;LockDisplay;GetReq;req-＞reqType = info-＞codes-＞major_opcode;req-＞xtReqType = X_XTestFakeInput;req-＞type = is_press ? KeyPress : KeyRelease;req-＞detail = keycode;req-＞time = delay;UnlockDisplay;SyncHandle;return 1;}// X应用通过X11协议发送鼠标按键按下和松开事件件intXTestFakeButtonEvent{XExtDisplayInfo *info = find_display ;register xXTestFakeInputReq *req;XTestCheckExtension ;LockDisplay;GetReq;req-＞reqType = info-＞codes-＞major_opcode;req-＞xtReqType = X_XTestFakeInput;req-＞type = is_press ? ButtonPress : ButtonRelease;req-＞detail = button;req-＞time = delay;UnlockDisplay;SyncHandle;return 1;}// X应用通过X11协议发送鼠标移动事件intXTestFakeMotionEvent{XExtDisplayInfo *info = find_display ;register xXTestFakeInputReq *req;XTestCheckExtension ;LockDisplay;GetReq;req-＞reqType = info-＞codes-＞major_opcode;req-＞xtReqType = X_XTestFakeInput;req-＞type = MotionNotify;req-＞detail = False;if  req-＞root = None;else req-＞root = RootWindow;req-＞rootX = x;req-＞rootY = y;req-＞time = delay;UnlockDisplay;SyncHandle;return 1;}{XExtDisplayInfo *info = find_display ;register xXTestFakeInputReq *req;XTestCheckExtension ;LockDisplay;GetReq;req-＞reqType = info-＞codes-＞major_opcode;req-＞xtReqType = X_XTestFakeInput;req-＞type = is_press ? ButtonPress : ButtonRelease;req-＞detail = button;req-＞time = delay;UnlockDisplay;SyncHandle;return 1;}// X应用通过X11协议发送相对于当前指针位置的指定偏移量  的鼠标移动事件intXTestFakeRelativeMotionEvent{XExtDisplayInfo *info = find_display ;register xXTestFakeInputReq *req;XTestCheckExtension ;LockDisplay;GetReq;req-＞reqType = info-＞codes-＞major_opcode;req-＞xtReqType = X_XTestFakeInput;req-＞type = MotionNotify;req-＞detail = True;req-＞root = None;req-＞rootX = dx;req-＞rootY = dy;req-＞time = delay;UnlockDisplay;SyncHandle;return 1;}受控计算设备在接收到控制请求后，进入步骤304，获取控制请求指向的响应函数的函数指针。每一操作事件均对应有至少一个响应函数，例如，鼠标左键键入事件，对应鼠标左键响应函数；鼠标滚轮键入事件，对应鼠标滚轮响应函数等。容易理解的是，由于控制请求基于X11协议生成，受控计算设备本身为Wayland环境，无法对控制请求进行处理，因此，控制请求会被转发至兼容层处理，前述介绍过，兼容层可以实现在基于第一通信协议的计算设备上运行基于第二通信协议的应用，在此，不再对兼容层进行赘述。具体地，首先，将控制请求发送至兼容层。然后，利用兼容层解析控制请求，以获取所述函数指针。其中，兼容层先确述控制请求的请求类型，请求类型指示操作事件，操作事件包括鼠标移动事件、鼠标键入事件和键盘键入事件。再基于操作事件，确定函数指针。换言之，利用兼容层处理基于第一协议的XTEST Fakeinput请求，解析出其调用的ScreenPtr的FakeAxisInputPtr、FakeKeyBoardInputPtr、FakeButtonInputPtr、FakeMotionOffsetInputPtr、FakeMotionAbsoluteInputPtr等一系列函数指针。值得注意的是，若鼠标键入事件为鼠标滚轮输入，则先获取鼠标滚轮的滚动方向和滚动圈数，基于滚动方向和滚动圈数，计算鼠标滚轮的滚动增值，作为该鼠标键入事件的操作数据。在一个具体示例中，示出兼容层解析控制请求，得到对应响应函数的函数指针的部分伪代码。// XWayland中处理来自X应用的请求ProcXTestFakeInput{REQUEST;int nev, n, type, rc;xEvent *ev;DeviceIntPtr dev = NULL;........switch  {case KeyPress:return BadDevice;if  {client-＞errorValue = ev-＞u.u.detail;return BadValue;}need_ptr_update = 0;break;case MotionNotify:if return BadDevice;if ) {rc = dixLookupWindow;if return rc;if  {client-＞errorValue = ev-＞u.keyButtonPointer.root;return BadValue;}/* Add the root window's offset to the valuators */if &amp;&amp;firstValuator＜= 1&amp;&amp;numValuators＞0) {if valuators+= root-＞drawable.pScreen-＞x;if valuators+= root-＞drawable.pScreen-＞y;}}if  {client-＞errorValue = ev-＞u.u.detail;return BadValue;}/* FIXME: Xinerama! */break;case ButtonPress:case ButtonRelease:if return BadDevice;if  {client-＞errorValue = ev-＞u.u.detail;return BadValue;}break;}if dixSaveScreens;int posx, posy;ScreenPtr pScreen = screenInfo.screens;miPointerGetPosition;// 判断这次请求的类型switch  {// 鼠标移动请求case MotionNotify:valuator_mask_set_range;nevents = GetPointerEvents;// 如果当前的环境) {;}break;case ButtonPress:// 如果当前的环境＞0 &amp;&amp;IsWaylandSession) {; );}break;case ButtonRelease:valuator_mask_set_range;nevents = GetPointerEvents;if ＞0 &amp;&amp;IsWaylandSession) {; );}// 判断当前鼠标滚轮的方向，根据方向计算滚动时的增值if &amp;&amp;IsWaylandSession) {int test = ev-＞u.u.detail == 5 ? 4 : -4;;}break;case KeyPress:if ) {);}break;case KeyRelease:nevents =GetKeyboardEvents;if ) {);}break;}if ) {for mieqProcessDeviceEvent);}if miPointerUpdateSprite;return Success;}当获取到相应的函数指针后，进入步骤306，将函数指针的指向转换为目标函数，目标函数与响应函数具有相同功能，且基于第一通信协议生成。容易理解的是，在控制请求中的函数指针指向的应该是基于第二通信协议下的响应函数，即基于X11协议的响应函数，当受控计算设备为Wayland环境，其包含的均为基于Wayland的函数，因此，需要将函数指针指向基于Waylandd协议的函数，即上述目标函数。在一个具体示例中，示出将函数指针指向目标函数的部分伪代码。// 对接Wayland鼠标滚轮模拟输入协议，将*pScreen-＞FakeAxisInput转为向Wayland server请求鼠标滚动static void fake_axis_input{struct xwl_screen *xwl_screen = xwl_screen_get;org_kde_kwin_fake_input_axis);}// 对接Wayland键盘模拟输入协议，将*pScreen-＞FakeKeyBoardInput转为向Wayland server请求键盘动作static void fake_keyboard_input{struct xwl_screen *xwl_screen = xwl_screen_get;// 1 WL_KEYBOARD_KEY_STATE_PRESSED0 WL_KEYBOARD_KEY_STATE_RELEASEDorg_kde_kwin_fake_input_keyboard_key;}static void fake_button_input{struct xwl_screen *xwl_screen = xwl_screen_get; // 1 WL_POINTER_BUTTON_STATE_PRESSED0 WL_POINTER_BUTTON_STATE_RELEASEDorg_kde_kwin_fake_input_button;}// 对接Wayland鼠标相对移动协议，将*pScreen-＞FakeMotionOffsetInput转为向Wayland server请求鼠标相对移动static void fake_motion_offset_input{struct xwl_screen *xwl_screen = xwl_screen_get;org_kde_kwin_fake_input_pointer_motion, wl_fixed_from_double);}// 对接Wayland鼠标绝对移动协议，将*pScreen-＞FakeMotionAbsoluteInput转为向Wayland server请求鼠标绝对移动static void fake_motion_absolute_input{struct xwl_screen *xwl_screen = xwl_screen_get; org_kde_kwin_fake_input_pointer_motion_absolute, wl_fixed_from_double);}{struct xwl_screen *xwl_screen = xwl_screen_get;org_kde_kwin_fake_input_axis);}static void fake_keyboard_input{struct xwl_screen *xwl_screen = xwl_screen_get;// 1 WL_KEYBOARD_KEY_STATE_PRESSED0 WL_KEYBOARD_KEY_STATE_RELEASEDorg_kde_kwin_fake_input_keyboard_key;}static void fake_button_input{struct xwl_screen *xwl_screen = xwl_screen_get;........// 将函数指针连接到实际处理的函数pScreen-＞FakeAxisInput = fake_axis_input;pScreen-＞FakeKeyBoardInput = fake_keyboard_input;pScreen-＞FakeButtonInput = fake_button_input;pScreen-＞FakeMotionOffsetInput = fake_motion_offset_input;pScreen-＞FakeMotionAbsoluteInput = fake_motion_absolute_input。随后，在步骤308中，利用转换指向地址后的函数指针，生成控制请求的模拟请求。具体地，利用第一通信协议，将指示操作事件的函数指针和对应操作数据进行封装，以生成模拟请求。即利用转换地址后的函数指针和原控制请求所包括的操作数据，形成该模拟请求，由于模拟请求的函数指针指向的是基于第一通信协议Wayland生成的目标函数，因此，该目标函数可直接在Wayland环境中运行。最后，在步骤310中，响应模拟请求，在受控计算设备中模拟出控制请求的响应结果。具体地，基于模拟请求所包含的函数指针，确定出目标函数。将操作数据作为函数参数，运行目标函数，以得到响应结果。本发明提供的方法通过生成基于第一通信协议的模拟请求替换基于第二通信协议的控制请求，能够使得使用第一通信协议的计算设备处理基于第二通信协议的远程控制请求。本发明提供的方法通过生成第二通信协议的函数指针与第一通信协议的目标函数的关联关系，实现基于第二通信协议下开发的含有远程功能的软件在第一通信协议环境下，远程控制功能的无缝兼容，具有代码修改量小、通用性强、适用面广等有点，极大的降低了含有远程控制功能的软件厂商在第一通信协议下兼容性适配的工作量和成本。图4示出了根据本发明一个实施例的远程控制装置400的结构示意图。该装置400驻留在受控计算设备中，受控计算设备通过第一通信协议显示信息。装置400包括相互耦接的接收模块402、获取模块404、转换模块406、生成模块408和响应模块410。其中，接收模块402适于接收来自主控计算设备的控制请求，控制请求基于第二通信协议生成。获取模块404适于获取控制请求指向的响应函数的函数指针。转换模块406适于将函数指针的指向转换为目标函数，目标函数与响应函数具有相同功能，且基于第一通信协议生成。生成模块408适于利用转换指向地址后的函数指针，生成控制请求的模拟请求。响应模块410适于响应模拟请求，在受控计算设备中模拟出控制请求的响应结果。需要说明的是，本实施例提供的远程控制装置400的工作原理及流程与上述远程控制方法300相似，相关之处可参考对上述远程控制方法300的描述，在此不再赘述。这里描述的各种技术可结合硬件或软件，或者它们的组合一起实现。从而，本发明的方法和设备，或者本发明的方法和设备的某些方面或部分可采取嵌入有形媒介，例如可移动硬盘、U盘、软盘、CD-ROM或者其它任意机器可读的存储介质中的程序代码的形式，其中当程序被载入诸如计算机之类的机器，并被所述机器执行时，所述机器变成实践本发明的设备。在程序代码在可编程计算机上执行的情况下，计算设备一般包括处理器、处理器可读的存储介质，至少一个输入装置，和至少一个输出装置。其中，存储器被配置用于存储程序代码；处理器被配置用于根据该存储器中存储的所述程序代码中的指令，执行本发明的方法。以示例而非限制的方式，可读介质包括可读存储介质和通信介质。可读存储介质存储诸如计算机可读指令、数据结构、程序模块或其它数据等信息。通信介质一般以诸如载波或其它传输机制等已调制数据信号来体现计算机可读指令、数据结构、程序模块或其它数据，并且包括任何信息传递介质。以上的任一种的组合也包括在可读介质的范围之内。在此处所提供的说明书中，算法和显示不与任何特定计算机、虚拟系统或者其它设备固有相关。各种通用系统也可以与本发明的示例一起使用。根据上面的描述，构造这类系统所要求的结构是显而易见的。此外，本发明也不针对任何特定编程语言。应当明白，可以利用各种编程语言实现在此描述的本发明的内容，并且上面对特定语言所做的描述是为了披露本发明的较佳实施方式。在此处所提供的说明书中，说明了大量具体细节。然而，能够理解，本发明的实施例可以在没有这些具体细节的情况下被实践。在一些实例中，并未详细示出公知的方法、结构和技术，不模糊对本说明书的理解。类似地，应当理解，为了精简本公开并帮助理解各个发明方面中的一个或多个，在上面对本发明的示例性实施例的描述中，本发明的各个特征有时被一起分组到单个实施例、图、或者对其的描述中。本领域那些技术人员应当理解在本文所公开的示例中的设备的模块或单元或组件可以布置在如该实施例中所描述的设备中，或者可替换地可以定位在与该示例中的设备不同的一个或多个设备中。前述示例中的模块可以组合为一个模块或者此外可以分成多个子模块。本领域那些技术人员可以理解，可以对实施例中的设备中的模块进行自适应性地改变并且把它们设置在与该实施例不同的一个或多个设备中。可以把实施例中的模块或单元或组件组合成一个模块或单元或组件，以及此外可以把它们分成多个子模块或子单元或子组件。此外，本领域的技术人员能够理解，尽管在此所述的一些实施例包括其它实施例中所包括的某些特征而不是其它特征，但是不同实施例的特征的组合意味着处于本发明的范围之内并且形成不同的实施例。此外，所述实施例中的一些在此被描述成可以由计算机系统的处理器或者由执行所述功能的其它装置实施的方法或方法元素的组合。因此，具有用于实施所述方法或方法元素的必要指令的处理器形成用于实施该方法或方法元素的装置。此外，装置实施例的在此所述的元素是如下装置的例子：该装置用于实施由为了实施该发明的目的的元素所执行的功能。如在此所使用的那样，除非另行规定，使用序数词“第一”、“第二”、“第三”等等来描述普通对象仅仅表示涉及类似对象的不同实例，并且并不意图暗示这样被描述的对象必须具有时间上、空间上、排序方面或者以任意其它方式的给定顺序。尽管根据有限数量的实施例描述了本发明，但是受益于上面的描述，本技术领域内的技术人员明白，在由此描述的本发明的范围内，可以设想其它实施例。此外，应当注意，本说明书中使用的语言主要是为了可读性和教导的目的而选择的，而不是为了解释或者限定本发明的主题而选择的。

标题title
共享硬件运算单元的局部缓存方法
摘要abst
本申请涉及集成电路设计技术领域，公开了一种共享硬件运算单元的局部缓存方法。硬件运算单元连接有至少一个输入寄存器和至少一个输出寄存器，每个输入寄存器连接有至少一级缓冲，所述方法包括：在中央处理器对所述至少一个输入寄存器的写入过程中，如果所述硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲；所述中央处理器在所述至少一个输入寄存器中写入新的值，所述硬件运算单元对新的值执行运算；所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器。本申请通过在硬件运算单元内部增加缓存的方法来允许多个软件线程随机访问。
权利要求书clms
1.一种共享硬件运算单元的局部缓存方法，其特征在于，硬件运算单元连接有至少一个输入寄存器和至少一个输出寄存器，每个输入寄存器连接有至少一级缓冲，所述方法包括：在中央处理器对所述至少一个输入寄存器的写入过程中，如果所述硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲；所述中央处理器在所述至少一个输入寄存器中写入新的值，所述硬件运算单元对新的值执行运算；以及所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器。2.如权利要求1所述的局部缓存方法，其特征在于，还包括：每个输入寄存器将存储其中的值写入对应的第一级缓冲时，每个第一级缓冲将存储其中的值写入对应的第二级缓冲。3.如权利要求1所述的局部缓存方法，其特征在于，还包括：每个第一级缓冲将存储其中的值返回到对应的输入寄存器时，每个第二级缓冲将存储其中的值返回到对应的第一级缓冲。4.如权利要求1所述的局部缓存方法，其特征在于，所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令包括：所述硬件运算单元在总线上检测到所述中央处理器对特定的输出寄存器的地址的读取命令。5.如权利要求1所述的局部缓存方法，其特征在于，每个第一级缓冲在所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后的一个或多个时钟周期，将存储其中的值返回到对应的输入寄存器。6.如权利要求1所述的局部缓存方法，其特征在于，还包括：每个第一级缓冲将存储其中的值返回到对应的输入寄存器后，所述中央处理器继续对所述至少一个输入寄存器中未被写入的输入寄存器的写入过程。7.如权利要求1所述的局部缓存方法，其特征在于，在所述中央处理器对所述至少一个输入寄存器的写入过程结束后，如果所述硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲；所述中央处理器在所述至少一个输入寄存器中写入新的值，所述硬件运算单元对新的值执行运算；所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器，并且，所述硬件运算单元对返回的值执行运算。8.如权利要求1所述的局部缓存方法，其特征在于，每个输入寄存器包括一级至八级缓冲。9.如权利要求1所述的局部缓存方法，其特征在于，所述硬件远算单元执行乘法、除法、开方和三角函数运算。
说明书desc
技术领域本申请涉及集成电路设计技术领域，特别涉及一种共享硬件运算单元的局部缓存方法。背景技术在现有系统级芯片设计中，如果需要中央处理器执行某个不在指令集中的运算，比如乘除，指数，开方，三角函数等运算，需要通过软件模拟，花费时间比较长。为了加快速度，会增加专门的硬件运算电路作为硬件加速单元。硬件加速单元作为共享的硬件资源，会被多个软件线程调用。如果有多个线程需要利用该硬件作为加速单元，可能正好会在写入输入数据和读出结果之间被中断，插入的线程如果同样需要硬件加速，使用后会影响上一个线程的结果。软件不得不花费额外的开销做处理，影响整体的效率。硬件运算单元一般需要输入一个或者多个变量，计算结束后读出计算结果。在输入变量和读出结果之间，如果被其他软件线程中断，在新的线程中又做了一次运算，输入的变量可能会被修改。被中断的线程如果用修改后的变量结算，结果就会错误。在计算机系统中，一些共享设备比如打印机，外设等，都是由操作系统来管理，对上层软件来说，都是通过驱动程序去操作共享设备。很多微控制器的应用没有操作系统，一般通过下面几种方式来处理被中断的情况：1.关闭中断，避免其他线程插入。该方按需要额外的操作，且会影响实时性。2.利用CPU指令集的原子操作，在计算结果读出之前不允许插入其他操作。然而，有的CPU不支持原子操作，且同样会影响实时性。且CPU的原子操作只支持对一个寄存器地址的读-改-写，不支持对多个地址的连续操作，无法把一个运算当作一个原子操作。3.插入的软件线程在运算前保存现场，运算后恢复现场，使被打算的软件线程能继续执行。比如中断程序会自动对某些寄存器做压栈出栈的处理，但是其他寄存器需要手工处理。该方案需要额外的压栈和出栈操作，增加处理时间，降低效率。4.增加多个硬件运算单元，分配个不同线程使用，互不干扰。该方案会增加芯片的面积和功耗。上述提高的每个方法都存在一定的缺点，在某些应用场景下会受到限制。硬件运算单元能通过牺牲面积增加硬件逻辑来加速运算，最快能在一个周期内完成运算，但为了避免多个软件线程同时使用该硬件运算单元，可能需要花费多余的时间或者成本，影响了整个系统的效率。发明内容本申请的目的在于提供一种共享硬件运算单元的局部缓存方法，通过在硬件运算单元内部增加缓存的方法来允许多个软件线程随机访问。本申请公开了一种共享硬件运算单元的局部缓存方法，硬件运算单元连接有至少一个输入寄存器和至少一个输出寄存器，每个输入寄存器连接有至少一级缓冲，所述方法包括：在中央处理器对所述至少一个输入寄存器的写入过程中，如果所述硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲；所述中央处理器在所述至少一个输入寄存器中写入新的值，所述硬件运算单元对新的值执行运算；以及所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器。在一个优选例中，还包括：每个输入寄存器将存储其中的值写入对应的第一级缓冲时，每个第一级缓冲将存储其中的值写入对应的第二级缓冲。在一个优选例中，还包括：每个第一级缓冲将存储其中的值返回到对应的输入寄存器时，每个第二级缓冲将存储其中的值返回到对应的第一级缓冲。在一个优选例中，所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令包括：所述硬件运算单元在总线上检测到所述中央处理器对特定的输出寄存器的地址的读取命令。在一个优选例中，每个第一级缓冲在所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后的一个或多个时钟周期，将存储其中的值返回到对应的输入寄存器。在一个优选例中，还包括：每个第一级缓冲将存储其中的值返回到对应的输入寄存器后，所述中央处理器继续对所述至少一个输入寄存器中未被写入的输入寄存器的写入过程。在一个优选例中，在所述中央处理器对所述至少一个输入寄存器的写入过程结束后，如果所述硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲；所述中央处理器在所述至少一个输入寄存器中写入新的值，所述硬件运算单元对新的值执行运算；所述硬件运算单元检测到所述中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器，并且，所述硬件运算单元对返回的值执行运算。在一个优选例中，每个输入寄存器包括一级至八级缓冲。在一个优选例中，所述硬件远算单元执行乘法、除法、开方和三角函数运算。本申请实施方式相对于现有技术具有以下有益效果：本申请的硬件运算单元的每个输入寄存器连接有至少一级缓冲，在对至少输入寄存器的写入过程中，如果硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的缓冲中，在输入寄存器中写入新的值，硬件运算单元对新的值执行运算，在输出寄存器中的计算结果均被读取后，每个缓冲将存储其中的值返回到对应的输入寄存器。本申请只需要给输入寄存器增加几个缓冲，可以实现多个线程共享同一硬件运算单元，硬件开销小。并且，线程中断的处理过程对软件来说完全透明，不需要任何处理，和单独操作硬件运算单元一样。本申请的说明书中记载了大量的技术特征，分布在各个技术方案中，如果要罗列出本申请所有可能的技术特征的组合的话，会使得说明书过于冗长。为了避免这个问题，本申请上述发明内容中公开的各个技术特征、在下文各个实施方式和例子中公开的各技术特征、以及附图中公开的各个技术特征，都可以自由地互相组合，从而构成各种新的技术方案，除非这种技术特征的组合在技术上是不可行的。例如，在一个例子中公开了特征A+B+C，在另一个例子中公开了特征A+B+D+E，而特征C和D是起到相同作用的等同技术手段，技术上只要择一使用即可，不可能同时采用，特征E技术上可以与特征C相组合，则，A+B+C+D的方案因技术不可行而应当不被视为已经记载，而A+B+C+E的方案应当视为已经被记载。附图说明图1是根据本申请一个实施例中的共享硬件运算单元的局部缓存方法流程示意图。图2是根据常规的硬件运算单元的的结构示意图。图3是根据本申请一个实施例中的共享硬件运算单元的结构示意图。具体实施方式在以下的叙述中，为了使读者更好地理解本申请而提出了许多技术细节。但是，本领域的普通技术人员可以理解，即使没有这些技术细节和基于以下各实施方式的种种变化和修改，也可以实现本申请所要求保护的技术方案。为使本申请的目的、技术方案和优点更加清楚，下面将结合附图对本申请的实施方式作进一步地详细描述。本申请的一个实施例中涉及一种共享硬件运算单元的局部缓存方法，硬件运算单元连接有至少一个输入寄存器和至少一个输出寄存器，每个输入寄存器连接有至少一级缓冲。输入寄存器例如可以具有3个，输出寄存器例如可以具有2个。应当理解，输入寄存器的数量取决于执行运算需要的输入变量的个数，输出寄存器的数量取决于运算输出的结果的数量。在一个实施例中，硬件远算单元执行乘法、除法、开方和三角函数运算。在一个实施例中，每个输入寄存器可以包括一级至八级缓冲，例如，包括三级缓冲。缓冲可以采用寄存器来实现。应当理解，每个输入寄存器设置的缓冲的级数取决于中断的级数，多级缓冲可以保存多级中断的输入数据，使得硬件运算单元可以处理多级中断。所述局部缓存方法的流程如图1所示，该方法包括以下步骤：步骤101，在中央处理器对至少一个输入寄存器的写入过程中，如果硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲。在一个实施例中，每个输入寄存器将存储其中的值写入对应的第一级缓冲时，每个第一级缓冲将存储其中的值写入对应的第二级缓冲，每个第二级缓冲将存储其中的值写入对应的第三级缓冲，并以此类推。步骤102，中央处理器在至少一个输入寄存器中写入新的值，硬件运算单元对新的值执行运算。此时，输入寄存器中写入被插入线程的值，硬件运算单元对插入的线程进行运算，并将运算的结果写入输出寄存器中。中央处理器从输出寄存器中读取计算结果。步骤103，硬件运算单元检测到中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器。在一个实施例中，硬件运算单元检测到中央处理器对特定的输出寄存器的读指令包括：硬件运算单元在总线上检测到中央处理器对特定的输出寄存器的地址的读取命令。中央处理器在读取输出寄存器过程中，在总线上发送需要读取的输出寄存器的地址命令，硬件运算单元可以检测到中央处理器读取的寄存器的地址，从而判断输出寄存器中的计算结果是否已经被中央处理器全部读取完全，从而确认插入线程的运算结束了，以便继续进行被中断的线程或执行新的线程。在一个实施例中，每个第一级缓冲在硬件运算单元检测到中央处理器对特定的输出寄存器的读指令后的一个或多个时钟周期，将存储其中的值返回到对应的输入寄存器。在一个实施例中，每个第一级缓冲将存储其中的值返回到对应的输入寄存器时，每个第二级缓冲将存储其中的值返回到对应的第一级缓冲，每个第二级缓冲将存储其中的值写入对应的第三级缓冲，并以此类推。在一个实施例中，每个第一级缓冲将存储其中的值返回到对应的输入寄存器后，中央处理器继续对至少一个输入寄存器中未被写入的输入寄存器的写入过程，从而继续执行被中断的线程的运算。在另一个实施例中，在中央处理器对至少一个输入寄存器的写入过程结束后，如果硬件运算单元收到中断指令，每个输入寄存器将存储其中的值写入对应的第一级缓冲。中央处理器在至少一个输入寄存器中写入新的值，硬件运算单元对新的值执行运算。硬件运算单元检测到中央处理器对特定的输出寄存器的读指令后，每个第一级缓冲将存储其中的值返回到对应的输入寄存器，并且，硬件运算单元对返回的值执行运算。此时，被中断线程的输入数据已经写入完毕，无需继续写入，在被插入的线程的计算结果读取完毕后，自动开始新的运算。本申请只需要给输入寄存器增加几个缓冲，可以实现多个线程共享同一硬件运算单元，允许多个软件线程随机访问，硬件开销小。并且，线程中断的处理过程对软件来说完全透明，不需要任何处理，和单独操作硬件运算单元一样。为了能够更好地理解本申请的技术方案，下面结合一个具体的例子来进行说明，该例子中罗列的细节主要是为了便于理解，不作为对本申请保护范围的限制。假设某个运算=f，允许有多个输入变量和输出结果。如图2所示，每个输入变量和输出结果都有一个寄存器，运算前CPU写入数据到输入寄存器x1、x2、x3等，运算后CPU从输出寄存器y1、y2读取计算结果。从写入数据到读出计算结果就是一个完整的计算过程，其正常操作流程如下：1.写输入寄存器2.启动运算或者在写入最后一个输入变量的时候自动开始运算3.运算结束后读取结果，读取最后一个结果时表示全部结束。如果在计算过程中发生中断，在进入中断程序后也需要利用同一个硬件运算单元做加速运算，同样会写入输入寄存器，同时读出输出寄存器的结果。此时寄存器的值已经被中断程序更新，从中断程序退出后，继续原来的计算会直接使用更新后的寄存器值，而不是原有的寄存器值，计算结果就会出错。为了防止出错，软件需要做一些现场保存或者关闭中断的操作，避免计算过程的数据被修改造成错误，软件方案需要额外的压栈和出栈操作，增加处理时间，降低效率。本申请通过在硬件运算单元内部增加缓存的方法来允许多个软件线程随机访问。参考图3所示，为每个输入寄存器增加一个级联缓冲寄存器串，例如，为输入寄存器x1增加x1缓冲1、x1缓冲2、……，为输入寄存器x2增加x2缓冲1、x2缓冲2、……，为输入寄存器x3增加x3缓冲1、x3缓冲2、……。每次写入某个寄存器的时候，会把输入寄存器中原来的值推入到缓冲1中，缓冲1的值推入到缓冲2中，以此类推。运算结束后，读取最后一个结果时，所有的缓冲的值往上退回一层，缓冲2的值退回到缓冲1，缓冲1的值退回到输入寄存器，以此类推。注意，写入的时候，每次只更新一个寄存器串；读出最后一个结果后，所有的寄存器都会更新。如果没有其他软件线程插入，推入和退回的寄存器值都没有作用，不影响下次的正常运算，因为下次运算需要重新写入新的数据。如果在运算过程中被其他线程插入，插入的线程中也需要用到硬件运算单元，其操作流程如下：1.写输入寄存器，写入寄存器x1和x2后被中断，寄存器x3还未写入a) CPU进入其他线程，该线程按正常流程操作b) 写入寄存器x1，原来寄存器x1的值推入到x1缓冲1c) 写入寄存器x2，原来寄存器x2的值推入到x2缓冲1d) 写入寄存器x3，原来寄存器x3的值推入到x3缓冲1。此时实际推入的是一个无用的值，因为步骤1还没写入有效值e) 硬件远算单元开始运算，CPU在运算后读取结果f) CPU读取完最后一个寄存器时，自动将x1缓冲1、x2缓冲1、x3缓冲1的值退回到寄存器x1、x2、x3中，并且启动一个新的运算g) 从当前插入线程退出后，寄存器x1和x2还是原来的值，寄存器x3和输出寄存器的结果虽然也更新了，但是一个无效值，不影响被插入线程继续执行。2.继续写入寄存器x33.启动运算或者在写入最后一个输入变量的时候自动开始运算4.运算结束后读取结果，读取最后一个结果时表示全部结束。上面的流程是在写入寄存器过程中被中断的情况。如果是在写入完毕，读取输出寄存器的时候被中断，此时同样将输入寄存器中的值推入到缓冲，运算单元根据新写入寄存器中的值执行插入线程，在运算完毕并且计算结果被读取后，自动将缓冲中的值退回到输入寄存器中，被中断线程的输入数据已写入完毕，运算单元自动启动一个新的运算，此时也能保证被插入的程序能读到正确的结果。缓冲寄存器的级数与可能被嵌入的级数有关。如果只有一级中断，则只需要一级缓冲寄存器。如果存在多级中断嵌入，且每级中断都可能调用硬件运算单元，则需要多级缓冲寄存器。需要说明的是，在本专利的申请文件中，诸如第一和第二等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个”限定的要素，并不排除在包括所述要素的过程、方法、物品或者设备中还存在另外的相同要素。本专利的申请文件中，如果提到根据某要素执行某行为，则是指至少根据该要素执行该行为的意思，其中包括了两种情况：仅根据该要素执行该行为、和根据该要素和其它要素执行该行为。多个、多次、多种等表达包括2个、2次、2种以及2个以上、2次以上、2种以上。在本说明书提及的所有文献都被认为是整体性地包括在本申请的公开内容中，以便在必要时可以作为修改的依据。此外应理解，以上所述仅为本说明书的较佳实施例而已，并非用于限定本说明书的保护范围。凡在本说明书一个或多个实施例的精神和原则之内，所作的任何修改、等同替换、改进等，均应包含在本说明书一个或多个实施例的保护范围之内。在一些情况下，在权利要求书中记载的动作或步骤可以按照不同于实施例中的顺序来执行并且仍然可以实现期望的结果。另外，在附图中描绘的过程不一定要求示出的特定顺序或者连续顺序才能实现期望的结果。在某些实施方式中，多任务处理和并行处理也是可以的或者可能是有利的。

标题title
一种基于数据污染传播分析的纹理动态索引方法
摘要abst
本发明涉及一种基于数据污染传播分析的纹理动态索引方法。本发明通过在安卓框架下修改Bitmap类，为其增加一个索引变量，将图像源映射到图像对象，并监控图像源和图像对象的修改，根据上述修改及时更新图像对象的索引，实现对于给定的、由一个内存地址指向的纹理缓存，可不需要读取其纹理缓存的具体内容，就可以建立对应的纹理索引，索引值满足纹理的唯一性，且通过跟踪对纹理的修改操作序列，可以支持纹理的动态变化，并且纹理动态索引依赖的信息是最小集。
权利要求书clms
1.一种基于数据污染传播分析的纹理动态索引方法，其特征在于，所述方法包括：步骤S1：修改安卓框架，在安卓端读取图像，为所述图像创建图像对象即Bitmap对象，并为所述Bitmap对象建立索引，将所述图像映射到所述Bitmap对象，具体包括：修改Bitmap类，为所述Bitmap类增加标识成员变量索引，所述索引包括以下信息：唯一标识符、源信息、对纹理的修改操作序列和引用Id；修改BitmapFactory类的decodeStream函数、decodeFile函数和decodeResource函数，监视所述Bitmap类的创建并获取所述源信息，并将所述decodeStream函数、decodeFile函数或decodeResource函数返回的所述图像的来源信息计入所述Bitmap对象的索引变量的源信息变量；步骤S2：修改安卓框架的基于Bitmap对象创建新Bitmap对象的函数；具体包括：将上述创建新Bitmap对象的函数的返回值的Bitmap对象的索引变量的引用Id的值设置为上述创建新Bitmap对象的函数的source参数的索引成员变量的引用；步骤S3：监视所述源信息的修改，并根据所述修改更新所述源信息；步骤S4：修改安卓框架的图像修改函数，监视对所述Bitmap对象的修改；步骤S5：修改安卓框架的纹理创建函数，在所述纹理创建函数的入口获取正在使用的纹理位图对应的Bitmap对象，将所述纹理位图对应的Bitmap对象的索引变量的唯一标识符变量与所述纹理创建函数的纹理id建立一一对应关系。2.根据权利要求1所述的纹理动态索引方法，其特征在于，所述步骤S3具体包括：当监视到图像文件的移动操作时，更新所述索引中的所述源信息的路径信息，当监视到图像文件的写操作时，删除与该图像文件对应的Bitmap对象的索引。3.根据权利要求1所述的纹理动态索引方法，其特征在于，所述步骤S4具体包括：步骤S41：判断当前Bitmap对象的索引的引用Id是否为空，如果不为空，则将所述引用Id指向的Bitmap对象的索引复制过来，并为当前Bitmap对象重新生成一个唯一标识符，且将当前Bitmap对象的引用Id设置为null；步骤S42：在当前Bitmap对象的对纹理的修改操作序列中搜索是否存在与当前修改相同的修改，如果存在与当前修改相同的修改，则在所述对纹理的修改操作序列中删除与当前修改相同的修改；步骤S43：将与当前修改相关的图像修改函数名、参数序列和时间戳记录到当前Bitmap对象的索引的对纹理的修改操作序列变量。4.根据权利要求3所述的纹理动态索引方法，其特征在于，满足以下条件之一即可确定在当前Bitmap对象的对纹理的修改操作序列中存在与当前修改相同的修改：图像修改函数名和参数序列与当前调用的图像修改函数和参数序列完全相同；对于针对单个像素点的修改，图像修改函数名和像素坐标与当前操作的图像修改函数和像素坐标相同；或者，对于针对多个像素点的修改，图像修改函数名与当前操作的图像修改函数相同且对纹理的修改操作序列中的像素范围属于当前操作的像素范围子集。5.根据权利要求1所述的纹理动态索引方法，其特征在于，所述步骤S5之后还包括：步骤S6：判断是否存在相同的索引，如果存在相同的索引，则只保留相同的索引中的其中一个索引，删除其它的相同索引。6.根据权利要求5所述的纹理动态索引方法，其特征在于，满足以下条件之一即可确定存在相同的索引：索引的引用Id都不为空，且相同；或索引的源信息相同，且对纹理的修改操作序列相同。
说明书desc
技术领域本发明属于计算机软件开发技术领域，具体涉及一种基于数据污染传播分析的纹理动态索引方法。背景技术在图形渲染过程中，通常采用纹理映射将单独的图片映射覆盖到3D模型上，并跟随模型移动变换，以完成映射到屏幕空间的图形渲染操作。其中，纹理即为进行纹理映射的图像资源。对纹理的各种优化操作往往都涉及纹理数据的修改或变动，即纹理数据被污染，在这种情况下，往往都需要建立纹理索引，例如如果需要对某压缩纹理解码后的结果进行缓存，以便下次使用时可从缓存文件中直接加载，就不需要再次进行解码，就需要能够建立一个纹理索引，将纹理缓存与一个索引值对应起来。而采用传统的图像哈希算法进行纹理映射时每次都需要读取完整图像，这些采用传统的图像哈希算法进行纹理映射的方法有两个问题：一是运行时性能低，难以满足高性能渲染的需求；二是解决不了纹理动态改变后的索引问题，例如纹理加载到内存后，往往会进行一些变换、修改操作，那么在纹理数据被污染时，传统方法做的纹理的索引就失效了。因此，需要一种运行时高效、且可支持动态变化的纹理动态索引方法。发明内容有鉴于此，本发明提供了一种基于数据污染传播分析的纹理动态索引方法，实现了根据对纹理的修改操作序列的跟踪来动态更新纹理的索引。本发明提供的一种基于数据污染传播分析的纹理动态索引方法，包括以下步骤：步骤S1：修改安卓框架，在安卓端读取图像，为所述图像创建图像对象即Bitmap对象，并为所述Bitmap对象建立索引，将图像映射到Bitmap对象，具体包括：修改Bitmap类，为所述Bitmap类增加标识成员变量索引，所述索引包括以下信息：唯一标识符、源信息、对纹理的修改操作序列和引用Id；修改BitmapFactory类的decodeStream函数、decodeFile函数和decodeResource函数，监视所述Bitmap类的创建并获取所述源信息，并将所述decodeStream函数、decodeFile函数或decodeResource函数返回的所述图像的来源信息计入所述Bitmap对象的索引变量的源信息变量；步骤S2：修改安卓框架的基于Bitmap对象创建新Bitmap对象的函数；具体包括：将上述创建新Bitmap对象的函数的返回值的Bitmap对象的索引变量的引用Id的值设置为上述创建新Bitmap对象的函数的source参数的索引成员变量的引用；步骤S3：监视所述源信息的修改，并根据所述修改更新所述源信息；步骤S4：修改安卓框架的图像修改函数，监视对所述Bitmap对象的修改；步骤S5：修改安卓框架的纹理创建函数，在所述纹理创建函数的入口获取正在使用的纹理位图对应的Bitmap对象，将所述纹理位图对应的Bitmap对象的索引变量的唯一标识符变量与所述纹理创建函数的纹理id建立一一对应关系。进一步地，所述步骤S3具体包括：当监视到图像文件的移动操作时，更新所述索引中的所述源信息中的路径信息，当监视到图像文件的写操作时，删除与该图像文件对应Bitmap对象的索引。进一步地，所述步骤S4具体包括：步骤S41：判断当前Bitmap对象的索引的引用Id是否为空，如果不为空，则将所述引用Id指向的Bitmap对象的索引复制过来，并为当前Bitmap对象重新生成一个唯一标识符，且将当前Bitmap对象的引用Id设置为null；步骤S42：在当前Bitmap对象的对纹理的修改操作序列中搜索是否存在与当前修改相同的修改，如果存在与当前修改相同的修改，则在所述对纹理的修改操作序列中删除与当前修改相同的修改；步骤S43：将与当前修改相关的图像修改函数名、参数序列和时间戳记录到当前Bitmap对象的索引的对纹理的修改操作序列变量。进一步地，满足以下条件之一即可确定在当前Bitmap对象的对纹理的修改操作序列中存在与当前修改相同的修改：图像修改函数名和参数序列与当前调用的图像修改函数和参数序列完全相同；对于针对单个像素点的修改，图像修改函数名和像素坐标与当前操作的图像修改函数和像素坐标相同；或者，对于针对多个像素点的修改，图像修改函数名与当前操作的图像修改函数相同且对纹理的修改操作序列中的像素范围属于当前操作的像素范围子集。进一步地，所述步骤S5之后还包括：步骤S6：判断是否存在相同的索引，如果存在相同的索引，则只保留相同的索引中的其中一个索引，删除其它的相同索引。进一步地，满足以下条件之一即可确定存在相同的索引：索引的引用Id都不为空，且相同；或索引的源信息相同，且对纹理的修改操作序列相同。有益效果本发明通过在安卓框架下修改Bitmap类，为其增加一个索引变量，将图像源映射到Bitmap对象，并监控图像源和Bitmap对象的修改，根据上述修改及时更新Bitmap对象的索引，实现对于给定的、由一个内存地址指向的纹理缓存，可不需要读取其纹理缓存的具体内容，就可以建立对应的纹理索引，索引值满足纹理的唯一性，且通过跟踪对纹理的修改操作序列，可以支持纹理的动态变化，并且纹理动态索引依赖的信息是最小集。具体实施方式以下实施例用于说明本发明，但不用来限制本发明的范围。下面对本发明作进一步的详细说明。可以理解的是，此处所描述的具体实施例仅仅用于解释本发明，而非对本发明的限定。实施例本实施例采用本发明提供的一种基于数据污染传播分析的纹理动态索引方法，具体包括以下步骤：步骤S1：修改安卓框架，在安卓兼容环境中读取图像，为读取的图像创建图像对象，并为所述Bitmap对象建立索引，将图像映射到Bitmap对象。其中，在安卓系统中读取图像通常包括从输入流读取、从文件读取和从资源对象读取等。相应地，在安卓系统中，创建Bitmap对象的方法一般包括以下三种：从输入流创建、从文件创建及从资源对象创建。为Bitmap对象建立索引，将图像映射到Bitmap对象的过程为：修改Bitmap类，为所述Bitmap类增加标识成员变量索引，这个索引为一个列表数据结构，所述索引包括以下信息：唯一标识符、源信息、对纹理的修改操作序列和引用Id；其中，源信息source包括图像文件的全路径及时间戳，或者图像文件在压缩文件中的相对路径，而对纹理的修改操作序列opSequence包括修改操作的类型、操作的参数列表，引用Id表示此Bitmap对象复制自另外一个Bitmap对象，初始值为null。修改BitmapFactory类的decodeStream函数、decodeFile函数和decodeResource函数，监视所述Bitmap类的创建并获取所述源信息，并将所述decodeStream函数、decodeFile函数或decodeResource函数返回的所述图像的来源信息计入所述Bitmap对象的索引变量的源信息变量；可以理解的是，由于图像的来源不同，为图像创建Bitmap对象所采用的函数也并不相同，比如，如果图像是从输入流读取的，则通过decodeStream函数创建Bitmap对象，如果图像是从文件读取的，则通过decodeFile函数创建Bitmap对象，如果图像是从资源对象读取的，则通过decodeResource函数创建Bitmap对象。通过不同的函数创建Bitmap对象后，将函数结束时的返回值中包括的图像的来源信息中的相对路径）计入已创建的图像对象的索引变量的源信息变量，将读取的图像映射到已创建的Bitmap对象。步骤S2：修改安卓框架的基于Bitmap对象创建新Bitmap对象的函数；例如Bitmap类的createBitmap、createScaledBitmap函数等。在实际应用中，可能会遇到基于现有的Bitmap对象再生成一个新的Bitmap对象的情况，可以理解为Bitmap对象的复制，此时，由于安卓框架的基于Bitmap对象创建新Bitmap对象的函数的返回值是一个新的Bitmap对象，那么只需将上述创建新Bitmap对象的函数的返回值的Bitmap对象的索引变量的引用Id的值设置为上述创建新Bitmap对象的函数的source参数的索引成员变量的引用，即可实现将新Bitmap对象与创建该新Bitmap对象基于的Bitmap对象关联起来。步骤S3：监视所述源信息的修改，并根据所述修改更新所述源信息；在一些情况下，图像文件本身可能会经历一些操作，这些操作会引起与图像文件对应的Bitmap对象中索引的某些参数的变化，因此就需要实时监视对图像文件的操作，判断相关操作是否会引起索引中相关参数的变化。比如，可以基于操作系统提供的文件监视接口，如Linux的inotify接口、Windows的文件系统过滤驱动接口等，监视做了标识的那些图片纹理文件或者压缩文件，如果监视到图像文件的移动操作，就更新索引中的参数之一源信息source中的路径信息。再比如，如果监视到对图像文件的写操作，那么该图像文件已不是原始的图像文件，即原始图像对应的图像数据已被污染，与原始图像对应的Bitmap对象无须存在，则此时需要删除该Bitmap对象的索引。步骤S4：修改安卓框架的图像修改函数，监视对所述Bitmap对象的修改；对Bitmap对象的修改通常是调用图像修改函数来实现，比如修改像素的函数setPixel、setPixels等。若安卓端存在对当前Bitmap对象的修改操作，且当前Bitmap对象的索引的引用Id成员不为空，说明当前Bitmap对象由另外一个Bitmap对象创建，可以将当前Bitmap对象的索引的引用Id指向的Bitmap对象的索引复制过来，同时，为了保证每个Bitmap对象索引的唯一性，需为当前Bitmap对象重新生成一个唯一标识符，并将当前Bitmap对象的索引的引用Id设置为null。若安卓端存在对当前Bitmap对象的修改操作，且当前Bitmap对象的索引的引用Id成员为空，则在当前Bitmap对象的索引的对纹理的修改操作序列opSequence中搜索是否存在与当前修改相同的修改，如果存在与当前修改相同的修改，则在当前Bitmap对象的索引的opSequence中删除与当前修改相同的修改，比如，如果在当前Bitmap对象的索引的opSequence中搜索到函数名和参数序列与当前调用参数完全相同的修改操作，则删除当前Bitmap对象的索引的opSequence中相应的老的修改操作；再比如，对于针对单个像素点的修改，如搜索到函数名和像素坐标与当前操作的函数名和像素坐标相同的修改操作，则删除当前Bitmap对象的索引的opSequence中相应的老的修改操作；或者，对于针对多个像素点的修改，如搜索到图像修改函数名与当前操作的图像修改函数相同且对纹理的修改操作序列中的像素范围属于当前操作的像素范围子集，则删除当前Bitmap对象的索引的opSequence中相应的老的修改操作。在当前Bitmap对象的索引的opSequence中删除与当前修改相同的修改操作之后，将与当前修改相关的图像修改函数名、参数序列和时间戳记录到当前Bitmap对象的索引的opSequence变量。可以理解的是，如果在当前Bitmap对象的索引的对纹理的修改操作序列opSequence中不存在与当前修改相同的修改，则可直接将与当前修改相关的图像修改函数名、参数序列和时间戳记录到当前Bitmap对象的索引的opSequence变量，以更新Bitmap对象的索引，使其与修改后的Bitmap对象对应。此处需要注意的是，在实际应用中，对Bitmap对象的有些修改的前后顺序虽然不同，但是效果是一样的，在这种情况下，Bitmap对象的索引可以不变。步骤S5：修改安卓框架的glGenTextures等纹理创建函数，在所述纹理创建函数的入口获取正在使用的纹理位图即图像对应的Bitmap对象，该Bitmap对象如果没经过修改则为原始图像对应的Bitmap对象，如果经过修改，则为修改后的Bitmap对象，将所述纹理位图对应的Bitmap对象的索引变量的唯一标识符变量与所述纹理创建函数的纹理id建立一一对应关系，即将纹理创建函数的纹理id与Bitmap对象唯一关联起来，即使对Bitmap对象进行修改，通过纹理id依然能唯一的确定经过修改的Bitmap对象，也就是说，Bitmap对象的索引值满足了纹理的唯一性，且能支持纹理的动态变化。可以理解的是，上述方法的过程中可能会产生两个或者多个相同的索引，为了减少冗余，去掉相同的索引，需要把相同的索引找出来。通常认为如果满足以下条件之一即可确定存在相同的索引：索引的引用Id都不为空，且相同；或，2）索引的源信息相同，且对纹理的修改操作序列相同。把相同的索引找出来之后，需要去掉多余的相同索引，具体可以通过删除相同索引中的多余的索引，只保留其中一个索引的方式实现。虽然，上文中已经用一般性说明、具体实施方式及试验，对本发明作了详尽的描述，但在本发明基础上，可以对之作一些修改或改进，这对本领域技术人员而言是显而易见的。因此，在不偏离本发明精神的基础上所做的这些修改或改进，均属于本发明要求保护的范围。

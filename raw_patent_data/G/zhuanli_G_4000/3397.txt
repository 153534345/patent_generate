标题title
基于BIM数据及现场数据的信息平台管理方法及系统
摘要abst
本发明公开基于BIM数据及现场数据的信息平台管理方法及系统，涉及信息平台管理技术领域。本发明包括，获取现场数据以及现场数据的属性；根据现场数据的属性获取现场数据在建筑信息模型内的虚拟存储空间；在接收每个现场数据并处理存储至建筑信息模型内对应的虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量；根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围；获取建筑信息模型内每个虚拟存储空间接收的现场数据的历史记录；对算力平台的算力资源进行划分得到算力资源周期分配计划。本发明有效避免了算力资源耗尽导致施工现场监控失效的问题。
权利要求书clms
1.一种基于BIM数据及现场数据的信息平台管理方法，其特征在于，包括，获取现场数据以及所述现场数据的属性；根据所述现场数据的属性获取所述现场数据在建筑信息模型内的虚拟存储空间；在接收每个现场数据并处理存储至所述建筑信息模型内对应的所述虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量；根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围；获取所述建筑信息模型内每个所述虚拟存储空间接收的所述现场数据的历史记录；根据每个所述虚拟存储空间接收的所述现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划；按照所述算力资源周期分配计划对所述现场数据进行处理。2.根据权利要求1所述的方法，其特征在于，所述现场数据的属性包括，考勤打卡、深基坑支护状态、地下水位状态、裸土未覆盖状态、消防通道堵塞状态、塔吊安全状态和/或高支模状态。3.根据权利要求1所述的方法，其特征在于，所述根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围的步骤，包括，对于每个所述现场数据的属性，获取多个所述现场数据的处理算力消耗量；剔除多个所述现场数据的处理算力消耗量中的异常值，得到多个所述现场数据的常规处理算力消耗量；根据多个所述现场数据的常规处理算力消耗量的数值分布得到多个所述现场数据的常规处理算力消耗量在每个数值单位区间的分布比例；根据多个所述现场数据的常规处理算力消耗量在每个数值单位区间的分布比例得到多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例；根据多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例得到多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率；将现场数据处理算力消耗量的数值聚集区间作为现场数据处理算力消耗量的范围，根据多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率得到现场数据处理算力消耗量的范围。4.根据权利要求3所述的方法，其特征在于，所述剔除多个所述现场数据的处理算力消耗量中的异常值，得到多个所述现场数据的常规处理算力消耗量的步骤，包括，判断所述现场数据的属性；若所述现场数据包括地下水位状态或裸土未覆盖状态，则，对于归属于同一属性的多个所述现场数据，将同一个属性的多个所述现场数据按照生成时间顺序进行排列，得到所述现场数据的时序队列；按照所述现场数据的时序队列将所述现场数据对应的所述处理算力消耗量进行排列得到多个所述处理算力消耗量的时序队列；根据多个所述处理算力消耗量的时序队列计算每个所述处理算力消耗量相比较相邻所述处理算力消耗量的增加或降低的比例的绝对值作为每个所述处理算力消耗量的波动值；获取每个所述处理算力消耗量的波动值的数值聚集分布范围；将不属于波动值的数值聚集分布范围的所述处理算力消耗量进行剔除得到多个所述现场数据的常规处理算力消耗量。5.根据权利要求3所述的方法，其特征在于，所述根据多个所述现场数据的常规处理算力消耗量在每个数值单位区间的分布比例得到多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例的步骤，包括，根据多个所述现场数据的常规处理算力消耗量在每个数值单位区间的分布比例得到每个数值单位区间的分布比例值；将每个数值单位区间的分布比例值按照数值大小进行排列，得到数值单位区间的分布比例值序列；计算得出数值单位区间的分布比例值序列中相邻两个数值单位区间的分布比例值的差值的均值作为数值单位区间分布比例均差值；在数值单位区间的分布比例值序列中，将与相邻数值单位区间的分布比例值的差值大于所述数值单位区间分布比例均差值的数值单位区间的分布比例值对应的所述现场数据的常规处理算力消耗量作为所述现场数据的常规聚集处理算力消耗量；获取每个所述现场数据的常规聚集处理算力消耗量的生成时间；按照生成时间的顺序将多个所述现场数据的常规聚集处理算力消耗量进行排列，在生成时间上连续的若干个所述现场数据的常规聚集处理算力消耗量构成一个数值聚集区间；根据所述现场数据的常规聚集处理算力消耗量在每个数值聚集区间中的分布以及得到多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例。6.根据权利要求3所述的方法，其特征在于，所述根据多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率得到现场数据处理算力消耗量的范围的步骤，包括，根据多个所述现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率得到每个所述现场数据的常规处理算力消耗量的发生概率；剔除掉发生概率小于设定值的所述现场数据的常规处理算力消耗量，得到所述现场数据的常规标准处理算力消耗量；将所述现场数据的常规标准处理算力消耗量的分布范围以及每个所述现场数据的常规标准处理算力消耗量的发生概率的作为现场数据处理算力消耗量的范围。7.根据权利要求1所述的方法，其特征在于，所述根据每个所述虚拟存储空间接收的所述现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划的步骤，包括，将所述算力平台虚拟化划分为若干个相互独立的算力模块；对于每个现场数据的属性，根据现场数据处理算力消耗量的范围得到每个属性的所述现场数据的算力消耗量期望值；根据每个所述虚拟存储空间接收的所述现场数据的历史记录得到每个属性的现场数据的生成量关于时间的关系；根据每个属性的现场数据的生成量关于时间的关系得到每个属性的现场数据的生成量周期；根据每个属性的现场数据的生成量关于时间的关系、每个属性的所述现场数据的算力消耗量期望值以及每个属性的现场数据的生成量周期得到在每个属性的现场数据的生成量周期内所述现场数据的算力消耗量期望值关于时间的关系；对每个属性的现场数据的重要程度进行设置，得到每个属性的现场数据的优先级；按照在每个属性的现场数据的生成量周期内所述现场数据的算力消耗量期望值关于时间的关系以及每个属性的现场数据的优先级调整每个所述现场数据的属性对应所述算力模块的算力资源，得到算力资源周期分配计划。8.根据权利要求7所述的方法，其特征在于，所述对于每个现场数据的属性，根据现场数据处理算力消耗量的范围得到每个属性的所述现场数据的算力消耗量期望值的步骤，包括，对于每个现场数据的属性，根据现场数据处理算力消耗量的范围得到所述现场数据的常规标准处理算力消耗量的分布范围以及每个所述现场数据的常规标准处理算力消耗量的发生概率；对于每个现场数据的属性，根据所述现场数据的常规标准处理算力消耗量的分布范围以及每个所述现场数据的常规标准处理算力消耗量的发生概率得到每个属性的所述现场数据的算力消耗量期望值。9.根据权利要求7所述的方法，其特征在于，所述按照在每个属性的现场数据的生成量周期内所述现场数据的算力消耗量期望值关于时间的关系以及每个属性的现场数据的优先级调整每个所述现场数据的属性对应所述算力模块的算力资源，得到算力资源周期分配计划的步骤，包括，获取所述每个属性的现场数据的生成量周期的最大公约数作为算力资源分配周期；在每个所述算力资源分配周期内，根据每个属性的现场数据的生成量周期的时间长度以及在每个属性的现场数据的生成量周期内所述现场数据的算力消耗量期望值关于时间的关系得到每个所述算力资源分配周期内不同属性的现场数据的算力消耗量期望值关于时间的关系；根据每个所述算力资源分配周期内不同属性的现场数据的算力消耗量期望值关于时间的关系以及每个属性的现场数据的优先级，优先分配给优先级高的现场数据，得到算力资源周期分配计划。10.基于BIM数据及现场数据的信息平台管理系统，其特征在于，包括，数据获取单元，用于获取现场数据以及所述现场数据的属性；根据所述现场数据的属性获取所述现场数据在建筑信息模型内的虚拟存储空间；算力测算单元，用于在接收每个现场数据并处理存储至所述建筑信息模型内对应的所述虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量；根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围；数据获取单元，还用于获取所述建筑信息模型内每个所述虚拟存储空间接收的所述现场数据的历史记录；算力分配单元，用于根据每个所述虚拟存储空间接收的所述现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划；按照所述算力资源周期分配计划对所述现场数据进行处理。
说明书desc
技术领域本发明属于信息平台管理技术领域，特别是涉及基于BIM数据及现场数据的信息平台管理方法及系统。背景技术建筑信息模型技术是一种新型的建筑设计、施工和运营管理方法，它通过数字化、信息化的手段，实现建筑项目的全生命周期管理。BIM技术在建筑行业的应用越来越广泛，对于提高项目管理效率、降低成本和提高质量具有重要意义，然而现有的BIM技术主要关注于设计阶段的应用，对于实时现场施工数据与BIM数据的关联处理和信息管理方面尚存在不足。在传统的建筑项目管理中，现场数据的收集、整理和分析通常是手工进行的，这种方法效率低下且容易出错。随着现代监测设备和物联网技术的发展，实时现场数据采集和处理的能力得到了很大提升，但如何将这些现场数据与BIM数据有效关联，用于对建筑信息模型的建模和工程管理进行科学有效的管理，仍然是一个亟待解决的问题。例如由于工程项目的复杂性，BIM模型在信息平台中处于时刻构建、读取和运算的过程中，频繁的数据处理操作可能会导致信息平台失去响应，丧失对重要工程数据的记录。在公开号为CN115662096A的专利中公开了一种基于BIM模型的智能围挡的监测方法，包括：采集施工现场数据，建立建筑物的BIM模型，导入BIM监测终端；将装有定位芯片的围挡运输至临边防护区域安装，并安装物联网定位设备，所述物联网定位设备连接定位平台，所述定位平台能根据物联网定位技术得到所有围挡实时的三维位置信息，所述定位平台连接BIM监测终端，将数据同步至BIM监测终端，BIM监测终端上显示新的BIM模型；通过BIM监测终端进行三维漫游浏览，根据每个围挡的三维位置信息进行对比，判定为问题围挡时预警。该方案对围挡实时的三维位置信息无限制上传BIM监测终端，未充分考虑BIM监测终端的算力消耗，可能会导致算力资源短时间耗尽从而失去监测响应。发明内容本发明的目的在于提供基于BIM数据及现场数据的信息平台管理方法及系统，通过对不同种类的现场数据进行算力资源划分，有效避免算力资源耗尽导致施工现场监控失效的问题。为解决上述技术问题，本发明是通过以下技术方案实现的：本发明提供一种基于BIM数据及现场数据的信息平台管理方法，包括，获取现场数据以及所述现场数据的属性；根据所述现场数据的属性获取所述现场数据在建筑信息模型内的虚拟存储空间；在接收每个现场数据并处理存储至所述建筑信息模型内对应的所述虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量；根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围；获取所述建筑信息模型内每个所述虚拟存储空间接收的所述现场数据的历史记录；根据每个所述虚拟存储空间接收的所述现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划；按照所述算力资源周期分配计划对所述现场数据进行处理。本发明还公开了一种基于BIM数据及现场数据的信息平台管理系统，包括，数据获取单元，用于获取现场数据以及所述现场数据的属性；根据所述现场数据的属性获取所述现场数据在建筑信息模型内的虚拟存储空间；算力测算单元，用于在接收每个现场数据并处理存储至所述建筑信息模型内对应的所述虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量；根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围；数据获取单元，还用于获取所述建筑信息模型内每个所述虚拟存储空间接收的所述现场数据的历史记录；算力分配单元，用于根据每个所述虚拟存储空间接收的所述现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划；按照所述算力资源周期分配计划对所述现场数据进行处理。本发明通过对每种属性的现场数据处理算力消耗量进行分析，得到每个属性的现场数据处理算力消耗量的范围。在对BIM数据模型也就是建筑信息模型中每个虚拟存储空间接收的现场的数据的历史记录即可以计算得到在一个周期时间内不同属性的现场数据的算力消耗期望值，最后即可以按照每种属性的现场数据的算力消耗期望值对每种属性的现场数据进行算力资源分配，在此过程中可以设置不同属性的现场数据的算力资源分配优先级，有效避免了算力资源耗尽导致施工现场监控失效的问题。当然，实施本发明的任一产品并不一定需要同时达到以上所述的所有优点。附图说明为了更清楚地说明本发明实施例的技术方案，下面将对实施例描述所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。图1为本发明所述基于BIM数据及现场数据的信息平台管理方法的工作流程示意图；图2为本发明所述基于BIM数据及现场数据的信息平台管理系统的功能模块及信息流向示意图；图3为本发明所述步骤S4的工作流程示意图；图4为本发明所述步骤S42的工作流程示意图；图5为本发明所述步骤S44的工作流程示意图；图6为本发明所述步骤S46的工作流程示意图；图7为本发明所述步骤S6的工作流程示意图；图8为本发明所述步骤S62的工作流程示意图；图9为本发明所述步骤S67的工作流程示意图；附图中，各标号所代表的部件列表如下：1-数据获取单元，2-算力测算单元，3-算力分配单元。具体实施方式下面将结合本发明实施例中的附图，对本发明实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例仅仅是本发明一部分实施例，而不是全部的实施例。基于本发明中的实施例，本领域普通技术人员在没有作出创造性劳动前提下所获得的所有其它实施例，都属于本发明保护的范围。对于大型的工程项目，在建设的过程中需要保持对多种数据的实时监控，但是并行传输到信息平台的多种数据可能会导致平台的计算资源耗尽，无法对重要的现场数据做出响应。为了避免此问题，本发明提供以下方案。请参阅图1至2所示，本发明提供了基于BIM数据及现场数据的信息平台管理系统，依靠建立的BIM模型数据也就是建筑信息模型，以及现场数据的属性对处理现场数据的算力资源进行分配。在功能模块上本系统包括数据获取单元1、算力测算单元2以及算力分配单元3。在实施的过程中首先需要数据获取单元1执行步骤S1获取现场数据以及现场数据的属性，此处的属性指的是现场数据的类型，例如考勤数据、建筑物等物体的位置形状数据等等，在建筑类工程项目中，现场数据的属性包括，考勤打卡、深基坑支护状态、地下水位状态、裸土未覆盖状态、消防通道堵塞状态、塔吊安全状态和/或高支模状态。之后可以执行步骤S2根据现场数据的属性获取现场数据在建筑信息模型内的虚拟存储空间。接下来可以由算力测算单元2执行步骤S3在接收每个现场数据并处理存储至建筑信息模型内对应的虚拟存储空间的过程中，获取每个现场数据的处理算力消耗量，这是由于即使属性相同的现场数据，处理其所需的算力也可能是不同，有鉴于此需要在接下来执行步骤S4根据多个现场数据的属性以及每个现场数据的处理算力消耗量获取每个属性的现场数据处理算力消耗量的范围。指的是计算机或其他计算设备在完成某个任务或运行某个程序时所需要的计算能力。在本方案中的处理算力消耗量的单位可以是哈希率，表示每秒钟可以处理的哈希数量。算力消耗量通常与计算任务的复杂性和数据量相关，越复杂的任务和越大的数据量需要越高的算力消耗量。之后可以再由数据获取单元1执行步骤S5获取建筑信息模型内每个虚拟存储空间接收的现场数据的历史记录，并在接下来由算力分配单元3执行步骤S6根据每个虚拟存储空间接收的现场数据的历史记录对算力平台的算力资源进行划分得到算力资源周期分配计划，这是由于施工项目的施工具有周期性，例如工作考勤数据会和项目参与人员的工作休息时间具有相同的时间周期性，因此对算力资源进行周期性分配更贴近项目施工需要。最后可以执行步骤S7按照算力资源周期分配计划对现场数据进行处理。也就是将属性相同的现场数据集中统一优先处理，有效避免了由于算计资源瓶颈导致的重要现场数据得不到即时响应。上述步骤可以根据以下代码实施：import java.util.*;public class DataProcessing {public static void main {List＜Data＞ dataList = getDataAndAttributes;Map＜String, List＜Data＞＞ virtualStorageSpaces = getVirtualStorageSpaces;Map＜String, Double＞ processingPowerConsumption = getProcessingPowerConsumption;Map＜String, Double＞ processingPowerRange = getProcessingPowerRange;Map＜String, List＜Data＞＞ historyRecords = getHistoryRecords;Map＜String, Double＞ resourceAllocationPlan = getResourceAllocationPlan;processData;}private static List＜Data＞ getDataAndAttributes {return new ArrayList＜＞;}private static Map＜String, List＜Data＞＞ getVirtualStorageSpaces {return new HashMap＜＞;}private static Map＜String, Double＞ getProcessingPowerConsumption {return new HashMap＜＞;}private static Map＜String, Double＞ getProcessingPowerRange {return new HashMap＜＞;}private static Map＜String, List＜Data＞＞ getHistoryRecords {return new HashMap＜＞;}private static Map＜String, Double＞ getResourceAllocationPlan {return new HashMap＜＞;}private static void processData {}static class Data {}}请参阅图3所示，由于同一属性的现场数据其处理算力消耗量不是一个固定值，为了对其进行量化计算需要得出其区间范围，在实施的过程中，对于每个现场数据的属性，首先可以执行步骤S41获取多个现场数据的处理算力消耗量。由于现场数据采集传感器可能由于各种原因产生或者传输异常的错误数据，因此接下来可以执行步骤S42剔除多个现场数据的处理算力消耗量中的异常值，得到多个现场数据的常规处理算力消耗量。接下来可以执行步骤S43根据多个现场数据的常规处理算力消耗量的数值分布得到多个现场数据的常规处理算力消耗量在每个数值单位区间的分布比例。接下来可以执行步骤S44根据多个现场数据的常规处理算力消耗量在每个数值单位区间的分布比例得到多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例。接下来可以执行步骤S45根据多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例得到多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率。最后可以执行步骤S46将现场数据处理算力消耗量的数值聚集区间作为现场数据处理算力消耗量的范围，根据多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率得到现场数据处理算力消耗量的范围。上述步骤可以根据以下代码实施：import java.util.*;public class DataProcessing {public static void main {List＜Data＞ dataList = getDataAndAttributes;for  {List＜Double＞ powerConsumptions = getProcessingPowerConsumptions;List＜Double＞ regularPowerConsumptions = removeOutliers;Map＜Double, Double＞ distributionRatios = getDistributionRatios;Map＜Double, Double＞ clusterDistributionRatios = getClusterDistributionRatios;Map＜Double, Double＞ clusterDistributionProbabilities = getClusterDistributionProbabilities;List＜Double＞ powerConsumptionRange = getPowerConsumptionRange;}}private static List＜Data＞ getDataAndAttributes {return new ArrayList＜＞;}private static List＜Double＞ getProcessingPowerConsumptions {return new ArrayList＜＞;}private static List＜Double＞ removeOutliers {return new ArrayList＜＞;}private static Map＜Double, Double＞ getDistributionRatios {return new HashMap＜＞;}private static Map＜Double, Double＞ getClusterDistributionRatios {return new HashMap＜＞;}private static Map＜Double, Double＞ getClusterDistributionProbabilities {return new HashMap＜＞;}private static List＜Double＞ getPowerConsumptionRange {return new ArrayList＜＞;}static class Data {}}请参阅图4所示，为了实现对同一属性下异常现场数据的过滤清除，上述步骤S42在执行的过程中首先可以执行步骤S421判断现场数据的属性。若现场数据包括地下水位状态或裸土未覆盖状态，则对于归属于同一属性的多个现场数据。接下来可以执行步骤S422将同一个属性的多个现场数据按照生成时间顺序进行排列，得到现场数据的时序队列。接下来可以执行步骤S423按照现场数据的时序队列将现场数据对应的处理算力消耗量进行排列得到多个处理算力消耗量的时序队列。接下来可以执行步骤S424根据多个处理算力消耗量的时序队列计算每个处理算力消耗量相比较相邻处理算力消耗量的增加或降低的比例的绝对值作为每个处理算力消耗量的波动值。接下来可以执行步骤S425获取每个处理算力消耗量的波动值的数值聚集分布范围。最后可以执行步骤S426将不属于波动值的数值聚集分布范围的处理算力消耗量进行剔除得到多个现场数据的常规处理算力消耗量。也即是将波动值异常的现场数据进行剔除。上述步骤可以根据以下代码实施：import java.util.*;public class DataProcessing {public static void main {List＜Data＞ dataList = getDataAndAttributes;for  {if ) {List＜Data＞ sameAttributeDataList = getSameAttributeDataList;List＜Data＞ sortedDataList = sortByGenerationTime;List＜Double＞ powerConsumptions = getProcessingPowerConsumptions;List＜Double＞ fluctuationValues = getFluctuationValues;List＜Double＞ fluctuationRange = getFluctuationRange;List＜Double＞ regularPowerConsumptions = filterByFluctuationRange;}}}private static List＜Data＞ getDataAndAttributes {return new ArrayList＜＞;}private static boolean isRelevantAttribute {return true;}private static List＜Data＞ getSameAttributeDataList {return new ArrayList＜＞;}private static List＜Data＞ sortByGenerationTime {return new ArrayList＜＞;}private static List＜Double＞ getProcessingPowerConsumptions {return new ArrayList＜＞;}private static List＜Double＞ getFluctuationValues {return new ArrayList＜＞;}private static List＜Double＞ getFluctuationRange {return new ArrayList＜＞;}private static List＜Double＞ filterByFluctuationRange {return new ArrayList＜＞;}static class Data {// 数据属性和其他字段}}请参阅图5所示，归属于同一属性的多个现场数据，其处理算力消耗量的分布也可能是多中心的，也就是说其数值分布上并不是一个数学分布能够完全覆盖的，考虑此情形，需要对一个属性下的多个现场数据的分布状态进行分析，首先可以执行步骤S441根据多个现场数据的常规处理算力消耗量在每个数值单位区间的分布比例得到每个数值单位区间的分布比例值。接下来可以执行步骤S442将每个数值单位区间的分布比例值按照数值大小进行排列，得到数值单位区间的分布比例值序列。接下来可以执行步骤S443计算得出数值单位区间的分布比例值序列中相邻两个数值单位区间的分布比例值的差值的均值作为数值单位区间分布比例均差值。接下来可以执行步骤S444在数值单位区间的分布比例值序列中，将与相邻数值单位区间的分布比例值的差值大于数值单位区间分布比例均差值的数值单位区间的分布比例值对应的现场数据的常规处理算力消耗量作为现场数据的常规聚集处理算力消耗量。接下来可以执行步骤S445获取每个现场数据的常规聚集处理算力消耗量的生成时间。接下来可以执行步骤S446按照生成时间的顺序将多个现场数据的常规聚集处理算力消耗量进行排列，在生成时间上连续的若干个现场数据的常规聚集处理算力消耗量构成一个数值聚集区间。最后可以执行步骤S447根据现场数据的常规聚集处理算力消耗量在每个数值聚集区间中的分布以及得到多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布比例。简要来说，在此过程中通过构建在时间上具有顺序的数值聚集区间，从而实现对具有相同属性的多个现场数据的常规处理算力消耗量范围的准确描述。上述步骤可以根据以下代码实施：import java.util.*;public class DataProcessing {public static void main {List＜Double＞ regularPowerConsumptions = getRegularPowerConsumptions;Map＜Double, Double＞ distributionProportions = getDistributionProportions;List＜Double＞ sortedProportionValues = sortProportionValues;double averageDifference = calculateAverageDifference;List＜Double＞ clusteredPowerConsumptions = getClusteredPowerConsumptions;Map＜Double, Long＞ powerConsumptionTimestamps = getPowerConsumptionTimestamps;List＜Double＞ sortedClusteredPowerConsumptions = sortByTimestamp;Map＜Double, Double＞ distributionProportionsInIntervals = getDistributionProportionsInIntervals;}private static List＜Double＞ getRegularPowerConsumptions {return new ArrayList＜＞;}private static Map＜Double, Double＞ getDistributionProportions {return new HashMap＜＞;}private static List＜Double＞ sortProportionValues {return new ArrayList＜＞;}private static double calculateAverageDifference {return 0.0;}private static List＜Double＞ getClusteredPowerConsumptions {return new ArrayList＜＞;}private static Map＜Double, Long＞ getPowerConsumptionTimestamps {return new HashMap＜＞;}private static List＜Double＞ sortByTimestamp {return new ArrayList＜＞;}private static Map＜Double, Double＞ getDistributionProportionsInIntervals {return new HashMap＜＞;}}请参阅图6所示，属性相同的现场数据也可能会出现其处理算力消耗量发生的概率很低的状态，这就导致其不具有统计实际意义，为了降低计算的复杂度可以将其剔除，在具体实践中首先可以执行步骤S461根据多个现场数据的常规处理算力消耗量在若干个数值聚集区间的分布概率得到每个现场数据的常规处理算力消耗量的发生概率。接下来可以执行步骤S462剔除掉发生概率小于设定值的现场数据的常规处理算力消耗量，得到现场数据的常规标准处理算力消耗量。最后可以执行步骤S463将现场数据的常规标准处理算力消耗量的分布范围以及每个现场数据的常规标准处理算力消耗量的发生概率的作为现场数据处理算力消耗量的范围。在这部分步骤中可以由操作人员自主选择发生概率的设定值，从而在效率和准确性中达到平衡。上述步骤可以根据以下代码实施：import java.util.*;public class DataProcessing {public static void main {List＜Double＞ sortedClusteredPowerConsumptions = getSortedClusteredPowerConsumptions;Map＜Double, Double＞ occurrenceProbabilities = getOccurrenceProbabilities;List＜Double＞ standardPowerConsumptions = filterByOccurrenceProbability;PowerConsumptionRange powerConsumptionRange = getPowerConsumptionRange;}private static List＜Double＞ getSortedClusteredPowerConsumptions{// 获取排序后的聚类处理算力消耗量的实现return new ArrayList＜＞;}private static Map＜Double, Double＞ getOccurrenceProbabilities {return new HashMap＜＞;}private static List＜Double＞ filterByOccurrenceProbability {List＜Double＞ standardPowerConsumptions = new ArrayList＜＞;for ) {if  ＞= threshold) {standardPowerConsumptions.add);}}return standardPowerConsumptions;}private static PowerConsumptionRange getPowerConsumptionRange {// 获取现场数据处理算力消耗量的范围的实现return new PowerConsumptionRange;}public static class PowerConsumptionRange {private List＜Double＞ standardPowerConsumptions;private Map＜Double, Double＞ occurrenceProbabilities;public PowerConsumptionRange {this.standardPowerConsumptions = standardPowerConsumptions;this.occurrenceProbabilities = occurrenceProbabilities;}}}请参阅图7所示，由于施工项目的各种工序在时间上具有周期性，因此在周期范围内对算力资源进行分配能够有效降低算力资源分配的难度，这就需要在执行步骤S6的过程中首先执行步骤S61将算力平台虚拟化划分为若干个相互独立的算力模块。对于每个现场数据的属性，接下来可以执行步骤S62根据现场数据处理算力消耗量的范围得到每个属性的现场数据的算力消耗量期望值。接下来可以执行步骤S63根据每个虚拟存储空间接收的现场数据的历史记录得到每个属性的现场数据的生成量关于时间的关系。接下来可以执行步骤S64根据每个属性的现场数据的生成量关于时间的关系得到每个属性的现场数据的生成量周期。接下来可以执行步骤S65根据每个属性的现场数据的生成量关于时间的关系、每个属性的现场数据的算力消耗量期望值以及每个属性的现场数据的生成量周期得到在每个属性的现场数据的生成量周期内现场数据的算力消耗量期望值关于时间的关系。接下来可以执行步骤S66对每个属性的现场数据的重要程度进行设置，得到每个属性的现场数据的优先级。最后可以执行步骤S67按照在每个属性的现场数据的生成量周期内现场数据的算力消耗量期望值关于时间的关系以及每个属性的现场数据的优先级调整每个现场数据的属性对应算力模块的算力资源，从而得到算力资源周期分配计划。也即是通过统计不同属性的现场数据的时间周期，从而对全部现场数据的算力资源分布进行调整。上述步骤可以根据以下代码实施：import java.util.*;public class ResourceAllocation {public static void main {List＜PowerModule＞ powerModules = createPowerModules;List＜Attribute＞ attributes = getAttributes;for  {double expectedPowerConsumption = getExpectedPowerConsumption;Map＜Long, Integer＞ generatedDataVolumeOverTime = getGeneratedDataVolumeOverTime;long generationCycle = getGenerationCycle;Map＜Long, Double＞ expectedPowerConsumptionOverTime = getExpectedPowerConsumptionOverTime;int priority = getPriority;allocatePowerResources;}}private static List＜PowerModule＞ createPowerModules {// 创建若干个相互独立的算力模块的实现return new ArrayList＜＞;}private static List＜Attribute＞ getAttributes {return new ArrayList＜＞;}private static double getExpectedPowerConsumption {return 0.0;}private static Map＜Long, Integer＞ getGeneratedDataVolumeOverTime {// 获取每个属性的现场数据的生成量关于时间的关系的实现return new HashMap＜＞;}private static long getGenerationCycle {return 0L;}private static Map＜Long, Double＞ getExpectedPowerConsumptionOverTime {return new HashMap＜＞;}private static int getPriority {// 获取每个属性的现场数据的优先级的实现return 0;}private static void allocatePowerResources {}public static请参阅图8所示，为了简化计算量，同时由于现场数据的数量众多且密集，因此可以用单一的期望值计算代替分布范围内每个现场数据的常规标准处理算力消耗量，具体而言就是对于每个现场数据的属性，首先可以执行步骤S621根据现场数据处理算力消耗量的范围得到现场数据的常规标准处理算力消耗量的分布范围以及每个现场数据的常规标准处理算力消耗量的发生概率。之后可以执行步骤S622对于每个现场数据的属性，根据现场数据的常规标准处理算力消耗量的分布范围以及每个现场数据的常规标准处理算力消耗量的发生概率得到每个属性的现场数据的算力消耗量期望值。上述步骤可以根据以下代码实施：import java.util.*;public class ExpectedPowerConsumption {public static void main {Map＜Attribute, Map＜Double, Double＞＞ powerConsumptionDistribution = getPowerConsumptionDistribution;Map＜Attribute, Double＞ expectedPowerConsumption = calculateExpectedPowerConsumption;for ) {System.out.println + ",Expected power consumption: " + entry.getValue);}}private static Map＜Attribute, Map＜Double, Double＞＞getPowerConsumptionDistribution {return new HashMap＜＞;}private static Map＜Attribute, Double＞ calculateExpectedPowerConsumption {Map＜Attribute, Double＞ expectedPowerConsumption = new HashMap＜＞;for ) {Attribute attribute = entry.getKey;Map＜Double, Double＞ distribution = entry.getValue;double expectedValue = 0.0;for ) {double powerConsumption = probabilityEntry.getKey;double probability = probabilityEntry.getValue;expectedValue += powerConsumption * probability;}expectedPowerConsumption.put;}return expectedPowerConsumption;}public static class Attribute {}}请参阅图9所示，对了对全部属性的现场数据进行完整周期内的算力资源分配，上述步骤S67在实施的过程中首先可以执行步骤S671获取每个属性的现场数据的生成量周期的最大公约数作为算力资源分配周期。接下来可以执行步骤S672在每个算力资源分配周期内，根据每个属性的现场数据的生成量周期的时间长度以及在每个属性的现场数据的生成量周期内现场数据的算力消耗量期望值关于时间的关系得到每个算力资源分配周期内不同属性的现场数据的算力消耗量期望值关于时间的关系。最后可以执行步骤S673根据每个算力资源分配周期内不同属性的现场数据的算力消耗量期望值关于时间的关系以及每个属性的现场数据的优先级，优先分配给优先级高的现场数据，得到算力资源周期分配计划。上述步骤可以根据以下代码实施：import java.util.*;public class PowerResourceAllocation {public static void main {List＜Integer＞ generationCycles = getGenerationCycles;int allocationCycle = gcdList;Map＜Attribute, Map＜Integer, Double＞＞ powerConsumptionByCycle= getPowerConsumptionByCycle;Map＜Attribute, Integer＞ attributePriority = getAttributePriority;List＜Map＜Attribute, Double＞＞ allocationPlan = allocatePowerResources;for ; i++) {System.out.println + ": " +allocationPlan.get);}}private static List＜Integer＞ getGenerationCycles {// 获取每个属性的现场数据的生成量周期的实现return new ArrayList＜＞;}private static int gcd {if  {return a;}return gcd;}private static int gcdList {int result = numbers.get;for ; i++) {result = gcd);}return result;}private static Map＜Attribute, Map＜Integer, Double＞＞ getPowerConsumptionByCycle {return new HashMap＜＞;}private static Map＜Attribute, Integer＞ getAttributePriority {return new HashMap＜＞;}private static List＜Map＜Attribute, Double＞＞ allocatePowerResources {List＜Map＜Attribute, Double＞＞ allocationPlan = new ArrayList＜＞;for  {Map＜Attribute, Double＞ allocation = new HashMap＜＞;List＜Attribute＞ sortedAttributes = sortAttributesByPriority;for  {double powerConsumption = powerConsumptionByCycle.get.get;allocation.put;}allocationPlan.add;}return allocationPlan;}private static List＜Attribute＞ sortAttributesByPriority {List＜Attribute＞ sortedAttributes = new ArrayList＜＞);sortedAttributes.sort -＞ attributePriority.get -attributePriority.get);return sortedAttributes;}public static class Attribute {}}综上所示，本发明通过分析各属性现场数据的处理算力消耗，确定各属性处理算力消耗的范围。针对BIM数据模型，即建筑信息模型中的虚拟存储空间接收的现场数据历史记录，计算一个周期内不同属性现场数据的期望算力消耗。最后，根据各属性现场数据的期望算力消耗为其分配算力资源，可在此过程中设置不同属性现场数据的优先级，从而有效避免因算力资源耗尽引发的施工现场监控失效问题。本发明所示实施例的上述描述并非意在详尽列举或将本发明限制到本文所公开的精确形式。尽管在本文仅为说明的目的而描述了本发明的具体实施例和本发明的实例，但是正如本领域技术人员将认识和理解的，各种等效修改是可以在本发明的精神和范围内的。如所指出的，可以按照本发明实施例的上述描述来对本发明进行这些修改，并且这些修改将在本发明的精神和范围内。本文已经在总体上将系统和方法描述为有助于理解本发明的细节。此外，已经给出了各种具体细节以提供本发明实施例的总体理解。然而，相关领域的技术人员将会认识到，本发明的实施例可以在没有一个或多个具体细节的情况下进行实践，或者利用其它装置、系统、配件、方法、组件、材料、部分等进行实践。在其它情况下，并未特别示出或详细描述公知结构、材料和/或操作以避免对本发明实施例的各方面造成混淆。因而，尽管本发明在本文已参照其具体实施例进行描述，但是修改自由、各种改变和替换意在上述公开内，并且应当理解，在某些情况下，在未背离所提出发明的范围和精神的前提下，在没有对应使用其他特征的情况下将采用本发明的一些特征。因此，可以进行许多修改，以使特定环境或材料适应本发明的实质范围和精神。本发明并非意在限制到在下面权利要求书中使用的特定术语和/或作为设想用以执行本发明的最佳方式公开的具体实施例，但是本发明将包括落入所附权利要求书范围内的任何和所有实施例及等同物。因而，本发明的范围将只由所附的权利要求书进行确定。

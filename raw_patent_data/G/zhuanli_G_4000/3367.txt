标题title
应用于动态数据的数据处理方法、装置和电子设备
摘要abst
本公开的实施例公开了应用于动态数据的数据处理方法、装置和电子设备。该方法的一具体实施方式包括：获取数据类型为半结构化类型的待写入数据；对待写入数据进行数据结构转换，以生成树状文档数据，其中，树状文档数据包括：至少一个叶子节点；根据树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；对聚合后数据树中的数据进行数据类型冲突解决；响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；根据动态数据块的元信息，发起元信息变更请求；响应于变更成功，将动态数据块写入数据引擎。该实施方式实现了针对半结构类型的数据的高效存储。
权利要求书clms
1.一种应用于动态数据的数据处理方法，包括：获取数据类型为半结构化类型的待写入数据；对所述待写入数据进行数据结构转换，以生成树状文档数据，其中，所述树状文档数据包括：至少一个叶子节点；根据所述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；对所述聚合后数据树中的数据进行数据类型冲突解决；响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；根据所述动态数据块的元信息，发起元信息变更请求；响应于变更成功，将所述动态数据块写入数据引擎。2.根据权利要求1所述的方法，其中，所述树状文档数据包括：至少一个子文档数据；所述至少一个子文档数据中的每个子文档数据包括：叶子节点组；以及所述根据所述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树，包括：生成初始聚合后数据树，其中，所述初始聚合后数据树包括：根节点；对于所述至少一个子文档数据中的每个子文档数据包括的叶子节点组中的每个叶子节点，执行以下处理步骤：响应于确定所述初始聚合后数据树未包含所述叶子节点、且所述叶子节点未拥有父叶子节点，确定所述叶子节点对应数据的数据类型，以及根据所述叶子节点对应的数据类型，生成链接于所述根节点的子节点；响应于确定所述初始聚合后数据树包含所述叶子节点，确定所述叶子节点对应数据的数据类型，以及将所述叶子节点对应的数据类型，添加至所述初始聚合后数据树中与所述叶子节点对应的子节点；响应于确定所述初始聚合后数据树未包含所述叶子节点、所述叶子节点拥有父叶子节点、且所述初始聚合后数据树包含所述叶子节点对应的父叶子节点，确定所述叶子节点对应数据的数据类型，以及根据所述叶子节点对应的数据类型，生成链接于所述叶子节点对应的父叶子节点的子节点。3.根据权利要求2所述的方法，其中，所述对所述聚合后数据树中的数据进行数据类型冲突解决，包括：对于所述聚合后数据树中的每个子节点对应的数据类型组，执行以下数据类型冲突解决步骤：响应于确定所述子节点对应的数据类型组中的各个数据类型一致，将所述子节点对应的数据类型组中的数据类型，确定为所述子节点对应的冲突解决后的数据类型；响应于确定所述子节点对应的数据类型组中的各个数据类型不一致，通过预先构建的冲突解决表，确定所述子节点对应的冲突解决后的数据类型。4.根据权利要求3所述的方法，其中，在所述响应于确定所述子节点对应的数据类型组中的各个数据类型不一致，通过预先构建的冲突解决表，确定所述子节点对应的冲突解决后的数据类型之后，所述方法还包括：响应于通过所述冲突解决表，确定所述子节点对应的冲突解决后的数据类型失败，确定冲突解决类型；响应于确定所述冲突解决类型为第一类型，将预设数据类型，确定为所述子节点对应的冲突解决后的数据类型。5.根据权利要求4所述的方法，其中，在所述对所述聚合后数据树中的数据进行数据类型冲突解决之后，所述方法还包括：响应于确定冲突解决类型为第二类型、且数据类型冲突解决失败，生成数据类型冲突解决失败的报错信息。6.根据权利要求5所述的方法，其中，所述冲突解决表包括：时间数据类型冲突解决表和非时间数据类型冲突解决表；以及所述响应于确定所述子节点对应的数据类型组中的各个数据类型不一致，通过预先构建的冲突解决表，确定所述子节点对应的冲突解决后的数据类型，包括：响应于确定子节点对应的数据类型组中的数据类型为时间数据类型，通过所述时间数据类型冲突解决表，确定所述子节点对应的冲突解决后的数据类型；响应于确定子节点对应的数据类型组中的数据类型为非时间数据类型，通过所述非时间数据类型冲突解决表，确定所述子节点对应的冲突解决后的数据类型。7.根据权利要求6所述的方法，其中，所述根据所述动态数据块的元信息，发起元信息变更请求，包括：根据所述元信息包括的数据块地址和数据块类型，向元数据处理服务器发起所述元信息变更请求。8.一种应用于动态数据的数据处理装置，包括：获取单元，被配置成获取数据类型为半结构化类型的待写入数据；转换单元，被配置成对所述待写入数据进行数据结构转换，以生成树状文档数据，其中，所述树状文档数据包括：至少一个叶子节点；数据聚合单元，被配置成根据所述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；冲突解决单元，被配置成对所述聚合后数据树中的数据进行数据类型冲突解决；生成单元，被配置成响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；发起单元，被配置成根据所述动态数据块的元信息，发起元信息变更请求；写入单元，被配置成响应于变更成功，将所述动态数据块写入数据引擎。9.一种电子设备，包括：一个或多个处理器；存储装置，其上存储有一个或多个程序；当所述一个或多个程序被所述一个或多个处理器执行，使得所述一个或多个处理器实现如权利要求1至7中任一所述的方法。10.一种计算机可读介质，其上存储有计算机程序，其中，所述计算机程序被处理器执行时实现如权利要求1至7中任一所述的方法。
说明书desc
技术领域本公开的实施例涉及计算机技术领域，具体涉及应用于动态数据的数据处理方法、装置和电子设备。背景技术动态数据存储是指对具有复杂数据结构的数据进行存储的一项技术。实际情况中，由于半结构化类型的数据的数据结构的灵活性较高，使得在对其进行存储时，数据存储难度较大。目前，在对半结构化类型的数据进行存储时，通常采用的方式为：针对不同数据结构的半结构化类型的数据，对数据表的命名空间进行更新。然而，发明人发现，当采用上述方式时，经常会存在如下技术问题：第一，当对命名空间进行频繁的变更时，往往会导致阻塞的情况发生；第二，针对半结构化类型的数据，当存在频繁的增减列需求时，往往需要根据数据特点，设置复杂的数据处理规则，使得数据处理性能低下，且设置的数据处理规则复用性较低；第三，针对半结构化类型的数据，往往包含较多不同数据类型的数据，采用相同的数据类型对数据进行处理，可能会导致数据精度丢失，以及增加后续的数据使用难度。该背景技术部分中所公开的以上信息仅用于增强对本发明构思的背景的理解，并因此，其可包含并不形成本国的本领域普通技术人员已知的现有技术的信息。发明内容本公开的内容部分用于以简要的形式介绍构思，这些构思将在后面的具体实施方式部分被详细描述。本公开的内容部分并不旨在标识要求保护的技术方案的关键特征或必要特征，也不旨在用于限制所要求的保护的技术方案的范围。本公开的一些实施例提出了应用于动态数据的数据处理方法、装置和电子设备，来解决以上背景技术部分提到的技术问题中的一项或多项。第一方面，本公开的一些实施例提供了一种应用于动态数据的数据处理方法，该方法包括：获取数据类型为半结构化类型的待写入数据；对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点；根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；对上述聚合后数据树中的数据进行数据类型冲突解决；响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；根据上述动态数据块的元信息，发起元信息变更请求；响应于变更成功，将上述动态数据块写入数据引擎。第二方面，本公开的一些实施例提供了一种应用于动态数据的数据处理装置，装置包括：获取单元，被配置成获取数据类型为半结构化类型的待写入数据；转换单元，被配置成对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点；数据聚合单元，被配置成根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；冲突解决单元，被配置成对上述聚合后数据树中的数据进行数据类型冲突解决；生成单元，被配置成响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；发起单元，被配置成根据上述动态数据块的元信息，发起元信息变更请求；写入单元，被配置成响应于变更成功，将上述动态数据块写入数据引擎。第三方面，本公开的一些实施例提供了一种电子设备，包括：一个或多个处理器；存储装置，其上存储有一个或多个程序，当一个或多个程序被一个或多个处理器执行，使得一个或多个处理器实现上述第一方面任一实现方式所描述的方法。第四方面，本公开的一些实施例提供了一种计算机可读介质，其上存储有计算机程序，其中，程序被处理器执行时实现上述第一方面任一实现方式所描述的方法。本公开的上述各个实施例具有如下有益效果：通过本公开的一些实施例的应用于动态数据的数据处理方法，降低了阻塞的情况发生，以及提高了数据的处理性能。具体来说，造成阻塞的情况发生，以及数据的处理性能低下的原因在于：第一，当对命名空间进行频繁的变更时，往往会导致阻塞的情况发生；第二，针对半结构化类型的数据，当存在频繁的增减列需求时，往往需要根据数据特点，设置复杂的数据处理规则，使得数据处理性能低下，且设置的数据处理规则复用性较低。基于此，本公开的一些实施例的应用于动态数据的数据处理方法，首先，获取数据类型为半结构化类型的待写入数据。接着，对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点。由于半结构化类型的数据的数据结构及其灵活，即不同的半结构化类型的数据往往具有不同的数据结构，因此，需要对待写入数据进行整体的数据结构转换。进一步，根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树。实际情况中，待写入数据中往往包含较多不同数据类型的数据，因此，需要根据数据类型进行数据聚合。除此之外，对上述聚合后数据树中的数据进行数据类型冲突解决。实际情况中，不同的数据类型的数据在存储时，可能存在存储失败，数据精度丢失等各种影响数据正常存储的问题，因此，需要进行数据类型冲突解决。接着，响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块。除此之外，根据上述动态数据块的元信息，发起元信息变更请求。最后，响应于变更成功，将上述动态数据块写入数据引擎。通过此种方式，实现了针对半结构类型的数据的高效存储，避免了频繁变更命名空间所导致的阻塞的情况发生。同时，无需设置复杂的数据处理规则，降低了维护成本，提高了数据的处理性能。附图说明结合附图并参考以下具体实施方式，本公开各实施例的上述和其他特征、优点及方面将变得更加明显。贯穿附图中，相同或相似的附图标记表示相同或相似的元素。应当理解附图是示意性的，元件和元素不一定按照比例绘制。图1是根据本公开的应用于动态数据的数据处理方法的一些实施例的流程图；图2是树状文档数据对应的树形结构的示意图；图3是聚合后数据树的树结构的示意图；图4是时间数据类型冲突解决表的示意图；图5是非时间数据类型冲突解决表的示意图；图6是数据类型冲突解决后的数据树的示意图；图7是根据本公开的应用于动态数据的数据处理装置的一些实施例的结构示意图；图8是适于用来实现本公开的一些实施例的电子设备的结构示意图。具体实施方式下面将参照附图更详细地描述本公开的实施例。虽然附图中显示了本公开的某些实施例，然而应当理解的是，本公开可以通过各种形式来实现，而且不应该被解释为限于这里阐述的实施例。相反，提供这些实施例是为了更加透彻和完整地理解本公开。应当理解的是，本公开的附图及实施例仅用于示例性作用，并非用于限制本公开的保护范围。另外还需要说明的是，为了便于描述，附图中仅示出了与有关发明相关的部分。在不冲突的情况下，本公开中的实施例及实施例中的特征可以相互组合。需要注意，本公开中提及的“第一”、“第二”等概念仅用于对不同的装置、模块或单元进行区分，并非用于限定这些装置、模块或单元所执行的功能的顺序或者相互依存关系。需要注意，本公开中提及的“一个”、“多个”的修饰是示意性而非限制性的，本领域技术人员应当理解，除非在上下文另有明确指出，否则应该理解为“一个或多个”。本公开实施方式中的多个装置之间所交互的消息或者信息的名称仅用于说明性的目的，而并不是用于对这些消息或信息的范围进行限制。下面将参考附图并结合实施例来详细说明本公开。参考图1，示出了根据本公开的应用于动态数据的数据处理方法的一些实施例的流程100。该应用于动态数据的数据处理方法，包括以下步骤：步骤101，获取数据类型为半结构化类型的待写入数据。在一些实施例中，应用于动态数据的数据处理方法的执行主体可以通过有线连接，或无线连接的方式获取数据类型为半结构化类型的待写入数据。其中，上述待写入数据是待写入数据引擎的数据。半结构化类型可以是以键值对的形式存储数据的类型。实践中，上述半结构化类型可以是JSON类型。作为示例，上述待写入数据可以是：{ "Name":"Allen", "Age":32, "Salary": , "Birthday":"2000-03-22", "FamilyRelationship":{"Mother":"Max","Father":"Jason","Brother":"Ken"}}。需要指出的是，上述无线连接方式可以包括但不限于3G/4G/5G连接、WiFi连接、蓝牙连接、WiMAX连接、Zigbee连接、UWB连接、以及其他现在已知或将来开发的无线连接方式。需要说明的是，上述计算设备可以是硬件，也可以是软件。当计算设备为硬件时，可以实现成多个服务器或终端设备组成的分布式集群，也可以实现成单个服务器或单个终端设备。当计算设备体现为软件时，可以安装在上述所列举的硬件设备中。其可以实现成例如用来提供分布式服务的多个软件或软件模块，也可以实现成单个软件或软件模块。在此不做具体限定。应该理解,计算设备的数目根据实现需要，可以具有任意数目的计算设备。步骤102，对待写入数据进行数据结构转换，以生成树状文档数据。在一些实施例中，上述执行主体可以对待写入数据进行数据结构转换，以生成树状文档数据。其中，上述树状文档数据可以是具有树形结构的文档数据。树状文档数据包括：至少一个叶子节点。其中，至少一个叶子节点中的叶子节点用于存储待写入数据中的键值对中的值。作为示例，上述树状文档数据对应的树形结构的示意图可以如图2所示，其中，上述树状文档数据对应的树形结构的根节点“RootNode”可以包括5个子节点，分别为“Name”节点、“Age”节点、“Salary”节点、“Birthday”节点和“FamilyRelationship”节点。“Name”节点包括1个子节点，用于存储键为“Name”的键值对的值“Allen”。“Age”节点包括1个子节点，用于存储键为“Age”的键值对的值“32”。“Salary”节点包括4个子节点，分别用于存储键为“Salary”的键值对的4个值“8000.0”、“9000.0”、“12000.2”和“7812.3”。“Birthday”节点包括1个子节点，用于存储键为“Birthday”的键值对的值“2000-03-22”。“FamilyRelationship”节点包括3个子节点，分别为“Mother”节点、“Father”节点和“Brother”节点。“Mother”节点包括1个子节点，用于存储键为“Mother”的键值对的值“Max”。“Father”节点包括1个子节点，用于存储键为“Father”的键值对的值“Jason”。“Brother”节点包括1个子节点，用于存储键为“Brother”的键值对的值“Ken”。实践中，树状文档数据可以存储树状文档数据对应的树形结构中的全部键值对。此外，待写入数据中可以包括多个JSON数据块。因此，上述执行主体可以对每个JSON数据块，生成对应的树状结构，即树状文档数据可以对应多个树状结构。例如，首先，上述执行主体可以先识别出上述待写入数据中包括的JSON数据块。然后，对于每个JSON数据块，第一步：生成根节点。第二步，采用递归的方式识别JSON数据块中的键值对，并根据识别得到的键值对的位置关系，生成与根节点连接的子节点，以得到JSON数据块对应的树状结构。步骤103，根据树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树。在一些实施例中，上述执行主体可以根据树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树。实践中，聚合后数据树是将上述树状文档数据中具有相同键的键值对包括的值对应的数据类型聚合得到的树结构。作为示例，上述执行主体可以通过先序遍历的方式，遍历上述树状文档数据中的每个叶子节点，以生成上述聚合后数据树。作为示例，上述树状文档数据可以是：{"a":1,"b":1.11,"c":"xxx"}{"a":1022222,"b":100,"c":22}{"x":{"x1":1,"x2":"2022-01-02"},"y":}{"x":{"x1":"222","x2":"2022-01-02 12:01:01"},"y":}。其中，键值对＜"a":1＞中的值“1”的数据类型为INT8。键值对＜"b":1.11＞中的值“1.11”的数据类型为FLOAT。键值对＜"c":"xxx"＞中的值“xxx”的数据类型为STRING。键值对＜"a":1022222＞中的值“1022222”的数据类型为INT32。键值对＜"b":100＞中的值“100”的数据类型为INT8。键值对＜"c":22＞中的值“22”的数据类型为INT8。键值对＜"x1":1＞中的值“1”的数据类型为INT8。键值对＜"x2":"2022-01-02"＞中的值“"2022-01-02"”的数据类型为DATE。键值对＜"y":＞中的值“”的数据类型为ARRAY。键值对＜"x1":"222"＞中的值“222”的数据类型为STRING。键值对＜"x2":"2022-01-02 12:01:01"＞中的值“2022-01-02 12:01:01”的数据类型为DATETIME。键值对＜"y":＞中的值“”对应的数据类型为ARRAY。则对应的聚合后数据树的树结构的示意图可以如图3所示，其中，“a”节点对应的数据类型为INT8和INT3。“b”节点对应的数据类型为FLOAT和INT8。“c”节点对应的数据类型为STRING和INT8。“x1”节点对应的数据类型为STRING和INT8。“x2”节点对应的数据类型为DATE和DATETIME。“y”节点对应的数据类型为ARRAY和ARRAY。可选地，树状文档数据包括：至少一个子文档数据。其中，至少一个子文档数据中的子文档数据对应一个JSON数据块。上述至少一个子文档数据中的每个子文档数据包括：叶子节点组。叶子节点组为子文档数据对应的树状结构中的叶子节点。在一些实施例的一些可选的实现方式中，上述执行主体根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树，可以包括以下步骤：第一步，生成初始聚合后数据树。其中，上述初始聚合后数据树包括：根节点。第二步，对于上述至少一个子文档数据中的每个子文档数据包括的叶子节点组中的每个叶子节点，执行以下处理步骤：第一子步骤，响应于确定上述初始聚合后数据树未包含上述叶子节点、且上述叶子节点未拥有父叶子节点，确定上述叶子节点对应数据的数据类型，以及根据上述叶子节点对应的数据类型，生成链接于上述根节点的子节点。第二子步骤，响应于确定上述初始聚合后数据树包含上述叶子节点，确定上述叶子节点对应数据的数据类型，以及将上述叶子节点对应的数据类型，添加至上述初始聚合后数据树中与上述叶子节点对应的子节点。第三子步骤，响应于确定上述初始聚合后数据树未包含上述叶子节点、上述叶子节点拥有父叶子节点、且上述初始聚合后数据树包含上述叶子节点对应的父叶子节点，确定上述叶子节点对应数据的数据类型，以及根据上述叶子节点对应的数据类型，生成链接于上述叶子节点对应的父叶子节点的子节点。步骤104，对聚合后数据树中的数据进行数据类型冲突解决。在一些实施例中，上述执行主体可以对聚合后数据树中的数据进行数据类型冲突解决。例如，如图3所示的聚合后数据树的树结构的示意图中的“a”节点对应的数据类型为INT8和INT3，其中，INT8和INT3的数据类型不同，但均未整型数据类型，因此可以用INT32解决数据类型冲突。又如，如图3所示的聚合后数据树的树结构的示意图中的“x1”节点对应的数据类型为STRING和INT8，其中，STRING和INT8的数据类型不同，因此可以用STRING解决数据类型冲突。在一些实施例的一些可选的实现方式中，上述执行主体对上述聚合后数据树中的数据进行数据类型冲突解决，可以包括以下步骤：对于上述聚合后数据树中的每个子节点对应的数据类型组，执行以下数据类型冲突解决步骤：第一步，响应于确定上述子节点对应的数据类型组中的各个数据类型一致，将上述子节点对应的数据类型组中的数据类型，确定为上述子节点对应的冲突解决后的数据类型。例如，如图3所示的聚合后数据树的树结构的示意图中的“y”节点对应的数据类型为ARRAY和ARRAY，因此可以将ARRAY作为“y”节点对应的冲突解决后的数据类型。第二步，响应于确定上述子节点对应的数据类型组中的各个数据类型不一致，通过预先构建的冲突解决表，确定上述子节点对应的冲突解决后的数据类型。其中，上述冲突解决表是用于解决数据类型不一致的数据表。可选地，冲突解决表包括：时间数据类型冲突解决表和非时间数据类型冲突解决表。时间数据类型冲突解决表是用于解决时间类型的数据类型的冲突的数据表。非时间数据类型冲突解决表是用于解决非时间类型的数据类型的冲突的数据表。可选地，响应于确定上述子节点对应的数据类型组中的各个数据类型不一致，通过预先构建的冲突解决表，确定上述子节点对应的冲突解决后的数据类型，包括：第一子步骤，响应于确定子节点对应的数据类型组中的数据类型为时间数据类型，通过上述时间数据类型冲突解决表，确定上述子节点对应的冲突解决后的数据类型。作为示例，如图3所示的聚合后数据树的树结构的示意图中的“x2”节点对应的数据类型为DATE和DATETIME，其中，DATE和DATETIME均为时间数据类型，因此，可以通过时间数据类型冲突解决表进行数据类型冲突解决，如图4所示的时间数据类型冲突解决表的示意图，可以将DATETIME作为冲突解决后的数据类型。第二子步骤，响应于确定子节点对应的数据类型组中的数据类型为非时间数据类型，通过上述非时间数据类型冲突解决表，确定上述子节点对应的冲突解决后的数据类型。作为示例，如图3所示的聚合后数据树的树结构的示意图中的“a”节点对应的数据类型为INT8和INT32，其中，INT8和INT32均为非时间数据类型，因此，可以通过非时间数据类型冲突解决表进行数据类型冲突解决，如图5所示的非时间数据类型冲突解决表的示意图，可以将INT32作为冲突解决后的数据类型。第三子步骤，响应于通过上述冲突解决表，确定上述子节点对应的冲突解决后的数据类型失败，确定冲突解决类型。其中，上述冲突解决类型表征预设的针对冲突解决后的数据类型确定失败的处理策略类型。实践中，冲突解决类型包括：第一类型和第二类型。其中，第一类型表征对数据类型进行强制转换。第二类型表征不对数据类型进行强制转换，并进行报错。第四子步骤，响应于确定上述冲突解决类型为第一类型，将预设数据类型，确定为上述子节点对应的冲突解决后的数据类型。其中，预设数据类型可以是能够兼容所有数据类型的数据类型。实践中，预设数据类型可以是STRING。第五子步骤，响应于确定冲突解决类型为第二类型、且数据类型冲突解决失败，生成数据类型冲突解决失败的报错信息。上述第一步至第二步中的内容，作为本公开的一个发明点，解决了背景技术提及的技术问题三，即“针对半结构化类型的数据，往往包含较多不同数据类型的数据，采用相同的数据类型对数据进行处理，可能会导致数据精度丢失，以及增加后续的数据使用难度。实际情况中，针对半结构化类型的数据，常用的数据处理方式为：第一，针对数据特点设置对应的DDL操作。第二，通过通用数据类型进行数据类型转换，以实现数据的有效存储。但存在如下问题：半结构化类型的数据的数据结构较为灵活，针对数据特点设置对应的DDL操作，需要设置复杂的DDL操作，性能较低，且维护成本极高。通过通用数据类型进行数据类型转换，随能够保证数据的有效存储，但是会极大的占用存储空间，如数据类型为INT8，占用字节为1字节。而INT32占用4字节，可见随着数据存储量的增加会极大的浪费存储空间。基于此，本公开根据子节点对应的数据类型组，通过时间数据类型冲突解决表和非时间数据类型冲突解决表，动态的设置对应的冲突解决后的数据类型。大大节约了存储空间，同时，在冲突解决后的数据类型的确定过程中，优先选择数据存储量较大的数据类型，以此避免了数据精度丢失的问题。步骤105，响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块。在一些实施例中，上述执行主体可以响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块。其中，上述动态数据块是变长的存储数据的数据块。作为示例，树状文档数据可以是：{"a":1,"b":1.11,"c":"xxx"}{"a":1022222,"b":100,"c":22}{"x":{"x1":1,"x2":"2022-01-02"},"y":}{"x":{"x1":"222","x2":"2022-01-02 12:01:01"},"y":}，对应的数据类型冲突解决后的数据树可以是如图6所示，其中，“a”节点对应数据的冲突解决后的数据类型为INT32。“b”节点对应数据的冲突解决后的数据类型为FLOAT。“c”节点对应数据的冲突解决后的数据类型为STRING。“x1”节点对应数据的冲突解决后的数据类型为STRING。“x2”节点对应数据的冲突解决后的数据类型为DATETIME。“y”节点对应数据的冲突解决后的数据类型为STRING。则对应的动态数据块为：RootNode.a11022222RootNode.b1.11100RootNode.cxxx22RootNode.x.x11222RootNode.x.x22022-01-022022-01-02 12:01:01RootNode.y步骤106，根据动态数据块的元信息，发起元信息变更请求。在一些实施例中，上述执行主体可以根据动态数据块的元信息，发起元信息变更请求。其中，元信息是上述动态数据块的数据块结构的信息。实践中，当动态数据块发生变化时，对应的元信息也会发生变化。因此，需要发起元信息变更请求，对元信息进行实时更新。可选地，元信息可以包括：数据块地址和数据块类型。其中，上述数据块地址表征动态数据块的存储地址。数据块类型表征上述动态数据块的数据块类型。在一些实施例的一些可选的实现方式中，上述执行主体根据上述动态数据块的元信息，发起元信息变更请求，可以包括：根据上述元信息包括的数据块地址和数据块类型，向元数据处理服务器发起上述元信息变更请求。其中，元数据处理服务器可以是用于提供元数据服务的服务器。步骤107，响应于变更成功，将动态数据块写入数据引擎。在一些实施例中，响应于变更成功，将动态数据块写入数据引擎。实践中，由于数据引擎是按照列式进行数据存储的，与动态数据块中的数据排布方式一致，即可以直接将动态数据块中的数据追加至数据引擎中，通过此种方式实现了提高了非结构化类型的数据的存储效率，以及数据存储的鲁棒性。本公开的上述各个实施例具有如下有益效果：通过本公开的一些实施例的应用于动态数据的数据处理方法，降低了阻塞的情况发生，以及提高了数据的处理性能。具体来说，造成阻塞的情况发生，以及数据的处理性能低下的原因在于：第一，当对命名空间进行频繁的变更时，往往会导致阻塞的情况发生；第二，针对半结构化类型的数据，当存在频繁的增减列需求时，往往需要根据数据特点，设置复杂的数据处理规则，使得数据处理性能低下，且设置的数据处理规则复用性较低。基于此，本公开的一些实施例的应用于动态数据的数据处理方法，首先，获取数据类型为半结构化类型的待写入数据。接着，对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点。由于半结构化类型的数据的数据结构及其灵活，即不同的半结构化类型的数据往往具有不同的数据结构，因此，需要对待写入数据进行整体的数据结构转换。进一步，根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树。实际情况中，待写入数据中往往包含较多不同数据类型的数据，因此，需要根据数据类型进行数据聚合。除此之外，对上述聚合后数据树中的数据进行数据类型冲突解决。实际情况中，不同的数据类型的数据在存储时，可能存在存储失败，数据精度丢失等各种影响数据正常存储的问题，因此，需要进行数据类型冲突解决。接着，响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块。除此之外，根据上述动态数据块的元信息，发起元信息变更请求。最后，响应于变更成功，将上述动态数据块写入数据引擎。通过此种方式，实现了针对半结构类型的数据的高效存储，避免了频繁变更命名空间所导致的阻塞的情况发生。同时，无需设置复杂的数据处理规则，降低了维护成本，提高了数据的处理性能。进一步参考图7，作为对上述各图所示方法的实现，本公开提供了一种应用于动态数据的数据处理装置的一些实施例，这些装置实施例与图1所示的那些方法实施例相对应，该应用于动态数据的数据处理装置具体可以应用于各种电子设备中。如图7所示，一些实施例的应用于动态数据的数据处理装置700包括：获取单元701、转换单元702、数据聚合单元703、冲突解决单元704、生成单元705、发起单元706和写入单元707。其中，获取单元701，被配置成获取数据类型为半结构化类型的待写入数据；转换单元702，被配置成对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点；数据聚合单元703，被配置成根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；冲突解决单元704，被配置成对上述聚合后数据树中的数据进行数据类型冲突解决；生成单元705，被配置成响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；发起单元706，被配置成根据上述动态数据块的元信息，发起元信息变更请求；写入单元707，被配置成响应于变更成功，将上述动态数据块写入数据引擎。可以理解的是，该应用于动态数据的数据处理装置700中记载的诸单元与参考图1描述的方法中的各个步骤相对应。由此，上文针对方法描述的操作、特征以及产生的有益效果同样适用于应用于动态数据的数据处理装置700及其中包含的单元，在此不再赘述。下面参考图8，其示出了适于用来实现本公开的一些实施例的电子设备800的结构示意图。图8示出的电子设备仅仅是一个示例，不应对本公开的实施例的功能和使用范围带来任何限制。如图8所示，电子设备800可以包括处理装置801，其可以根据存储在只读存储器802中的程序或者从存储装置808加载到随机访问存储器803中的程序而执行各种适当的动作和处理。在随机访问存储器803中，还存储有电子设备800操作所需的各种程序和数据。处理装置801、只读存储器802以及随机访问存储器803通过总线804彼此相连。输入/输出接口805也连接至总线804。通常，以下装置可以连接至I/O接口805：包括例如触摸屏、触摸板、键盘、鼠标、摄像头、麦克风、加速度计、陀螺仪等的输入装置806；包括例如液晶显示器、扬声器、振动器等的输出装置807；包括例如磁带、硬盘等的存储装置808；以及通信装置809。通信装置809可以允许电子设备800与其他设备进行无线或有线通信以交换数据。虽然图8示出了具有各种装置的电子设备800，但是应理解的是，并不要求实施或具备所有示出的装置。可以替代地实施或具备更多或更少的装置。图8中示出的每个方框可以代表一个装置，也可以根据需要代表多个装置。特别地，根据本公开的一些实施例，上文参考流程图描述的过程可以被实现为计算机软件程序。例如，本公开的一些实施例包括一种计算机程序产品，其包括承载在计算机可读介质上的计算机程序，该计算机程序包含用于执行流程图所示的方法的程序代码。在这样的一些实施例中，该计算机程序可以通过通信装置809从网络上被下载和安装，或者从存储装置808被安装，或者从只读存储器802被安装。在该计算机程序被处理装置801执行时，执行本公开的一些实施例的方法中限定的上述功能。需要说明的是，本公开的一些实施例中记载的计算机可读介质可以是计算机可读信号介质或者计算机可读存储介质或者是上述两者的任意组合。计算机可读存储介质例如可以是——但不限于——电、磁、光、电磁、红外线、或半导体的系统、装置或器件，或者任意以上的组合。计算机可读存储介质的更具体的例子可以包括但不限于：具有一个或多个导线的电连接、便携式计算机磁盘、硬盘、随机访问存储器、只读存储器、可擦式可编程只读存储器、光纤、便携式紧凑磁盘只读存储器、光存储器件、磁存储器件、或者上述的任意合适的组合。在本公开的一些实施例中，计算机可读存储介质可以是任何包含或存储程序的有形介质，该程序可以被指令执行系统、装置或者器件使用或者与其结合使用。而在本公开的一些实施例中，计算机可读信号介质可以包括在基带中或者作为载波一部分传播的数据信号，其中承载了计算机可读的程序代码。这种传播的数据信号可以采用多种形式，包括但不限于电磁信号、光信号或上述的任意合适的组合。计算机可读信号介质还可以是计算机可读存储介质以外的任何计算机可读介质，该计算机可读信号介质可以发送、传播或者传输用于由指令执行系统、装置或者器件使用或者与其结合使用的程序。计算机可读介质上包含的程序代码可以用任何适当的介质传输，包括但不限于：电线、光缆、RF等等，或者上述的任意合适的组合。在一些实施方式中，客户端、服务器可以利用诸如HTTP之类的任何当前已知或未来研发的网络协议进行通信，并且可以与任意形式或介质的数字数据通信互连。通信网络的示例包括局域网，广域网，网际网以及端对端网络，以及任何当前已知或未来研发的网络。上述计算机可读介质可以是上述电子设备中所包含的；也可以是单独存在，而未装配入该电子设备中。上述计算机可读介质承载有一个或者多个程序，当上述一个或者多个程序被该电子设备执行时，使得该电子设备：获取数据类型为半结构化类型的待写入数据；对上述待写入数据进行数据结构转换，以生成树状文档数据，其中，上述树状文档数据包括：至少一个叶子节点；根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树；对上述聚合后数据树中的数据进行数据类型冲突解决；响应于数据类型冲突解决成功，根据数据类型冲突解决后的数据树，生成动态数据块；根据上述动态数据块的元信息，发起元信息变更请求；响应于变更成功，将上述动态数据块写入数据引擎。可以以一种或多种程序设计语言或其组合来编写用于执行本公开的一些实施例的操作的计算机程序代码，上述程序设计语言包括面向对象的程序设计语言—诸如Java、Smalltalk、C++，还包括常规的过程式程序设计语言—诸如“C”语言或类似的程序设计语言。程序代码可以完全地在用户计算机上执行、部分地在用户计算机上执行、作为一个独立的软件包执行、部分在用户计算机上部分在远程计算机上执行、或者完全在远程计算机或服务器上执行。在涉及远程计算机的情形中，远程计算机可以通过任意种类的网络——包括局域网或广域网——连接到用户计算机，或者，可以连接到外部计算机。附图中的流程图和框图，图示了按照本公开各种实施例的系统、方法和计算机程序产品的可能实现的体系架构、功能和操作。在这点上，流程图或框图中的每个方框可以代表一个模块、程序段、或代码的一部分，该模块、程序段、或代码的一部分包含一个或多个用于实现规定的逻辑功能的可执行指令。也应当注意，在有些作为替换的实现中，方框中所标注的功能也可以以不同于附图中所标注的顺序发生。例如，两个接连地表示的方框实际上可以基本并行地执行，它们有时也可以按相反的顺序执行，这依所涉及的功能而定。也要注意的是，框图和/或流程图中的每个方框、以及框图和/或流程图中的方框的组合，可以用执行规定的功能或操作的专用的基于硬件的系统来实现，或者可以用专用硬件与计算机指令的组合来实现。描述于本公开的一些实施例中的单元可以通过软件的方式实现，也可以通过硬件的方式来实现。所描述的单元也可以设置在处理器中，例如，可以描述为：一种处理器包括获取单元、转换单元、数据聚合单元、冲突解决单元、生成单元、发起单元和写入单元。其中，这些单元的名称在某种情况下并不构成对该单元本身的限定，例如，数据聚合单元还可以被描述为“根据上述树状文档数据包括的至少一个叶子节点中的每个叶子节点的节点数据类型，进行数据聚合以生成聚合后数据树的单元”。本文中以上描述的功能可以至少部分地由一个或多个硬件逻辑部件来执行。例如，非限制性地，可以使用的示范类型的硬件逻辑部件包括：现场可编程门阵列、专用集成电路、专用标准产品、片上系统、复杂可编程逻辑设备等等。以上描述仅为本公开的一些较佳实施例以及对所运用技术原理的说明。本领域技术人员应当理解，本公开的实施例中所涉及的发明范围，并不限于上述技术特征的特定组合而成的技术方案，同时也应涵盖在不脱离上述发明构思的情况下，由上述技术特征或其等同特征进行任意组合而形成的其它技术方案。例如上述特征与本公开的实施例中公开的具有类似功能的技术特征进行互相替换而形成的技术方案。

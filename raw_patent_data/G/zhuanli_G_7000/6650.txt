标题title
一种内存数据库存储引擎管理方法
摘要abst
本发明特别涉及一种内存数据库存储引擎管理方法。该内存数据库存储引擎管理方法，基于RocksDB存储引擎的Memtable管理机制，在Memtable内部新建ART索引用以取代skiplist索引，采用ART索引加Hash索引的双索引机制查询key‑value，优化RocksDB存储引擎的读性能，从而实现RocksDB内存引擎模式，减少磁盘读写，提高查询速度。该内存数据库存储引擎管理方法，优化了现有分布式NewSQL数据库中基于RocksDB存储引擎的读性能问题，充分发挥了内存的高效读写性能，能够在内存中缓存更多的数据，解决了RocksDB的读放大问题。
权利要求书clms
1.一种内存数据库存储引擎管理方法，其特征在于：基于RocksDB存储引擎的Memtable管理机制，在Memtable内部新建ART索引用以取代skiplist索引，采用ART索引加Hash索引的双索引机制查询key-value，优化RocksDB存储引擎的读性能，从而实现RocksDB内存引擎模式，减少磁盘读写，提高查询速度。2.根据权利要求1所述的内存数据库存储引擎管理方法，其特征在于，具体实现过程如下：1)将插入Memtable的数据转为插入到ART算法管理的内存块中，并将ART算法的叶节点地址加入Hash索引中；2)修改Memtable刷盘的逻辑，使得Memtable永不转换imMemtable，通过内存块的形式进行刷盘，内存块通过双向链表进行管理；3)执行查询操作时，先从Hash表中查询，然后查询ART树，最后查询磁盘SST文件。3.根据权利要求2所述的内存数据库存储引擎管理方法，其特征在于：所述步骤1)中，写入的数据在内存中以内存块的形式存储，通过双向链表对key进行排序，双向链表的每个节点内存储当前key对应的多个版本数据形成的链表，双向链表的每个节点指向内存块存储的该key对应的key-value；所述ART索引用于快速定位双向链表的特定节点，所述Hash索引用于快速查询ART树的叶子节点的地址；写入数据时，首先通过Hash索引与ART索引计算待插入的叶子结点位置，然后根据ART的叶子节点添加双向链表，通过双向链表对业务key进行排序。4.根据权利要求3所述的内存数据库存储引擎管理方法，其特征在于：所述步骤1)中，当有新的key插入叶子节点时，使用ART算法快速定位到双向链表的插入节点进行插入，同时增加hash表的插入逻辑，对Hash表加锁；将key的String类型作为Hash表中的key，将叶子节点指针位置作为Hash表中的value插入到Hash表中。5.根据权利要求2所述的内存数据库存储引擎管理方法，其特征在于：所述步骤1)中，新建一个ART索引维护类，使用ART算法替换Memtable中的skiplist算法；在ART索引维护类中新建一个Hash索引类成员HashMap，用于ART索引叶节点的快速查询。6.根据权利要求5所述的内存数据库存储引擎管理方法，其特征在于：所述步骤1)中，使用PureMemRep类继承public MemtableRep，新增Memtable的内存仓库管理类，使用InlineART类替换InlinSkiplist类，用以实现基于ART算法的内存数据索引；在InlineART类中增加类成员HashTable，hash表中存放ART叶节点和key。7.根据权利要求2所述的内存数据库存储引擎管理方法，其特征在于：所述步骤2)中，启用异步刷盘线程，维护所有内存块的队列，队列按照内存块的上次刷盘时间排序；线程从队列取内存块，并将内存块增量的kv数据进行落盘，追加到文件末尾或形成新的磁盘SST文件。8.根据权利要求2所述的内存数据库存储引擎管理方法，其特征在于：所述步骤3)中，调用Memtable::NewIterator接口创建基于ART树的Iterator，用于遍历ART树中的节点；新建Memtable::NewHashIterator接口，增加ReadOptions参数，用于判断是否为MVCCGet读取；如果是则调用NewHashIterator接口，直接从Hash表中查找存储key的双向链表所对应的叶子节点，如果不是则调用NewIterator接口在hash索引中查找叶子节点，若没有再去ART索引查询；最终得到ART树的叶子节点，得到存储多版本key的双向链表，通过遍历双向链表得到内存块中的数据。9.根据权利要求8所述的内存数据库存储引擎管理方法，其特征在于：所述步骤3)中，当读取多版本数据即MVCCGet数据时，在Hash表中取出key对应的叶子节点，然后从叶子节点对应的双向链表中取出对应的key；如果hash索引中没有查到key，说明已经数据已经落盘，则去磁盘SST文件中查找；当读取非MVCCGet数据时，则在hash索引中查找对应的叶子节点，若没找到对应的叶子节点，则在ART树中查找叶子节点，若ART树中没有找到对应的叶子节点，则去磁盘SST文件中查找。
说明书desc
技术领域本发明涉及数据库管理技术领域，特别涉及一种内存数据库存储引擎管理方法。背景技术近年来，随着动态随机存储器容量的上升和单位价格的下降，使大量数据在内存中的存储和处理成为可能。相对于磁盘，内存的数据读写速度要高出几个数量级，将数据保存在内存中相比从磁盘上访问能够极大地提高应用的性能。CockroachDB是一款开源的分布式数据库，具有NoSQL对海量数据的存储管理能力，又保持了传统数据库支持的ACID和SQL等，还支持跨地域、去中心、高并发、多副本强一致和高可用等特性。支持OLTP场景，同时支持轻量级OLAP场景。CockroachDB使用RocksDB作为KV存储引擎，RocksDB是一个高性能的Key-Value数据库。RocksDB是基于LSM做存储，RocksDB在内存中的结构叫做Memtable，用于形成Log-Structured的file叫做logfile，磁盘上的file结构叫做sstfile，用于记录对file更改的log叫做manifest。LSM存储模型的所有写操作都是顺序写，在稍微损失读性能的情况下，极大地提高了数据的写性能。换来的代价是读性能和增加合并的开销：RocksDB单列族的Memtable默认有64MB，超过这个大小时，写入数据会从Memtable转换为immutable Memtable，然后启动后台线程定时对写入immutable Memtable的数据进行Compaction压缩操作，以进行资源的回收；并将immutable Memtable加入flush pipeline，等待后台线程去flush到SST中，导致读放大问题，查询一个Key值所对应的Value值，可能需要遍历多个SSTable文件，对应了复数次随机IO。而且空间放大，多版本数据在合并之前会占用更多的存储空间。为了优化现有分布式NewSQL数据库中基于RocksDB存储引擎的读放大问题，优化基于ART算法的内存数据库的读性能问题，本发明提出了一种内存数据库存储引擎管理方法。发明内容本发明为了弥补现有技术的缺陷，提供了一种简单高效的内存数据库存储引擎管理方法。本发明是通过如下技术方案实现的：一种内存数据库存储引擎管理方法，其特征在于：基于RocksDB存储引擎的Memtable管理机制，在Memtable内部新建ART索引用以取代skiplist索引，采用ART索引加Hash索引的双索引机制查询key-value，优化RocksDB存储引擎的读性能，从而实现RocksDB内存引擎模式，减少磁盘读写，提高查询速度。该内存数据库存储引擎管理方法，具体实现过程如下：1)将插入Memtable的数据转为插入到ART算法管理的内存块中，并将ART算法的叶节点地址加入Hash索引中；2)修改Memtable刷盘的逻辑，使得Memtable永不转换imMemtable，通过内存块的形式进行刷盘，内存块通过双向链表进行管理；3)执行查询操作时，先从Hash表中查询，然后查询ART树，最后查询磁盘SST文件。所述步骤1)中，写入的数据在内存中以内存块的形式存储，通过双向链表对key进行排序，双向链表的每个节点内存储当前key对应的多个版本数据形成的链表，双向链表的每个节点指向内存块存储的该key对应的key-value；所述ART索引用于快速定位双向链表的特定节点，所述Hash索引用于快速查询ART树的叶子节点的地址；写入数据时，首先通过Hash索引与ART索引计算待插入的叶子结点位置，然后根据ART的叶子节点添加双向链表，通过双向链表对业务key进行排序。所述步骤1)中，当有新的key插入叶子节点时，使用ART算法快速定位到双向链表的插入节点进行插入，同时增加hash表的插入逻辑，对Hash表加锁；将key的String类型作为Hash表中的key，将叶子节点指针位置作为Hash表中的value插入到Hash表中。所述步骤1)中，新建一个ART索引维护类，使用ART算法替换Memtable中的skiplist算法；在ART索引维护类中新建一个Hash索引类成员HashMap，用于ART索引叶节点的快速查询。所述步骤1)中，使用PureMemRep类继承public MemtableRep，新增Memtable的内存仓库管理类，使用InlineART类替换InlinSkiplist类，用以实现基于ART算法的内存数据索引；在InlineART类中增加类成员HashTable，hash表中存放ART叶节点和key。所述步骤2)中，启用异步刷盘线程，维护所有内存块的队列，队列按照内存块的上次刷盘时间排序；线程从队列取内存块，并将内存块增量的kv数据进行落盘，追加到文件末尾或形成新的磁盘SST文件。内存块一般具有固定大小，用于存储数据库插入时传入的KV数据。按照传入的先后顺序顺序排放存储在内存块中。内存块存放满时，创建新的内存块存放新插入的KV数据。所述步骤3)中，调用Memtable::NewIterator接口创建基于ART树的Iterator，用于遍历ART树中的节点；新建Memtable::NewHashIterator接口，增加ReadOptions参数，用于判断是否为MVCCGet读取；如果是则调用NewHashIterator接口，直接从Hash表中查找存储key的双向链表所对应的叶子节点，如果不是则调用NewIterator接口在hash索引中查找叶子节点，若没有再去ART索引查询；最终得到ART树的叶子节点，得到存储多版本key的双向链表，通过遍历双向链表得到内存块中的数据。所述步骤3)中，当读取多版本数据即MVCCGet数据时，在Hash表中取出key对应的叶子节点，然后从叶子节点对应的双向链表中取出对应的key；如果hash索引中没有查到key，说明已经数据已经落盘，则去磁盘SST文件中查找；当读取非MVCCGet数据时，则在hash索引中查找对应的叶子节点，若没找到对应的叶子节点，则在ART树中查找叶子节点，若ART树中没有找到对应的叶子节点，则去磁盘SST文件中查找。本发明的有益效果是：该内存数据库存储引擎管理方法，优化了现有分布式NewSQL数据库中基于RocksDB存储引擎的读性能问题，充分发挥了内存的高效读写性能，能够在内存中缓存更多的数据，解决了RocksDB的读放大问题。附图说明为了更清楚地说明本发明实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。附图1为本发明内存数据库存储引擎管理方法示意图。具体实施方式为了使本技术领域的人员更好的理解本发明中的技术方案，下面将结合本发明实施例，对本发明实施例中的技术方案进行清楚，完整的描述。显然，所描述的实施例仅仅是本发明一部分实施例，而不是全部的实施例。基于本发明中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都应当属于本发明保护的范围。ART是以二进制位串为关键字的trie树，是一种多叉树形结构，同时又类似多层索引表，每个中间节点包含指向多个子节点的指针数组，叶子节点包含指向实际的对象的指针。中间节点根据长度的不同分成若干种不同类型，随着数据的变化而自行调整。虽然使用基于ART树构建的KV内存存储引擎会具备很好的性能优势，但由于树的高度取决于key的长度，时间复杂度取决于key的长度，所以当key的长度增加时，性能会下降，存在性能瓶颈。哈希索引基于哈希表实现，只有精确匹配索引key的查询才有效。对于每个key，存储引擎都会对所有的value计算一个哈希码，哈希码是一个较小的值，并且不同key值计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个key的指针。Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位。该内存数据库存储引擎管理方法，基于RocksDB存储引擎的Memtable管理机制，在Memtable内部新建ART索引用以取代skiplist索引，采用ART索引加Hash索引的双索引机制查询key-value，优化RocksDB存储引擎的读性能，从而实现RocksDB内存引擎模式，减少磁盘读写，提高查询速度。该内存数据库存储引擎管理方法，具体实现过程如下：1)将插入Memtable的数据转为插入到ART算法管理的内存块中，并将ART算法的叶节点地址加入Hash索引中；2)修改Memtable刷盘的逻辑，使得Memtable永不转换imMemtable，通过内存块的形式进行刷盘，内存块通过双向链表进行管理；3)执行查询操作时，先从Hash表中查询，然后查询ART树，最后查询磁盘SST文件。所述步骤1)中，写入的数据在内存中以内存块的形式存储，通过双向链表对key进行排序，双向链表的每个节点内存储当前key对应的多个版本数据形成的链表，双向链表的每个节点指向内存块存储的该key对应的key-value；所述ART索引用于快速定位双向链表的特定节点，所述Hash索引用于快速查询ART树的叶子节点的地址；写入数据时，首先通过Hash索引与ART索引计算待插入的叶子结点位置，然后根据ART的叶子节点添加双向链表，通过双向链表对业务key进行排序。所述步骤1)中，当有新的key插入叶子节点时，使用ART算法快速定位到双向链表的插入节点进行插入，同时增加hash表的插入逻辑，对Hash表加锁；将key的String类型作为Hash表中的key，将叶子节点指针位置作为Hash表中的value插入到Hash表中。所述步骤1)中，新建一个ART索引维护类，使用ART算法替换Memtable中的skiplist算法；在ART索引维护类中新建一个Hash索引类成员HashMap，用于ART索引叶节点的快速查询。所述步骤1)中，使用PureMemRep类继承public MemtableRep，新增Memtable的内存仓库管理类，使用InlineART类替换InlinSkiplist类，用以实现基于ART算法的内存数据索引；在InlineART类中增加类成员HashTable，hash表中存放ART叶节点和key。所述步骤2)中，启用异步刷盘线程，维护所有内存块的队列，队列按照内存块的上次刷盘时间排序；线程从队列取内存块，并将内存块增量的kv数据进行落盘，追加到文件末尾或形成新的磁盘SST文件。内存块一般具有固定大小，用于存储数据库插入时传入的KV数据。按照传入的先后顺序顺序排放存储在内存块中。内存块存放满时，创建新的内存块存放新插入的KV数据。所述步骤3)中，调用Memtable::NewIterator接口创建基于ART树的Iterator，用于遍历ART树中的节点；新建Memtable::NewHashIterator接口，增加ReadOptions参数，用于判断是否为MVCCGet读取；如果是则调用NewHashIterator接口，直接从Hash表中查找存储key的双向链表所对应的叶子节点，如果不是则调用NewIterator接口在hash索引中查找叶子节点，若没有再去ART索引查询；最终得到ART树的叶子节点，得到存储多版本key的双向链表，通过遍历双向链表得到内存块中的数据。所述步骤3)中，当读取多版本数据即MVCCGet数据时，在Hash表中取出key对应的叶子节点，然后从叶子节点对应的双向链表中取出对应的key；如果hash索引中没有查到key，说明已经数据已经落盘，则去磁盘SST文件中查找；当读取非MVCCGet数据时，则在hash索引中查找对应的叶子节点，若没找到对应的叶子节点，则在ART树中查找叶子节点，若ART树中没有找到对应的叶子节点，则去磁盘SST文件中查找。以上所述的实施例，只是本发明具体实施方式的一种，本领域的技术人员在本发明技术方案范围内进行的通常变化和替换都应包含在本发明的保护范围内。

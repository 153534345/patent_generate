标题title
基于定长块的数据存储实现方法和计算机可读存储介质
摘要abst
本发明公开基于定长块的数据存储实现方法：以定长块为单元分配磁盘空间；收到写请求后若为快照后的第一个写请求则把数据对象中定长块转为共享块并把共享块信息加入数据对象的共享链，结合写请求的快照序列号创建对应快照对象并复制数据对象的共享链；根据写请求的数据地址确认对应定长块是否已分配，若否，则分配定长块并初始化位图；共享链的深度是否超过阈值，若超，通过共享链读取对应的共享数据并和写请求的数据合并，写入定长块并更新位图，否则根据写请求的数据地址写入定长块并更新位图；对比定长块的位图和其共享链中共享块的位图，去掉没有数据依赖关系的共享块，并对该共享块的引用计数减1；若减1后其计数为0释放该共享块磁盘空间。
权利要求书clms
1.一种基于定长块的数据存储实现方法，其特征在于，包括：S1、存储的磁盘空间以定长块为单元进行分配管理；所述定长块由多个逻辑管理单元组成，并用位图的比特1或0来代表定长块内对应的逻辑管理单元是否有数据；S2、当存储服务收到写请求后，通过对比写请求所携带的快照序列号以及本地对象所对应的序列号，确认该写请求是否为打快照后的第一个写请求；S3、如果该写请求为打快照后的第一个写请求，则把数据对象中的定长块转换为共享块并把共享块信息加入数据对象的共享链中；结合写请求中携带的快照序列号，创建一个对应的快照对象并复制数据对象中的共享链；S4、根据该写请求的数据地址，确认对应的定长块是否已分配，如果没有分配对应的定长块，则分配定长块并初始化所分配定长块的位图信息；S5、确认共享链的深度是否超过阈值，如果超过阈值，通过共享链读取对应的共享数据，并和写请求的数据合并，写入定长块，并更新对应的位图信息；否则根据写请求的数据地址，写入定长块，并更新对应的位图信息；S6、通过对比定长块的位图信息和其共享链中共享块的位图信息，去掉没有数据依赖关系的共享块，并对该共享块的引用计数减1；如果减1后所述共享块的引用计数为0，则释放该共享块的磁盘空间。2.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于：将数据对象按照定长块大小进行逻辑上的划分，每一个定长块大小的逻辑地址对应一个定长块大小的物理地址空间。3.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于：步骤S2中，若写请求所携带的快照序列号比本地对象所对应的序列号大，则判断为打快照后的第一个写请求；否则，该写请求不是打快照后的第一个写请求，则直接执行步骤S4。4.如权利要求3所述的基于定长块的数据存储实现方法，其特征在于：数据对象最初的快照序列号为0，每写一次，数据对象会记录一次最新的快照序列号。5.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于：在数据对象打快照之前，先进行无快照写入，包括：在写入之前，根据写入数据对象的逻辑地址，在元数据表中查询该逻辑地址是否已存在；若已存在，则写入对应的数据并更新对应的位图信息；若不存在，则根据该逻辑地址申请长度为定长块数量不等的连续磁盘空间，并记录加入到元数据表中，再申请磁盘地址空间，然后写数据并更新位图信息。6.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于：共享块信息包含共享块的位图、引用计数和物理地址；步骤S3中，把共享块信息作为整体加入数据对象的共享链的头部并引用计数加1；同时，复制共享链需把该共享链中所有共享块的引用计数加1。7.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于，步骤S5中通过共享链读取对应的共享数据包括：根据数据对象的逻辑地址，在元数据表中查找对应的定长块；再依照共享链排列顺序及相应的位图，寻找对应的共享数据，进行读取。8.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于，还包括：通过数据重定向，将离散数据重定向到连续的磁盘空间内。9.如权利要求1所述的基于定长块的数据存储实现方法，其特征在于，还包括快照删除，所述快照删除包括：把快照对象中的共享链所有共享块引用计数减1；如果所述快照对象的共享链中有共享块的引用计数为0的，则释放该共享块的磁盘空间。10.一种计算机可读存储介质，其上存储有计算机程序，其特征在于：该计算机程序被处理器执行时，可实现权利要求1至9任一项所述基于定长块的数据存储实现方法的步骤。11.一种基于定长块的数据存储实现方法，其特征在于，包括按如下方式进行快照删除：把快照对象中的共享链所有共享块引用计数减1；如果所述快照对象的共享链中有共享块引用计数为0的，则释放该共享块的磁盘空间。
说明书desc
技术领域本发明涉及数据存储技术领域，具体涉及一种基于定长块的数据存储实现方法。背景技术快照是只读的数据，是对象的一种拷贝，通常用于数据的备份及恢复。目前，快照拷贝技术实现的方式有两种：一种实现技术是写时复制，另一种实现技术是写时重定向。对象，分为数据对象和快照对象，数据对象：也就是对象的原始对象，该对象可以写；快照对象：对对象做快照后通过COW机制或者ROW机制拷贝出来的快照对象，该对象只能读，不能写。COW机制：当对一个数据对象打一个快照时，把涉及数据对象的地址也就是元数据拷贝到快照对象中，后续去对该数据对象进行修改时，涉及到的数据对象区域的修改就会读上来然后被写入到快照对象空间中，然后再进行改写。COW这种机制每次改写数据，实际进行了一次读操作和两次写操作，影响写业务，但是能维持数据对象在磁盘空间的连续性。ROW机制：图1为ROW机制的实现过程示意图，当对一个数据对象打一个快照后，把涉及数据对象地址也就是元数据拷贝到快照对象中，后续去对该数据对象进行修改时，把修改的数据写到磁盘空间新位置，然后使数据对象修改区域的地址指向新位置。ROW机制会把数据对象的数据分散到磁盘的各个位置，通过地址元数据管理起来。该机制使得磁盘空间碎片化严重，导致后续大块连续读的额外开销比较大。BlueStore是分布式存储ceph的存储引擎，管理对象数据如何写入，其对象数据的管理通过变长lextent实现，每一个对象有一张extent-map。extent-map包含多个lextent，每个lextent负责管理对象内的一个逻辑段数据并且关联一个blob，blob包含多个pextent，最终将对象的数据映射磁盘上。lextent是由对象数据写入逻辑地址和偏移组成，pextent是磁盘上一段连续的足够大物理地址。一个lextent对应一个pextent，同时对象记录一个blob_offset，对应的是逻辑段通过blob映射到磁盘物理段，会产生物理段的偏移。这种基于lextent/blob/pextent多层映射管理，加大了元数据开销。图2是无快照写入过程的两次写请求，有两个lextent写入到同一个pextent，这种情况在小块随机写的场景会出现。有快照写入，采用ROW机制，打快照后数据写入操作过程如下：第1步、快照对象引用此时数据对象的地址，也就是exetent-map；第2步、写入的lextent包含在快照对象的exetent-map中，则更改该lextent指向新的pextent，并把对象写入；否则，则按照无快照写入流程实现；第3步、再次写入同样的lextent，按照无快照写入流程实现。按照图2存在的数据对象为基础，打入快照后的第一次写lextent1。最终的地址射如图3所示。在无快照写入过程中，一个pextent在小块随机写场景下会对应多个lextent，如果单个对象的lextent过多的话，元数据开销就会增加；而对象打快照后的ROW机制写入，通过更改数据对象的地址来实现，但随着数据写入，地址也就是元数据会越来越多，磁盘数据空间越离散，维护元数据的成本也会逐步提高，读取的额外开销也越大。发明内容为了降低元数据的开销，优化数据离散空间，本发明提出一种基于定长块的数据存储实现方法，以解决前述现有技术存在的元数据开销大、磁盘数据空间随着数据写入变得越来越离散导致维护成本高、读取开销大的技术问题。本发明为解决上述技术问题提出如下技术方案：一种基于定长块的数据存储实现方法，包括：S1、存储的磁盘空间以定长块为单元进行分配管理；所述定长块由多个逻辑管理单元组成，并用位图的比特1或0来代表定长块内对应的逻辑管理单元是否有数据；S2、当存储服务收到写请求后，通过对比写请求所携带的快照序列号以及本地对象所对应的序列号，确认该写请求是否为打快照后的第一个写请求；S3、如果该写请求为打快照后的第一个写请求，则把数据对象中的定长块转换为共享块并把共享块信息加入数据对象的共享链中；结合写请求中携带的快照序列号，创建一个对应的快照对象并复制数据对象中的共享链；S4、根据该写请求的数据地址，确认对应的定长块是否已分配，如果没有分配对应的定长块，则分配定长块并初始化所分配定长块的位图信息；S5、确认共享链的深度是否超过阈值，如果超过阈值，通过共享链读取对应的共享数据，并和写请求的数据合并，写入定长块，并更新对应的位图信息；否则根据写请求的数据地址，写入定长块，并更新对应的位图信息；S6、通过对比定长块的位图信息和其共享链中共享块的位图信息，去掉没有数据依赖关系的共享块，并对该共享块的引用计数减1；如果减1后所述共享块的引用计数为0，则释放该共享块的磁盘空间。本发明另提出一种计算机可读存储介质，其上存储有计算机程序，该计算机程序被处理器执行时，可实现前述基于定长块的数据存储实现方法的步骤。本发明另还提出一种基于定长块的数据存储实现方法，包括按如下方式进行快照删除：把快照对象中的共享链所有共享块的引用计数减1；如果所述快照对象的共享链中有共享块的引用计数为0的，则释放该共享块的磁盘空间。本发明技术方案的有益效果在于：基于定长块，使用位图形式管理数据，减少元数据开销；在ROW机制下，根据共享链的深度，重定向数据离散空间，提高了数据读写效率。附图说明图1是ROW机制的实现过程示意图。图2是BlueStore无快照写入的两次写请求的示意图。图3是BlueStore有快照写入的快照-lextent-pextent映射图。图4是本发明实施例基于定长块的数据存储实现方法流程图。图5是本发明实施例中定长块与位图对应关系图。图6是本发明实施例步骤S2的一种示例性实施过程。图7至图9是本发明实施例步骤S3和S4的一种示例性实施过程。图10和图11是本发明实施例步骤S5的一种示例性实施过程。图12是本发明实施例步骤S6的一种示例性实施过程。图13和图14是本发明实施例删除快照对象的一种示例性实施过程。具体实施方式下面结合附图和具体的实施方式对本发明作进一步说明。在说明之前，先对本发明实施例涉及的技术术语/缩略语进行解释如下：block：对象的逻辑管理单元，也是磁盘块大小，block可取为4K、8K、16K等，1K =1024Byte，Byte也就是字节，用于计量存储容量的一种计量单位。chunk：定长块，是指一定长度的连续磁盘空间，chunk由多个block组成，chunk可取为256K、512K、1024K等。bitmap：位图，用比特位1和0来存放某种状态。本发明实施例中，一个chunk对应一个bitmap，bitmap的位数等于该chunk的block数，用1代表该block有数据，0表示该block没有数据；bitmap中的bit的值由chunk/block决定，并初始化全为0。比如，图6所示，一个chunk由4个block构成，第一次写之后chunk1对应的bitmap为1000，表示第一个block有数据，第二个block、第三个block和第四个block没有数据。共享链：用来管理对数据对象打多次快照、写数据形成相互依赖的共享块。元数据表：包含多个以chunk为大小的逻辑地址并且该逻辑地址对应的物理磁盘空间已分配，由组成，实际在地址计算的时候，要换算为Byte。共享块：定长块被打快照后变为共享块。引用计数：引用共享块的对象数量。地址：由偏移和长度组成。本发明实施例提出一种基于定长块的数据存储实现方法，将对象按照chunk大小进行逻辑上的划分，每一个chunk大小的逻辑地址对应一个chunk大小的物理地址空间。chunk由多个磁盘块大小的block组成，用bitmap的bit为1和0分别代表该block有数据、无数据。一个chunk对应一个bitmap。extent-map包含多个以chunk为大小的逻辑地址。用bitmap的形式记录物理数据，小块随机写场景用少于bit位就能表示多个lextent，可以有效减少元数据开销。参考图4，本发明实施例基于定长块的数据存储实现方法，包括如下步骤S1-S6：S1、存储的磁盘空间以定长块为单元进行分配管理；所述定长块由多个逻辑管理单元组成，并用位图的比特1或0来代表定长块内对应的逻辑管理单元是否有数据。如图5所示，是本发明实施例中定长块与位图对应关系图。比如，逻辑管理单元block1和block4所对应的位图比特均为0，代表逻辑管理单元block1和block4未被写过，没有数据；而block2和block3的位图比特为1，代表有数据。S2、当存储服务收到写请求后，通过对比写请求所携带的快照序列号以及本地对象所对应的序列号，确认该写请求是否为打快照后的第一个写请求。本地的数据对象最初默认的快照序列号为0，每写一次，数据对象会记录一次最新的快照序列号。若写请求所携带的快照序列号比本地对象所对应的序列号大，则判断为打快照后的第一个写请求，先执行步骤S3，再到步骤S4；否则，该写请求不是打快照后的第一个写请求，直接执行步骤S4。S3、如果该写请求为打快照后的第一个写请求，则把数据对象中的定长块转换为共享块并把共享块信息加入数据对象的共享链中；结合写请求中携带的快照序列号，创建一个对应的快照对象并复制数据对象中的共享链。共享块信息包含共享块的位图、引用计数和物理地址；步骤S3中，把共享块信息作为整体加入数据对象的共享链的头部并引用计数加1；同时，复制共享链需把该共享链中所有共享块的引用计数加1。S4、根据该写请求的数据地址，确认对应的定长块是否已分配，如果没有分配对应的定长块，则分配定长块并初始化所分配定长块的位图信息，然后执行步骤S5；如果已分配，则直接进入步骤S5。S5、确认共享链的深度是否超过阈值，如果超过阈值，通过共享链读取对应的共享数据，并和写请求的数据合并，写入定长块，并更新对应的位图信息；否则根据写请求的数据地址，写入定长块，并更新对应的位图信息。S6、通过对比定长块的位图信息和其共享链中共享块的位图信息，去掉没有数据依赖关系的共享块，并对该共享块的引用计数减1；如果减1后所述共享块的引用计数为0，则释放该共享块的磁盘空间。共享块的位图中为1的比特位在定长块的位图中相应的位置都能找到，即定长块位图包含共享块位图，定长块数据不依赖共享块数据。进行快照删除时，把快照对象中的共享链所有共享块引用计数减1；如果所述快照对象的共享链中有共享块引用计数为0的，则释放该共享块的磁盘空间。在数据对象打快照之前，先进行无快照写入，无快照写入流程如下：在写入之前，根据写入数据对象的逻辑地址，在extent-map中查询该逻辑地址是否已存在；若已存在，则写入对应的数据并更新对应的位图；若不存在，则根据该逻辑地址申请长度为定长块数量不等的连续磁盘空间，并记录加入到extent-map中，再申请磁盘地址空间，然后写数据并更新位图。然后进行有快照写入。有快照写入需先确认是否是打快照后的第一次写申请，然后再进行写。下面通过具体的示例来对前述基于定长块的数据存储实现方法进行说明。请先参考图6，图6示例了前述步骤S2的具体实施例：a、第一次写请求逻辑地址是，写入的数据为A，携带快照序列号为0。该序列号不大于数据对象的快照序列号，所以只是写数据。写请求逻辑地址在元数据表查不到，也就是定长块未分配，所以把逻辑地址加入元数据表中，申请定长块chunk1，初始化bitmap为0，写入数据A，并更新chunk1的bitmap中第一个bit为1，数据对象逻辑地址指向chunk1；b、第二次写请求逻辑地址是，写入的数据为B，携带快照序列号为0。该逻辑地址包含在元数据表：＜＞中，只写对应的数据，并更新chunk1的bitmap，也就是第二bit置1；c、第三次写请求逻辑地址是，写入的数据为C、D，携带快照序列号为0。该逻辑地址包含在extent-map＜＞中，写入chunk1，并更新chunk1的bitmap，也就是第4个bit置1；但是剩余逻辑地址在元数据表＜＞查不到，所以新的逻辑地址加入元数据表中，并且chunk2新的bitmap与之对应，使对应的bitmap中第一个bit位置为1。参考图7至图9，图7至图9示例了前述步骤S3和S4的具体实施例：在图6第二步写数据后的基础上，对数据对象打快照1，携带快照序列号为1。a、如图7，第一次写请求逻辑地址是，写入数据为B`和C，携带快照序列号1。此时写请求的快照序列号比数据对象记录的快照序列号大，是该快照的第一个写请求，需把chunk1变为共享块并加入数据对象的逻辑地址对应的共享链的头部中，同时引用计数加1，快照对象1复制该共享链。写请求逻辑地址是包含在数据对象的元数据表＜＞中，但是地址＜＞此时指向是的共享块，相当于该地址未分配定长块，该地址需分配新的定长块chunk2，写入数据并更新chunk2对应的bitmap，即bitmap中第二个和第三个bit位置为1；此时数据对象拥有快照序列号1。b、如图8，第二次写请求逻辑地址是，写入数据为E，携带快照序列号0。该序列号没有数据对象拥有的快照序列号大，所以只是写数据。逻辑地址是在数据对象的元数据表：＜＞中查不到，需要把逻辑地址加入到元数据表中：＜，＞。逻辑地址指向新申请的定长块chunk3中，写入数据并更新chunk3对应的bitmap，即bitmap中第一个bit位置位1。c、如图9，第三次写请求逻辑地址是，写入数据为D，携带快照序列号2。该序列号比数据对象拥有的快照序列号大，所以数据对象的所有定长块变为共享块，并把共享块chunk2加入逻辑地址对应的共享链中的头部，共享块chunk3加入逻辑地址对应的共享链中的头部，快照对象2引用数据对象的共享链。写入数据为D到新分配的定长块chunk4中并更新bitmap，即bitmap中第四个bit位置位1。此时数据对象拥有快照序列号2。参考图10和图11，图10和图11示例性地给出前述步骤S5的具体实施过程：假设共享链深度阈值为1。以图9执行的结果为例，写请求逻辑地址是，携带的数据是A``，B``，C，携带快照序列号0。此时数据对象的元数据表中，拥有两个逻辑地址＜，＞，逻辑地址引用两个快照，结合写请求的地址对应的数据读上来和写请求的数据进行合并；逻辑地址引用1个快照，不读取数据；1）把逻辑地址指向的数据读上来，过程如下：a、先读取chunk4，根据其对应的bitmap，读取地址对应的数据D；b、根据共享链，接下来读取chunk2，根据其对应的bitmap，读取地址对应的数据B`和C；c、根据共享链，接下来读取chunk1，根据其对应的bitmap，剩下的地址对应的数据在chunk1可以找到，数据为A。此时数据全部读上来，结束读流程。2）把读取上来的数据结合写请请求的地址，进行数据合并。合并后的数据是A``，B``，C和D，写入的逻辑地址是对应的chunk4并更新其bitmap。参考图12，图12示例性地给出前述步骤S6的具体实施过程：以图11执行结果为例，数据对象的定长块chunk4的bimap为1111，其对应的共享链中共享块chunk2的bitmap为0110，共享块chunk1的bitmap为1100，chunk4的bitmap包含chunk2和chunk1的bitmap，即不需要依赖chunk2和chunk1，即共享块chunk和chunk1的引用计数减1；chunk2和chunk1对应的引用计数不为0，不释放对应的空间；后续清空该共享链。数据对象的定长块chunk3，其对应的共享链中的chunk是自己，不进行处理。为防止频繁重定向，数据重定向需要满足以下条件①和②：a、共享链的深度超过一预设值时开始进行数据重定向；b、共享链的深度是在每次打快照第一次写数据时计算。数据重定向写入流程如下：1）按照读取数据的流程把数据读取出；2）读取的数据写入数据对象的对应的chunk内并更新bitmap；3）共享链中的所有共享块引用计数减1，清空数据对象的共享链。在数据重定向后，数据对象拥有完整的数据了，不依赖共享链中的共享块了，所以其引用计数减1，数据对象的共享链可清空。进行快照删除时，把所述快照对象中的共享链所有共享块引用计数减1；如果所述快照对象的共享链中有共享块引用计数为0的，则释放对应的共享块空间；如果快照对象共享链中的共享块在数据对象的共享链中，则读取数据对象的共享链中共享块引用计数为1的共享数据，写入数据对象中并更新相应的位图。引用计数是用来管理和持久化共享块空间，共享块引用计数不为1，共享块空间无法回收。在快照删除时，分为两种情况：1）欲删除的快照对象共享链中的共享块存在于数据对象的共享链中；2）欲删除的快照对象共享链中的共享块不存在数据对象的共享链中。对于第1）种情况，快照删除流程为：1.1、把该快照对象的共享链中所有共享块引用计数减1；1.2、根据数据对象的共享链，从头到尾，遍历共享块引用计数为1共享块，有引用计数不为1则终止遍历。根据可回收共享块空间及其对应的bitmap，把数据对象缺失的数据读上来，写入数据对象对应的磁盘空间中，更新数据对象bitmap；把可回收共享块信息从数据对象共享链中删除并释放共享块空间。参考图13和图14，是删除快照对象的一种示例性实施过程：以图12的执行结果为例，如图13和图14所示，此时快照对象2的映射关系如下，逻辑地址对应的共享链：＜＞,＜＞变为:＜＞,＜＞。逻辑地址对应的共享链：＜＞，引用计数保持不变。删除快照对象2，快照对象2共享链中的所有共享块引用计数减1。此时在逻辑地址对应的共享链chunk2对应的引用计数ref=0，所以释放chunk2；逻辑地址对应的共享链的共享块引用计数不为0，不进行处理。对于第2）种情况，快照删除流程为：2.1、把该快照对象的共享链中所有共享块引用计数减1；2.2、该快照对象的共享链中所有共享块引用计数为0的快照进行空间释放。以上内容是结合具体的优选实施方式对本发明所作的进一步详细说明，不能认定本发明的具体实施只局限于这些说明。对于本发明所属技术领域的技术人员来说，在不脱离本发明构思的前提下，还可以做出若干等同替代或明显变型，而且性能或用途相同，都应当视为属于本发明的保护范围。

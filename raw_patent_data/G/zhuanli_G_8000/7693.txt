标题title
一种开源软件贡献者数据处理方法及装置
摘要abst
本发明公开了一种开源软件贡献者数据处理方法及装置，开源软件项目部署在多个代码托管平台上，所述方法包括：获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据；基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，以便对各贡献者的贡献分数进行展示。该方法中，在将开源软件项目部署在多个代码托管平台的同时，能够对开源软件的贡献数据及时地进行统计和展示。
权利要求书clms
1.一种开源软件贡献者数据处理方法，所述开源软件项目部署在多个代码托管平台上，其特征在于，所述方法包括：获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据；基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，以便对各贡献者的贡献分数进行展示。2.根据权利要求1所述的一种开源软件贡献者数据处理方法，其特征在于，所述基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，具体包括：将与所述代码更新数据对应的贡献者作为目标贡献者；对于每个目标贡献者执行如下步骤：利用所述代码更新数据更新所述目标贡献者的贡献数据；其中，所述贡献数据包括以下维度评分参数中的任一种或多种：代码提交次数、代码推送次数、总代码行数、被采用的代码行数、被收藏次数、意见反馈次数；按照各评分参数的预设权重统计目标贡献者更新后的贡献数据中各维度的评分参数得到贡献分数。3.根据权利要求2所述的一种开源软件贡献者数据处理方法，其特征在于，所述按照各评分参数的预设权重统计目标贡献者更新后的贡献数据中各维度的评分参数得到贡献分数，具体包括：根据以下公式计算目标贡献者的贡献分数S：其中，h为评分参数的维度，为第i个评分参数，为第i个评分参数对应的预设权重。4.根据权利要求1所述的一种开源软件贡献者数据处理方法，其特征在于，所述方法还包括：接收来自第三方网站用户页面的分数查看请求；所述分数查看请求包括所述第三方网站用户页面获取的用户对各维度评分参数的关注度；基于所述关注度生成与各维度评分参数对应的自定义权重；按照各评分参数的自定义权重统计各贡献者的贡献数据中各维度的评分参数得到个性贡献分数；将各贡献者对应的个性贡献分数发送至所述第三方网站用户页面，以便于所述第三方网站用户页面展示所述个性贡献分数的排行。5.根据权利要求4所述的一种开源软件贡献者数据处理方法，其特征在于，所述基于所述关注度生成与各维度评分参数对应的自定义权重，具体包括：根据以下公式生成各维度评分参数对应的自定义权重：其中，h为评分参数的维度，为通过第三方网站用户页面获取的用户对第i个评分参数的关注度，为关注度为1的评分参数对应的自定义权重，为关注度为0的评分参数对应的自定义权重；其中，所述按照各评分参数的自定义权重统计各贡献者的贡献数据中各维度的评分参数得到个性贡献分数，具体包括：对于每个贡献者根据以下公式计算对应的个性贡献分数P：为包含a个关注度为1的评分参数的第一集合中的第j个评分参数，为包含个关注度为0的评分参数的第二集合中的第k个评分参数。6.根据权利要求4所述的一种开源软件贡献者数据处理方法，其特征在于，所述方法还包括：对于获取到的每份代码更新数据执行以下步骤：检测该份代码更新数据中的提交者账号和推送者账号；当检测到该份代码更新数据中的提交者账号为已注册账号且检测到该份代码更新数据中的推送者账号与其他已注册的提交者账号存在绑定关系的情况下，检测到第一数量和第二数量的差值小于第一阈值时，将该份代码更新数据标记为与其他已注册提交者账号以及所述推送者账号关联的数据；其中，第一数量为该推送者账号与当前提交者账号共同关联的代码更新数据的数量，第二数量为该推送者账号与其他已注册的提交者账号共同关联的代码更新数据的数量。7.根据权利要求1所述的一种开源软件贡献者数据处理方法，其特征在于，所述方法还包括计算贡献者的未采用代码贡献分数，具体包括：获取该贡献者向所有代码托管平台中开源软件项目推送的未被采用代码；对于每一份未被采用代码：选取第一推送时间晚于第二推送时间的被采用代码作为目标代码；其中，第一推送时间为被采用代码向各代码托管平台进行推送的时间，第二推送时间为未被采用代码向各代码托管平台进行推送的时间；检测该份未被采用代码与多份相应的目标代码的文本相似度得到多个文本相似度结果；基于分值最高的文本相似度结果与预设相似度阈值的差值，得到该份未被采用代码的代码贡献子分数；统计该贡献者所有未被采用代码的代码贡献子分数得到该贡献者的未采用代码贡献分数。8.根据权利要求1所述的一种开源软件贡献者数据处理方法，其特征在于，所述基于分值最高的文本相似度结果与预设相似度阈值的差值，得到该份未被采用代码的代码贡献子分数，具体包括：当分值最高的文本相似度结果与预设相似度阈值的差值不大于零时，将该份未被采用代码的代码贡献子分数设置为零；当分值最高的文本相似度结果与预设相似度阈值的差值大于零时，将该份未被采用代码的代码贡献子分数设置为分值最高的文本相似度结果与预设相似度的阈值。9.一种开源软件贡献者数据处理装置，其特征在于，包括：数据汇总模块，用于获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据；加权处理模块，用于基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数；计算排行模块，用于根据所述贡献分数对各贡献者进行排行。10.一种电子设备，包括：存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，其特征在于，所述处理器执行所述程序时实现如权利要求1至8中任一项所述的开源软件贡献者数据处理方法。
说明书desc
技术领域本发明涉及开源软件技术领域，特别涉及一种开源软件贡献者数据处理方法及装置。背景技术开源软件的贡献者活跃度和贡献度衡量一款开源软件活跃度的最重要指标之一。每一款开源软件都会在自己的主页展示自己的贡献者信息。展示形式有很多种，包括用户昵称、头像，如果借助一些工具和平台，还可以支持排行榜的展示。现有技术中，用于对贡献值的贡献度进行统计和展示的方案大致包括如下两种，第一种是依靠已成熟的代码托管平台自身对贡献度进行统计和展示；第二种是不使用已成熟的代码托管平台，自己搭建代码托管平台，依靠自己搭建的代码托管平台对贡献度进行统计和展示。对于第一种对贡献值的贡献度进行统计和展示的方案，可以参照GitHub、Gitline、Gitlab等平台提供的功能。对于第二种对贡献值的贡献度进行统计和展示的方案，现有技术中也披露了相应的文献，如公开号为CN108182058A、CN111475197A等中国专利公开的自研代码托管平台方案。发明人在研究如何统计和展示开源软件各贡献者对应的贡献度时，发现若是采用第二种方式，由于贡献者所有数据都在同一个平台上，其优势是在一个平台上能够很及时方便地统计所有贡献者对开源软件做出的贡献，并且很及时方便地将这些贡献展示给各贡献者和公众；劣势是让贡献者在开源软件自研的代码托管平台上进行代码贡献，显然会错失大量对该自研代码托管平台不熟悉的优秀程序员，不符合软件开源的初衷。采用第一种方式有更多机会可以让已成熟代码托管平台上的优秀程序员参与到开源软件的代码贡献中，但是不同程序员习惯使用的代码托管平台不相同，需要在不同的代码托管平台都部署该开源软件对应的项目，以便让各代码托管平台的程序员都可以向该项目贡献代码。但是由于各代码托管平台相互之间数据并不互通，在进行贡献统计和展示时存在困难。发明内容本发明的目的在于至少解决现有技术中存在的技术问题之一，提供一种开源软件贡献者数据处理方法及装置，在将开源软件项目部署在多个代码托管平台的同时，能够对开源软件的贡献数据及时地进行统计和展示。第一方面，提供了一种开源软件贡献者数据处理方法，所述开源软件项目部署在多个代码托管平台上，所述方法包括：获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据；基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，以便对各贡献者的贡献分数进行展示。第二方面，提供了一种开源软件贡献者数据处理装置，包括：数据汇总模块，用于获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据；加权处理模块，用于基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数；计算排行模块，用于根据所述贡献分数对各贡献者进行排行。第三方面，提供一种电子设备，包括：存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，所述处理器执行所述程序时实现如本发明第一方面实施例中任一项所述的开源软件贡献者数据处理方法。第四方面，提供一种计算机可读存储介质，所述计算机可读存储介质存储有计算机可执行指令，所述计算机可执行指令用于使计算机执行如本发明第一方面实施例中任一项所述的开源软件贡献者数据处理方法。有益效果：相较于现有技术中各代码托管平台相互之间数据并不互通导致无法及时全面地统计一个开源软件项目在不同代码托管平台上的实时贡献数据。由于本发明的方法同时统计了不同的代码托管平台上对应开源软件项目的贡献情况，即使贡献者通过不同的代码托管平台向开源软件项目做出贡献，也能够并全面地进行统计。同时，本发明提供的开源软件贡献者数据处理方法能够通过在各代码托管平台配置webhook自动实时地获取各贡献者在各代码托管平台上的贡献情况，实现了贡献数据的及时自动统计，能够向公众展示实时的贡献分数。本发明的附加方面和优点将在下面的描述中部分给出，部分将从下面的描述中变得明显，或通过本发明的实践了解到。附图说明下面结合附图和实施例对本发明进一步地说明；图1为一个实施例中一种开源软件贡献者数据处理装置的结构框图。图2为一个实施例中开源软件贡献者数据处理方法的流程示意图。图3为一个实施例中开源软件贡献者数据处理方法的流程示意图。图4为一个实施例中开源软件贡献者数据处理方法的流程示意图。图5为一个实施例中开源软件贡献者数据处理方法的流程示意图。图6为一个实施例中开源软件贡献者数据处理方法的流程示意图。图7为一个实施例中计算机设备的结构框图。具体实施方式本部分将详细描述本发明的具体实施例，本发明之较佳实施例在附图中示出，附图的作用在于用图形补充说明书文字部分的描述，使人能够直观地、形象地理解本发明的每个技术特征和整体技术方案，但其不能理解为对本发明保护范围的限制。参照图1，在一个实施例中，本发明提供的一种开源软件贡献者数据处理装置可以由图7所示的计算机设备来实现，其中数据汇总模块、加权处理模块、计算排行模块均可由软件程序模块来实现，如图1所示，该实施例中，还为第三方网站提供了供其进行调用的API，第三方网站可以通过该API传入自定义权重，加权处理模块可以根据自定义权重计算各贡献者的分数并将基于自定义权重计算的个性贡献分数反馈给第三方网站。可以理解的是，开源软件项目发起者也可以在自己的网站按照预设权重统计更贡献者的分数并利用计算排行模块将贡献者排行展示给访问其网站的用户。具体地说，该解决方案共包括数据汇总模块、加权处理模块、计算排行模块和相应模块的功能api组成。数据汇总模块负责与不同的代码托管平台进行接口数据对接。首先本模块会对外暴露一个支持签名加密的某开源项目 webhook 数据接收的接口地址，用户需要将这个地址注册到各个代码托管平台上，代码托管平台发生用户代码贡献、意见反馈、文档贡献、收藏等操作时，开源平台可以通过 webhook 机制将事件推送到数据汇总模块的webhook数据接收接口，数据汇总模块受到webhook 的触发，可以根据webhook数据和来源平台的类型，请求对应代码托管平台的公开API获得本次贡献的数据详情。获取到的数据会被格式化成统一格式进行存储。加权处理模块支持第三方网站用户通过API和页面操作对开源项目的源码贡献、意见反馈、文档贡献、收藏等操作定义计算时的权重，然后将数据汇总模块存储的不同类型数据结合定义的权重进行各维度数据的计算。计算排行模块在加权处理模块的基础之上，对不同维度计算过权重的数据进行汇总，生成不同类型和格式的数据，如源码贡献排行榜、社区活跃排行榜、综合排行榜等，支持API和分享图形式提供数据。可以理解的是，本发明提供的方案从将给开源软件项目部署到各代码托管平台之时便配置了webhook，所以webhook能够监控到项目各个阶段的代码更新情况，并不需要操作人员定期通过代码托管平台提供的API人工定期去不同代码托管平台汇总开源软件的贡献情况。需要说明的是，本发明提供了两种统计贡献分数或者个性贡献分数的方式，一种是将专家审核通过后被采用的代码对应的评分参数来进行贡献分数的计算，另一种是将贡献者的所有代码的评分参数均用于贡献分数的计算，相应的也就是提供两份贡献排名，以便更全面的统计代码贡献情况。下面，将通过几个具体的实施例对本发明实施例提供的开源软件贡献者数据处理方法进行详细介绍和说明。如图2所示，在一个实施例中，提供了一种开源软件贡献者数据处理方法。本实施例主要以该方法应用于计算机设备来举例说明。所述开源软件项目部署在多个代码托管平台上，所述方法包括：步骤S202，获取各代码托管平台对应的代码更新数据；其中，所述代码更新数据是由配置在各代码托管平台上的webhook监控到程序员向各代码托管平台上所述开源软件项目推送代码的事件时，实时向预设的回调URL发送的数据。步骤S204，基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，以便对各贡献者的贡献分数进行展示。相较于现有技术中各代码托管平台相互之间数据并不互通导致无法及时全面地统计一个开源软件项目在不同代码托管平台上的实时贡献数据。由于本发明的方法同时统计了不同的代码托管平台上对应开源软件项目的贡献情况，即使贡献者通过不同的代码托管平台向开源软件项目做出贡献，也能够并全面地进行统计。同时，本发明提供的开源软件贡献者数据处理方法能够通过在各代码托管平台配置webhook自动实时地获取各贡献者在各代码托管平台上的贡献情况，实现了贡献数据的及时自动统计，能够向公众展示实时的贡献分数。如图3所示，在一个实施例中，所述基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数，具体包括：步骤S2041，将与所述代码更新数据对应的贡献者作为目标贡献者。对于每个目标贡献者执行如下步骤：步骤S2042，利用所述代码更新数据更新所述目标贡献者的贡献数据；其中，所述贡献数据包括以下维度评分参数中的任一种或多种：代码提交次数、代码推送次数、总代码行数、被采用的代码行数、被收藏次数、意见反馈次数。步骤S2043，按照各评分参数的预设权重统计目标贡献者更新后的贡献数据中各维度的评分参数得到贡献分数。可以理解的是，本步骤S2043中，所述目标贡献者更新后的贡献数据包括被采用代码对应的贡献数据以及全部代码的贡献数据，从而得到两套贡献分数以及两个贡献排行榜。其中被采用的代码对应的贡献数据，是经过专家审核后被采用的代码对应的贡献数据。例如，A贡献者总共的代码推送次数为20次，被采用的代码对应的次数为3次，则被采用的代码对应的代码推送次数为3，全部代码对应的代码推送次数为20。显然，若是B贡献者总共的代码推送次数为4次，但是一次都未被采用，则其贡献数据对应的所有维度评分参数均为0。这是不公平的，不能够鼓励贡献者的积极性，需要提供两个排行榜，所以在另一份排行榜中，B贡献者贡献数据对应的所有维度评分参数均为4。具体的，在一个示例中，所述按照各评分参数的预设权重统计目标贡献者更新后的贡献数据中各维度的评分参数得到贡献分数，具体包括：根据以下公式计算目标贡献者的贡献分数S：其中，h为评分参数的维度，例如当评分参数为代码提交次数、代码推送次数、总代码行数、被采用的代码行数、被收藏次数、意见反馈次数上述六种时，h=6，为第i个评分参数，为第i个评分参数对应的预设权重，此处的预设权重是由专家根据代码审核的结果提供的经验权重。相较于现有技术中以单一维度进行贡献评分的方式，本实施例中将包含多维度评分参数的贡献数据进行加权计算得到能够体现贡献者综合贡献排行的贡献分数，能够更全面地反映出各贡献者对于开源软件的综合贡献。同时，由于对于每个贡献数据发生了更新的目标贡献者都实时重新计算其最新的贡献分数，能够向公众展示最新贡献分数。如图4所示，在一个实施例中，所述方法还包括：步骤S302，接收来自第三方网站用户页面的分数查看请求；所述分数查看请求包括所述第三方网站用户页面获取的用户对各维度评分参数的关注度。步骤S304，基于所述关注度生成与各维度评分参数对应的自定义权重。步骤S306，按照各评分参数的自定义权重统计各贡献者的贡献数据中各维度的评分参数得到个性贡献分数。步骤S308，将各贡献者对应的个性贡献分数发送至所述第三方网站用户页面，以便于所述第三方网站用户页面展示所述个性贡献分数的排行。考虑到，专家制定好的各评分参数的预设权重一般是根据专家自己的视角来考虑各贡献者的贡献程度，例如，专家认为被采用的代码行数的权重应当是最高的，认为这些贡献者的贡献是最大的，所以在开源软件官网展示的贡献排行中人们可以看到排行最靠前的贡献者是其代码被采用行数最多的贡献者。但是不同用户关注的贡献数据的维度可能存在不同，例如，对于更关注意见反馈次数和被收藏次数的用户而言，显然采用专家制定好的各评分参数的预设权重来给用户呈现贡献排行时，有可能导致用户关注的贡献者排名不再前列，此时该排行对于用户的意义并不大。为了解决上述问题，本实施例中，在第三方网站调用开源软件贡献数据时，会提供给第三方网站的用户对各评分参数的关注度进行选择的功能，对于用户关注度高的评分参数赋予更高的权重，从而能够确保在展示给第三方网站的贡献排行中让排在前列的贡献者是用户实际观众的贡献者。具体地，所述基于所述关注度生成与各维度评分参数对应的自定义权重，具体包括：根据以下公式生成各维度评分参数对应的自定义权重：其中，h为评分参数的维度，为通过第三方网站用户页面获取的用户对第i个评分参数的关注度，为关注度为1的评分参数对应的自定义权重，为关注度为0的评分参数对应的自定义权重；其中，所述按照各评分参数的自定义权重统计各贡献者的贡献数据中各维度的评分参数得到个性贡献分数，具体包括：对于每个贡献者根据以下公式计算对应的个性贡献分数P：为包含a个关注度为1的评分参数的第一集合中的第j个评分参数，为包含个关注度为0的评分参数的第二集合中的第k个评分参数。本实施例中，基于第三方网站用户页面的用户对各评分参数的关注度来生成各贡献者对应的个性贡献分数，通过个性贡献分数进行贡献的排行，使得位于排行最前列的贡献者为第三方网站用户页面用户通过关注度来指定的贡献者，向用户提供匹配度更高的推荐展示效果。如公式，在进行所示，计算每个贡献者的个性贡献分数时，所有评分参数的权重之和等于1。以评分参数的数量为代码提交次数、代码推送次数、总代码行数、被采用的代码行数、被收藏次数、意见反馈次数等6个来举例说明，在第三方网站用户页面上的某个区域显示有六个与上述评分参数对应的控件，在每个控件上分别显示上述6个评分参数的名称，即代码提交次数等。若是用户比较关注的是意见反馈次数和被收藏次数两个评分参数，则用户会通过鼠标点击与意见反馈次数和被收藏次数两个评分参数对应的控件，然后按下回车键，此时第三方网站用户页面获得了该用户对这6个维度评分参数的关注度，即认为意见反馈次数和被收藏次数两个评分参数的关注度为1，其他4个评分参数的关注度为0从而生成分数查看请求，并通过开源软件贡献者数据处理平台提供的API向部署了该开源软件贡献者数据处理平台的服务器发送所述分数查看请求，将各评分参数的关注度数据传递给开源软件贡献者数据处理平台。开源软件贡献者数据处理平台会根据公式、和为关注度不同的评分参数重新分配权重并在加权处理模块根据公式对每个贡献者的分数进行计算，然后通过计算排行模块将按照个性贡献分数进行排行并通过API将排行数据返回给第三方网站用户页面，以便用户查看。本实施例通过公式和公式，能够重新对贡献者用于进行排行的贡献分数进行调整，具体表现为用户关注的评分参数越少，一般认为用户在6个评分参数中这些关注度为1的评分参数更受用户重视，则该评分参数在个性贡献分数中的权重应当越高。如表1所示，其展示了当用户关注不同数量的评分参数时，各评分参数权重的变化情况。表1 自定义权重表格参照表1可见，本实施例进行个性贡献分数计算时，能够保证用户关注的每个评分参数的权重都不低于用户不关注的评分参数的权重，并且用户关注的所有评分参数的总权重不低于用户不关注的评分参数的总权重，如此，可以保证在进行个性贡献分数计算时，用户关注的评分参数对贡献分数的占比较大，保证在进行分数排行时将用户关注的内容排列到越前列，使用户通过贡献者排行上的链接快速跳转至该贡献者对应的贡献介绍页面查看自己感兴趣的内容时可以快速的命中，推荐精度更高。另外的，通过本实施例进行个性贡献分数计算时，能保证在用户关注的评分参数越少，则认为用户越重视该评分参数，所以为该评分参数分配越多的权重，如表1所示，当用户只关注2个评分参数时，各关注度为1的评分参数的权重为1/3，当用户只关注3个评分参数时，各关注度为1的评分参数的权重为1/4，显然，如此能够保证进行贡献分数计算时用户关注度越高的评分参数获得越高的权重，使得用户最关注的评分参数对贡献分数影响最大，从而使得在该评分参数做出最大贡献的贡献者能够尽可能出现在排行榜的前列，进一步提升推荐的精度。需要说明的是，随着用户关注的评分参数数量的增加，例如增加至5个时，此时可以认为用户并不存在需要特别关注某个评分参数，所以如表1所示，此时关注度为1和关注度为0的评分参数的权重相同。现有技术中，一个程序员可能在多个代码托管平台注册了账号，而程序员在其电脑上配置Git工具时设置的账号称之为提交者账号。此处有必要对提交以及推送进行解释，提交是在Git工具上通过“git commit”命令来触发的操作，gitcommit 命令主要是将暂存区里的改动提交到本地的版本库。每次使用 git commit 命令我们都会在本地版本库生成一个 40 位的哈希值，这个哈希值也叫 commit-id。推送是在Git工具上完成了提交操作之后，执行的操作，通过“git push”命令来触发，git push 命令用于将本地分支的更新，推送到远程主机，远程主机即代码托管平台对应的服务器，在向该远程主机推送更新数据时需要登录该远程代码托管平台对应的账户。考虑到一个程序员由于工作需求或者个人喜好的原因会拥有多个代码托管平台的推送者账号，但是一个程序员一般是在一台电脑上通过相同的提交者账号对不同代码托管平台进行操作的，所以现有的代码托管平台进行贡献者统计时，一般是以提交者账号作为贡献者。例如，程序员张三有一个提交者账号:zhangsan@csdn.net，三个推送者账号: zhangsan@github.com，zhangsan@gitlab.com，zhangsan@gitline.com，而开源软件在github、gitlab和gitline三个代码托管平台上都部署了开源软件项目，则当张三无论向哪个代码托管平台上的该开源软件项目推送代码时，都会根据提交者账号来识别贡献者，从而可以将张三在三个代码托管平台上的贡献数据都全面进行统计，避免遗漏。上述现有技术存在如下问题：当存在程序员偶尔借用其他同事的电脑对代码进行提交并推送至代码托管平台的情况时，就会出现提交者账号是同事的，而推送者账号是自己的情况。此时若是认为本次推送的代码贡献者为提交者账号显然是误判，考虑到上述情况，提供如下解决方案：在一个示例中，当检测到该份代码更新数据中的提交者账号为未注册账号时，则为所述提交者账号进行注册并将该份代码更新数据中的提交者账号和推送者账号进行绑定，并将该份代码更新数据标记为所述提交者账号的数据。例如，张三首次向GitHub平台中的该开源软件项目推送代码时，webhook会被触发从而向开源软件贡献者数据处理平台发送代码更新数据，开源软件贡献者数据处理平台的数据汇总模块会将该份代码更新数据中的提交者账号进行注册并将该份代码更新数据中的提交者账号和推送者账号zhangsan@github.com进行绑定，并将该份代码更新数据标记为所述提交者账号的数据。在一个示例中，当检测到该份代码更新数据中的提交者账号为已注册账号且检测到该份代码更新数据中的推送者账号与其他已注册的提交者账号不存在绑定关系时，则将该份代码更新数据中的推送者账号与提交者账号进行绑定并将该份代码更新数据标记为与所述提交者账号以及所述推送者账号关联的数据。例如，张三第二次是通过gitline平台对该开源软件项目进行代码推送的，Gitline平台上的配置的webhook会被触发从而向开源软件贡献者数据处理平台发送代码更新数据，开源软件贡献者数据处理平台的数据汇总模块会将该份代码更新数据中的推送者账号与提交者账号进行绑定并将该份代码更新数据标记为与所述提交者账号以及所述推送者账号关联的数据。可知，此时提交者账号绑定了两个推送者账号。此后，每一次张三向代码托管平台推送代码时，webhook会被触发从而向开源软件贡献者数据处理平台发送代码更新数据，开源软件贡献者数据处理平台的数据汇总模块会将该份代码更新数据中的推送者账号与提交者账号进行绑定并将该份代码更新数据标记为与所述提交者账号以及所述推送者账号关联的数据。上述实施例中，开源软件贡献者数据处理平台会统计每份代码更新数据中提交者账号和推送者账号的关联情况，根据推送者账号与提交者账号共同关联的代码更新数据的数量来识别出每个推送者账号常用的电脑，由于提交者账号与安装在电脑上的Git工具绑定，所以此处可以认为提交者账号与程序员的电脑是绑定的，能够通过提交者账号识别出某个推送者账号对应的常用的电脑。如图5所示，在一个实施例中，所述方法还包括：对于获取到的每份代码更新数据执行以下步骤：步骤S402，检测该份代码更新数据中的提交者账号和推送者账号。步骤S404，当检测到该份代码更新数据中的提交者账号为已注册账号且检测到该份代码更新数据中的推送者账号与其他已注册的提交者账号存在绑定关系的情况下，检测到第一数量和第二数量的差值小于第一阈值时，将该份代码更新数据标记为与其他已注册提交者账号以及所述推送者账号关联的数据。其中，第一数量为该推送者账号与当前提交者账号共同关联的代码更新数据的数量，第二数量为该推送者账号与其他已注册的提交者账号共同关联的代码更新数据的数量。举例来说，张三的电脑不在身边或电脑坏了，于是借了李四的电脑来用，则其第30次向该开源软件贡献代码时用的电脑就不是自己的，该电脑上的Git工具配置的提交者账号为lisi@csdn.net，张三在该电脑上通过Git工具执行“git commit”进行提交之后，登录自己的gitlab平台账号，即zhangsan@gitlab.com，然后通过Git工具执行了“git push”指令，Gitlab平台上的配置的webhook会被触发从而向开源软件贡献者数据处理平台发送代码更新数据，数据汇总模块检测到该份代码更新数据中的提交者账号为已注册账号且该份代码更新数据中的推送者账号与其他已注册的提交者账号存在绑定关系，则会对第一数量和第二数量进行检测。例如该推送者账号与当前提交者账号共同关联的代码更新数据的数量为0，即第一数量为0，该推送者账号与其他已注册的提交者账号共同关联的代码更新数据的数量为12，即第二数量为12，第一数量和第二数量的差值为-12，第一阈值为-5，则差值-12小于第一阈值-5，将该份代码更新数据标记为与其他已注册提交者账号以及所述推送者账号关联的数据。可以理解的是，本实施例中，显然zhangsan@gitlab.com这个推送者账号与其他已注册的提交者账号共同关联的代码更新数据的数量远远大于与当前提交者账号共同关联的代码更新数据的数量，因此可以认为配置有其他已注册的提交者账号的电脑是该程序员自己的电脑或常用的电脑，而配置有当前提交者账号的电脑是该程序员临时借用的电脑，所以需要对贡献数据进行修正，即将该份代码更新数据标记为与其他已注册提交者账号以及所述推送者账号关联的数据。同理，当检测到第一数量和第二数量的差值大于第二阈值时，将该份代码更新数据标记为与当前提交者账号以及所述推送者账号关联的数据。例如，张三第31次向该开源软件贡献代码时用的电脑是自己的，该电脑上的Git工具配置的提交者账号为zhangsan@csdn.net，张三在该电脑上通过Git工具执行“git commit”进行提交之后，登录自己的gitlab平台账号，即zhangsan@gitlab.com，然后通过Git工具执行了“git push”指令，Gitlab平台上的配置的webhook会被触发从而向开源软件贡献者数据处理平台发送代码更新数据，数据汇总模块检测到该份代码更新数据中的当前提交者账号为已注册账号且该份代码更新数据中的推送者账号与其他已注册的提交者账号存在绑定关系，则会对第一数量和第二数量进行检测。例如该推送者账号与当前提交者账号共同关联的代码更新数据的数量为12，即第一数量为12，该推送者账号与其他已注册的提交者账号共同关联的代码更新数据的数量为1，即第二数量为1，第一数量和第二数量的差值为11，第二阈值为5，则差值11大于第二阈值5，将将该份代码更新数据标记为与当前提交者账号以及所述推送者账号关联的数据。可以理解的是，本实施例中，显然zhangsan@gitlab.com这个推送者账号与当前提交者账号共同关联的代码更新数据的数量远远大于与其他已注册的提交者账号共同关联的代码更新数据的数量，因此可以认为配置有其他已注册的提交者账号的电脑是该程序员临时借用的电脑，可以忽略。即将该份代码更新数据标记为与当前提交者账号以及所述推送者账号关联的数据。在一个实施例中，检测到第一数量和第二数量的差值不小于第一阈值且不大于第二阈值时，将该份代码更新数据标记为与当前提交者账号以及所述推送者账号关联的数据。可以理解的是，若是一个推送者账号同时与两个已注册的提交者账号存在绑定关系，并且该推送者账号通过两个已注册提交者账号提交的代码数量差值X不是很大，例如在第一阈值和第二阈值之间，-5≤X≤5，则说明分别配置有两个提交者账号的两台电脑均是该程序员常用的电脑，即当前使用的电脑也是程序员的电脑，当前提交者账号也是同一个程序员的账号，所以将该份代码更新数据标记为与当前提交者账号以及所述推送者账号关联的数据。如图6所示，在一个实施例中，所述方法还包括计算贡献者的未采用代码贡献分数的步骤，具体包括：步骤S502，获取该贡献者向所有代码托管平台中开源软件项目推送的未被采用代码。对于每一份未被采用代码：步骤S504，选取第一推送时间晚于第二推送时间的被采用代码作为目标代码；其中，第一推送时间为被采用代码向各代码托管平台进行推送的时间，第二推送时间为未被采用代码向各代码托管平台进行推送的时间。步骤S506，检测该份未被采用代码与多份相应的目标代码的文本相似度得到多个文本相似度结果。步骤S508，基于分值最高的文本相似度结果与预设相似度阈值的差值，得到该份未被采用代码的代码贡献子分数。具体的，所述基于分值最高的文本相似度结果与预设相似度阈值的差值，得到该份未被采用代码的代码贡献子分数，具体包括：步骤S5081，当分值最高的文本相似度结果与预设相似度阈值的差值不大于零时，将该份未被采用代码的代码贡献子分数设置为零。步骤S5082，当分值最高的文本相似度结果与预设相似度阈值的差值大于零时，将该份未被采用代码的代码贡献子分数设置为分值最高的文本相似度结果与预设相似度的阈值。可以理解的是，代码之间的文本相似度计算属于现有技术，此处不再赘述，本实施例的主要技术贡献在于对未被采用代码的贡献进行了研究，发现了未被采用代码的贡献作为被采用代码改进基础情况下，其贡献存在被忽略的问题，并通过将被采用的代码与在被采用代码之前推送的未被采用代码进行文本相似度计算来找到未被采用代码的贡献情况。步骤S510，统计该贡献者所有未被采用代码的代码贡献子分数得到该贡献者的未采用代码贡献分数。为了保证开源软件项目代码质量，并不会对所有贡献者的每一份代码都进行采用，而是会由专家进行审核之后才会采用。这就可能导致很多用户虽然贡献了很多代码，但是一份都未被采用。然而，存在以下情况，虽然某个贡献者A的代码并未被采用，但是被采用的代码实际是基于该贡献者A的代码作为改进基础，这种情况下如果认为A完全没有贡献，显然是不公平的，也会打击A的积极性。因此，在开源软件项目进行贡献者评分时，不能够忽略A这一类的用户的贡献。而现有的开源软件项目在进行公布贡献的时候，一般都是以最终被专家审核通过采用之后的代码来进行公布宣传的，这对于提供了改进基础而未被采用的用户很不友好。本实施例中，为了克服上述问题，提供了计算贡献者的未采用代码贡献分数的方法，其会检测检测该份未被采用代码与多份相应的目标代码的文本相似度得到多个文本相似度结果，由于其中被采用的目标代码都是晚于未被采用代码进行推送的，若是某分代码虽然未被采用，但是其推送到代码托管平台的时间早于被采用代码推送的代码托管平台的时间，则被采用的代码就有可能是基于该未被采用代码而进行的改进，并且文本相似度越高，则认为被采用代码在未被采用代码基础上需要改进的内容越少，即未被采用代码的贡献越大。因此，通过本实施例，能够统计未被采用代码对于被采用代码做出的贡献。图7示出了一个实施例中计算机设备的内部结构图。该计算机设备具体可以是终端或服务器。如图7所示，该计算机设备包括通过系统总线连接的处理器、存储器、网络接口、输入装置和显示屏。其中，存储器包括非易失性存储介质和内存储器。该计算机设备的非易失性存储介质存储有操作系统，还可存储有计算机程序，该计算机程序被处理器执行时，可使得处理器实现开源软件贡献者数据处理方法。该内存储器中也可储存有计算机程序，该计算机程序被处理器执行时，可使得处理器执行开源软件贡献者数据处理方法。本领域技术人员可以理解，图7中示出的结构，仅仅是与本发明方案相关的部分结构的框图，并不构成对本发明方案所应用于其上的计算机设备的限定，具体的计算机设备可以包括比图中所示更多或更少的部件，或者组合某些部件，或者具有不同的部件布置。在一个实施例中，本申请提供的开源软件贡献者数据处理装置可以实现为一种计算机程序的形式，计算机程序可在如图7所示的计算机设备上运行。计算机设备的存储器中可存储组成该开源软件贡献者数据处理装置的各个程序模块，比如，图1所示的数据汇总模块、加权处理模块、技术排行模块。各个程序模块构成的计算机程序使得处理器执行本说明书中描述的本申请各个实施例的开源软件贡献者数据处理方法中的步骤。例如，图7所示的计算机设备可以通过如图1所示的开源软件贡献者数据处理装置中的数据汇总模块执行获取各代码托管平台对应的代码更新数据的步骤。通过加权处理模块执行基于各代码托管平台对应的代码更新数据实时统计各贡献者对应的贡献数据得到贡献分数的步骤。通过计算排行模块执行根据所述贡献分数对各贡献者进行排行的步骤。在一个实施例中，提供了一种电子设备，包括：存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，所述处理器执行所述程序时执行上述开源软件贡献者数据处理方法的步骤。此处开源软件贡献者数据处理方法的步骤可以是上述各个实施例的开源软件贡献者数据处理方法中的步骤。在一个实施例中，提供了一种计算机可读存储介质，所述计算机可读存储介质存储有计算机可执行指令，所述计算机可执行指令用于使计算机执行上述开源软件贡献者数据处理方法的步骤。此处开源软件贡献者数据处理方法的步骤可以是上述各个实施例的开源软件贡献者数据处理方法中的步骤。本领域普通技术人员可以理解实现上述实施例方法中的全部或部分流程，是可以通过计算机程序来指令相关的硬件来完成，所述的程序可存储于一非易失性计算机可读取存储介质中，该程序在执行时，可包括如上述各方法的实施例的流程。其中，本申请所提供的各实施例中所使用的对存储器、存储、数据库或其它介质的任何引用，均可包括非易失性和/或易失性存储器。非易失性存储器可包括只读存储器、可编程ROM、电可编程ROM、电可擦除可编程ROM或闪存。易失性存储器可包括随机存取存储器或者外部高速缓冲存储器。作为说明而非局限，RAM以多种形式可得，诸如静态RAM、动态RAM、同步DRAM、双数据率SDRAM、增强型SDRAM、同步链路DRAM、存储器总线直接RAM、直接存储器总线动态RAM、以及存储器总线动态RAM等。以上实施例的各技术特征可以进行任意的组合，为使描述简洁，未对上述实施例中的各个技术特征所有可能的组合都进行描述，然而，只要这些技术特征的组合不存在矛盾，都应当认为是本说明书记载的范围。

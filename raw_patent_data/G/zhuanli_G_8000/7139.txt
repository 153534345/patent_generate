标题title
一种数据持久化方法、服务器及管理设备
摘要abst
本申请提供了一种数据持久化方法、服务器及管理设备，所述数据持久化方法包括：通过第一线程轮询存储有原始单据数据的第一缓存队列，得到目标单据数据，并复制到第二缓存队列中；第一线程对目标单据数据进行持久化处理，得到目标单据数据的第一处理结果；若第一处理结果指示处理成功，则第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；若第一处理结果指示处理失败，则第一线程将处理失败的目标单据数据插入至第三缓存队列，并第二线程周期性地对第三缓存队列中的目标单据数据进行持久化处理。根据该持久化方法能够对处理失败的目标单据再次进行持久化处理，以确保得到处理成功的目标单据数据。
权利要求书clms
1.一种数据持久化方法，其特征在于，所述数据持久化方法应用于服务器，所述数据持久化方法包括：通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列；通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列；通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果；若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。2.根据权利要求1所述的数据持久化方法，其特征在于，在通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列之后，所述数据持久化方法还包括：通过第三线程轮询所述第二缓存队列中的目标单据数据，并获取目标单据数据在所述第二缓存队列中的第一存储时间；当所述第一存储时间大于第一时间阈值时，通过所述第三线程将所述第二缓存队列中的目标单据数据恢复至所述第一缓存队列。3.根据权利要求1所述的数据持久化方法，其特征在于，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，所述数据持久化方法还包括：对所述原始单据数据进行复制，并将复制得到的原始单据数据存储至第二数据库；所述第二数据库为具有高写入效率的非关系型数据库。4.根据权利要求3所述的数据持久化方法，其特征在于，所述数据持久化方法还包括：通过第四线程轮询所述第一数据库，以获取处理成功的目标单据数据；通过所述第四线程轮询所述第二数据库，以获取复制得到的原始单据数据；通过所述第四线程将所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据进行匹配，以得到匹配结果；若所述匹配结果指示所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据匹配失败，则通过所述第四线程获取所述第二数据库中复制得到的原始单据数据的第二存储时间；当所述第二存储时间大于第二时间阈值时，通过所述第四线程将所述第二数据库中的原始单据数据恢复至所述第一缓存队列。5.一种数据持久化方法，其特征在于，所述数据持久化方法应用于管理设备，所述数据持久化方法包括：使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号；使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号；针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号；将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。6.根据权利要求5所述的数据持久化方法，其特征在于，当所述服务器的数量大于所述缓存队列集合中的第一缓存队列的数量时；通过以下方式得到缓存队列集合：识别当前时刻多个第一缓存队列的队列状态；若成功识别出任一第一缓存队列处于空闲状态，则监测该第一缓存队列处于空闲状态的持续时间，当所述空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合；若在第三预设时间间隔内未识别出任一第一缓存队列处于空闲状态，则增加第一缓存队列，以得到缓存队列集合。7.一种服务器，其特征在于，所述服务器包括：轮询模块、复制模块、第一处理模块、第一存储模块以及第二处理模块；所述轮询模块，用于通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列；所述复制模块，用于通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列；所述第一处理模块，用于通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果；所述第一存储模块，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；所述第二处理模块，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。8.一种管理设备，其特征在于，所述管理设备包括：第一标识模块、第二标识模块、计算模块以及确定模块；所述第一标识模块，用于使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号；所述第二标识模块，用于使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号；所述计算模块，用于针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号；所述确定模块，用于将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。9.一种电子设备，其特征在于，包括：处理器、存储器和总线，所述存储器存储有所述处理器可执行的机器可读指令，当电子设备运行时，所述处理器与所述存储器之间通过所述总线通信，所述机器可读指令被所述处理器执行时执行如权利要求1-6中任一项所述方法的步骤。10.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质上存储有计算机程序，所述计算机程序被处理器运行时执行如权利要求1-6任一所述方法的步骤。
说明书desc
技术领域本申请涉及单据处理技术领域，尤其是涉及一种数据持久化方法、服务器及管理设备。背景技术数据持久化是指将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称，其中，数据模型可以是任何数据结构或者数据对象，存储模型可以是关系模型、XML、二进制流等。常用的数据持久化方法为：服务端同步处理数据的方法，具体的，客户端将数据上传至服务端，服务端立即调用逻辑处理模块对数据进行处理，处理成功则将相应的数据存储至数据库，以实现持久化，处理失败则告知客户端原因。但是，这种服务器同步处理数据的方法，由于数据在持久化成功之前，客户端必须要等待服务端的处理结果，方能继续上传数据，这样便会阻塞客户端的上传操作，造成客户端的长时间等待，导致用户体验较差。为了解决上述存在的问题，目前主要采用服务端异步处理数据的方法来实现数据持久化，具体地，异步处理数据的方法为：客户端将数据上传至服务端的缓存队列，然后调用单独的线程对缓存队列中的数据进行处理，处理成功则将相应的数据存储至单据库，以实现持久化，处理失败则告知客户端原因。然而，上述采用服务端异步处理单据的方法，在持久化的过程中若持久化失败，会存在数据丢失的问题。发明内容有鉴于此，本申请的目的在于提供一种数据持久化方法、服务器及管理设备，使用第三缓存队列来存储被第一线程处理失败的目标单据数据，以解决在持久化处理失败的目标单据数据易丢失的问题，同时可以通过第二线程对第三缓存队列中的目标单据数据再次进行持久化处理，能够对持久化处理失败的目标单据再次进行持久化处理，以确保目标单据数据被成功持久化。本申请实施例提供了一种数据持久化方法，所述数据持久化方法应用于服务器，所述数据持久化方法包括：通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列；通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列；通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果；若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。进一步的，在通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列之后，所述数据持久化方法还包括：通过第三线程轮询所述第二缓存队列中的目标单据数据，并获取目标单据数据在所述第二缓存队列中的第一存储时间；当所述第一存储时间大于第一时间阈值时，通过所述第三线程将所述第二缓存队列中的目标单据数据恢复至所述第一缓存队列。进一步的，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，所述数据持久化方法还包括：对所述原始单据数据进行复制，并将复制得到的原始单据数据存储至第二数据库；所述第二数据库为具有高写入效率的非关系型数据库。进一步的，所述数据持久化方法还包括：通过第四线程轮询所述第一数据库，以获取处理成功的目标单据数据；通过所述第四线程轮询所述第二数据库，以获取复制得到的原始单据数据；通过所述第四线程将所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据进行匹配，以得到匹配结果；若所述匹配结果指示所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据匹配失败，则通过所述第四线程获取所述第二数据库中复制得到的原始单据数据的第二存储时间；当所述第二存储时间大于第二时间阈值时，通过所述第四线程将所述第二数据库中的原始单据数据恢复至所述第一缓存队列。本申请另一实施例提供了一种数据持久化方法，所述数据持久化方法应用于管理设备，所述数据持久化方法包括：使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号；使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号；针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号；将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。进一步的，当所述服务器的数量大于所述缓存队列集合中的第一缓存队列的数量时；通过以下方式得到缓存队列集合：识别当前时刻多个第一缓存队列的队列状态；若成功识别出任一第一缓存队列处于空闲状态，则监测该第一缓存队列处于空闲状态的持续时间，当所述空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合；若在第三预设时间间隔内未识别出任一第一缓存队列处于空闲状态，则增加第一缓存队列，以得到缓存队列集合。本申请实施例还提供了一种服务器，所述服务器包括：轮询模块、复制模块、第一处理模块、第一存储模块以及第二处理模块；所述轮询模块，用于通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列；所述复制模块，用于通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列；所述第一处理模块，用于通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果；所述第一存储模块，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；所述第二处理模块，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。进一步的，所述服务器还包括：第一数据恢复模块，在通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列之后，所述第一数据恢复模块用于：通过第三线程轮询所述第二缓存队列中的目标单据数据，并获取目标单据数据在所述第二缓存队列中的第一存储时间；当所述第一存储时间大于第一时间阈值时，通过所述第三线程将所述第二缓存队列中的目标单据数据恢复至所述第一缓存队列。进一步的，所述服务器还包括：第二存储模块，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，所述第二存储模块用于：对所述原始单据数据进行复制，并将复制得到的原始单据数据存储至第二数据库；所述第二数据库为具有高写入效率的非关系型数据库。进一步的，所述服务器还包括：第二数据恢复模块，所述第二数据恢复模块用于：通过第四线程轮询所述第一数据库，以获取处理成功的目标单据数据；通过所述第四线程轮询所述第二数据库，以获取复制得到的原始单据数据；通过所述第四线程将所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据进行匹配，以得到匹配结果；若所述匹配结果指示所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据匹配失败，则通过所述第四线程获取所述第二数据库中复制得到的原始单据数据的第二存储时间；当所述第二存储时间大于第二时间阈值时，通过所述第四线程将所述第二数据库中的原始单据数据恢复至所述第一缓存队列。本申请实施例还提供了一种管理设备，所述管理设备包括：第一标识模块、第二标识模块、计算模块以及确定模块；所述第一标识模块，用于使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号；所述第二标识模块，用于使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号；所述计算模块，用于针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号；所述确定模块，用于将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。进一步的，所述管理设备还包括：调整模块，当所述服务器的数量大于所述缓存队列集合中的第一缓存队列的数量时，所述调整模块用于通过以下方式得到缓存队列集合：识别当前时刻多个第一缓存队列的队列状态；若成功识别出任一第一缓存队列处于空闲状态，则监测该第一缓存队列处于空闲状态的持续时间，当所述空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合；若在第三预设时间间隔内未识别出任一第一缓存队列处于空闲状态，则增加第一缓存队列，以得到缓存队列集合。本申请实施例还提供一种电子设备，包括：处理器、存储器和总线，所述存储器存储有所述处理器可执行的机器可读指令，当电子设备运行时，所述处理器与所述存储器之间通过总线通信，所述机器可读指令被所述处理器执行时执行如上述的数据持久化方法的步骤。本申请实施例还提供一种计算机可读存储介质，该计算机可读存储介质上存储有计算机程序，该计算机程序被处理器运行时执行如上述的数据持久化方法的步骤。本申请实施例提供的数据持久化方法、服务器及管理设备，通过使用第三缓存队列来存储被第一线程处理失败的目标单据数据，以解决在持久化处理失败的目标单据数据易丢失的问题，同时可以通过第二线程对第三缓存队列中的目标单据数据再次进行持久化处理，能够对持久化处理失败的目标单据再次进行持久化处理，以确保目标单据数据被成功持久化。此外，基于动态变化的第一缓存队列的数量，通过求余函数来确定多个服务器各自对应的第一缓存队列，以提高服务器的利用率。为使本申请的上述目的、特征和优点能更明显易懂，下文特举较佳实施例，并配合所附附图，作详细说明如下。附图说明为了更清楚地说明本申请实施例的技术方案，下面将对实施例中所需要使用的附图作简单地介绍，应当理解，以下附图仅示出了本申请的某些实施例，因此不应被看作是对范围的限定，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他相关的附图。图1示出了本申请实施例所提供的一种数据持久化方法的流程图；图2示出了本申请实施例所提供的将目标单据数据恢复至第一缓存队列的步骤的流程图；图3示出了本申请另一实施例所提供的一种数据持久化方法的流程图；图4示出了本申请实施例所提供的一种服务器的结构示意图；图5示出了本申请实施例所提供的一种管理设备的结构示意图；图6示出了本申请实施例所提供的一种电子设备的结构示意图。具体实施方式为使本申请实施例的目的、技术方案和优点更加清楚，下面将结合本申请实施例中附图，对本申请实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例仅仅是本申请一部分实施例，而不是全部的实施例。通常在此处附图中描述和示出的本申请实施例的组件可以以各种不同的配置来布置和设计。因此，以下对在附图中提供的本申请的实施例的详细描述并非旨在限制要求保护的本申请的范围，而是仅仅表示本申请的选定实施例。基于本申请的实施例，本领域技术人员在没有做出创造性劳动的前提下所获得的每个其他实施例，都属于本申请保护的范围。经研究发现，数据持久化是指将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称，其中，数据模型可以是任何数据结构或者数据对象，存储模型可以是关系模型、XML、二进制流等。常用的数据持久化方法为：服务端同步处理数据的方法，具体的，客户端将数据上传至服务端，服务端立即调用逻辑处理模块对数据进行处理，处理成功则将相应的数据存储至数据库，以实现持久化，处理失败则告知客户端原因。但是，这种服务器同步处理数据的方法，由于数据在持久化成功之前，客户端必须要等待服务端的处理结果，方能继续上传数据，这样便会阻塞客户端的上传操作，造成客户端的长时间等待，导致用户体验较差。为了解决上述存在的问题，目前主要采用服务端异步处理数据的方法来实现数据持久化，具体地，异步处理数据的方法为：客户端将数据上传至服务端的缓存队列，然后调用单独的线程对缓存队列中的数据进行处理，处理成功则将相应的数据存储至单据库，以实现持久化，处理失败则告知客户端原因。然而，上述采用服务端异步处理单据的方法，在持久化的过程中若持久化失败，会存在数据丢失的问题。基于此，本申请实施例提供了一种数据持久化方法，所述数据持久化方法应用于服务器，能够对持久化处理失败的目标单据再次进行持久化处理，以确保目标单据数据被成功持久化。请参阅图1，图1为本申请实施例所提供的一种数据持久化方法的流程图。如图1中所示，本申请实施例提供的数据持久化方法，包括：S101、通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列。该步骤中，服务器接收客户端发送的原始单据数据，然后根据预先建立的服务器和第一缓存队列之间的对应关系，确定出该目标服务器对应的第一缓存队列，将原始单据数据插入至该第一缓存队列。服务器通过第一线程轮询第一缓存队列，其中，轮询可以是周期性的，进一步的，轮询周期可以根据实际情况进行设置，申请人在此不做任何限定。通过第一线程从第一缓存队列中取出目标单据数据的数据内容，但是仍将可以表征目标单据数据的状态编号保留在第一缓存队列中，以便客户端可以根据目标单据数据的状态编号，获取到目标单据数据的处理状态。这里，原始单据数据为客户端发送至服务器的单据数据。此外，所述数据持久化方法还包括对所述第一缓存队列进行加锁的步骤，具体的说，所述第一线程在轮询所述第一缓存队列时，还包括：所述第一线程对所述第一缓存队列进行加锁。该步骤中，由于第一缓存队列会对应有多个服务器，每个服务器都可以创建自己的第一线程，因此，也可以有多个第一线程，这样，会存在一个目标单据数据可能会被多个服务器各自对应的第一线程取出的情况。因此，在任一服务器创建的第一线程访问第一缓存队列时，首先将该第一缓存队列进行加锁，以防止在第一缓存队列取出目标单据数据的过程中，该目标单据数据被其他服务器创建的第一线程取出。在该第一线程取出目标单据数据之后，将第一缓存队列释放。作为示例，第一线程可以使用LUA脚本对第一缓存队列进行加锁，此外，还可以通过其他方式对第一缓存队列进行加锁，申请人在此不做任何限定。此外，所述数据持久化方法还包括对原始单据数据进行预处理的步骤，具体的说，在将所述单据数据插入至第一缓存队列之前，所述数据持久化方法还包括：步骤1011、针对于每一个原始单据数据，获取该原始单据数据的编号和处理状态的标识。该步骤中，服务器接收到客户端上传的原始单据数据，通常将原始单据数据的编号和原始单据数据的处理状态的标识进行单独存储，因此，可以通过以下方式获取该原始单据数据的编号和该原始单据数据的处理状态的标识：首先获取该原始单据数据的识编号，然后基于该原始单据数据的编号获取该原始单据数据的处理状态的标识。作为示例，可以使用数字序列、字母序列以及数字与字母的结合来表示单据数据的编号，申请人在这里不做任何限定。作为其中一个示例，单据数据的编号可以表示为SNO，单据数据的编号被用于表征该单据数据。此外，可以将单据数据的处理状态分为已上传、已完成以及未上传等，其中，已上传表示该单据数据仅被上传至服务器，还未进行持久化处理；已完成表示该单据数据已经被成功持久化处理；未上传表示该单据数据暂未上传至服务器。进一步的，可以使用不同的处理状态的标识来表示不同的单据数据的处理状态，具体的，已上传的标识可以表示为001；已完成的标识可以表示为002；未上传的标识可以表示为000。作为示例，存储于客户端的单据数据的处理状态为未上传，标识表示为000，客户端将原始单据数据发送至服务器之后，服务器首先获取该原始单据数据的编号SNO，此时，然后将单据数据的处理状态的标识更改为已上传001。步骤1012、将所述原始单据数据的编号和所述处理状态的标识进行拼接，得到该原始单据数据的状态编号。该步骤中，将原始单据数据的编号与该原始单据数据的处理状态进行拼接，得到可以表征该原始单据处理状态的新的编号，即状态编号。作为示例，服务器将获取得到的单据数据的编号SNO和单据数据的处理状态的标识001进行拼接，得到该单据数据的状态编号SNO-001。步骤1013、使用该状态编号表征所述原始单据数据的处理状态。该步骤中，服务器将原始单据数据的编号更改为状态编号，使用该状态编号来表征原始单据数据的处理状态，以使服务器通过获取单据数据的编号便能够获得该单据数据的处理状态。相较于现有的使用单据数据的编号来表征单据数据的方式，简化了获取单据数据的处理状态的过程。S102、通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列。该步骤中，由于目标单据数据在持久化过程中会存在数据丢失的情况，因此，在通过第一线程轮询所述第一缓存队列，以得到目标单据数据之后，第一线程还可以将目标单据数据进行复制，并将复制得到的目标单据数据存储至第二缓存队列中，以实现对目标单据数据的备份。步骤S103、通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果。该步骤中，第一线程通过调用预先设置的处理逻辑，对目标单据数据进行逻辑处理，以得到目标单据数据的第一处理结果。这里，第一处理结果可以表征处理持久化处理成功，也可以表征持久化处理失败。若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功则执行步骤S104，若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据。该步骤中，当第一处理结果指示目标单据数据被第一线程处理成功时，可以将该目标单据数据存储至第一数据库中，已完成目标单据数据的持久化。其中，第一数据库为具有较高查询性能的关系型数据库。作为示例，该关系型数据库可以是Oracle数据库，此外，还可以是其他具有较高查询性能的关系型数据库，申请人在此不做任何限定。这里，第一线程将持久化处理成功的目标单据数据存储至第一数据库中时，还同步更新该目标单据数据在第一缓存队列中的状态编号以及删除第二缓存队列中对应的目标单据数据。其中，新该目标单据数据在第一缓存队列中的状态编号具体可以包括：将状态编号中表征处理状态的标识由已上传更改为已完成。若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则执行步骤S105、若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。该步骤中，当第一处理结果指示目标单据数据被第一线程处理失败时，则将该目标单据数据插入至第三缓存队列。进一步的，当第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对目标单据进行持久化处理，直至第三缓存队列中不存在处理失败的单据数据。其中，通过第二线程对第三缓存队列中的目标单据数据进行持久化处理，会得到目标单据数据的第二处理结果，当第二处理结果指示目标单据数据被第二线程处理成功时，则通过第二线程将处理成功的目标单据数据存储至第一数据库；当第二处理结果指示目标单据数据被第二线程处理失败时，则增加对第三缓存队列中的目标单据数据进行持久化处理的周期，即增加两次持久化处理的间隔时间。请参阅图2，图2为本申请实施例所提供的将目标单据数据恢复至第一缓存队列的步骤的流程图。实施该步骤，如图2所示，将目标单据数据恢复至第一缓存队列的步骤，包括：步骤S201、通过第三线程轮询所述第二缓存队列中的目标单据数据，并获取目标单据数据在所述第二缓存队列中的第一存储时间。该步骤中，第三线程轮询第二缓存队列中的目标单据数据，并获取目标单据数据在第二缓存队列中的第一存储时间。具体的，第三线程可以周期性轮询第二缓存队列中的目标单据数据，其中，轮询周期可以根据实际情况进行设置。作为示例，可以根据目标单据数据的数量设定第三线程的轮询周期，当目标单据数据较多时，可以设置较短的轮询周期，当目标单据数据较少时，可以设置较长的轮询周期。由于第二缓存队列中的目标单据数据并不是一直存在的，而是基于持久化过程所需的时间，具有相应的存储时间，因此，可以通过获取目标破单据数据在第二缓存队列中的第一存储时间，以判断目标单据数据是否在持久化过程中丢失。步骤S202、当所述第一存储时间大于第一时间阈值时，通过所述第三线程将所述第二缓存队列中的目标单据数据恢复至所述第一缓存队列。该步骤中，当第一存储时间大于第一时间阈值时，则认为目标单据数据在持久化过程中丢失，因此，通过第三线程将第二缓存队列中的目标单据数据恢复至第一缓存队列，以使第一线程可以重新从第一缓存队列中获取到在上一次持久化过程中被丢失的目标单据数据，并对其再次进行持久化处理。在具体实施时，所述数据持久化方法还包括从第二缓存队列中删除目标单据数据的步骤，具体的说，在将处理成功的目标单据数据存储至第一数据库之后，还包括：从所述第二缓存队列中将将处理成功的目标单据数据删去。该步骤中，目标单据数据无论第一线程处理成功，还是被第二线程处理成功，都会将处理成功的目标单据数据存储至第一数据库，因此，再将将处理成功的目标单据数据存储至第一数据库之后，从第二缓存队列中将将处理成功的目标单据数据删去，以避免浪费资源对处理成功的目标单据数据重复进行持久化处理。此外，所述数据持久化方法还包括对接收到客户端发送的原始单据数据进行备份的步骤，具体的说，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，还包括：对所述原始单据数据进行复制，并将复制得到的原始单据数据存储至第二数据库。所述第二数据库为具有高写入效率的非关系型数据库。这里，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，具体可以为在通过第一线程轮询存储有原始单据数据的第一缓存队列之前。该步骤中，在服务器发生异常情况，重新启动后，存储在第一缓存队列的、第二缓存队列以及第三缓存队列中的目标单据数据都会丢失，因此，在将单据数据存储至第一缓存队列之前，需要将原始单据数据进行复制并存储在第二数据库中，以实现单据数据的备份。其中，第二数据库为非关系型数据库，具有较高的写入效率，同时，在服务器重新启动后，第二数据库中的单据数据不会丢失。此外，所述数据持久化方法还包括将第二数据库的目标单据数据恢复至第一缓存队列的步骤，具体的说，所述数据持久化方法还包括：步骤1061、通过第四线程轮询所述第一数据库，以获取处理成功的目标单据数据。该步骤中，服务器通过第四线程从第一数据库中获取处理成功的目标单据数据。第一数据库中的目标单据数据包括：通过第一线程被处理成功的目标单据数据和通过第二线程被处理成功的目标单据数据。步骤1062、通过第四线程轮询所述第二数据库，以获取复制得到的原始单据数据。该步骤中，服务器通过第四线程从第二数据库中获取复制得到的单据数据。第二数据库中的单据数据是针对客户端发送的单据数据进行复制得到的，也就是未经历持久化过程的单据数据。步骤1063、通过所述第四线程将所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据进行匹配，以得到匹配结果。该步骤中，服务器通过第四线程将第二数据库中复制得到的原始单据数据与第一数据库中的处理成功的单据数据进行匹配，以确定哪些单据数据已经被持久化处理成功。若所述匹配结果指示所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据匹配失败，则执行步骤1064、通过所述第四线程获取所述第二数据库中复制得到的原始单据数据的第二存储时间。该步骤中，第二数据库中复制得到的原始单据数据与第一数据库中处理成功的目标单据数据匹配失败，单据数据可能存在两种情况，其一是，单据数据处于持久化过程中，其二是，单据数据在持久化过程中丢失，那么，需要针对该单据数据采取数据恢复策略。具体的，通过第四线程第二数据库中复制得到的单据数据的第二存储时间。当所述第二存储时间大于第二时间阈值时，执行步骤1065、通过所述第四线程将所述第二数据库中的原始单据数据恢复至所述第一缓存队列。该步骤中，可以通过估测单据数据的持久化处理的时间，预先设置第二时间阈值。当第二存储时间大于第二时间阈值时，认为该单据数据在持久化过程中丢失，则第四线程将单据数据插入至第一缓存队列，以使服务器对该单据数据重新进行持久化处理。本申请实施例提供的数据持久化方法，通过使用第三缓存队列来存储被第一线程处理失败的目标单据数据，以解决在持久化处理失败的目标单据数据易丢失的问题，同时可以通过第二线程对第三缓存队列中的目标单据数据再次进行持久化处理，能够对持久化处理失败的目标单据再次进行持久化处理，以确保目标单据数据被成功持久化。此外，本申请另一实施例提供了一种数据持久化方法，所述数据持久化方法应用于管理设备，能够基于动态变化的第一缓存队列的数量，通过求余函数来确定多个服务器各自对应的第一缓存队列，以提高服务器的利用率。请参阅图3，图3为本申请另一实施例所提供的一种数据持久化方法的流程图。如图3中所示，本申请另一实施例提供的数据持久化方法，数据持久化方法应用于管理设备，包括：步骤S301、使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号。该步骤中，使用正整数依次对多个服务器进行唯一数字标识，以得到各服务器唯一对应的服务器编号。作为示例，服务器的数量可以为m个，使用正整数依次对多个服务器进行唯一数字标识，会得到如下所示的与各服务器唯一对应的服务器编号：服务器1、服务器2、……服务器M，其中，m与M数值相等。步骤S302、使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号。该步骤中，使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，以得到各第一缓存队列唯一对应的队列编号。作为示例，第一缓存队列的数量可以为n个，使用正整数依次对多个第一缓存队列进行唯一数字标识，会得到如下所示的与各第一缓存队列唯一对应的队列编号：第一缓存队列1、第一缓存队列2、……第一缓存队列N，其中，n与N数值相等。其中，所述服务器的数量大于所述缓存队列集合中的第一缓存队列的数量。此外，所述数据持久化方法还包括获取缓存队列集合的步骤，具体的说，可以通过以下方法得到缓存队列集合：步骤3011、识别当前时刻多个第一缓存队列的队列状态。该步骤中，第一缓存队列的队列状态包括：空闲状态和运行状态；其中，空闲状态是指该第一缓存队列中不存在目标单据数据，运行状态是指该第一缓存队列中存在目标单据数据。管理设备可以每隔预定时间间隔，针对每一个第一缓存队列，识别当前时刻该第一缓存队列的队列状态。作为示例，预定时间间隔可以根据实际情况进行设定，即目标单据数据的数量和当前时刻是存在一定的变化规律的，比如当前时刻为早上6点，目标单据数据会较少，那么可以设置较长的预定时间间隔，而当前时刻为晚上6点时，目标单据数据会较多，那么可以设置较短的预定时间间隔。步骤3012、若成功识别出任一第一缓存队列处于空闲状态，则监测该第一缓存队列处于空闲状态的持续时间，当所述空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合。该步骤中，如果识别出任一第一缓存队列处于空闲状态，即存在处于空闲状态的第一缓存队列，那么，管理设备将针对该处于空闲状态的第一缓存队列，监测该第一缓存队列处于空闲状态的持续时间，当空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合。由于当第一缓存队列处于空闲状态时，该第一缓存队列对应的服务器也同样处于空闲状态，当空闲状态大于第二时间阈值时，则认为当前时刻的目标单据数据的数量较少，当前时刻的第一缓存队列的数量相较于目标单据数据的数量存在冗余，相应的，冗余的第一缓存队列对应的服务器也将处于空闲状态，由此会造成服务器资源的浪费，那么，可以通过减少第一缓存队列的数量，来确保服务器资源的有效利用。步骤3012、若在第三预设时间间隔内未识别出任一第一缓存队列处于空闲状态，则增加第一缓存队列，以得到缓存队列集合。该步骤中，如果在第三预设时间间隔内未识别出任一缓存队列处于空闲状态，则认为当前时刻的目标单据数据的数量较多，相应的，通过增加第一缓存队列，以缓解当前时刻各第一缓存队列的压力，同时确保服务器资源的有效利用。步骤S303、针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号。该步骤中，求余函数又称为mod函数，其格式为mod，其中，nExp1为第一数值，nExp2为第二数值，其计算方法为：将两个数值进行除法运算，以得到一个余数。本申请实施例针对该余数函数进行改进，可以通过以下公式得到服务器编号唯一对应的队列编号：+1，其中，M为服务器的服务器编号，n为第一缓存队列的数量。其中，服务器编号唯一对应的队列编号是指：针对一个服务器，通过求余函数，只能够确定出一个队列编号，而一个队列编号可以对应有多个服务器。作为示例，当服务器的数量m为3时，对多个服务器进行编号，将得到各服务器的服务器编号：服务器1、服务器2以及目标服务器3。当第一缓存队列的数量n为2时，对多个第一缓存队列进行编号，将得到各第一缓存队列的队列编号：第一缓存队列1和第二缓存队列2。可以通过公式+1得到服务器1对应的队列编号为2，可以通过公式+1得到服务器2对应的队列编号为1，可以通过公式+1得到服务器3对应的队列编号为2。步骤S304、将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。该步骤中，管理设备将队列编号对应的第一缓存队列确定为该服务器对应的第一缓存队列。作为示例，上述服务器1对应的队列编号为1，服务器2对应的队列编号为2，服务器3对应的队列编号为2，那么，服务器与第一缓存队列的对应关系为：服务器1和3对应于第一缓存队列2，服务器2对应于第一缓存队列1；即服务器1将接收到的客户端发送的单据数据插入至第一缓存队列2，服务器2将接收到的客户端发送的单据数据插入至第一缓存队列1，服务器3将接收到的客户端发送的单据数据插入至第一缓存队列2。本申请另一实施例提供的数据持久化方法，可以基于动态变化的第一缓存队列的数量，通过求余函数来确定多个服务器各自对应的第一缓存队列，以提高服务器的利用率。此外，所述数据持久化方法还包括调整第一缓存队列中的目标单据数据的处理状态的步骤，具体的说，在将处理成功的目标单据数据存储至第一数据库，还包括：通过所述第一线程在所述第一缓存队列中将处理成功的目标单据数据的处理状态进行调整。该步骤中，由于第一缓存队列中将目标单据数据的状态编号进行保留，因此，第一线程可以获取处理成功的目标单据数据的状态编号并将保留在第一缓存队列中的单据数据的处理状态由已上传001更改为已完成002。此外，本申请实施例还提供了一种数据持久化的方法，所述数据持久化的方法应用于客户端，具体的说，还包括：通过第五线程轮询第一缓存队列中的原始单据数据，以确定所述原始单据数据的处理状态。该步骤中，由于单据数据的状态编号由单据数据的编号和单据数据的处理状态的标识拼接而成，因此，可以直接根据单据数据的状态编号确定单据数据的处理状态，其中，存储与第一缓存队列中的原始单据数据的处理状态可以包括已上传、已完成。这里，在通过第五线程轮询第一缓存队列中的原始单据数据时，确定所述第一缓存队列中包括的所以原始单据数据，得到第一单据数据列表。将查询到的第一单据数据列表与客户端中的保存的已上传至服务器的第二单据数据列表进行比对，对于出现在第二单据数据列表但未出现在第一单据数据列表中的单据数据，则认为该单据数据在客户端发送至服务器的过程中丢失，则通过第五线程将该单据数据重新上传至服务器，以使服务器针对该单据数据重新进行持久化处理。基于同一发明构思，本申请实施例中还提供了与数据持久化方法对应的服务器及管理设备，由于本申请实施例中的服务器及管理设备解决问题的原理与本申请实施例上述方法相似，因此服务器及管理设备的实施可以参见方法的实施，重复之处不再赘述。请参阅图4，图4为本申请实施例所提供的一种服务器的结构示意图。如图4中所示，所述服务器400包括：轮询模块401、复制模块402、第一处理模块403、第一存储模块404以及第二处理模块405；所述轮询模块401，用于通过第一线程轮询存储有原始单据数据的第一缓存队列，以得到目标单据数据；所述原始单据数据为接收客户端发送的单据数据，所述第一缓存队列为基于预定分配策略所确定的与所述服务器对应的缓存队列；所述复制模块402，用于通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列；所述第一处理模块403，用于通过所述第一线程对所述目标单据数据进行持久化处理，得到所述目标单据数据的第一处理结果；所述第一存储模块404，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理成功，则通过所述第一线程将处理成功的目标单据数据存储至第一数据库，同时删除第二缓存队列中对应的目标单据数据；所述第二处理模块405，用于若所述第一处理结果指示所述目标单据数据被所述第一线程处理失败，则通过所述第一线程将处理失败的目标单据数据插入至第三缓存队列，在所述第三缓存队列中存在处理失败的目标单据数据时，通过第二线程周期性地对所述第三缓存队列中的目标单据数据进行持久化处理，直至所述第三缓存队列中不存在处理失败的目标单据数据。进一步的，所述服务器400还包括：第一数据恢复模块406，在通过所述第一线程对所述目标单据数据进行复制，将复制得到的目标单据数据存储至第二缓存队列之后，所述第一数据恢复模块406用于：通过第三线程轮询所述第二缓存队列中的目标单据数据，并获取目标单据数据在所述第二缓存队列中的第一存储时间；当所述第一存储时间大于第一时间阈值时，通过所述第三线程将所述第二缓存队列中的目标单据数据恢复至所述第一缓存队列。进一步的，所述服务器400还包括：第二存储模块407，在通过第一线程轮询存储有原始单据数据的第一缓存队列之前，所述第二存储模块407用于：对所述原始单据数据进行复制，并将复制得到的原始单据数据存储至第二数据库；所述第二数据库为具有高写入效率的非关系型数据库。进一步的，所述服务器400还包括：第二数据恢复模块408，所述第二数据恢复模块408用于：通过第四线程轮询所述第一数据库，以获取处理成功的目标单据数据；通过所述第四线程轮询所述第二数据库，以获取复制得到的原始单据数据；通过所述第四线程将所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据进行匹配，以得到匹配结果；若所述匹配结果指示所述第二数据库中复制得到的原始单据数据与所述第一数据库中处理成功的目标单据数据匹配失败，则通过所述第四线程获取所述第二数据库中复制得到的原始单据数据的第二存储时间；当所述第二存储时间大于第二时间阈值时，通过所述第四线程将所述第二数据库中的原始单据数据恢复至所述第一缓存队列。本申请实施例提供的服务器，通过使用第三缓存队列来存储被第一线程处理失败的目标单据数据，以解决在持久化处理失败的目标单据数据易丢失的问题，同时可以通过第二线程对第三缓存队列中的目标单据数据再次进行持久化处理，能够对持久化处理失败的目标单据再次进行持久化处理，以确保目标单据数据被成功持久化。请参阅图5，图5为本申请实施例所提供的一种管理设备的结构示意图。如图5中所示，所述管理设备500包括：第一标识模块501、第二标识模块502、计算模块503以及确定模块504；所述第一标识模块501，用于使用正整数依次对多个服务器进行唯一数字标识，得到各服务器唯一对应的服务器编号；所述第二标识模块502，用于使用正整数依次对缓存队列集合中的多个第一缓存队列进行唯一数字标识，得到各第一缓存队列唯一对应的队列编号；所述计算模块503，用于针对每一个服务器，基于该服务器的服务器编号与缓存队列集合中的第一缓存队列的数量，通过求余函数，得到所述服务器编号唯一对应的队列编号；所述确定模块504，用于将该队列编号对应的第一缓存队列确定为该服务器对应的缓存队列。进一步的，所述管理设备500还包括：调整模块505，当所述服务器400的数量大于所述缓存队列集合中的第一缓存队列的数量时，所述调整模块505用于通过以下方式得到缓存队列集合：识别当前时刻多个第一缓存队列的队列状态；若成功识别出任一第一缓存队列处于空闲状态，则监测该第一缓存队列处于空闲状态的持续时间，当所述空闲状态的持续时间大于第二时间阈值时，将该第一缓存队列删去，以得到缓存队列集合；若在第三预设时间间隔内未识别出任一第一缓存队列处于空闲状态，则增加第一缓存队列，以得到缓存队列集合。本申请实施例提供的服务器，可以基于动态变化的第一缓存队列的数量，通过求余函数来确定多个服务器各自对应的第一缓存队列，以提高服务器的利用率。请参阅图6，图6为本申请实施例所提供的一种电子设备的结构示意图。如图6中所示，所述电子设备600包括处理器601、存储器602和总线603。所述存储器602存储有所述处理器601可执行的机器可读指令，当电子设备600运行时，所述处理器601与所述存储器602之间通过总线603通信，所述机器可读指令被所述处理器601执行时，可以执行如上述图1、图2以及图3所示方法实施例中的分布式环境的数据持久化方法的步骤，具体实现方式可参见方法实施例，在此不再赘述。本申请实施例还提供一种计算机可读存储介质，该计算机可读存储介质上存储有计算机程序，该计算机程序被处理器运行时可以执行如上述图图1、图2以及图3所示方法实施例中的分布式环境的数据持久化方法的步骤，具体实现方式可参见方法实施例，在此不再赘述。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，上述描述的系统、装置和单元的具体工作过程，可以参考前述方法实施例中的对应过程，在此不再赘述。在本申请所提供的几个实施例中，应该理解到，所揭露的系统、装置和方法，可以通过其它的方式实现。以上所描述的装置实施例仅仅是示意性的，例如，所述单元的划分，仅仅为一种逻辑功能划分，实际实现时可以有另外的划分方式，又例如，多个单元或组件可以结合或者可以集成到另一个系统，或一些特征可以忽略，或不执行。另一点，所显示或讨论的相互之间的耦合或直接耦合或通信连接可以是通过一些通信接口，装置或单元的间接耦合或通信连接，可以是电性，机械或其它的形式。所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部单元来实现本实施例方案的目的。另外，在本申请各个实施例中的各功能单元可以集成在一个处理单元中，也可以是各个单元单独物理存在，也可以两个或两个以上单元集成在一个单元中。所述功能如果以软件功能单元的形式实现并作为独立的产品销售或使用时，可以存储在一个处理器可执行的非易失的计算机可读取存储介质中。基于这样的理解，本申请的技术方案本质上或者说对现有技术做出贡献的部分或者该技术方案的部分可以以软件产品的形式体现出来，该计算机软件产品存储在一个存储介质中，包括若干指令用以使得一台计算机设备执行本申请各个实施例所述方法的全部或部分步骤。而前述的存储介质包括：U盘、移动硬盘、只读存储器、随机存取存储器、磁碟或者光盘等各种可以存储程序代码的介质。最后应说明的是：以上所述实施例，仅为本申请的具体实施方式，用以说明本申请的技术方案，而非对其限制，本申请的保护范围并不局限于此，尽管参照前述实施例对本申请进行了详细的说明，本领域的普通技术人员应当理解：任何熟悉本技术领域的技术人员在本申请揭露的技术范围内，其依然可以对前述实施例所记载的技术方案进行修改或可轻易想到变化，或者对其中部分技术特征进行等同替换；而这些修改、变化或者替换，并不使相应技术方案的本质脱离本申请实施例技术方案的精神和范围，都应涵盖在本申请的保护范围之内。因此，本申请的保护范围应以权利要求的保护范围为准。

标题title
一种性能分析数据的获取方法、装置、设备及存储介质
摘要abst
本公开提供了一种性能分析数据的获取方法、装置、设备及存储介质，所述方法包括：首先，获取目标应用程序的golang方法调用栈，并确定golang方法调用栈与协程之间的对应关系，以及获取该目标应用程序的lua方法调用栈，并确定lua方法调用栈与协程之间的对应关系。然后，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈。进而，基于缝合后方法调用栈确定该目标应用程序的性能分析数据。本公开实施例能够获取到更全面的性能分析数据，有利于提高对应用程序的性能分析准确性。
权利要求书clms
1.一种性能分析数据的获取方法，其特征在于，所述方法包括：获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系；以及，获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系；基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈；基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。2.根据权利要求1所述的方法，其特征在于，所述获取所述目标应用程序的lua方法调用栈，包括：基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈；相应的，所述确定所述lua方法调用栈与协程之间的对应关系，包括：确定所述lua方法调用栈与所述lua虚拟机所属的协程之间的对应关系。3.根据权利要求2所述的方法，其特征在于，所述基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈之前，还包括：将预设传入管道中的lua虚拟机添加到预设lua虚拟机池中，以及将预设移出管道中的lua虚拟机从所述预设lua虚拟机池中移出；其中，所述预设传入管道中的lua虚拟机携带所属的协程的协程标识，所述预设传入管道中的lua虚拟机为所述目标应用程序针对创建的lua虚拟机传入的，所述预设移出管道中的lua虚拟机为所述目标应用程序针对销毁的lua虚拟机传入的；相应的，所述基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈，包括：通过遍历所述预设lua虚拟机池中的lua虚拟机，获取各个lua虚拟机分别对应的lua方法调用栈。4.根据权利要求1所述的方法，其特征在于，所述基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈，包括：基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈，分别确定为目标缝合golang方法调用栈和目标缝合lua方法调用栈；确定所述目标缝合golang方法调用栈中的目标方法栈帧；其中，所述目标方法栈帧为表征golang方法调用lua方法的栈帧；基于所述目标方法栈帧在所述目标缝合golang方法调用栈中的位置，将所述目标缝合lua方法调用栈与所述目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈。5.根据权利要求4所述的方法，其特征在于，所述基于所述目标方法栈帧在所述目标缝合golang方法调用栈中的位置，将所述目标缝合lua方法调用栈与所述目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈，包括：将所述目标缝合lua方法调用栈缝合至所述目标缝合golang方法调用栈中与所述目标方法栈帧相邻的下一个栈帧的位置，得到缝合后方法调用栈。6.根据权利要求1所述的方法，其特征在于，所述获取目标应用程序的golang方法调用栈，包括：在预设采样周期内，获取目标应用程序的golang方法调用栈；相应的，所述获取所述目标应用程序的lua方法调用栈，包括：在所述预设采样周期内，获取所述目标应用程序的lua方法调用栈。7.根据权利要求1所述的方法，其特征在于，所述方法应用于性能分析工具，所述性能分析工具集成在所述目标应用程序中。8.一种性能分析数据的获取装置，其特征在于，所述装置包括：第一获取模块，用于获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系；第二获取模块，用于获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系；数据缝合模块，用于基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈；确定模块，用于基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。9.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质中存储有指令，当所述指令在终端设备上运行时，使得所述终端设备实现如权利要求1-7任一项所述的方法。10.一种设备，其特征在于，包括：存储器，处理器，及存储在所述存储器上并可在所述处理器上运行的计算机程序，所述处理器执行所述计算机程序时，实现如权利要求1-7任一项所述的方法。11.一种计算机程序产品，其特征在于，所述计算机程序产品包括计算机程序/指令，所述计算机程序/指令被处理器执行时实现如权利要求1-7任一项所述的方法。
说明书desc
技术领域本公开涉及数据处理领域，尤其涉及一种性能分析数据的获取方法、装置、设备及存储介质。背景技术性能分析，是以收集应用程序运行时数据为手段的研究应用程序行为的分析方法，是一种动态程序分析方法。性能分析的目的在于确定应用程序的哪个部分应该被优化，从而通过对该部分进行优化以提高应用程序的运行速度或者内存使用效率等性能。golang是目前比较流行的编程语言，也称为go语言，在基于golang语言编写的应用程序中，往往会存在golang方法调用lua相关脚本逻辑的情况。而业内的性能分析工具通常仅能够针对单一编程语言进行性能分析。例如，golang官方提供的性能调优分析工具pprof，在对golang方法调用lua相关脚本逻辑的应用程序进行性能分析时，仅能获取到golang方法调用相关的性能分析数据，而对于涉及到lua方法调用相关的性能分析数据则处于缺失的状态，使得最终获取到的性能分析数据不完整，进而影响对应用程序的性能分析结果。因此，针对golang方法调用lua相关脚本逻辑的应用程序，如何获取到更完整的性能分析数据，提高对这类应用程序的性能分析准确性，是目前亟需解决的技术问题。发明内容为了解决上述技术问题或者至少部分地解决上述技术问题，本公开实施例提供了一种性能分析数据的获取方法，能够更全面的获取到应用程序的性能分析数据，有利于提高对应用程序的性能分析准确性。第一方面，本公开提供了一种性能分析数据的获取方法，所述方法包括：获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系；以及，获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系；基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈；基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。一种可选的实施方式中，所述获取所述目标应用程序的lua方法调用栈，包括：基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈；相应的，所述确定所述lua方法调用栈与协程之间的对应关系，包括：确定所述lua方法调用栈与所述lua虚拟机所属的协程之间的对应关系。一种可选的实施方式中，所述基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈之前，还包括：将预设传入管道中的lua虚拟机添加到预设lua虚拟机池中，以及将预设移出管道中的lua虚拟机从所述预设lua虚拟机池中移出；其中，所述预设传入管道中的lua虚拟机携带所属的协程的协程标识，所述预设传入管道中的lua虚拟机为所述目标应用程序针对创建的lua虚拟机传入的，所述预设移出管道中的lua虚拟机为所述目标应用程序针对销毁的lua虚拟机传入的；相应的，所述基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈，包括：通过遍历所述预设lua虚拟机池中的lua虚拟机，获取各个lua虚拟机分别对应的lua方法调用栈。一种可选的实施方式中，所述基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈，包括：基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈，分别确定为目标缝合golang方法调用栈和目标缝合lua方法调用栈；确定所述目标缝合golang方法调用栈中的目标方法栈帧；其中，所述目标方法栈帧为表征golang方法调用lua方法的栈帧；基于所述目标方法栈帧在所述目标缝合golang方法调用栈中的位置，将所述目标缝合lua方法调用栈与所述目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈。一种可选的实施方式中，所述基于所述目标方法栈帧在所述目标缝合golang方法调用栈中的位置，将所述目标缝合lua方法调用栈与所述目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈，包括：将所述目标缝合lua方法调用栈缝合至所述目标缝合golang方法调用栈中与所述目标方法栈帧相邻的下一个栈帧的位置，得到缝合后方法调用栈。一种可选的实施方式中，所述获取目标应用程序的golang方法调用栈，包括：在预设采样周期内，获取目标应用程序的golang方法调用栈；相应的，所述获取所述目标应用程序的lua方法调用栈，包括：在所述预设采样周期内，获取所述目标应用程序的lua方法调用栈。一种可选的实施方式中，所述方法应用于性能分析工具，所述性能分析工具集成在所述目标应用程序中。第二方面，本公开提供了一种性能分析数据的获取装置，所述装置包括：第一获取模块，用于获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系；第二获取模块，用于获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系；数据缝合模块，用于基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈；确定模块，用于基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。第三方面，本公开提供了一种计算机可读存储介质，所述计算机可读存储介质中存储有指令，当所述指令在终端设备上运行时，使得所述终端设备实现上述的方法。第四方面，本公开提供了一种设备，包括：存储器，处理器，及存储在所述存储器上并可在所述处理器上运行的计算机程序，所述处理器执行所述计算机程序时，实现上述的方法。第五方面，本公开提供了一种计算机程序产品，所述计算机程序产品包括计算机程序/指令，所述计算机程序/指令被处理器执行时实现上述的方法。本公开实施例提供的技术方案与现有技术相比至少具有如下优点：本公开实施例提供了一种性能分析数据的获取方法，首先，获取目标应用程序的golang方法调用栈，并确定golang方法调用栈与协程之间的对应关系，以及获取该目标应用程序的lua方法调用栈，并确定lua方法调用栈与协程之间的对应关系。然后，基于golang方法调用栈与协程之间的对应关系以及lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈。进而，基于缝合后方法调用栈确定该目标应用程序的性能分析数据。本公开实施例能够获取到目标应用程序的lua方法调用栈，并通过对golang方法调用栈和lua方法调用栈的数据缝合处理，得到包含有golang方法调用栈和lua方法调用栈的性能分析数据，可见，本公开实施例能够获取到更全面的性能分析数据，有利于提高对应用程序的性能分析准确性。附图说明此处的附图被并入说明书中并构成本说明书的一部分，示出了符合本公开的实施例，并与说明书一起用于解释本公开的原理。为了更清楚地说明本公开实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作简单地介绍，显而易见地，对于本领域普通技术人员而言，在不付出创造性劳动性的前提下，还可以根据这些附图获得其他的附图。图1为本公开实施例提供的一种性能分析数据的获取方法的流程图；图2为本公开实施例提供的一种golang方法调用栈的示意图；图3为本公开实施例提供的一种lua方法调用栈的示意图；图4为本公开实施例提供的一种缝合后方法调用栈的示意图；图5为本公开实施例提供的一种lua方法调用栈的获取方法的示意图；图6为本公开实施例提供的一种性能分析数据的获取装置的结构示意图；图7为本公开实施例提供的一种性能分析数据的获取设备的结构示意图。具体实施方式为了能够更清楚地理解本公开的上述目的、特征和优点，下面将对本公开的方案进行进一步描述。需要说明的是，在不冲突的情况下，本公开的实施例及实施例中的特征可以相互组合。在下面的描述中阐述了很多具体细节以便于充分理解本公开，但本公开还可以采用其他不同于在此描述的方式来实施；显然，说明书中的实施例只是本公开的一部分实施例，而不是全部的实施例。目前，golang官方提供的性能调优分析工具pprof，只能针对应用程序中单一的golang语言进行性能分析，针对golang方法调用lua相关脚本逻辑的应用程序，仅能获取到golang方法调用相关的性能分析数据，而对于涉及到lua方法调用相关的性能分析数据则处于缺失的状态，导致后续基于获取到的性能分析数据对应用程序进行性能分析的结果不准确。为此，本公开实施例提供了一种性能分析数据的获取方法，不仅能够获取到目标应用程序的golang方法调用栈，还能够获取到该目标应用程序的lua方法调用栈。通过对golang方法调用栈和lua方法调用栈的数据缝合处理，能够得到包含有golang方法调用栈和lua方法调用栈的性能分析数据。可见，本公开实施例能够获取到更全面的性能分析数据，有利于提高对应用程序的性能分析准确性。基于此，本公开实施例提供了一种性能分析数据的获取方法，参考图1，为本公开实施例提供的一种性能分析数据的获取方法的流程图，该方法包括：S101：获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系。golang是目前比较流行的编程语言，也称为go语言，基于golang语音编写的应用程序可以称为golang应用程序。lua是目前比较流行的脚本语言，基于lua语言编写的脚本逻辑能够被第三方语言编写的方法所调用。本公开实施例中，目标应用程序可以包括存在golang方法调用lua相关脚本逻辑的golang应用程序，具体的，目标应用程序可以为基于golang语言编写的应用程序，且在该应用程序中存在golang方法调用lua相关脚本逻辑的内容。实际应用中，在对目标应用程序进行性能分析之前，首先采集目标应用程序运行过程中的性能分析数据，而方法调用栈是性能分析数据中非常关键的数据之一。其中，方法调用栈能够表征应用程序中处于同一协程内的各个方法之间的调用关系。实际应用中，在确定需要进行性能分析的应用程序即目标应用程序之后，可以按照预设采样周期，获取目标应用程序的golang方法调用栈，具体的，周期性的采集目标应用程序的性能分析数据。针对每个采样周期，可以利用本公开实施例提供的性能分析数据的获取方法，获取本次采样周期内目标应用程序运行过程中的性能分析数据，其中，性能分析数据至少包括golang方法调用栈和lua方法调用栈。本公开实施例中，在确定目标应用程序之后，首先获取该目标应用程序的golang方法调用栈。其中，golang方法调用栈用于表征golang方法之间的调用关系。具体的，可以获取目标应用程序中各个协程内的golang方法调用栈，并记录golang方法调用栈与协程之间的对应关系。一种可选的实施方式中，不同的协程可以具有不同的协程ID，在获取到目标应用程序的不同协程内的golang方法调用栈后，可以记录各个协程的协程ID与golang方法调用栈之间的对应关系。由于同一应用程序中可以包括多个协程，因此，本公开实施例可以记录该目标应用程序中的多个协程ID分别与golang方法调用栈之间的对应关系。S102：获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系。本公开实施例中，lua方法调用栈用于表征目标应用程序中的golang方法调用的lua方法之间的调用关系。实际应用中，如果在golang应用程序中执行lua相关脚本逻辑，则需要在golang应用程序中创建lua虚拟机，然后在lua虚拟机中执行lua相关脚本逻辑。而针对golang应用程序中多个协程并发执行lua脚本相关逻辑的情况，则会在golang应用程序中的多个协程内分别创建lua虚拟机，实现在多个协程并发执行lua脚本相关逻辑的效果。本公开实施例中，可以基于目标应用程序中的lua虚拟机，获取lua虚拟机对应的lua方法调用栈，并且基于该lua虚拟机所属的协程，确定该协程与该lua方法调用栈之间的对应关系。一种可选的实施方式中，可以通过对目标应用程序中各个协程内的lua虚拟机上运行的lua方法进行分析，获取该目标应用程序中的各个协程分别对应的lua方法调用栈，用于构成该目标应用程序的性能分析数据。值得注意的是，本公开实施例对于上述S101和S102之间的先后执行顺序不做限制。S103：基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈。本公开实施例中，在获取到目标应用程序中的golang方法调用栈与协程之间的对应关系以及lua方法调用栈与协程之间的对应关系之后，确定与同一协程具有对应关系的golang方法调用栈和lua方法调用栈，分别作为目标缝合golang方法调用栈和目标缝合lua方法调用栈。如图2所示，为本公开实施例提供的一种golang方法调用栈的示意图，其中，图2中的golang方法调用栈与协程a具有对应关系，该golang方法调用栈中的每个golang栈帧用于存储协程a中执行的一个golang方法的名称，即golang方法调用栈中的golang栈帧与golang方法具有对应关系。每个协程具有一个golang方法调用栈，用于表征该协程内的各个golang方法之间的调用关系。如图3所述，为本公开实施例提供的一种lua方法调用栈的示意图，其中，图3中的lua方法调用栈也是与协程a具有对应关系，该lua方法调用栈中的每个lua栈帧用于存储协程a中执行的一个lua方法的名称，即lua方法调用栈中的lua栈帧与lua方法具有对应关系，每个协程通常具有一个lua方法调用栈，在可选的实现方式中，一个协程也可以具有多个lua方法调用栈。具体的，lua方法调用栈用于表征对应的协程内被golang方法调用的各个lua方法之间的调用关系。由于上述图2中的golang方法调用栈与协程a具有对应关系，图3中的lua方法调用栈也是与协程a具有对应关系，因此，可以将图2中的golang方法调用栈确定为目标缝合golang方法调用栈，以及可以将图3中的lua方法调用栈确定为目标缝合lua方法调用栈。通过将目标缝合golang方法调用栈与目标缝合lua方法调用栈进行数据缝合处理，得到协程a对应的缝合后方法调用栈。实际应用中，在golang应用程序中，如果存在golang方法调用lua相关脚本逻辑的情况，则必须通过特定的函数实现。为此，本公开实施例可以基于该特定的函数在golang方法调用栈中的位置，对lua方法调用栈和golang方法调用栈进行数据缝合处理。一种可选的实施方式中，在确定与同一协程具有对应关系的目标缝合golang方法调用栈和目标缝合lua方法调用栈之后，在所述目标缝合golang方法调用栈查找目标方法栈帧，而该目标方法栈帧为能够表征出golang方法调用lua方法的栈帧。如图2所示，“golang调用lua栈帧”用于表示该目标方法栈帧。在确定标缝合golang方法调用栈中的目标方法栈帧之后，基于该目标方法栈帧在目标缝合golang方法调用栈中的位置，将目标缝合lua方法调用栈与目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈。一种可选的实施方式中，为了便于开发人员基于性能分析数据对目标应用程序的性能进行分析，本公开实施例可以将目标缝合lua方法调用栈缝合至目标缝合golang方法调用栈中的与目标方法栈帧相邻的下一个栈帧的位置，得到缝合后方法调用栈。如图4所示，为本公开实施例提供的一种缝合后方法调用栈的示意图。可见，本公开实施例针对目标应用程序提供的性能分析数据中不仅包括golang方法调用栈，还包括lua方法调用栈，从而保证了性能分析数据的全面性，从而能够提高对目标应用程序进行性能分析的准确性。实际应用中，可以基于上述缝合方法，对目标应用程序中的各个协程内的golang方法调用栈与lua方法调用栈进行数据缝合处理，得到各个协程分别对应的缝合后方法调用栈。S104：基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。本公开实施例中，在获取到目标应用程序中各个协程分别对应的缝合后方法调用栈之后，可以将各个协程分别对应的缝合后方法调用栈确定为该目标应用程序的性能分析数据，用于对该目标应用程序进行性能分析。实际应用中，可以将各个采样周期内获取到的目标应用程序中各个协程分别对应的缝合后方法调用栈，均确定为该目标应用程序的性能分析数据，用于对该目标应用程序进行性能分析。例如，按照每1秒采集一次数据的采样周期，采集目标应用程序在1分钟内的性能分析数据，可以将该1分钟内的各个采样周期内分别获取到的目标应用程序中各个协程分别对应的缝合后方法调用栈，均确定为该目标应用程序的性能分析数据，用于对该目标应用程序进行性能分析。本公开实施例提供的性能分析数据的获取方法中，首先，获取目标应用程序的golang方法调用栈，并确定golang方法调用栈与协程之间的对应关系，以及获取该目标应用程序的lua方法调用栈，并确定lua方法调用栈与协程之间的对应关系。然后，基于golang方法调用栈与协程之间的对应关系以及lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈。进而，基于缝合后方法调用栈确定该目标应用程序的性能分析数据。本公开实施例能够获取到目标应用程序的lua方法调用栈，并通过对golang方法调用栈和lua方法调用栈的数据缝合处理，得到包含有golang方法调用栈和lua方法调用栈的性能分析数据，可见，本公开实施例能够获取到更全面的性能分析数据，有利于提高对应用程序的性能分析准确性。基于上述实施例的内容，本公开实施例还提供了一种lua方法调用栈的获取方法，具体的，参考图5，为本公开实施例提供的一种lua方法调用栈的获取方法的示意图。实际应用中，本公开实施例可以预先设置lua虚拟机池、传入管道和移出管道，并针对预设lua虚拟机池、预设传入轨道和预设移出轨道进行维护。具体的，目标应用程序在运行的过程中，一旦在某个协程内创建lua虚拟机，则需要同步将该lua虚拟机＝发送至预设传入管道中，同时，将该lua虚拟机所属的协程的协程标识也发送至该预设传入管道中，建立该lua虚拟机与该协程之间的对应关系。其中，协程标识可以包括协程ID等能够唯一标识协程的信息。另外，目标应用程序在运行的过程中，一旦针对某个lua虚拟机进行销毁时，则需要同步将该lua虚拟机发送至预设传出管道中。本公开实施例中，在获取目标应用程序中的lua方法调用栈之前，首先访问预设传入管道和预设移出管道，具体的，将预设传入管道中的lua虚拟机与协程之间的对应关系添加到预设lua虚拟机池中，以及，将预设移出管道中的lua虚拟机从预设lua虚拟机池中移出。然后，通过遍历预设lua虚拟机池中的lua虚拟机，获取各个lua虚拟机分别对应的lua方法调用栈。另外，由于预设lua虚拟机池中的各个lua虚拟机分别与协程具有对应关系，因此，本公开实施例在获取到各个lua虚拟机分别对应的lua方法调用栈之后，确定lua虚拟机所属的协程与对应的lua方法调用栈之间的对应关系。本公开实施例通过预设lua虚拟机池、预设传入管道和预设移出管道，能够实现对目标应用程序中各个协程内的golang方法调用的lua方法的lua方法调用栈的获取，丰富了性能分析数据，从而提高了性能分析的准确性。一种应用场景中，本公开实施例提供的性能分析数据的获取方法可以应用于性能分析工具中，该性能分析工具可以集成在目标应用程序中。具体的，如果针对该目标应用程序存在性能分析的需求，可以向该目标应用程序中集成的性能分析工具发送性能分析请求，以便能够启动该性能分析工具，用于执行本公开实施例提供的性能分析数据的获取方法。另一种应用场景中，本公开实施例中的性能分析工具也可以独立于目标应用程序，本公开实施例对于性能分析工具的存在形式不做限制。基于上述方法实施例，本公开还提供了一种性能分析数据的获取装置，参考图6，为本公开实施例提供的一种性能分析数据的获取装置的结构示意图，所述装置包括：第一获取模块601，用于获取目标应用程序的golang方法调用栈，并确定所述golang方法调用栈与协程之间的对应关系；第二获取模块602，用于获取所述目标应用程序的lua方法调用栈，并确定所述lua方法调用栈与协程之间的对应关系；数据缝合模块603，用于基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈；确定模块604，用于基于所述缝合后方法调用栈，确定所述目标应用程序的性能分析数据。一种可选的实施方式中，所述第一获取模块，包括：第一获取子模块，用于基于所述目标应用程序中的lua虚拟机，获取所述lua虚拟机对应的lua方法调用栈；第一确定子模块，用于确定所述lua方法调用栈与所述lua虚拟机所属的协程之间的对应关系。一种可选的实施方式中，所述装置还包括：添加模块，用于将预设传入管道中的lua虚拟机添加到预设lua虚拟机池中；其中，所述预设传入管道中的lua虚拟机携带所属的协程的协程标识，所述预设传入管道中的lua虚拟机为所述目标应用程序针对创建的lua虚拟机传入的；移出模块，用于将预设移出管道中的lua虚拟机从所述预设lua虚拟机池中移出；其中，所述预设移出管道中的lua虚拟机为所述目标应用程序针对销毁的lua虚拟机传入的；相应的，所述第一获取子模块，具体用于：通过遍历所述预设lua虚拟机池中的lua虚拟机，获取各个lua虚拟机分别对应的lua方法调用栈。一种可选的实施方式中，所述数据缝合模块，包括：第二确定子模块，用于基于所述golang方法调用栈与协程之间的对应关系以及所述lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈，分别确定为目标缝合golang方法调用栈和目标缝合lua方法调用栈；第三确定子模块，用于确定所述目标缝合golang方法调用栈中的目标方法栈帧；其中，所述目标方法栈帧为表征golang方法调用lua方法的栈帧；数据缝合子模块，用于基于所述目标方法栈帧在所述目标缝合golang方法调用栈中的位置，将所述目标缝合lua方法调用栈与所述目标缝合golang方法调用栈进行数据缝合处理，得到缝合后方法调用栈。一种可选的实施方式中，所述数据缝合子模块，具体用于：将所述目标缝合lua方法调用栈缝合至所述目标缝合golang方法调用栈中与所述目标方法栈帧相邻的下一个栈帧的位置，得到缝合后方法调用栈。一种可选的实施方式中，所述第一获取模块，包括：第二获取子模块，用于在预设采样周期内，获取目标应用程序的golang方法调用栈；相应的，所述第二获取模块，包括：第三获取子模块，用于在所述预设采样周期内，获取所述目标应用程序的lua方法调用栈。一种可选的实施方式中，所述装置应用于性能分析工具，所述性能分析工具集成在所述目标应用程序中。本公开实施例提供的性能分析数据的获取装置中，首先，获取目标应用程序的golang方法调用栈，并确定golang方法调用栈与协程之间的对应关系，以及获取该目标应用程序的lua方法调用栈，并确定lua方法调用栈与协程之间的对应关系。然后，基于golang方法调用栈与协程之间的对应关系以及lua方法调用栈与协程之间的对应关系，将与同一协程具有对应关系的golang方法调用栈和lua方法调用栈进行数据缝合处理，得到缝合后方法调用栈。进而，基于缝合后方法调用栈确定该目标应用程序的性能分析数据。本公开实施例能够获取到目标应用程序的lua方法调用栈，并通过对golang方法调用栈和lua方法调用栈的数据缝合处理，得到包含有golang方法调用栈和lua方法调用栈的性能分析数据，可见，本公开实施例能够获取到更全面的性能分析数据，有利于提高对应用程序的性能分析准确性。除了上述方法和装置以外，本公开实施例还提供了一种计算机可读存储介质，计算机可读存储介质中存储有指令，当所述指令在终端设备上运行时，使得所述终端设备实现本公开实施例所述的性能分析数据的获取方法。本公开实施例还提供了一种计算机程序产品，所述计算机程序产品包括计算机程序/指令，所述计算机程序/指令被处理器执行时实现本公开实施例所述的性能分析数据的获取方法。另外，本公开实施例还提供了一种性能分析数据的获取设备，参见图7所示，可以包括：处理器701、存储器702、输入装置703和输出装置704。性能分析数据的获取设备中的处理器701的数量可以一个或多个，图7中以一个处理器为例。在本公开的一些实施例中，处理器701、存储器702、输入装置703和输出装置704可通过总线或其它方式连接，其中，图7中以通过总线连接为例。存储器702可用于存储软件程序以及模块，处理器701通过运行存储在存储器702的软件程序以及模块，从而执行性能分析数据的获取设备的各种功能应用以及数据处理。存储器702可主要包括存储程序区和存储数据区，其中，存储程序区可存储操作系统、至少一个功能所需的应用程序等。此外，存储器702可以包括高速随机存取存储器，还可以包括非易失性存储器，例如至少一个磁盘存储器件、闪存器件、或其他易失性固态存储器件。输入装置703可用于接收输入的数字或字符信息，以及产生与性能分析数据的获取设备的用户设置以及功能控制有关的信号输入。具体在本实施例中，处理器701会按照如下的指令，将一个或一个以上的应用程序的进程对应的可执行文件加载到存储器702中，并由处理器701来运行存储在存储器702中的应用程序，从而实现上述性能分析数据的获取设备的各种功能。需要说明的是，在本文中，诸如“第一”和“第二”等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括所述要素的过程、方法、物品或者设备中还存在另外的相同要素。以上所述仅是本公开的具体实施方式，使本领域技术人员能够理解或实现本公开。对这些实施例的多种修改对本领域的技术人员来说将是显而易见的，本文中所定义的一般原理可以在不脱离本公开的精神或范围的情况下，在其它实施例中实现。因此，本公开将不会被限制于本文所述的这些实施例，而是要符合与本文所公开的原理和新颖特点相一致的最宽的范围。

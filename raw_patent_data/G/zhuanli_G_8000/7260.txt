标题title
一种基于GPU的5GLDPC编码器的编码方法
摘要abst
本发明提出一种基于GPU的5GLDPC编码器的编码方法，包括：1：主机端存储空间初始化；2：GPU设备端存储空间初始化；3：GPU设备端的LDPC校验矩阵信息初始化；4：主机端向GPU拷贝编码指示信息和数据信息；5：主机端调用GPU函数进行LDPC编码；6：GPU对接收到的信息比特进行预处理；7：GPU将处理后的数据信息搬运到高速片上内存；8：GPU对LDPC进行并行编码；9：GPU对编码后的奇偶校验比特进行压缩并计算；10：将压缩信息传回主机端；11：主机端对接收的压缩校验信息与信息比特进行拼接，形成完整的LDPC编码信息。本发明能提高编码器吞吐量，使编码器具有灵活、高速的特性。
权利要求书clms
1.一种基于GPU的5GLDPC编码器的编码方法，其中，编码器包括主机端和图形处理器GPU设备端；主机端设置主机内存和CPU芯片，CPU芯片用于编码信息预处理、码字组合以及控制调度整个编码过程，将待编码信息流发送到GPU设备端；GPU设备端设置GPU芯片，GPU芯片由若干个流多处理器SM组成，每个SM负责一组不同码型的低密度奇偶校验码LDPC码块的编码，SM中开启的大量线程对信息流进行高速、并行编码；主机端和GPU设备端通过高速串行计算机扩展总线PCI-E进行数据传输；基于上述编码器，其特征在于：编码方法具体步骤如下：步骤1：主机端存储空间初始化；在主机端根据同时处理的最大码块数量num_C，为信息比特和编码后的比特分配足够的存储空间；步骤2：GPU设备端存储空间初始化；GPU设备端配置内存空间，为信息比特和编码后的比特分配足够的全局内存空间，按照本次编码的最大占用资源对GPU分配高速片上内存空间；步骤3：GPU设备端的LDPC校验矩阵信息初始化；在GPU设备端，将5G协议规定的所有LDPC基矩阵Hb信息进行预存储，将基矩阵中的偏移量信息H_shift以及每行中循环块所在列的位置H_offset写入GPU全局内存；基矩阵Hb包括了矩阵A、B、C、D、I；步骤4：主机端向GPU拷贝编码指示信息和数据信息；主机端将每个码块的编码信息写入一个结构体，包括每个码块基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，编码层数mb，修正值remainder；采用压缩排布的方式在主机端和设备端之间传输信息数据和编码比特，结构体中还包括每个码块信息比特的起始位置src_offset，以及编码完成后比特存储起始位置dst_offset，多个码块的编码指示信息结构体形成一个编码指示信息结构体数组，主机端将所有等待并行处理码块的指示信息结构体数组传送到GPU全局内存；主机端将每个码块的信息比特按照32比特进行比特打包，然后将所有码块的打包比特压缩排布，把待编码的信息比特数据拷贝到GPU全局内存；步骤5：主机端调用GPU函数进行LDPC编码；主机端设置GPU虚拟处理器分组block的数量等于最大码块数量num_C，block维度为一维，多个block并行处理不同码型的LDPC码字编码；主机端设置每个block的开启线程数量为256，线程维度为一维；步骤6：GPU对接收到的信息比特根据编码指示信息进行预处理；GPU每个block的线程到对应的结构体数组中获取对应码块的编码指示信息，包括基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，修正值remainder，信息比特的起始位置src_offset，编码完成后比特存储起始位置dst_offset，然后根据信息比特的起始位置src_offset、信息比特组数量kb和提升值Zc获取信息比特s，从src_offset指示的位置开始，到ceil*4字节的空间包含了码块的信息比特，ceil表示向上取整；分为kb个信息比特子组si,，i= 1, 2, …, kb，每组对应有Zc个比特；GPU对信息比特s中的每个信息比特子组si根据修正值remainder进行循环填充至32的倍数，每个子组对应基矩阵一个循环块；步骤7：GPU将处理后的数据信息搬运到高速片上内存；步骤8：GPU对LDPC进行并行编码；LDPC码的编码使用校验矩阵H执行，通过求方程式HcT=0解出码字c，其中，cT表示码字c的转置；编码阶段共包括以下3个步骤：步骤8.1：线程分组，建立线程与信息处理的映射关系，通过高效移位操作计算kb个信息比特子组si对应的比特与校验矩阵相乘的结果，；将计算结果的mb组元素缓存到高速片上内存中，为后面步骤计算奇偶校验比特做准备；步骤8.2：根据编码指示信息计算第一部分奇偶校验比特pa；第一部分奇偶校验比特pa包括4组校验比特，z= 1, 2, 3, 4；需要对校验矩阵H中前4层方程求解，根据校验矩阵H类型B_type列出对应的方程组，将步骤8.1中信息比特子组si对应的比特与校验矩阵相乘，根据相乘的结果求解方程组，读取高速片上内存中缓存的向量结果的前4组结果，求出第一部分奇偶校验比特pa；步骤8.3：根据步骤8.2的pa计算第二部分奇偶校验比特pc；依据步骤8.1中的方式计算第一部分奇偶校验比特pa与校验矩阵H相乘的结果，，再将与对应组进行模二相加，由于第二部分奇偶校验比特pc对应的校验矩阵为子矩阵I，相加结果即为第二部分奇偶校验比特pc结果；步骤9：GPU对编码后的奇偶校验比特进行压缩，计算后奇偶校验比特p共有mb组，每组需要根据修正值remainder删除冗余比特，得到每组Zc个有效比特，将有效比特进行压缩，根据比特存储起始位置dst_offset，将压缩校验比特结果写入全局内存；步骤10：将全局内存中的压缩信息传回主机端；步骤11：主机端对接收的压缩校验信息与信息比特进行拼接，形成完整的LDPC编码信息。2.根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤3中，LDPC基矩阵Hb信息包括：5G NR标准规定了BG1和BG2两种基矩阵，结构如式所示，大小为mb×nb，mb代表编码层数，即基矩阵的行数，nb代表基矩阵的列数，nb=mb+kb；基矩阵Hb中，右上角0区域表示该部分内全是0，其中A的维度是4×kb，B的维度是4×4，C的维度是×kb，D的维度是×4，I的维度是×；基矩阵Hb包含了所有循环块对应的偏移量H_shift，通过计算得到每个循环块在一行中所在列的位置H_offset，将全部基本信息结构在译码前全部传入GPU内存。3.根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤4中，校验矩阵类型B_type包括：子矩阵B是维度4×4的方阵，其有4种不同类型，5G协议规定了不同BG图样对应的固定的B_type；修正值remainder包括：根据提升值Zc的大小设置不同的修正值remainder，根据Zc与32的余数决定修正值remainder大小，当Zc32时，修正值remainder=Zc%32；当Zc＜32时，修正值remainder=-Zc%32；remainder=0代表信息比特打包到一组无符号的32位整数变量；压缩排布的方式包括：PCI-E传输速度受限制，对于一组不同的LDPC码块进行编码时，选用固定步长，对于提升值Zc的LDPC码编码时需要填充大量冗余数据0，导致传输时间长，因此采用压缩数据量的方式传入数据，通过主机端生成一组码块起始位置相对于首个码块起始位置的偏移量信息，用来指示每个码块在一组数据中的位置，每个码块相对于第一个码块起始位置的偏移量是前面所有码块的有效长度之和；比特打包包括：由于信息数据为0或1的比特，将信息比特按照每32个比特为一组进行打包，能够充分利用GPU资源，GPU中每个线程操控32个比特进行并行计算。4. 根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤6中，循环填充包括：根据修正值remainder大小，对信息比特子组si中Zc比特的数据进行填充，由于GPU中寄存器内存大小为32比特，需填充至32的整数倍，形成以32bit为基本符号存储的信息数据，因此每个si占用M个寄存器，M = ceil，寄存器表示为Rt，t=1,2,…,M，实际有效信息数据只覆盖了M个寄存器中前Zc个比特；当remainder=0时，Zc为32的整数倍，每组的有效信息填满了全部M个寄存器，不需要填充任何数据；当remainder＞0时，表示Zc不是32的整数倍且Zc＞32，si中的实际比特没有填满M个寄存器，每个si在实际占用的Zc个比特后开始填充同组si中头部数据比特，直至补全最后一个寄存器中的数据；当remainder＜0时，表示Zc＜32，每个占用一个寄存器，实际有效信息数据只覆盖前Zc个比特，将Zc个比特循环进行填充直至填满32个比特。5.根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤8中，校验矩阵H由基矩阵Hb扩展而来；基矩阵Hb中的一行元素指示的偏移量，对应H校验矩阵一层单位阵Zc×Zc的偏移；校验矩阵H表示为式，其中，下角标Zc表示了在基矩阵Hb元素上的Zc倍扩展LDPC编码包括：LDPC码字分为三部分，C=，分别对应子矩阵B与子矩阵I，LDPC码的编码使用方程式HcT=0执行。6.根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤8.1中的线程分组具体包括：GPU将每个block内的256个线程分16组，Zc最大为384，每个子组中最多包含384比特数据，需要每16个线程为一个协作组，每个线程负责32比特数据的操作和计算；在处理多码型LDPC编码过程中，协作组中实际参与运算的线程数量为ceil；每个协作组负责校验矩阵H内一层的所有循环位移块对应的比特与校验矩阵相乘的求解，每层的求解最终算出一组结果，256个线程支持校验矩阵H内最多16个层的比特与校验矩阵相乘同时求解，每次计算16组结果，然后所有线程求解后面16层的运算，直到mb组结果求解完成；步骤8.1中的信息比特子组si对应的比特与校验矩阵相乘具体包括：相乘结果用表示，sT表示s的转置，矩阵AZc和矩阵CZc由多个循环位移块组成，因此矩阵AZc与sT相乘以及矩阵CZc与sT相乘均表示为，AZc与sT的相乘结果为，矩阵CZc与sT相乘结果为；其中，i表示信息子组的位置及循环位移块在基矩阵中的列数，i= 1, 2, …, kb； j表示循环位移块在基矩阵中的行数， j= 1, 2, …, mb，表示模二相加，表示基矩阵中第j行，判断第i列的循环位移块是否为0，若为0，，若不为0，，因此表示了非0子块对应的信息比特子组si；当循环位移块不为0时，具有循环位移量，表示了信息比特子组si应进行循环位移的大小，因此表示了的循环位移结果；步骤8.1中的高效移位包括：对每层进行遍历，协作组中的有效工作的线程读取基矩阵偏移量H_shift，每个线程标号为tid；当remainder0时，协作组中的有效工作线程负责在高速片上缓存区读两个32比特信息的数据，从位置lid与位置hid读取两个信息元素Elid与Ehid，其中lid的位置根据偏移量H_shift确定，lid = %M，hid位置由lid确定，hid = %M，若remainder=0，协作组中线程直接将两个信息元素合并为64比特，通过指令向左移动H_shift%32位，然后保留左侧的32比特作为输出；若remainder＞0时，协作组中线程分为两种操作，第一部分线程hid%M=0，表示lid所在寄存器位置为M个寄存器中的最后一个，hid为第一个寄存器，二者空间上位置不连续，需要将hid的位置元素向左移位32-remainder，形成新的hid位置元素，再将两个信息元素合并为64比特，第二部分线程hid%M＞0，表示lid与hid位置连续，计算过程与remainder=0情况一致，形成，最终通过指令将向左移动H_shift%32位，然后保留左侧的32比特作为输出；当remainder＜0时，协作组中的有效工作线程负责在高速片上缓存区读一个32比特信息的数据，从位置id读取信息元素Eid，其中当Zc16时，直接通过指令将向左移动H_shift%32位，当Zc＞16时，需要再将信息元素Eid向右循环移动remainder位得到Eid’，将两个信息元素合并为64比特，通过指令将向左移动H_shift%32位，保留左侧的32比特作为输出结果。7. 根据权利要求6所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤8.2中，根据校验矩阵H类型B_type列出对应的方程组包括：用表示第一部分校验比特pa的校验子组，z= 1, 2, 3, 4；表示的位循环移位结果，，即步骤8.1中缓存的的前4组信息比特的模二相加；校验子组已知后，通过方程组得到,,。8. 根据权利要求7所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：根据步骤8.2中计算的pa，通过步骤8.1的高效移位操作，将pa与校验矩阵对应位置相乘得到， ；将与中的第5位至第mb对应位置相加，得到第二部分奇偶校验比特pc的结果。9.根据权利要求1所述的一种基于GPU的5GLDPC编码器的编码方法，其特征在于：在步骤9中，将有效比特进行压缩为：编码后的5GLDPC码为系统码，并且信息比特编码后的码字长，GPU设备需要消耗大量时间将码字传回主机端，采用编码信息压缩方式，只将高速片上缓存中的编码后的校验比特部分搬运到全局内存，节省搬运时间；当remainder为0时，Zc为32的整数倍，将高速片上缓存的信息比特连续拷贝到全局内存；当remainder不为0时，Zc不是32的整数倍，需要将每个信息子组中Zc个比特之后填充的比特删掉，每个Zc只包含前Zc个信息比特，再将所有比特移位合并，恢复为紧密的信息比特排布；然后将紧密排布的校验信息比特按照32比特为一组进行数据打包，末尾不够32比特的用0填充，将打包后的数据写入dst_offset指示的位置。
说明书desc
技术领域本发明属于通信技术领域，涉及一种基于图形处理器GPU的5GLDPC编码器的编码方法。背景技术最近，低密度奇偶校验码在5G通信中发挥着重要作用，并被选为增强型移动宽带数据通道的编码方案，采用准循环低密度奇偶校验码进行编码。由于5G QC-LDPC 具有多种校验矩阵和提升值，会组合出不同形式的LDPC码字，编码器设计难度极大。并且考虑到5G移动通信系统的空口资源配置，上下行的速率通常有对应关系，因此基站的LDPC编码器必须在规定时隙内完成大量码字编码，编码过程面临巨大的时延挑战，因此，设计一种低时延、高吞吐、低复杂性的5GLDPC编码器是一项亟待解决的难题。Nguyen等人提出了一种新型高效编码方法和高吞吐量低复杂度编码器结构，消耗的芯片面积和存储空间明显减少。通过存储每个子矩阵的置换信息的量化值而不是整个奇偶校验矩阵，在保持高吞吐量的同时，降低所需的内存存储。。Tian等人研究了QC-LDPC编码器的并行设计和实现，采用多通道并行结构来获得多个奇偶校验位，从而显著降低编码延迟。并将高并行度编码算法映射到可配置的电路结构，能够支持所有5G NR码长和码率。Liao等人提出了一种基于GPU的LDPC 编码方法。在单个GPU上对1/2到8/9的码率的LDPC编码实现了较高的吞吐量，实验表明了基于GPU的并行仿真任务可以在性能和成本之间取得良好的平衡。近期，相关专家和研究人员基于专用硬件平台和通用处理平台进行了大量5G LDPC码高速编码器的尝试，基于专用硬件的LDPC编码器，可以获得较低延时、较高的能量效率，考虑到基站测量大量码块的编码需求，需要批量部署大量专用芯片才能达到高吞吐性能要求。因此开发周期长、运维难度高，难以满足未来通信系统对任务多样化的发展需求。基于GPU通用处理平台设计的LDPC编码器通过软件设计进行实现，采用程序层面上的升级，灵活地进行部署和参数配置，但是现阶段的基于GPU的LDPC编码算法没有充分利用GPU计算资源，5GLDPC编码的并行处理设计方法仍有待提升。发明内容本发明提出一种基于GPU的5GLDPC编码器的编码方法，充分利用GPU计算资源对LDPC编码进行大规模并行处理，进一步提高编码器吞吐量，支持并行处理不同码型的LDPC编码，使编码器具有灵活、高速的特性。本发明首先提供一种基于GPU的5GLDPC高速编码器，所述编码器结构主要包括主机端和GPU设备端；主机端设置主机内存和CPU芯片，CPU芯片用于编码信息预处理、码字组合以及控制调度整个编码过程，将待编码信息流发送到GPU设备端；GPU设备端设置GPU芯片，GPU芯片由若干个流多处理器组成，每个SM负责一组不同码型LDPC码块的编码，处理器中开启的大量线程对信息流进行高速、并行编码；主机端和GPU设备端通过高速串行计算机扩展总线进行数据传输。本发明还提供一种基于GPU的5GLDPC编码器的编码方法，整个编码过程可以分为11步，基于上述编码器，具体编码步骤如下：步骤1：主机端存储空间初始化。在主机端根据同时处理的最大码块数量num_C，为信息比特和编码后的比特分配足够的存储空间；步骤2：GPU设备端存储空间初始化。GPU设备端配置内存空间，为信息比特和编码后的比特分配足够的全局内存空间，按照本次编码的最大占用资源对GPU分配高速片上内存空间；步骤3：GPU设备端的LDPC校验矩阵信息初始化。在GPU设备端，将5G协议规定的所有LDPC基矩阵Hb信息进行预存储，将基矩阵中的偏移量信息H_shift以及每行中循环块所在列的位置H_offset写入GPU全局内存。基矩阵Hb包括了子矩阵A、B、C、D、I；步骤4：主机端向GPU拷贝编码指示信息和数据信息。主机端将每个码块的编码信息写入一个结构体，其中包括每个码块基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，编码层数mb，修正值remainder。采用压缩排布的方式在主机端和设备端之间传输信息数据和编码比特，结构体中还包括每个码块信息比特的起始位置src_offset，以及编码完成后比特存储起始位置dst_offset，多个码块的编码指示信息结构体形成一个编码指示信息结构体数组，主机端将所有等待并行处理码块的指示信息结构体数组传送到GPU全局内存。主机端将每个码块的信息比特按照32比特进行比特打包，然后将所有码块的打包比特压缩排布，把待编码的信息比特数据拷贝到GPU全局内存。步骤5：主机端调用GPU函数进行LDPC编码。主机端设置GPU虚拟处理器分组block的数量等于最大码块数量num_C，block维度为一维，多个block并行处理不同码型的LDPC码字编码。主机端设置每个block的开启线程数量为256，线程维度为一维。步骤6：GPU对接收到的信息比特根据编码指示信息进行预处理。GPU每个block的线程到对应的结构体数组中获取对应码块的编码指示信息，包括基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，修正值remainder，信息比特的起始位置src_offset，编码完成后比特存储起始位置dst_offset，然后根据信息比特的起始位置src_offset、信息比特组数量kb和提升值Zc获取信息比特s，从src_offset指示的位置开始，到ceil*4字节的空间包含了该码块的信息比特，ceil表示向上取整。s表示了系统子矩阵A对应编码器接收的信息比特，它分为kb个信息比特子组si,，每组对应有Zc个比特。GPU对信息比特s中的每个信息比特子组si根据修正值remainder进行循环填充至32的倍数，每个子组对应基矩阵一个循环块。步骤7：GPU将处理后的数据信息搬运到高速片上内存。步骤8：GPU对LDPC进行并行编码。LDPC码的编码使用校验矩阵H执行，通过求方程式HcT=0解出码字c，其中cT表示码字c的转置。编码阶段共包括以下3个步骤:步骤8.1：线程分组，建立线程与信息处理的映射关系，通过高效移位操作计算kb个信息比特子组si对应的比特与校验矩阵相乘的结果，将计算结果的mb组元素缓存到高速片上内存中，为后面步骤计算奇偶校验比特做准备。步骤8.2：根据编码指示信息计算第一部分奇偶校验比特pa。第一部分奇偶校验比特pa包括4组校验比特 ，因此需要对校验矩阵H中前4层方程求解，根据校验矩阵H类型B_type列出对应的方程组，将步骤8.1中信息比特子组si对应的比特与校验矩阵相乘，根据相乘的结果求解方程组，读取高速片上内存中缓存向量的前4组结果，结合方程式求出第一部分校验比特pa。步骤8.3：根据步骤8.2的pa计算第二部分奇偶校验比特pc。依据步骤8.1中的方式计算第一部分奇偶校验比特pa与校验矩阵H相乘的结果，，再将与对应组进行模二相加，由于第二部分奇偶校验比特pc对应的校验矩阵为子矩阵I，相加结果即为第二部分奇偶校验比特pc结果。步骤9：GPU对编码后的奇偶校验比特进行压缩，计算后奇偶校验比特p共有mb组，每组需要根据修正值remainder删除冗余比特，得到每组Zc个有效比特，将有效比特进行压缩，根据比特存储起始位置dst_offset，将压缩校验比特结果写入全局内存。步骤10：将全局内存中的压缩信息传回主机端。步骤11：主机端对接收的压缩校验信息与信息比特进行拼接，形成完整的LDPC编码信息。其中，步骤3的LDPC基矩阵Hb信息包括：5G NR标准规定了BG1和BG2两种基矩阵，其具有结构如式所示，大小为mb×nb，mb代表编码层数，即基矩阵的行数，nb代表基矩阵的列数，nb=mb+kb。基矩阵Hb中，右上角0区域表示该部分内全是0，其中A的维度是4×kb，B的维度是4×4，C的维度是×kb，D的维度是×4，I的维度是×。基矩阵Hb包含了所有循环块对应的偏移量H_shift，通过计算得到每个循环块在一行中所在列的位置H_offset，将全部基本信息结构在译码前全部传入GPU内存。其中，步骤4的校验矩阵类型B_type包括：B的维度4×4，其有4种不同类型，5G协议规定了不同BG图样对应的固定的B_type。其中，步骤4所述的修正值remainder包括：根据提升值Zc的大小设置不同的修正值remainder，根据Zc与32的余数决定修正值remainder大小，当Zc32时，修正值remainder=Zc%32；当Zc＜32时，修正值remainder=-Zc%32。remainder=0代表信息比特可以恰好打包到一组无符号的32位整数变量。其中，步骤4所述的压缩排布的方式包括：PCI-E传输速度受限制，对于一组不同的LDPC码块进行编码时，选用固定步长，对于具有较小提升值Zc的LDPC码编码时需要填充大量冗余数据0，导致传输时间较长，因此采用压缩数据量的方式传入数据，通过主机端生成一组码块起始位置相对于首个码块起始位置的偏移量信息，用来指示每个码块在一组数据中的位置，每个码块相对于第一个码块起始位置的偏移量是前面所有码块的有效长度之和，相比于固定步长，对于提升值Zc=2的LDPC码，传输能够节省最多192倍的传输数据量。其中，步骤4所述的比特打包包括：由于信息数据为0或1的比特，将信息比特按照每32个比特为一组进行打包，能够充分利用GPU资源，GPU中每个线程操控32个比特进行并行计算，极大地增加了并行计算效率。其中，步骤6所述的循环填充包括：根据修正值remainder大小，对信息比特子组si中Zc比特的数据进行填充，由于GPU中寄存器内存大小为32比特，需填充至32的整数倍，形成以32bit为基本符号存储的信息数据，因此每个si占用M个寄存器，M = ceil，寄存器表示为Rt，t=1,2,…,M，实际有效信息数据只覆盖了M个寄存器中前Zc个比特。具体来说，当remainder=0时，Zc为32的整数倍，每组的有效信息填满了全部M个寄存器，不需要填充任何数据；当remainder＞0时，表示Zc不是32的整数倍且Zc＞32，si中的实际比特没有填满M个寄存器，每个si在实际占用的Zc个比特后开始填充同组si中头部数据比特，直至补全最后一个寄存器中的数据。当remainder＜0时，表示Zc＜32，每个占用一个寄存器，实际有效信息数据只覆盖前Zc个比特，将Zc个比特循环进行填充直至填满32个比特。循环填充目的在于为后续步骤中能够有效地对信息子组中的数据及逆行位移操作。其中，步骤8.1~步骤8.3为编码阶段，将该阶段合并到一个内核函数去执行，减少线程块间的同步开销、内核函数启动开销以及全局内存的访问量，编码中间信息放入GPU高速片上内存，减少全局内存的访问，提高编码速度。其中，步骤8所述的校验矩阵H包括：校验矩阵H由基矩阵Hb扩展Zc倍而来。基矩阵Hb中的一行元素指示的偏移量，对应H矩阵一层单位阵Zc×Zc的偏移。校验矩阵H可以表示为式，其中，下角标Zc表示了在基矩阵Hb元素上的Zc倍扩展；其中，步骤8的LDPC编码包括：LDPC码字可以分为三部分，C=，分别对应子矩阵B与子矩阵I，LDPC码的编码使用方程式HcT=0执行。其中，步骤8.1中的线程分组具体包括：GPU将每个block内的256个线程分16组，由于Zc最大为384，每个子组中最多包含384比特数据，因此需要每16个线程为一个协作组，每个线程负责32比特数据的操作和计算。在处理多码型LDPC编码过程中，协作组中实际参与运算的线程数量为ceil。每个协作组负责校验矩阵H内一层的所有循块对应的比特与校验矩阵相乘的求解，每层的求解最终算出一组结果，256个线程支持校验矩阵H内最多16个层的比特与校验矩阵相乘同时求解，每次计算16组结果，然后所有线程求解后面16层的运算，直到mb组结果求解完成。其中，步骤8.1中的信息比特子组si对应的比特与校验矩阵相乘具体包括，相乘结果用表示，sT表示s的转置，矩阵AZc和矩阵CZc由多个循环位移块组成，因此矩阵AZc与sT相乘以及矩阵CZc与sT相乘均可以表示为AZc与sT的相乘结果为，矩阵CZc与sT相乘结果为。其中，i表示信息子组的位置，也代表循环位移块在基矩阵中的列数，j表示循环位移块在基矩阵中的行数 ，表示模二相加，表示基矩阵中第j行，判断第i列的循环位移块是否为0，若为0，，若不为0，，因此表示了非0子块对应的信息比特子组si；当循环位移块不为0时，其具有循环位移量，表示了信息比特子组si应进行循环位移的大小，因此表示了的循环位移结果。其中，步骤8.1的高效移位包括：对每层进行遍历，协作组中的有效工作的线程读取基矩阵偏移量H_shift，每个线程标号为tid。当remainder0时，协作组中的有效工作线程负责在高速片上缓存区读两个32比特信息的数据，从位置lid与位置hid读取两个信息元素Elid与Ehid，其中lid的位置根据偏移量H_shift确定，lid = %M，hid位置由lid确定，hid = %M，若remainder=0，协作组中线程直接将两个信息元素合并为64比特，通过指令向左移动H_shift%32位，然后保留左侧的32比特作为输出；若remainder＞0时，协作组中线程分为两种操作，第一部分线程hid%M=0，表示lid所在寄存器位置为M个寄存器中的最后一个，hid为第一个寄存器，二者空间上位置不连续，需要将hid的位置元素向左移位32-remainder，形成新的hid位置元素，再将两个信息元素合并为64比特，第二部分线程hid%M＞0，表示lid与hid位置连续，计算过程与remainder=0情况一致，形成，最终通过指令将向左移动H_shift%32位，然后保留左侧的32比特作为输出。当remainder＜0时，协作组中的有效工作线程负责在高速片上缓存区读一个32比特信息的数据，从位置id读取信息元素Eid，其中当Zc16时，直接通过指令将向左移动H_shift%32位即可，当Zc＞16时，需要再将信息元素Eid向右循环移动remainder位得到Eid’，将两个信息元素合并为64比特，通过指令将向左移动H_shift%32位，保留左侧的32比特作为输出结果。其中，步骤8.2根据校验矩阵H类型B_type列出对应的方程组包括：用 表示第一部分奇偶校验比特pa的校验子组，表示的位循环移位结果，，即步骤8.1中缓存的的前4组信息比特的模二相加。校验子组已知后，通过方程组得到,, ;其中，步骤8.3的奇偶校验比特pa与H相乘计算包括：计算第二部分奇偶校验比特pc，根据步骤8.2中计算的pa，通过步骤8.1的高效移位操作，将pa与校验矩阵对应位置相乘得到。将与中的第5位至第mb对应位置相加，得到第二部分奇偶校验比特pc的计算结果。其中，步骤9的将有效比特进行压缩包括，编码后的5GLDPC码为系统码，并且信息比特编码后的码字较长，GPU设备需要消耗大量时间将码字传回主机端，因此采用编码信息压缩方式，只将高速片上缓存中的编码后的校验比特部分搬运到全局内存，从而节省大量的搬运时间。当remainder为0时，Zc为32的整数倍，将高速片上缓存的信息比特连续拷贝到全局内存；当remainder不为0时，Zc不是32的整数倍，需要将每个信息子组中Zc个比特之后填充的比特删掉，每个Zc只包含前Zc个信息比特，再将所有比特移位合并，恢复为紧密的信息比特排布。然后将紧密排布的校验信息比特按照32比特为一组进行数据打包，末尾不够32比特的用0填充，将打包后的数据写入dst_offset指示的位置。与现有方法相比，本发明的优点与积极效果在于：本发明在软件逻辑层面为每个码块灵活划分相应的计算资源，支持同时对不同码长码率的码块进行编码，在对大规模LDPC码块进行编码的过程中，能有效地减小主机与设备之间的数据传输开销，提高编码器的灵活性和实用价值。本发明充分结合LDPC编码算法的特点和GPU的架构特点，充分利用GPU资源，提升访存效率和数据计算单元利用率，通过比特打包的方式，增加运算的指令吞吐，减少单个码块消耗资源的同时提高单个码块的编码并行性，提高整体的信息吞吐量。附图说明图1为本发明的基于GPU的LDPC高速编码器结构示意图。图2为本发明的基于GPU的LDPC高速编码方法流程图。图3为本发明的信息压缩排布示意图。图4为本发明的比特打包示意图。图5为本发明的比特循环填充示意图。图6为本发明的比特高效移位示意图。图7为本发明的有效编码比特进行压缩示意图。图8为本发明的压缩校验比特与信息比特拼接示意图。具体实施方式下面结合附图1-8和实施示例对本发明进行详细说明。本发明提供一种基于GPU的5G LDPC码高速编码器。图1展示了高速编码器的结构示意图，其中Nsm表示GPU芯片上流多处理器的个数，编码器结构包括主机端和GPU设备端；主机端设置主机内存和CPU芯片，CPU芯片用于编码信息预处理、码字组合以及控制调度整个编码过程，将待编码信息流发送到GPU设备端；GPU设备端设置GPU芯片，GPU芯片由若干个流多处理器组成，每个SM负责一组不同码型LDPC码块的编码，SM的逻辑单元包括全局内存、常量内存、高速片上内存、寄存器内存等，由于高速片上内存存储编码过程中的中间计算信息，从而降低逐层更新访问存储信息时延；寄存器内存用于存放所有计算访存过程产生的中间量等临时变量，处理器中开启的大量线程对信息流进行高速并行编码；主机端和GPU设备端通过高速串行计算机扩展总线进行数据传输。本发明还提供一种基于GPU的5GLDPC编码器的编码方法，整个编码过程可以分为11步，图2展示了该方法流程图，具体编码步骤如下：步骤1：主机端存储空间初始化。在主机端根据同时处理的最大码块数量num_C，为信息比特和编码后的比特分配足够的存储空间；步骤2：GPU设备端存储空间初始化。GPU端配置内存空间，为信息比特和编码后的比特分配足够的全局内存空间，按照本次编码的最大占用资源对GPU分配高速片上内存空间；步骤3：GPU设备端LDPC校验矩阵信息初始化。在GPU设备端，将5G协议规定的所有LDPC基矩阵Hb信息进行预存储，将基矩阵中的偏移量信息H_shift以及每行中循环块所在列的位置H_offset写入GPU全局内存。基矩阵Hb包括了子矩阵A、B、C、D、I；步骤4：主机端向GPU拷贝编码指示信息和数据信息。主机端将每个码块的编码信息写入一个结构体，其中包括每个码块基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，编码层数mb，修正值remainder。采用压缩排布的方式在主机端和设备端之间传输信息数据和编码比特，结构体中还包括每个码块信息比特的起始位置src_offset，以及编码完成后比特存储起始位置dst_offset，多个码块的编码指示信息结构体形成一个编码指示信息结构体数组，主机端将所有等待并行处理码块的指示信息结构体数组传送到GPU全局内存。主机端将每个码块的信息比特按照32比特进行比特打包，然后将所有码块的打包比特压缩排布，把待编码的信息比特数据拷贝到GPU全局内存。步骤5：主机端调用GPU函数进行LDPC编码。主机端设置GPU虚拟处理器分组block的数量等于最大码块数量num_C，block维度为一维，多个block并行处理不同码型的LDPC码字编码。主机端设置每个block的开启线程数量为256，线程维度为一维。步骤6：GPU对接收到的信息比特根据编码指示信息进行预处理。GPU每个block的线程到对应的结构体数组中获取对应码块的编码指示信息，包括基本图BG、提升值Zc，信息比特组数量kb，校验矩阵类型B_type，修正值remainder，信息比特的起始位置src_offset，编码完成后比特存储起始位置dst_offset，然后根据信息比特的起始位置src_offset、信息比特组数量kb和提升值Zc获取信息比特s，从src_offset指示的位置开始，到ceil*4字节的空间包含了该码块的信息比特，ceil表示向上取整。s表示了子矩阵A对应编码器接收的信息比特部分，它分为kb个信息比特子组si,，每组对应有Zc个比特。GPU对信息比特s中的每个信息比特子组si，根据修正值remainder进行循环填充至32的倍数，每个信息比特子组对应基矩阵一个循环块。步骤7：GPU将处理后的数据信息搬运到高速片上内存。步骤8：GPU对LDPC进行并行编码。LDPC码的编码使用校验矩阵H执行，通过求方程式解出码字c，编码阶段共包括以下3个步骤:步骤8.1：线程分组，建立线程与信息处理的映射关系，通过高效移位操作计算kb个信息比特子组si对应的比特与校验矩阵相乘的结果，将计算结果的mb组元素缓存到高速片上内存中，为后面步骤计算奇偶校验比特准备。步骤8.2：根据编码指示信息计算第一部分奇偶校验比特pa第一部分奇偶校验比特pa包括4组校验比特 ，因此需要对校验矩阵H中前4层方程求解，根据校验矩阵H类型B_type列出对应的方程组，将步骤8.1中信息比特子组si对应的比特与校验矩阵相乘，根据相乘的结果求解方程组，读取高速片上内存中缓存的向量结果的前4组结果，结合方程式求出第一部分奇偶校验比特pa。步骤8.3：根据步骤8.2的pa计算第二部分奇偶校验比特pc。依据步骤8.1中的方式计算第一部分奇偶校验比特pa与校验矩阵H相乘的结果，，再将与对应组进行模二相加，由于第二部分奇偶校验比特pc对应的校验矩阵为子矩阵I，相加结果即为第二部分奇偶校验比特pc结果。步骤9：GPU对编码后的奇偶校验比特进行压缩，计算后奇偶校验比特p共有mb组，每组需要根据修正值remainder删除冗余比特，得到每组Zc个有效比特，将有效比特进行压缩，同时根据编码完成后比特存储起始位置dst_offset将压缩校验比特结果写入全局内存。步骤10：将全局内存中的压缩信息传回主机端。步骤11：主机端对接收的压缩校验信息与信息比特进行拼接，形成完整的LDPC编码信息。如图8所示，主机端对信息比特通过PCI-E总线发送到GPU端，GPU端进行高速编码，然后只将校验比特部分通过PCI-E总线返回主机端，主机端再对信息比特和校验比特进行拼接，形成完整的码字。其中，步骤4的修正值remainder计算的具体操作为：根据提升值Zc的大小设置不同的修正值remainder，根据Zc与32的余数决定修正值remainder大小，当Zc32时，修正值remainder=Zc%32；当Zc＜32时，修正值remainder=－Zc%32。remainder=0代表信息比特可以恰好打包到一组无符号的32位整数变量。例如，Zc=8032，remainder=Zc%32= 16。其中，步骤4的压缩排布的具体操作为：PCI-E传输速度受限制，对于一组不同的LDPC码块进行编码时，选用固定步长，对于具有较小提升值Zc的LDPC码编码时需要填充大量冗余数据0，导致传输时间较长，因此采用压缩数据量的方式传入数据，通过主机端生成一组码块起始位置相对于首个码块起始位置的偏移量信息，用来指示每个码块在一组数据中的位置，每个码块相对于第一个码块起始位置的偏移量是前面所有码块的有效长度之和，相比于固定步长，对于提升值Zc=2的LDPC码，传输能够节省最多192倍的传输数据量。如图3所示，dst_offsetn、Pn、Zn分别表示了第n个码块的起始位置、字节大小、提升值大小，Pn=ceil*4字节，每个码块只存储自身的有效字节Pn，不存储其他冗余位置的0，每个码块的起始位置dst_offsetn都通过前一个码块的起始位置dst_offsetn-1加上前一个码块的字节Pn-1获得，即为前面所有码块的有效长度之和，该压缩方式几乎不产生冗余比特，减少了传输数据量。其中，步骤4的比特打包的具体操作为：由于信息数据为0或1的比特，将信息比特按照每32个比特为一组进行打包，如图4所示，对于一串信息比特数据，每32比特为一组进行划分，每组中的比特正好放入一个寄存器内，这样能够充分利用GPU资源，GPU中每个线程操控32个比特进行并行计算，极大地增加了并行计算效率。其中，步骤6的循环填充的具体操作为：根据修正值remainder大小，对信息比特子组si中Zc比特的数据进行填充，由于GPU中寄存器内存大小为32比特，需填充至32的整数倍，形成以32bit为基本符号存储的信息数据，因此每个si占用M个寄存器，M =ceil，寄存器表示为Rt，t=1,2,…,M，实际有效信息数据只覆盖了M个寄存器中前Zc个比特。具体来说，当remainder=0时，Zc为32的整数倍，每组的有效信息填满了全部M个寄存器，不需要填充任何数据；当remainder＞0时，表示Zc不是32的整数倍且Zc＞32，si中的实际比特没有填满M个寄存器，每个si在实际占用的Zc个比特后开始填充同组si中头部数据比特，直至补全最后一个寄存器中的数据。当remainder＜0时，表示Zc＜32，每个占用一个寄存器，实际有效信息数据只覆盖前Zc个比特，将Zc个比特循环进行填充直至填满32个比特。循环填充目的在于为后续步骤中能够有效地对信息子组中的数据及逆行位移操作。如图5所示，展示了第一信息比特子组s1的循环填充过程，当Zc=80，remainder = 16，其比特索引为，由于floor = 2，80%32=16，前2个32bit符号正常填充，填充的索引为，第3组符号拆分成两部分，每部分16bit，第3个符号前半部分填充索引为的16比特的信息，第3个符号后半部分填充索引为的16比特的信息。其中，步骤8的LDPC编码的具体操作为：LDPC码字可以分为三部分，C=，其中s表示子矩阵A对应编码器接收的信息比特，分别对应子矩阵B与I，LDPC码的编码使用方程式执行： 然后，将方程式自然地分为等式和等式：式和式中T表示该矩阵的转置。其中，步骤8.1中，线程分组的具体操作为：GPU将每个block内的256个线程分16组，由于Zc最大为384，每个子组中最多包含384比特数据，因此需要每16个线程为一个协作组，每个线程负责32比特数据的操作和计算。在处理多码型LDPC编码过程中，协作组中实际参与运算的线程数量为ceil。每个协作组负责校验矩阵H内一层的所有循环位移块对应的比特与校验矩阵相乘的求解，每层的求解最终算出一组结果，256个线程支持校验矩阵H内最多16个层的比特与校验矩阵相乘同时求解，每次计算16组结果，然后所有线程求解后面16层的运算，直到mb组结果求解完成。其中，步骤8.1中，信息比特子组si与校验矩阵相乘的具体操作为：相乘结果用表示，sT表示s的转置，矩阵AZc和矩阵CZc由多个循环位移块组成，因此矩阵AZc与sT相乘以及矩阵CZc与sT相乘均可以表示为AZc与sT的相乘结果为，矩阵CZc与sT相乘结果为。其中，i表示信息子组的位置，也代表循环位移块在基矩阵中的列数，j表示循环位移块在基矩阵中的行数 ，表示模二相加，表示基矩阵中第j行，判断第i列的循环位移块是否为0，若为0，，若不为0，，因此表示了非0子块对应的信息比特子组si；当循环位移块不为0时，其具有循环位移量，表示了信息比特子组si应进行循环位移的大小，因此表示了的循环位移结果。其中，步骤8.1的高效移位的具体操作为：每层按照度进行遍历，协作组中的有效工作的线程读取基矩阵偏移量H_shift，每个线程标号为tid。当remainder0时，协作组中的有效工作线程负责在高速片上缓存区读两个32比特信息的数据，从位置lid与位置hid读取的两个信息元素Elid与Ehid，其中lid的位置根据偏移量H_shift确定，lid = %M，hid位置由lid确定，hid = %M，若remainder=0，协作组中线程直接将两个信息元素合并为64比特，通过指令向左移动H_shift%32位，然后保留左侧的32比特作为输出；若remainder＞0时，协作组中线程分为两种操作，第一部分线程hid%M=0，表示lid所在寄存器位置为M个寄存器中的最后一个，hid为第一个寄存器，二者空间上位置不连续，需要将hid的位置元素向左移位32-remainder，形成新的hid位置元素，再将两个信息元素合并为64比特，第二部分线程hid%M＞0，表示lid与hid位置连续，计算过程与remainder=0情况一致，形成，最终通过指令将向左移动H_shift%32位，然后保留左侧的32比特作为输出。当remainder＜0时，协作组中的有效工作线程负责在高速片上缓存区读一个32比特信息的数据，从位置id读取信息元素Eid，其中当Zc16时，直接通过指令将向左移动H_shift%32位即可，当Zc＞16时，需要再将信息元素Eid向右循环移动remainder位得到Eid’，将两个信息元素合并为64比特，通过指令将向左移动H_shift%32位，保留左侧的32比特作为输出结果。图6展示了当remainder=16时，第一组s1的高效移位过程，当Zc=80时，第一组s1索引为，共占用M=3个寄存器，数据依次承载在寄存器m1，m2，m3上，每个协作组中的3个有效工作线程tid：0、1、2负责在高速片上缓存区读两个32比特信息的数据，从位置lid与位置hid读取的两个信息元素Elid与Ehid，其中lid的位置根据偏移量H_shift确定，图6中H_shift = 10，lid = %M，hid位置由lid确定，hid =%M，因此线程0加载m1，m2的数据，线程1加载m2，m3的数据，线程2加载m3，m1的数据。线程2满足hid%M=0，表示线程2lid所在寄存器位置为M个寄存器中的最后一个，hid为第一个寄存器，二者空间上位置不连续，因此将hid的位置元素向左移位16，形成新的hid位置元素，再将两个信息元素合并为64比特；线程0、线程1满足hid%M＞0，表示lid与hid位置连续，计算过程与remainder=0情况一致，形成。最终通过指令将向左移动H_shift%32=10位，然后保留左侧的32比特作为输出，得到如图6所示的输出结果。其中，步骤8.2根据H矩阵类型B_type列出对应的方程组包括：将式以块形式书写，可以扩展为以下方程组：其中，表示pa的校验子组，表示的循环移位结果。通过将上述所有方程相加，得到校验子组结果， 即步骤8.1中缓存的的前4组信息比特的模二相加。校验子组已知后，通过方程组得到,, ;其中，步骤8.3的pa与H相乘计算的具体操作为：使用等式计算第二部分奇偶校验比特pc，根据步骤8.2中计算的pa，通过步骤8.1的高效移位操作，将pa与校验矩阵对应位置相乘，得到。将与中的第5位至第mb对应位置相加，得到第二部分奇偶校验比特pc的计算结果。其中，步骤9的将有效编码比特进行压缩的具体操作为，编码后的5GLDPC码为系统码，并且信息比特编码后的码字较长，GPU设备需要消耗大量时间将码字传回主机端，因此采用编码信息压缩方式，只将高速片上缓存中的编码后的校验比特部分搬运到全局内存，从而节省大量的搬运时间。当remainder为0时，Zc为32的整数倍，将高速片上缓存的信息比特连续拷贝到全局内存；当remainder不为0时，Zc不是32的整数倍，需要将每个信息子组中Zc个比特之后填充的比特删掉，每个Zc只包含前Zc个信息比特，再将所有比特移位合并，恢复为紧密的信息比特排布。如图7所示，Zc=80，remainder = 16，以第一组信息比特为例，其索引为，由于floor = 2，80%32=16，前2个32bit符号正常搬运，填充的索引为，第3个符号拆分成两部分，每部分16bit，第3个符号前半部分填充索引为的16比特的信息，第3个符号后半部分填充下一组信息比特索引为 的16比特的信息。然后将紧密排布的校验信息比特按照32比特为一组进行数据打包，末尾不够32比特的用0填充，将打包后的数据写入dst_offset指示位置。

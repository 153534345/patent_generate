标题title
深度学习框架的算子处理方法、装置、设备和存储介质
摘要abst
本公开提供了一种深度学习框架的算子处理方法，涉及计算机技术领域，尤其涉及深度学习等人工智能技术领域。具体实现方案为：获取待处理算子，其中，待处理算子包括算子核函数和与深度学习框架无关的模板参数；响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数；以及根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。本公开还提供了一种深度学习框架的算子处理装置、电子设备和存储介质。
权利要求书clms
1.一种深度学习框架的算子处理方法，包括：获取待处理算子，其中，所述待处理算子包括算子核函数和与深度学习框架无关的模板参数；响应于接收到针对所述待处理算子的输入信息，利用所述输入信息解析所述模板参数，得到与深度学习框架相关的多个完整模板参数；以及根据多个完整模板参数，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子。2.根据权利要求1所述的方法，其中，所述响应于接收到针对所述待处理算子的输入信息，利用所述输入信息解析所述模板参数，得到与深度学习框架相关的多个完整模板参数包括：利用宏创建可变参数列表；以及基于所述可变参数列表迭代地解析所述模板参数，其中，所述输入信息作为所述宏的宏参数。3.根据权利要求2所述的方法，其中，所述可变参数列表包括：待处理算子的名称；所述算子核函数的名称；所述算子核函数的数据布局；用于实现所述深度学习框架的设备类型；以及用于实现所述深度学习框架的数据类型。4.根据权利要求2所述的方法，其中，所述基于所述可变参数列表迭代地解析所述模板参数包括：确定所述宏包括的参数数目；根据所述参数数目，确定迭代结束位置；以及利用可变参数列表，根据所述迭代结束位置迭代处理所述输入信息。5.根据权利要求2-4之一所述的方法，其中，所述基于所述可变参数列表迭代地解析所述模板参数还包括：利用所述可变参数列表迭代地解析所述模板参数，得到多个内部模板参数；以及将所述多个内部模板参数进行拼接，得到所述多个完整模板参数。6.根据权利要求5所述的方法，其中，所述多个内部模板参数包括多个字符串；所述将所述多个内部模板参数进行拼接，得到多个完整模板参数包括：根据所述输入信息，将所述多个字符串进行拼接，得到针对所述待处理算子的多个完整模板参数。7.根据权利要求5所述的方法，其中，根据多个完整模板参数，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子包括：通过对所述多个完整模板参数进行显式实例化，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子。8.根据权利要求7所述的方法，其中，所述多个完整模板参数各自包括模板函数描述信息和模板函数信息；所述通过对所述多个完整模板参数进行显式实例化，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子包括：将所述模板函数描述信息实例化为头文件；以及将所述模板函数信息实例化为源码文件。9.根据权利要求5所述的方法，其中，所述根据多个完整模板参数，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子包括：针对所述多个完整模板参数中的每个完整模板参数，确定该完整模板参数的函数参数类型；根据所述函数参数类型，将所述完整模板参数的输入信息转换为对应参数信息；以及记录所述对应参数信息。10.根据权利要求5所述的方法，还包括：根据所述多个完整模板参数，创建基于所述深度学习框架的待注册算子；以及将所述待注册算子注册到所述深度学习框架内部的全局算子表中。11.根据权利要求10所述的方法，其中，所述待注册算子包括待注册算子描述信息和待注册算子核函数，所述待注册算子核函数中包括归一化的输入信息和归一化的函数指针；所述根据所述多个完整内部模板函数，创建基于所述深度学习框架的待注册算子包括：针对所述多个完整模板参数中的每个完整模板参数，确定与所述完整模板参数对应的结构体，所述结构体包含静态函数，所述静态函数具有归一化形式；将所述静态函数的输入信息作为所述归一化的输入信息；以及将所述静态函数的函数指针作为所述归一化的函数指针。12.根据权利要求11所述的方法，其中，所述静态函数的输入信息组成输入信息列表，所述输入信息列表包括输入张量列表；所述结构体包括至少一个特化子结构体，所述至少一个特化子结构体各自具有对应的数据类型。13.根据权利要求10所述的方法，其中，所述全局算子表包括：算子核工厂类；算子核名称类和内核键值类；以及算子核类。14.根据权利要求13所述的方法，其中，所述算子核类包括以下中的至少一个：算子核函数的指针；算子核函数输入参数的描述信息；以及算子核函数输出参数的描述信息。15.根据权利要求1所述的方法，其中，所述与深度学习框架无关的模板参数用于分发所述待处理算子；所述与深度学习框架无关的模板参数包括与所述深度学习框架的实现设备和所述深度学习框架的数据类型均无关的模板参数。16.根据权利要求1所述的方法，还包括：响应于针对所述可用算子的调用指令，调用所述可用算子；以及通过编译调用的所述可用算子，执行与所述可用算子相对应的函数功能。17.一种深度学习框的算子处理装置，包括：获取模块，用于获取待处理算子，其中，所述待处理算子包括算子核函数和与深度学习框架无关的模板参数；解析模块，用于响应于接收到针对所述待处理算子的输入信息，利用所述输入信息解析所述模板参数，得到与深度学习框架相关的多个完整模板参数；以及处理模块，用于根据多个完整模板参数，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子。18.根据权利要求17所述的装置，其中，所述解析模块包括：创建子模块，用于利用宏创建可变参数列表；以及解析子模块，用于基于所述可变参数列表迭代地解析所述模板参数，其中，所述输入信息作为所述宏的宏参数。19.根据权利要求18所述的装置，其中，所述可变参数列表包括：待处理算子的名称；所述算子核函数的名称；所述算子核函数的数据布局；用于实现所述深度学习框架的设备类型；以及用于实现所述深度学习框架的数据类型。20.根据权利要求18所述的装置，其中，所述解析子模块包括：第一确定单元，用于确定所述宏包括的参数数目；第二确定单元，用于根据所述参数数目，确定迭代结束位置；以及处理单元，用于利用可变参数列表，根据所述迭代结束位置迭代处理所述输入信息。21.根据权利要求18-20之一所述的装置，其中，所述解析子模块还包括：解析单元，用于利用所述可变参数列表迭代地解析所述模板参数，得到多个内部模板参数；以及拼接单元，用于将所述多个内部模板参数进行拼接，得到所述多个完整模板参数。22.根据权利要求21所述的装置，其中，所述多个内部模板参数包括多个字符串；所述拼接单元包括：拼接子单元，用于根据所述输入信息，将所述多个字符串进行拼接，得到针对所述待处理算子的多个完整模板参数。23.根据权利要求21所述的装置，其中，根据处理模块包括：显式实例化子模块，用于通过对所述多个完整模板参数进行显式实例化，对所述算子核函数进行处理，得到用于所述深度学习框架的可用算子。24.根据权利要求23所述的装置，其中，所述多个完整模板参数各自包括模板函数描述信息和模板函数信息；所述显式实例化子模块包括：第一实例化单元，用于将所述模板函数描述信息实例化为头文件；以及第二实例化单元，用于将所述模板函数信息实例化为源码文件。25.根据权利要求21所述的装置，其中，所述处理模块包括：第一确定子模块，用于针对所述多个完整模板参数中的每个完整模板参数，确定该完整模板参数的函数参数类型；转换子模块，应与根据所述函数参数类型，将所述完整模板参数的输入信息转换为对应参数信息；以及记录子模块，用于记录所述对应参数信息。26.根据权利要求21所述的装置，还包括：创建模块，用于根据所述多个完整模板参数，创建基于所述深度学习框架的待注册算子；以及注册模块，用于将所述待注册算子注册到所述深度学习框架内部的全局算子表中。27.根据权利要求26所述的装置，其中，所述待注册算子包括待注册算子描述信息和待注册算子核函数，所述待注册算子核函数中包括归一化的输入信息和归一化的函数指针；所述创建模块包括：第二确定子模块，用于针对所述多个完整模板参数中的每个完整模板参数，确定与所述完整模板参数对应的结构体，所述结构体包含静态函数，所述静态函数具有归一化形式；第一归一化子模块，用于将所述静态函数的输入信息作为所述归一化的输入信息；以及第二归一化模块，用于将所述静态函数的函数指针作为所述归一化的函数指针。28.根据权利要求27所述的装置，其中，所述静态函数的输入信息组成输入信息列表，所述输入信息列表包括输入张量列表；所述结构体包括至少一个特化子结构体，所述至少一个特化子结构体各自具有对应的数据类型。29.根据权利要求25所述的装置，其中，所述全局算子表包括：算子核工厂类；算子核名称类和内核键值类；以及算子核类。30.根据权利要求29所述的装置，其中，所述算子核类包括以下中的至少一个：算子核函数的指针；算子核函数输入参数的描述信息；以及算子核函数输出参数的描述信息。31.根据权利要求17所述的装置，其中，所述与深度学习框架无关的模板参数用于分发所述待处理算子；所述与深度学习框架无关的模板参数包括与所述深度学习框架的实现设备和所述深度学习框架的数据类型均无关的模板参数。32.根据权利要求17所述的装置，还包括：调用模块，用于响应于针对所述可用算子的调用指令，调用所述可用算子；以及执行模块，用于通过编译调用的所述可用算子，执行与所述可用算子相对应的函数功能。33.一种电子设备，包括：至少一个处理器；以及与所述至少一个处理器通信连接的存储器；其中，所述存储器存储有可被所述至少一个处理器执行的指令，所述指令被所述至少一个处理器执行，以使所述至少一个处理器能够执行权利要求1至16中任一项所述的方法。34.一种存储有计算机指令的非瞬时计算机可读存储介质，其中，所述计算机指令用于使所述计算机执行根据权利要求1至16中任一项所述的方法。35.一种计算机程序产品，包括计算机程序，所述计算机程序在被处理器执行时实现根据权利要求1至16中任一项所述的方法。
说明书desc
技术领域本公开涉及计算机技术领域，尤其涉及深度学习等人工智能技术领域。更具体地，本公开提供了一种深度学习框架的算子处理方法、装置、电子设备和存储介质。背景技术随着人工智能技术的发展，深度学习框架逐渐受到越来越多的关注。深度学习框架的评价指标包括框架的可扩展性。发明内容本公开提供了一种深度学习框架的算子处理方法、装置、设备以及存储介质。根据本公开的一方面，提供了一种深度学习框架的算子处理方法，该方法包括：获取待处理算子，其中，待处理算子包括算子核函数和与深度学习框架无关的模板参数；响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数；以及根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。根据本公开的另一方面，提供了一种深度学习框架的算子处理装置，该装置包括：获取模块，用于获取待处理算子，其中，待处理算子包括算子核函数和与深度学习框架无关的模板参数；解析模块，用于响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数；以及处理模块，用于根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。根据本公开的另一方面，提供了一种电子设备，包括：至少一个处理器；以及与至少一个处理器通信连接的存储器；其中，存储器存储有可被至少一个处理器执行的指令，指令被至少一个处理器执行，以使至少一个处理器能够执行根据本公开提供的方法。根据本公开的另一方面，提供了一种存储有计算机指令的非瞬时计算机可读存储介质，该计算机指令用于使计算机执行根据本公开提供的方法。根据本公开的另一方面，提供了一种计算机程序产品，包括计算机程序，该计算机程序在被处理器执行时实现根据本公开提供的方法。应当理解，本部分所描述的内容并非旨在标识本公开的实施例的关键或重要特征，也不用于限制本公开的范围。本公开的其它特征将通过以下的说明书而变得容易理解。附图说明附图用于更好地理解本方案，不构成对本公开的限定。其中：图1是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图；图2是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图；图3是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图；图4是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图；图5是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图；图6是根据本公开的一个实施例的全局算子表的示例示意图；图7是根据本公开的一个实施例的深度学习框架的算子处理装置的框图；以及图8是根据本公开的一个实施例的可以应用深度学习框架的算子处理方法的电子设备的框图。具体实施方式以下结合附图对本公开的示范性实施例做出说明，其中包括本公开实施例的各种细节以助于理解，应当将它们认为仅仅是示范性的。因此，本领域普通技术人员应当认识到，可以对这里描述的实施例做出各种改变和修改，而不会背离本公开的范围和精神。同样，为了清楚和简明，以下的描述中省略了对公知功能和结构的描述。深度学习框架是人工智能领域的基础设施，已经进入较为成熟的发展阶段。能否进行更高效、更便捷地支持上层扩展及二次开发，是评价一个深度学习框架产品能否作为“基础设施”、能否实现人工智能产业落地以及能否进行领域扩展的重要指标。深度学习框架包括：PaddlePaddle框架、PyTorch框架、TensorFlow框架、MindSpore框架以及其他多个小众框架。这些框架可以提供类似的功能。然而，作为人工智能时代生态建设的“基石”，深度学习框架需要吸引更多上游开发者加入，使得框架被进一步地加工改造。为此，深度学习框架需要具有设计清晰、易维护、易理解、便于定制化扩展开发等特点，以降低上游开发者共建框架生态的成本。算子体系可以占据一个框架半数以上的代码，可以作为深度学习框架的主体。能否低成本地对算子体系扩展新增，是降低其中共建框架生态的成本的关键一环。算子是深度学习框架中的张量计算单元。算子可以将特定的张量组合作为输入，可以完成特定的计算逻辑，并返回计算结果。使用深度学习框架搭建模型的过程，可以是组合不同算子以满足特定计算逻辑的过程。算子的多样性与丰富程度，可以作为衡量深度学习框架的重要指标。深度学习框架中的算子可以是持续地动态新增的。不同算子之间既有所联系又有所区别。复杂的算子往往可以通过简单的算子组合实现。若深度学习框架支持这种算子组合实现的模式，有助于实现降本增效，也有助于吸引外部开发者对该框架进行二次开发。函数是编程语言中的基础范式。函数之间可以互相调用。为了使得深度学习框架具备便捷的算子组合开发能力，可以基于函数式算子体系构建深度学习框架。函数式算子体系应用较少。函数和算子之间存在矛盾。例如，函数本身过于简单，不具备携带信息和特征的能力。此外，函数过于灵活，形式多样，参数多样，难以规范化。算子是一个相对复杂的概念，带有特征描述，需要适配多种设备。此外，算子作为框架的统一调度单元，需要抽象出一致的形态，以便适配全局调度。出于现实考虑，深度学习框架产品往往会作出折中的设计，放弃函数式范式，使用“结构体+内部计算方法”的形式，牺牲组合复用便利性，以保持算子范式的统一。然而，这种折中的设计会导致框架维护成本和扩展成本提高。一些深度学习框架产品可以对顶层算子函数进行封装，以屏蔽算子多样性。这些深度学习框架产品可以利用在函数内部做分发选择的方式，实现算子之间的复用。在算子之间复用时，这些深度学习框架产品会产生分发选择的调度开销，性能有损。这些深度学习框架产品虽然保有算子组合复用的便利性，但牺牲了部分性能。如果不进行算子组合即可使性能更优，可以放弃算子复用的方式，将多个算子核的代码直接放到一起，以提升性能。因此，解决函数式算子之间复用性能的问题，可以使函数式算子的优势得以持久地发挥。为了形成兼顾“函数式”与“高性能复用”的算子体系，需要自动化地将形式简单、灵活多样的“函数”包装为形式统一且具备描述特征的算子，做到“函数式”开发；以及确保函数式算子复用时不会引入额外的调度分发开销，做到“高性能复用”。为了实现函数式算子体系，需要函数式算子范式设计和函数式算子解析及注册。函数式算子范式设计，即用函数的写法实现算子的计算内核。函数中一般使用C++编程语言完成算子的核心计算逻辑编写。函数式算子天然支持算子间互相复用。函数式算子解析及注册，即设计关键组件，自动化地将形式简单、灵活多样的函数包装为形式统一且具备描述特征的算子，以供框架统一调度。此外，为了实现可复用的函数式算子体系，还需要函数式算子之间支持设备无关复用。在同一算子应用于不同的设备时，需要不同的内核函数。例如，算子应用于CPU时，需要有CPU的算子内核，GPU有GPU的算子内核，即使是函数式算子，这两个内核也需要是不同的函数；而新开发一个算子，并且它可以复用其他算子组合实现时，它复用的算子需要是设备无关的，否则就会造成重复开发，举个简单的例子：假设已有两个算子：-算子A：-算子A CPU内核：A_CPU-算子A GPU内核：A_GPU-算子B：-算子B CPU内核：B_CPU-算子B GPU内核：B_GPU例如，基于算子A和算子B实现一个新算子。一种实现方式为：-算子C：-算子C CPU内核：C_CPU{A_CPU；B_CPU；}-算子C GPU内核：C_GPU{A_GPU；B_GPU；}该实现方式不是合理的函数式算子体系，冗余代码多，维护成本高。此外，基于这种方式的复用算子，只能分设备复用，很容易发现，每个设备算子C内核实现代码，都是几乎一样的。函数式算子体系是为了提升算子复用效率，降低维护成本，便于扩展开发。而这种每个设备内核都需要几乎复制一份内核实现的方式，并不是严格的函数式算子体系。如上文所述，不同的深度学习框架例如可以包括Pytorch框架、TensorFlow框架和MindSpore框架。在Pytorch框架下，算子最终会封装成一个函数式的接口，函数式算子之间也可以复用，Pytorch的一个算子分为多层实现，上层调用下层时，需要查找下一层算子实现。在PyTorch框架下，算子之间复用，及算子内复用时，采用了算子内核映射表查找并选择对应内核的方式。这种方式的开销是比较重的，一个算子的执行过程中，可能需要进行多次算子查找。在TensorFlow框架下，算子依然是结构体算子，不是函数式算子。结构体形式的算子内核实现不够直观，增加了额外的概念，且算子之间复用需要引入更复杂的写法及更大的调度开销，设计上天然属于不便于新算子组合开发的形式。一般在结构体形式的算子体系下，在实现算子核函数时，需要额外定义函数，以便于不同算子能够复用该算子核函数。这种方式能够实现一定程度的泛化，但维护成本高，规范管理困难，框架长期发展会出现多处冗余的代码，维护成本逐渐增大。在TensorFlow框架的衍生产品tensorflow/runtime框架中，算子可以是函数式算子。但tensorflow/runtime框架只是一个实验性产品，算子数目较少，尚不成体系。此外，算子参数列表比较混乱，规范性较差，不能实现高性能复用。MindSpore框架下的算子与TensorFlow框架类似，不再赘述。图1是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图。如图1所示，该方法100可以包括操作S110至操作S130。在操作S110，获取待处理算子。例如，待处理算子包括算子核函数和与深度学习框架无关的模板参数。例如，获得的待处理算子例如可以为Scale算子。Scale算子可以包括算子核函数scale_kernel和模板参数T。scale_kernel可以进行scale运算。例如，与深度学习框架无关的模板参数例如可以包括与深度学习框架的实现设备无关的模板参数，也可以包括与深度学习框架的数据类型无关的模板参数。例如，实现设备例如可以是CPU或GPU。又例如，数据类型例如可以为Float类型、Int类型。例如，在将Scale算子作为待处理算子的情况下，待处理算子例如可以表示为ScaleKernel＜T，Context＞。在操作S120，响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数。例如，一个完整模板参数可以为＜Float，CPUContext＞。Float为数据类型，CPUContext为设备类型。在操作S130，根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。例如，在获取待处理算子之后，通过解析得到具体深度学习框架的可用算子，并在该深度学习框架中注册该可用算子，以便深度学习框架中的其他例程或任务可以根据实际深度学习应用调用该可用算子以执行对应的算法或功能，例如缩放、卷积等。例如，根据完整模板参数＜Float，CPUContext＞，对算子核函数scale_kernel进行处理，可以得到可用算子。可用算子例如可以表示为ScaleKernel＜Float，CPUContext＞。通过本公开实施例，在算子被复用时，可以实现无调度开销，实现高性能复用。在一些实施例中，方法100还可以包括：响应于针对可用算子的调用指令，调用可用算子；以及通过编译调用的可用算子，执行与可用算子相对应的函数功能。例如，响应于针对可用算子ScaleKernel＜float，CPUContext＞的调用指令，调用可用算子ScaleKernel＜float，CPUContext＞；以及通过编译调用的可用算子ScaleKernel＜float，CPUContext＞，执行scale函数的功能。在一些实施例中，与深度学习框架的实现设备无关算子核函数的声明例如可以为：template＜typename T，typename Context＞void ScaleKernel；Temnlate为模板。typename T为与深度学习框架的数据类型无关的模板参数。typename Context为与深度学习框架的实现设备无关的模板参数。typename T和typenameContext可以不与具体实现设备绑定。又例如，可以复用基础运算的算子Calc例如可以为：template＜typename T，typename Context＞void CalcKernel{ScaleKernel＜T，Context＞}算子Calc调用的算子是算子ScaleKernel＜T，Context＞。算子ScaleKernel＜T，Context＞是与实现设备无关的算子。在编译时，获取模板参数T和Context，由编译器转换为具体地数据类型和实现设备。在一个示例中，算子ScaleKernel＜T，Context＞可以被转换为ScaleKernel＜float，CPUContext＞。在运行时，算子Calc可以调用scale运算的float类型、基于CPU设备的指令集，无需其他逻辑做判断和选择，可以做到无调度开销的复用，实现高性能复用。在一些实施例中，响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数包括：利用宏创建可变参数列表；以及基于可变参数列表迭代地解析模板参数，其中，输入信息作为宏的宏参数。例如，宏是C语言的一种机制，可以用于简化重复的代码，在编译预处理时，会将该宏替换成相应的代码段以便执行。例如，针对上文所述的待处理算子ScaleKernel＜T，Context＞，可以根据输入信息，确定可变参数列表。由宏基于可变参数列表迭代地进行解析。在一个示例中，宏PD_REGISTER_KERNEL可以对可变参数列表进行解析：PD_REGISTER_KERNEL{}在一些实施例中，可变参数列表包括：待处理算子的名称；算子核函数的名称；算子核函数的数据布局；用于实现深度学习框架的设备类型；以及用于实现深度学习框架的数据类型。例如，针对上文所述的Scale算子，在利用宏创建的参数列表中：scale为算子名称，CPU为用于实现深度学习框架的设备类型，ALL_LAYOUT表示算子核函数ScaleKernel可以适配所有的数据布局，ScaleKernel表示要注册和解析的算子核函数名，float、double、bfloat16、uint8_t、intl6_t、int、int64_t表示深度学习框架支持的数据类型。在一些实施例中，基于可变参数列表迭代地解析模板参数包括：确定宏包括的参数数目；根据参数数目，确定迭代结束位置；以及利用可变参数列表，根据迭代结束位置迭代处理输入信息。例如，针对上文所述的待处理算子ScaleKernel＜T，Context＞，在利用宏PD_REGISTER_KERNEL对参数列表解析时，可以利用另一个宏PD_NARGS来确定宏PD_REGISTER_KERNEL包含的参数数目。又例如，在确定参数数目后，可以将参数数目作为宏的后缀，以便拼接出下层宏方法，然后调用该宏方法进行解析。例如，宏PD_NARGS例如可以为：#define PD_NARGS_PD_NARGS))#define_PD_NARGS_PD_ARG_N#define_PD_ARG_N_EXPANDN#define_PD_ARG_N_PD_ARG_N_EXPAND args#define_PD_RESQ_N15，14，13，12，11，10，9，8，7，6，5，4，3，2，1，0例如，对于PD_NARGS，“…”可以为上文所述的可变参数列表。通过本公开实施例，可以确定宏存在几个参数，并从对应参数个数位置开始迭代解析宏参数，以便确定迭代结束位置。在另一些实施例中，可以将宏PD_NARGS嵌套在可变参数宏_VA_ARGS之外，以便宏PD_NARGS进行相关处理。例如，可以通过以下方式将宏PD_NARGS嵌套在可变参数宏VA_ARGS之外：_PD_KERNEL_REGISTRAR_INIT，reg_type，kernel_name，backend，context，layout，args_def_fn，在确定迭代结束位置之后，可以基于可变参数列表迭代地解析模板参数。在一些实施例中，基于可变参数列表迭代地解析模板参数还可以包括：利用可变参数列表，基于输入信息迭代地解析模板参数，得到多个内部模板参数；以及将多个内部模板参数进行拼接，得到多个完整模板参数。下面将结合图2进行详细说明。图2是根据本公开的另一个实施例的深度学习框架的算子处理方法的流程图。如图2所示，方法221基于可变参数列表迭代地解析模板参数，下面将结合操作S2211和操作S2212进行详细说明。在操作S2211，利用可变参数列表迭代地解析模板参数，得到多个内部模板参数。例如，可以利用宏VA_ARGS对宏参数进行迭代，以便基于可变参数列表迭代地解析模板参数。例如，利用可变参数列表，可以通过以下方式进行迭代地解析，以得到模板参数：#define_PD_KERNEL_REGISTRAR_INIT_3#define_PD_KERNEL_REGISTRAR_INIT_4_PD_KERNEL_REGISTRAR_INIT_3对于宏PD_KERNEL_REGISTRAR_INIT_4，其宏参数“…”为上文所述的可变参数列表。在一个示例中，宏参数例如包括：float、double、bfloat16、uint8_t、int8_t、int16_t、int、int64_t。宏PD_KERNEL_REGISTRAR_INIT_4内部可以调用宏PD_KERNEL_REGISTRAR_INIT_3。宏PD_KERNEL_REGISTRAR_INIT_3可以嵌套在宏VA_ARGS之外，用于将可变参数列表作为一个整体进行迭代。宏PD_KERNEL_REGISTRAR_INIT_3可以将可变参数列表中的第一个参数解析出来，例如将float解析出来。在此情况下，cpp_dtype可以为float，宏PD_KERNEL_REGISTRAR_INIT_4的宏参数“…”中可以包括double、bfloat16、uint8_t、int8_t、int16_t、int、int64_t。在下次迭代时，double为可变参数列表中的第一个参数。在操作S2212，将多个内部模板参数进行拼接，得到多个完整模板参数。在本公开实施例中，多个内部模板参数包括多个字符串。在本公开实施例中，将多个内部模板参数进行拼接，得到多个完整模板参数包括：根据输入信息，将多个字符串进行拼接，得到针对待处理算子的多个完整模板参数。例如，解析出的内部模板参数为字符串。多个字符串例如包括字符串Float和字符串CPUContext。将这两个字符串拼接，可以得到完整模板参数＜Float，CPUContext＞。在一些实施例中，根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子可以包括：针对多个完整模板参数中的每个完整模板参数，确定该完整模板参数的函数参数类型；根据函数参数类型，将完整模板参数的输入信息转换为对应参数信息；以及记录对应参数信息。下面将结合图3进行详细说明图3是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图。如图3所示，该方法330例如可以遍历I个完整模板参数，并针对第i个完整模板参数执行包括操作S331至操作S335，以便将完整模板参数的输入信息转换为对应参数信息。I为大于或等于1的整数，i为小于或等于I的整数。在操作S331，确定第i个完整模板参数的函数参数类型。例如，根据第i个完整模板参数，可以确定一些函数参数的类型，作为函数参数类型。在操作S332，根据函数参数类型，将第i个完整模板参数的输入信息转换为第i组参数信息。例如，不同的函数参数类型可以与不同的转换方式对应。函数参数类型与转换方式之间的对应关系可以是预设的。又例如，上文所述的针对待处理算子的输入信息中可以包括与第i个完整模板参数对应第i个的输入信息。第i个输入信息中可以包括多个函数参数。根据相应的函数参数类型，可以将输入信息转换为对应的第i组参数信息。在操作S333，记录第i组参数信息。例如，可以将第i组参数信息记录于内存中。在操作S334，确定i是否等于I。在i＝I的情况下，执行操作S335，结束流程。在i＝I时，已经遍历了I个完整模板参数，可以结束流程。在i小于I的情况下，返回至操作操作S331，针对第i+1个完整模板参数执行操作S331至操作S334。在一个示例中，在数据类型为8种且设备类别为2种的情况下，通过迭代遍历方式，可以得到16组参数信息以支持不同的设备类型和数据类型组合。在一个示例中，针对上文所述的第i个函数的输入信息，可以确定第i个函数的函数参数类型，记录其类型及相关的必要信息。例如可以利用C++模板元编程技术，以实现在编译期计算、判断、转换、查询等功能。在一些实施例中，例如上文所述的方法300还可以包括：根据多个完整模板参数，创建基于深度学习框架的待注册算子；以及将待注册算子注册到深度学习框架内部的全局算子表中。在深度学习框架内部，为了实现统一调度，深度学习框架内部的算子对应的函数写法可以是归一化的，并且该归一化的写法与用户的自定义算子的计算函数的编写方式存在较大差异。例如，在不同的场景下，不同用户的计算函数的写法可能是不同的，例如一个张量作为输入的时候，函数写法是：返回Tensor列表算子计算函数名{…}而如果有两个输入张量，函数写法是：返回Tensor列表算子计算函数名{…}当有更多的输入时，也会有更多的函数声明。在C++编程语言中，不同的函数声明意味着不同的函数指针类型，也就是不同的数据类型，而框架需要存储用户可能编写的函数指针类型，并可以在框架底层调用，这种写法灵活性极强的范式，在C++编程语言中是无法以简洁通用的形式存储下来。为了实现整体的简洁，还需要对用户编写的各种各样的计算函数进行归一化。例如，一个自定义计算函数的函数形式为：返回Tensor列表算子计算函数名{...}另一个自定义计算函数的函数形式为：返回Tensor列表算子计算函数名{…}上述两个自定义计算函数的函数形式是不统一的，本实施例中，需要对不同的自定义计算函数进行归一化，以方便在深度学习框架内部进行统一调度。在本公开实施例中，待注册算子包括待注册算子描述信息和待注册算子核函数，待注册算子核函数中包括归一化的输入信息和归一化的函数指针；根据多个完整内部模板函数，创建基于深度学习框架的待注册算子包括：针对多个完整模板参数中的每个完整模板参数，确定与完整模板参数对应的结构体，结构体包含静态函数，静态函数具有归一化形式；将静态函数的输入信息作为归一化的输入信息；以及将静态函数的函数指针作为归一化的函数指针。例如，深度学习框架内的各种算子可以继承OpKernel类，并填充实现自身的计算函数。算子的对应的输入输出张量可以存储于执行上下文中，可以通过执行上下文的Input和Output功能来获取。在一个示例中，在构造待注册算子核函数时，可以基于归一化形式的函数进行构造，该归一化的函数可以为与完整模板参数对应的结构体中的静态函数。又例如，在构造待注册算子核函数时，可以包括：创建上述静态函数的输入信息、创建上述的静态函数的函数指针，以及创建其他一些标准处理，比如，从context中获取输入信息并放入inputs变量中。通过构造待注册算子核函数时采用具有统一形式的静态函数，可以对自定义计算函数进行统一，以便深度学习框架的统一调度。进一步地，在一些实施例中，静态函数的输入信息组成输入信息列表，输入信息列表包括输入张量列表；结构体包括至少一个特化子结构体，至少一个特化子结构体各自具有对应的数据类型，数据类型包括张量和非张量。例如，归一化形式的静态函数的输入可以为输入信息列表，进一步地，输入信息列表可以包括输入张量列表和属性列表，属性列表用于存储其他数据类型的输入变量。在一个示例中，输入变量的数据类型包括张量型、整数型、浮点型，表示为：tensor1、tensor2、int、float。静态函数的输入信息列表可以包括张量列表以及属性列表。例如，输入信息列表可以采用C++的模板参数推导机制获得。下面将结合图4进行详细说明根据本公开的一个实施例的深度学习框架的算子处理方法。图4是根据本公开的一个实施例的深度学习框架的算子处理方法的流程图。如图4所示，方法441可以实现算子核函数输入信息和函数指针的归一化。下面将结合操作S4411至操作S4415进行详细说明。在操作S4411，获取待注册算子。例如，待注册算子包括待注册算子描述信息和待注册算子核函数。待注册算子描述信息包括待注册算子输入信息和待注册算子输出信息。待注册算子核函数可以用于描述该算子的主要计算逻辑。在操作S4412，根据与待注册算子的完整模板参数对应的结构体，确定至少一个子结构体。例如，待注册算子可以根据多个完整模板参数创建的。每个完整模板参数可以与一个结构体对应。结构体例如可以是预设的。该结构体可以以函数返回值、可变函数参数列表以及一个函数指针作为模板参数，其中函数指针的返回值类型与参数列表和模板参数中的类型一致。该结构体包含一个用于计算的静态函数。该静态函数具有归一化形式。又例如，该结构体例如可以包括至少一个特化子结构体。特化子结构体用于进行模板参数推导。在操作S4413，将一个特化子结构体与待注册算子的输入信息进行匹配，得到结构体的静态函数的输入子信息。例如，可以预设每个特化子结构体的特化实现，以便匹配特定数据类型的结构体。每个子结构体的特化实现均以该结构体匹配的数据类型作为首个模板参数，随后为剩余模板参数列表。又例如，至少一个特化子结构体包括一个具有结束标识的特化子结构体。该具有结束标识的特化子结构体可以将结束标识作为模板参数。又例如，特化子结构体可以包含子静态函数。子静态函数以参数索引作为模板参数，可以用于标记当前匹配到第几个参数。在操作S4414，确定是否匹配到结束标识。在匹配到结束标识的情况下，执行操作S4415，结束流程。在未匹配到结束标识的情况下，返回至操作S4413，根据下一个子结构体，进行匹配。例如，在编译过程中，编译器会逐个解析算子核函数的输入信息。如果当前解析的输入信息与前述所定义的子结构体的某种特化实现的第一个模板参数匹配时，就会调用该特化子结构体的特化实现，完成对当前参数的解析。接下来，继续将剩余的输入信息与其他特化子结构体进行匹配，以解析后面的输入信息，当遇到以结束标志为模板参数的特化子结构体匹配时，匹配完成。进一步地，在一些实施例中，具有归一化形式函数的函数形式可以为：返回Tensor列表算子计算函数名{…}图5是根据本公开的另一个实施例的深度学习框架的算子处理方法的流程图。在操作S510，获取待处理算子。例如，待处理算子包括算子核函数和模板参数。该模板函数与深度学习框架无关，可以用于分发待处理算子。接下来，方法500可以响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数。下面将结合操作S521至操作S523进行详细说明。在操作S521，利用宏创建可变参数列表。在操作S522，利用可变参数列表迭代地解析模板参数，得到多个内部模板参数。在操作S523，将多个内部模板参数进行拼接，得到多个完整模板参数。可以理解，关于在操作S522和操作S523的详细描述，可以参考上文所述的操作S2211和操作S2212，本公开在此不再赘述。接下来方法500可以根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。下面将结合操作S531、S532和操作S533进行详细说明。在操作S531，对多个完整模板参数进行显式实例化。在本公开实施例中，多个完整模板参数各自包括模板函数描述信息和模板函数信息。例如，将模板函数描述信息实例化为头文件。模板函数描述信息可以为模板函数声明。头文件例如可以为“.h”文件。例如，将模板函数信息实例化为源码文件。模板函数信息可以为模板函数实现。源码文件例如可以为“.cc”文件。在C++编程语言中，应用模板函数的内核形式是有一些限制的。在编译时，模板函数需要根据实际的模板参数类型实例化，并将模板函数的实现也展开到对应调用的位置。将模板函数描述信息实例化至头文件，并将源码文件实例化至源码文件，可以避免编译时引入大量模板函数代码展开而影响编译效率。在操作S532，将完整模板参数的输入信息转换为对应参数信息。可以理解，关于操作S532的详细描述，可以参考上文所述的方法330，本公开在此不再赘述。在操作S533，实现待注册算子核函数输入信息和函数指针的归一化。可以理解，关于操作S533的详细描述，可以参考上文所述的方法441，本公开在此不再赘述。在操作S540，将算子注册到深度学习框架内部的全局算子表中。例如，在执行操作S532或操作S533之后，可以获取将算子注册到全局算子表的信息。这些信息例如可以包括算子核函数的对应参数信息和/或归一化的函数指针。在操作S550，根据全局算子表，调用可用算子。在一些实施例中，在上文所述的源码文件中，可以对模板函数进行显式实例化。例如，在头文件中，模板函数描述信息例如可以为：template＜typename T，typename Context＞void ScaleKernel。又例如，在源码文件中，对于显式实例化的函数ScaleKernel＜float，CPUContext＞例如可以为：template ScaleKernel＜float，CPUContext＞。在数据类型为8种且设备类别为2种的情况下，与显式实例化的函数对应的代码可以包括16组。在另一些实施例中，根据多个完整模板参数，可以生成多个如下的实例化声明语句：Template decltype；这里decltype即是用来自动解析函数类型的方法。这样即可在提升编译效率的同时，也提升写法的间接性，自动完成这一显式实例化过程。在一些实施例，全局算子表包括：算子核工厂类；算子核名称类和内核键值类；以及算子核类。例如，算子核类包括以下中的至少一个：算子核函数的指针；算子核函数输入参数的描述信息；以及算子核函数输出参数的描述信息。下面将结合图6对全局算子表进行详细说明。图6是根据本公开的一个实施例的全局算子表的示例示意图。如图6所示，全局算子表600的数据结构可以包括第一级算子核工厂类610、第二级算子核名称类620、内核键值类630和算子核类640。在图6的示例中，算子核类640可以包括第三级的算子核函数的指针641和算子核函数参数的描述信息642。算子核函数参数的描述信息642例如可以包括算子核函数输入参数的描述信息和算子核函数输出函数的描述信息。在一些实施例中，根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子包括：通过对多个完整模板参数进行显式实例化，对算子核函数进行处理，得到用于深度学习框架的可用算子。在一些实施例中，多个完整模板参数各自包括模板函数描述信息和模板函数信息；通过对多个完整模板参数进行显式实例化，对算子核函数进行处理，得到用于深度学习框架的可用算子包括：将模板函数描述信息实例化为头文件；以及将模板函数信息实例化为源码文件。图7是根据本公开的一个实施例的深度学习框架的算子处理装置的框图。如图7所示，该装置700可以包括获取模块710、解析模块720和处理模块730。获取模块710，用于获取待处理算子。例如，待处理算子包括算子核函数和与深度学习框架无关的模板参数。解析模块720，用于响应于接收到针对待处理算子的输入信息，利用输入信息解析模板参数，得到与深度学习框架相关的多个完整模板参数。处理模块730，用于根据多个完整模板参数，对算子核函数进行处理，得到用于深度学习框架的可用算子。在一些实施例中，解析模块包括：创建子模块，用于利用宏创建可变参数列表；以及解析子模块，用于基于可变参数列表迭代地解析模板参数，其中，输入信息作为宏的宏参数。在一些实施例中，可变参数列表包括：待处理算子的名称；算子核函数的名称；算子核函数的数据布局；用于实现深度学习框架的设备类型；以及用于实现深度学习框架的数据类型。在一些实施例中，解析子模块包括：第一确定单元，用于确定宏包括的参数数目；第二确定单元，用于根据参数数目，确定迭代结束位置；以及处理单元，用于利用可变参数列表，根据迭代结束位置迭代处理输入信息。在一些实施例中，解析子模块还包括：解析单元，用于利用可变参数列表迭代地解析模板参数，得到多个内部模板参数；以及拼接单元，用于将多个内部模板参数进行拼接，得到多个完整模板参数。在一些实施例中，多个内部模板参数包括多个字符串；拼接单元包括：拼接子单元，用于根据输入信息，将多个字符串进行拼接，得到针对待处理算子的多个完整模板参数。在一些实施例中，根据处理模块包括：显式实例化子模块，用于通过对多个完整模板参数进行显式实例化，对算子核函数进行处理，得到用于深度学习框架的可用算子。在一些实施例中，多个完整模板参数各自包括模板函数描述信息和模板函数信息；显式实例化子模块包括：第一实例化单元，用于将模板函数描述信息实例化为头文件；以及第二实例化单元，用于将模板函数信息实例化为源码文件。在一些实施例中，处理模块包括：第一确定子模块，用于针对多个完整模板参数中的每个完整模板参数，确定该完整模板参数的函数参数类型；转换子模块，应与根据函数参数类型，将完整模板参数的输入信息转换为对应参数信息；以及记录子模块，用于记录对应参数信息。在一些实施例中，装置700还包括：创建模块，用于根据多个完整模板参数，创建基于深度学习框架的待注册算子；以及注册模块，用于将待注册算子注册到深度学习框架内部的全局算子表中。在一些实施例中，待注册算子包括待注册算子描述信息和待注册算子核函数，待注册算子核函数中包括归一化的输入信息和归一化的函数指针；创建模块包括：第二确定子模块，用于针对多个完整模板参数中的每个完整模板参数，确定与完整模板参数对应的结构体，结构体包含静态函数，静态函数具有归一化形式；第一归一化子模块，用于将静态函数的输入信息作为归一化的输入信息；以及第二归一化模块，用于将静态函数的函数指针作为归一化的函数指针。在一些实施例中，静态函数的输入信息组成输入信息列表，输入信息列表包括输入张量列表；结构体包括至少一个特化子结构体，至少一个特化子结构体各自具有对应的数据类型，数据类型包括张量和非张量。在一些实施例中，全局算子表包括：算子核工厂类；算子核名称类和内核键值类；以及算子核类。在一些实施例中，算子核类包括以下中的至少一个：算子核函数的指针；算子核函数输入参数的描述信息；以及算子核函数输出参数的描述信息。在一些实施例中，与深度学习框架无关的模板参数用于分发待处理算子；与深度学习框架无关的模板参数包括与深度学习框架的实现设备和深度学习框架的数据类型均无关的模板参数。在一些实施例中，装置700还包括：调用模块，用于响应于针对可用算子的调用指令，调用可用算子；以及执行模块，用于通过编译调用的可用算子，执行与可用算子相对应的函数功能。本公开的技术方案中，所涉及的用户个人信息的收集、存储、使用、加工、传输、提供和公开等处理，均符合相关法律法规的规定，且不违背公序良俗。根据本公开的实施例，本公开还提供了一种电子设备、一种可读存储介质和一种计算机程序产品。图8示出了可以用来实施本公开的实施例的示例电子设备800的示意性框图。电子设备旨在表示各种形式的数字计算机，诸如，膝上型计算机、台式计算机、工作台、个人数字助理、服务器、刀片式服务器、大型计算机、和其它适合的计算机。电子设备还可以表示各种形式的移动装置，诸如，个人数字处理、蜂窝电话、智能电话、可穿戴设备和其它类似的计算装置。本文所示的部件、它们的连接和关系、以及它们的功能仅仅作为示例，并且不意在限制本文中描述的和/或者要求的本公开的实现。如图8所示，设备800包括计算单元801，其可以根据存储在只读存储器802中的计算机程序或者从存储单元808加载到随机访问存储器803中的计算机程序，来执行各种适当的动作和处理。在RAM 803中，还可存储设备800操作所需的各种程序和数据。计算单元801、ROM 802以及RAM 803通过总线804彼此相连。输入/输出接口805也连接至总线804。设备800中的多个部件连接至I/O接口805，包括：输入单元806，例如键盘、鼠标等；输出单元807，例如各种类别的显示器、扬声器等；存储单元808，例如磁盘、光盘等；以及通信单元809，例如网卡、调制解调器、无线通信收发机等。通信单元809允许设备800通过诸如因特网的计算机网络和/或各种电信网络与其他设备交换信息/数据。计算单元801可以是各种具有处理和计算能力的通用和/或专用处理组件。计算单元801的一些示例包括但不限于中央处理单元、图形处理单元、各种专用的人工智能计算芯片、各种运行机器学习模型算法的计算单元、数字信号处理器、以及任何适当的处理器、控制器、微控制器等。计算单元801执行上文所描述的各个方法和处理，例如深度学习框架的算子处理方法。例如，在一些实施例中，深度学习框架的算子处理方法可被实现为计算机软件程序，其被有形地包含于机器可读介质，例如存储单元808。在一些实施例中，计算机程序的部分或者全部可以经由ROM 802和/或通信单元809而被载入和/或安装到设备800上。当计算机程序加载到RAM 803并由计算单元801执行时，可以执行上文描述的深度学习框架的算子处理方法的一个或多个步骤。备选地，在其他实施例中，计算单元801可以通过其他任何适当的方式而被配置为执行深度学习框架的算子处理方法。本文中以上描述的系统和技术的各种实施方式可以在数字电子电路系统、集成电路系统、场可编程门阵列、专用集成电路、专用标准产品、芯片上系统的系统、复杂可编程逻辑设备、计算机硬件、固件、软件、和/或它们的组合中实现。这些各种实施方式可以包括：实施在一个或者多个计算机程序中，该一个或者多个计算机程序可在包括至少一个可编程处理器的可编程系统上执行和/或解释，该可编程处理器可以是专用或者通用可编程处理器，可以从存储系统、至少一个输入装置、和至少一个输出装置接收数据和指令，并且将数据和指令传输至该存储系统、该至少一个输入装置、和该至少一个输出装置。用于实施本公开的方法的程序代码可以采用一个或多个编程语言的任何组合来编写。这些程序代码可以提供给通用计算机、专用计算机或其他可编程数据处理装置的处理器或控制器，使得程序代码当由处理器或控制器执行时使流程图和/或框图中所规定的功能/操作被实施。程序代码可以完全在机器上执行、部分地在机器上执行，作为独立软件包部分地在机器上执行且部分地在远程机器上执行或完全在远程机器或服务器上执行。在本公开的上下文中，机器可读介质可以是有形的介质，其可以包含或存储以供指令执行系统、装置或设备使用或与指令执行系统、装置或设备结合地使用的程序。机器可读介质可以是机器可读信号介质或机器可读储存介质。机器可读介质可以包括但不限于电子的、磁性的、光学的、电磁的、红外的、或半导体系统、装置或设备，或者上述内容的任何合适组合。机器可读存储介质的更具体示例会包括基于一个或多个线的电气连接、便携式计算机盘、硬盘、随机存取存储器、只读存储器、可擦除可编程只读存储器、光纤、便捷式紧凑盘只读存储器、光学储存设备、磁储存设备、或上述内容的任何合适组合。为了提供与用户的交互，可以在计算机上实施此处描述的系统和技术，该计算机具有：用于向用户显示信息的显示装置或者LCD监视器)；以及键盘和指向装置，用户可以通过该键盘和该指向装置来将输入提供给计算机。其它种类的装置还可以用于提供与用户的交互；例如，提供给用户的反馈可以是任何形式的传感反馈；并且可以用任何形式来接收来自用户的输入。可以将此处描述的系统和技术实施在包括后台部件的计算系统、或者包括中间件部件的计算系统、或者包括前端部件的计算系统、或者包括这种后台部件、中间件部件、或者前端部件的任何组合的计算系统中。可以通过任何形式或者介质的数字数据通信来将系统的部件相互连接。通信网络的示例包括：局域网、广域网和互联网。计算机系统可以包括客户端和服务器。客户端和服务器一般远离彼此并且通常通过通信网络进行交互。通过在相应的计算机上运行并且彼此具有客户端-服务器关系的计算机程序来产生客户端和服务器的关系。应该理解，可以使用上面所示的各种形式的流程，重新排序、增加或删除步骤。例如，本发公开中记载的各步骤可以并行地执行也可以顺序地执行也可以不同的次序执行，只要能够实现本公开公开的技术方案所期望的结果，本文在此不进行限制。上述具体实施方式，并不构成对本公开保护范围的限制。本领域技术人员应该明白的是，根据设计要求和其他因素，可以进行各种修改、组合、子组合和替代。任何在本公开的精神和原则之内所作的修改、等同替换和改进等，均应包含在本公开保护范围之内。

标题title
窗口元素抓取方法、装置以及存储介质
摘要abst
本申请公开了一种窗口元素抓取方法、装置以及存储介质，其中该方法包括：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。
权利要求书clms
1.一种窗口元素抓取方法，其特征在于，包括：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；获取所述目标窗口应用程序包含的窗口元素，并根据所述窗口元素在内存中构建树形结构，其中所述树形结构中的节点与所述窗口元素在所述目标窗口应用程序中的排列相关并且包含所述窗口元素的结构信息；以及响应于所述用户选择抓取的目标窗口元素的第二触发操作，根据所述树形结构确定与所述目标窗口元素相关的窗口元素信息。2.根据权利要求1所述的方法，其特征在于，所述窗口元素包括主窗口元素和至少一级子窗口元素，并且根据所述窗口元素在内存中构建树形结构，包括：根据所述主窗口元素在内存中构建所述树形结构的根节点；根据所述至少一级子窗口元素在内存中构建所述树形结构的子节点；以及根据所述根节点和所述子节点以及主窗口元素和至少一级子窗口元素在所述目标窗口应用程序中的排列构建所述树形结构。3.根据权利要求2所述的方法，其特征在于，所述窗口元素的结构信息包括以下至少一项：所述窗口元素的元素信息、运行ID、外包矩形、父节点指针、子节点指针。4.根据权利要求3所述的方法，其特征在于，根据所述主窗口元素在内存中构建所述树形结构的根节点，包括：在内存中构建所述树形结构的根节点；获取与所述主窗口元素对应的句柄并根据所述句柄获取所述主窗口元素的可访问对象，根据所述可访问对象获取与所述主窗口元素对应的元素信息；确定所述主窗口元素的运行ID和外包矩形，并设置所述主窗口元素的父节点指针为空，设置所述主窗口元素的子节点指针为第一级子窗口元素；将与所述主窗口对应的元素信息、运行ID、外包矩形、父节点指针为空、子节点指针为第一级子窗口元素作为所述根节点的结构信息。5.根据权利要求4所述的方法，其特征在于，还包括：为所述根节点和所述主窗口元素的可访问对象分配一个线程，并将所述根节点和所述主窗口元素的可访问对象放入与所述线程对应的第一队列中，并且该分配一个线程并确定与所述线程对应的第一队列，并且根据所述至少一级子窗口元素在内存中构建所述树形结构的子节点，包括：通过所述线程，根据所述第一队列中的所述主窗口元素的可访问对象获取所述第一级子窗口元素的可访问对象，并根据所述第一级子窗口元素的可访问对象构建与所述第一级子窗口元素对应的子节点；确定所述第一级子窗口元素对应的元素信息、运行ID、外包矩形，并设置所述第一级子窗口元素的父节点指针为所述根节点，设置所述第一级子窗口元素的子节点指针为第二级子窗口元素，作为所述第一级子窗口元素对应的子节点的结构信息；将所述第一级子窗口元素的子节点和对应的可访问对象存储至内存中预先设置的第二队列，并计算所述第二队列中节点的数量；根据预先设置的线程数量和所述第二队列中节点的数量，将所述第一级子窗口元素的子节点存储至每个线程对应的第一队列；通过每个线程，根据每个线程对应的第一队列中的第一级子窗口元素的可访问对象获取所述第二级子窗口元素的可访问对象，并根据所述第二级子窗口元素的可访问对象构建与所述第二级子窗口元素对应的子节点；确定所述第二级子窗口元素对应的元素信息、运行ID、外包矩形，并设置所述第二级子窗口元素的父节点指针为所述第一级子窗口元素的子节点，设置所述第二级子窗口元素的的子节点指针为第三级子窗口元素，作为所述第二级子窗口元素的子节点的结构信息。6.根据权利要求3所述的方法，其特征在于，还包括：根据所述主窗口元素和至少一级子窗口元素的外包矩形对所述树形结构进行修正操作。7.根据权利要求1所述的方法，其特征在于，还包括：设置监听线程对所述窗口元素进行监听；以及在所述窗口元素发生变化的情况下，根据发生变化的窗口元素对所述树形结构进行局部调整。8.根据权利要求3所述的方法，其特征在于，响应于所述用户选择抓取的目标窗口元素的第二触发操作，还包括：对所述树形结构的节点进行遍历，确定不包含所述第二触发操作的位置信息并且外包矩形面积最小的窗口元素作为所述目标窗口元素；以及突出显示所述目标窗口元素。9.根据权利要求1所述的方法，其特征在于，根据所述树形结构确定与所述目标窗口元素相关的窗口元素信息，包括：根据所述树形结构确定所述目标窗口元素的元素信息和/或确定所述目标窗口元素在所述树形结构的位置信息，其中所述位置信息为所述目标窗口元素在所述树形结构的路径。10.一种存储介质，其特征在于，所述存储介质包括存储的程序，其中，在所述程序运行时由处理器执行权利要求1至9中任意一项所述的方法。
说明书desc
技术领域本申请涉及自动控制技术领域，特别是涉及一种窗口元素抓取方法、装置以及存储介质。背景技术RPA是Robotic Process Automation的首字母缩写，即机器人流程自动化。RPA要自动的同屏幕上的各种窗口、按钮、下拉列表等不同元素进行交互，首先就要定位到元素的位置，然后获取元素信息，再对元素做相应的操作。所以定位及获取元素信息的抓屏技术作为RPA技术的基础显得尤为重要。由于用户在不同的操作系统，不同的软件窗口上作业，所以要求RPA能在不同的操作系统和不同的软件窗口上进行操作，那么对窗口元素的抓取也是在不同操作系统和不同的窗口上进行，这使得抓屏是多种方法实现的复合技术。目前抓屏的技术主要包含：1.通过系统的API基于窗口元素的树形结构来定位窗口元素及获取窗口元素的信息；2.使用图像识别和OCR的技术来定位和获取元素信息；3.直接使用窗口元素的坐标位置来定位窗口元素。目前使用频率最高，操作最稳定的抓屏技术是通过系统的API基于窗口元素的树形结构来定位窗口元素及获取窗口元素的信息。RPA的抓屏程序通过窗口的可访问技术或程序的API及程序脚本和窗口元素进行交互；这种方法一般直接调用系统或相应程序的API函数来获取窗口的可访问对象，通过窗口元素的可访问对象，获取窗口元素的坐标位置和窗口元素的信息，定位元素在整个窗口元素中的结构位置。然而，现有的RPA的抓屏程序和用户操作的业务程序是在两个进程中的，抓屏程序要获取其他程序窗口的信息，就需要和其他程序进行进程间通信，进程间通信耗时是远大于进程内的数据访问的。抓屏程序直接使用系统和程序API函数获取只有少量窗口元素的程序窗口信息的时效性是勉强可以接受的。但对于复杂的窗口程序或者丰富的网页，直接使用API函数获取元素信息特别是定位元素在整个窗口中的结构位置时，抓屏程序会和业务窗口进行大量的进程间通信，消耗大量时间，这使得抓屏程序无法正常使用。目前RPA的抓屏技术也向着和用户无交互，用户无感知的智能抓屏方向发展，即在后台运行抓屏程序自动抓取用户的业务操作，这对抓屏技术的时效性提出了更高的要求。同时现在的一些程序故意在窗口上做一些改动使得系统或程序API函数无法直接定位到窗口内的窗口元素，导致抓屏失败。故直接使用系统或程序API抓屏存在许多的问题。针对上述的现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题，目前尚未提出有效的解决方案。发明内容本公开的实施例提供了一种窗口元素抓取方法、装置以及存储介质，以至少解决现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。根据本公开实施例的一个方面，提供了一种窗口元素抓取方法，包括：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。根据本公开实施例的另一个方面，还提供了一种存储介质，存储介质包括存储的程序，其中，在程序运行时由处理器执行以上任意一项所述的方法。根据本公开实施例的另一个方面，还提供了一种窗口元素抓取装置，包括：窗口程序确定模块，用于响应于用户选择程序的第一触发操作，确定目标窗口应用程序；树形结构构建模块，用于获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及窗口信息抓取模块，用于响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。根据本公开实施例的另一个方面，还提供了一种窗口元素抓取装置，包括：处理器；以及存储器，与处理器连接，用于为处理器提供处理以下处理步骤的指令：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。在本公开实施例中，在进行窗口元素的抓取的过程中，首先获取待抓取的目标窗口应用程序中的窗口元素，并在内存中根据窗口元素构建树形结构。在用户选择待抓取的窗口元素时，可以从该树形结构中获取抓取的窗口元素的窗口元素信息。因此，在用户操作选择窗口元素的同时可以同时抓取窗口元素信息，相当于用户操作窗口应用程序和抓取的过程在同一个进程中进行。与现有技术中抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信相比，本方案只需要在内存中的树形结构获取窗口信息，不需要进行跨进程操作。因此可以达到提升窗口元素抓取效率的技术效果。此外，树形结构是根据窗口元素而创建的，因此即使面对复杂的窗口元素，本方案也可以快速地进行窗口元素抓取。进而解决了现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。附图说明此处所说明的附图用来提供对本公开的进一步理解，构成本申请的一部分，本公开的示意性实施例及其说明用于解释本公开，并不构成对本公开的不当限定。在附图中：图1是用于实现根据本公开实施例1所述的方法的计算设备的硬件结构框图；图2是根据本公开实施例1的第一个方面所述的窗口元素抓取方法的流程示意图；图3示意性地示出了本公开实施例1窗口元素结构的示意图；图4是根据本公开实施例1所述的窗口元素抓取的整体流程示意图；图5是根据本公开实施例1所述的构建树形结构的过程示意图；图6a是根据本公开实施例1所述的元素抓取的程序实现过程示意图；图6b是根据本公开实施例1所述的树形结构构建的程序实现过程示意图；图7是根据本公开实施例2所述的窗口元素抓取装置的示意图；以及图8是根据本公开实施例3所述的窗口元素抓取装置的示意图。具体实施方式为了使本技术领域的人员更好地理解本公开的技术方案，下面将结合本公开实施例中的附图，对本公开实施例中的技术方案进行清楚、完整地描述。显然，所描述的实施例仅仅是本公开一部分的实施例，而不是全部的实施例。基于本公开中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都应当属于本公开保护的范围。需要说明的是，本公开的说明书和权利要求书及上述附图中的术语“第一”、“第二”等是用于区别类似的对象，而不必用于描述特定的顺序或先后次序。应该理解这样使用的数据在适当情况下可以互换，以便这里描述的本公开的实施例能够以除了在这里图示或描述的那些以外的顺序实施。此外，术语“包括”和“具有”以及他们的任何变形，意图在于覆盖不排他的包含，例如，包含了一系列步骤或单元的过程、方法、系统、产品或设备不必限于清楚地列出的那些步骤或单元，而是可包括没有清楚地列出的或对于这些过程、方法、产品或设备固有的其它步骤或单元。实施例1根据本实施例，还提供了一种窗口元素抓取方法实施例，需要说明的是，在附图的流程图示出的步骤可以在诸如一组计算机可执行指令的计算机系统中执行，并且，虽然在流程图中示出了逻辑顺序，但是在某些情况下，可以以不同于此处的顺序执行所示出或描述的步骤。本实施例所提供的方法实施例可以在移动终端、计算机终端或者类似的计算设备中执行。图1示出了一种用于实现窗口元素抓取方法的计算设备的硬件结构框图。如图1所示，计算设备可以包括一个或多个处理器、用于存储数据的存储器、以及用于通信功能的传输装置。除此以外，还可以包括：显示器、输入/输出接口、通用串行总线端口、网络接口、电源和/或相机。本领域普通技术人员可以理解，图1所示的结构仅为示意，其并不对上述电子装置的结构造成限定。例如，计算设备还可包括比图1中所示更多或者更少的组件，或者具有与图1所示不同的配置。应当注意到的是上述一个或多个处理器和/或其他数据处理电路在本文中通常可以被称为“数据处理电路”。该数据处理电路可以全部或部分的体现为软件、硬件、固件或其他任意组合。此外，数据处理电路可为单个独立的处理模块，或全部或部分的结合到计算设备中的其他元件中的任意一个内。如本公开实施例中所涉及到的，该数据处理电路作为一种处理器控制。存储器可用于存储应用软件的软件程序以及模块，如本公开实施例中的窗口元素抓取方法对应的程序指令/数据存储装置，处理器通过运行存储在存储器内的软件程序以及模块，从而执行各种功能应用以及数据处理，即实现上述的应用程序的窗口元素抓取方法。存储器可包括高速随机存储器，还可包括非易失性存储器，如一个或者多个磁性存储装置、闪存、或者其他非易失性固态存储器。在一些实例中，存储器可进一步包括相对于处理器远程设置的存储器，这些远程存储器可以通过网络连接至计算设备。上述网络的实例包括但不限于互联网、企业内部网、局域网、移动通信网及其组合。传输装置用于经由一个网络接收或者发送数据。上述的网络具体实例可包括计算设备的通信供应商提供的无线网络。在一个实例中，传输装置包括一个网络适配器，其可通过基站与其他网络设备相连从而可与互联网进行通讯。在一个实例中，传输装置可以为射频模块，其用于通过无线方式与互联网进行通讯。显示器可以例如触摸屏式的液晶显示器，该液晶显示器可使得用户能够与计算设备的用户界面进行交互。此处需要说明的是，在一些可选实施例中，上述图1所示的计算设备可以包括硬件元件、软件元件、或硬件元件和软件元件两者的结合。应当指出的是，图1仅为特定具体实例的一个实例，并且旨在示出可存在于上述计算设备中的部件的类型。在上述运行环境下，根据本实施例的第一个方面，提供了一种窗口元素抓取方法，该方法可以应用在终端设备上运行，根据用户的触发操作，抓取对应的窗口元素的相关信息。图2示出了该方法的流程示意图，参考图2所示，该方法包括：S202：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；S204：获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及S206：响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。正如背景技术中所述的，现有的RPA的抓屏程序和用户操作的业务程序是在两个进程中的，抓屏程序要获取其他程序窗口的信息，就需要和其他程序进行进程间通信，进程间通信耗时是远大于进程内的数据访问的。故直接使用系统或程序API抓屏存在许多的问题。针对背景技术中存在的技术问题，结合图3所示，本市实施例技术方案在步骤S202中，在需要进行窗口元素抓取的情况下，操作人员首先可以选择需要进行抓取的目标窗口应用程序。其中，目标窗口程序例如可以有多个，例如：word程序、excel程序以及其他的窗口应用程序，操作人员可以通过触发的方式选择目标窗口应用程序。在一个具体实例中，目标窗口应用程序运行在PC端，因此操作人员可通过鼠标的移动选择目标窗口应用程序。在另一个实例中，目标窗口应用程序例如还可以运行在支持触屏操作的终端设备上，因此操作人员还可以通过触控的方式选择目标窗口应用程序。在这种情况下，终端设备可以响应于用户选择程序的第一触发操作，确定目标窗口应用程序。进一步地，在步骤S204中，终端设备获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构。在一个具体实例中，图3示例性地示出了目标窗口应用程序包含的窗口元素，例如：窗口元素200、窗口元素210以及窗口元素211等。终端设备在确定目标窗口应用程序之后，首先获取目标窗口应用程序包含的窗口元素。进一步地，终端设备根据窗口元素在内存中构建树形结构，即按照窗口元素在目标窗口应用程序中的排列将窗口元素构建成树形结构。由于每个窗口元素在窗口应用程序都对应有结构信息，在一个具体实例中，结构信息例如包括窗口元素类型、文本等。因此，构建的树形结构中的节点还包含窗口元素的结构信息。最终，在步骤S206中，用户可以在该目标窗口应用程序中选择需要进行抓取的窗口元素，例如：用户需要抓取窗口元素211，则用户可以通过鼠标点击或者通过触控的方式选择该窗口元素211。在用户进行第二触发操作的情况下，终端设备可以响应该触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息，其中窗口元素信息例如包括窗口元素的类型、文本以及窗口元素在该树形结构中的位置信息等。从而完成窗口元素的抓取操作。从而通过这种方式，在进行窗口元素的抓取的过程中，首先获取待抓取的目标窗口应用程序中的窗口元素，并在内存中根据窗口元素构建树形结构。在用户选择待抓取的窗口元素时，可以从该树形结构中获取抓取的窗口元素的窗口元素信息。因此，在用户操作选择窗口元素的同时可以同时抓取窗口元素信息，相当于用户操作窗口应用程序和抓取的过程在同一个进程中进行。与现有技术中抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信相比，本方案只需要在内存中的树形结构获取窗口信息，不需要进行跨进程操作。因此可以达到提升窗口元素抓取效率的技术效果。此外，树形结构是根据窗口元素而创建的，因此即使面对复杂的窗口元素，本方案也可以快速地进行窗口元素抓取。进而解决了现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。可选地，窗口元素包括主窗口元素和至少一级子窗口元素，并且根据窗口元素在内存中构建树形结构，包括：根据主窗口元素在内存中构建树形结构的根节点；根据至少一级子窗口元素在内存中构建树形结构的子节点；以及根据根节点和子节点以及主窗口元素和至少一级子窗口元素在目标窗口应用程序中的排列构建树形结构。具体地，一般性地窗口元素包括主窗口元素和至少一级子窗口元素，其中每一级子窗口元素例如可以包括至少一个子窗口元素。参考图3所示，例如：窗口元素200对应于主窗口元素，窗口元素210等对应于第一级子窗口元素，窗口元素211等对应于第二级子窗口元素，此外可以包括多级窗口元素，此处不再赘述。在根据窗口元素在内存中构建树形结构的操作中，终端设备首先根据主窗口元素在内存中构建树形结构的根节点，即：将主窗口元素构建成该树形结构的根节点。然后，终端设备根据至少一级子窗口元素在内存中构建树形结构的子节点，其中将每一级子窗口元素构建成树形结构的每一层子节点，例如将窗口元素210等第一级子窗口元素构建成该树形结构的第一层子节点，将窗口元素211等第二级子窗口元素构建成该树形结构的第二层子节点，依次对每一级子窗口元素进行构建，直至将最后一级子窗口元素构建成子节点，完成节点的构建。最终，根据根节点和子节点以及主窗口元素和至少一级子窗口元素在目标窗口应用程序中的排列构建树形结构。从而，可以依次的对窗口元素进行节点的构建，最终构建成树形结构。可选地，窗口元素的结构信息包括以下至少一项：窗口元素的元素信息、运行ID、外包矩形、父节点指针、子节点指针。具体地，每个窗口元素包括对应的结构信息，树形结构的每个节点包括窗口元素的结构信息，其中结构信息可以构成结构体。在一个具体实例中，树形结构的节点结构信息组成的结构体形式如下所示：TreeNodeStruct TreeNode{Info；RID；Rect；RectAdjust；pParent；pChildrenList；}；Info包含窗口元素的元素类型，元素名称，文本信息等；RID表示窗口元素的运行时ID，窗口元素从创建到销毁过程中的唯一编号；Rect表示窗口元素的外包矩形，即窗口的左上角点的坐标和右下角点的坐标；RectAdjust表示修正后的窗口元素外包矩形；pParent指向窗口元素的父节点；pChildrenList包含窗口元素所有的子节点指针。通过该结构体的设计，在窗口元素抓取的过程中可以快速地确定窗口元素信息。可选地，根据主窗口元素在内存中构建树形结构的根节点，包括：在内存中构建树形结构的根节点；获取与主窗口元素对应的句柄并根据句柄获取主窗口元素的可访问对象，根据可访问对象获取与主窗口元素对应的元素信息；确定主窗口元素的运行ID和外包矩形，并设置主窗口元素的父节点指针为空，设置主窗口元素的子节点指针为第一级子窗口元素；将与主窗口对应的元素信息、运行ID、外包矩形、父节点指针为空、子节点指针为第一级子窗口元素作为根节点的结构信息。具体地，在根据主窗口元素在内存中构建树形结构的根节点的操作中，终端设备首先在内存中构建树形结构的根节点。然后，终端设备获取与主窗口元素对应的句柄。再具体操作中，终端设备开启线程，当鼠标移动时，向上逐级获取鼠标所在位置的窗口句柄直到获取到程序的最上层主窗口句柄。然后，终端设备调用系统API使用主窗口句柄hwnd_top作为参数获取主窗口的可访问对象。进一步地，根据可访问对象acc_obj_top获取与主窗口元素对应的元素信息，即Info信息。进一步地，终端设备确定主窗口元素的运行ID和外包矩形，并设置主窗口元素的父节点指针为空，设置主窗口元素的子节点指针为第一级子窗口元素。最终，将与主窗口对应的元素信息、运行ID、外包矩形、父节点指针为空、子节点指针为第一级子窗口元素作为根节点的结构信息。在实际操作中，例如可以通过acc_obj_top获取主窗口的元素信息存入根节点tree_node_top的Info之中。其中，还可以在内存中分配一个Map，使每个节点可以通过RID直接映射到。然后获取主窗口的运行时IR存入RID中，获取窗口的外包矩形存入Rect和RectAdjust中，将pParent设为空，将pChildrenList设置为第一级子窗口元素。从而通过这种方式，可以将主窗口元素的结构信息和树形结构的根节点进行关联，完成树形结构的根节点的构建。可选地，还包括：为根节点和主窗口元素的可访问对象分配一个线程，并将根节点和主窗口元素的可访问对象放入与线程对应的第一队列中，并且该分配一个线程并确定与线程对应的第一队列，并且根据至少一级子窗口元素在内存中构建树形结构的子节点，包括：通过线程，根据第一队列中的主窗口元素的可访问对象获取第一级子窗口元素的可访问对象，并根据第一级子窗口元素的可访问对象构建与第一级子窗口元素对应的子节点；确定第一级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第一级子窗口元素的父节点指针为根节点，设置第一级子窗口元素的子节点指针为第二级子窗口元素，作为第一级子窗口元素对应的子节点的结构信息；将第一级子窗口元素的子节点和对应的可访问对象存储至内存中预先设置的第二队列，并计算第二队列中节点的数量；根据预先设置的线程数量和第二队列中节点的数量，将第一级子窗口元素的子节点存储至每个线程对应的第一队列；通过每个线程，根据每个线程对应的第一队列中的第一级子窗口元素的可访问对象获取第二级子窗口元素的可访问对象，并根据第二级子窗口元素的可访问对象构建与第二级子窗口元素对应的子节点；确定第二级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第二级子窗口元素的父节点指针为第一级子窗口元素的子节点，设置第二级子窗口元素的的子节点指针为第三级子窗口元素，作为第二级子窗口元素的子节点的结构信息。具体地，在完成根节点的构建之后，为根节点和主窗口元素的可访问对象分配一个线程，并将根节点和主窗口元素的可访问对象放入与线程对应的第一队列中。具体地，可以将根节点tree_node_top和主窗口元素的可访问对象acc_obj_top放入该第一队列中。在根据至少一级子窗口元素在内存中构建树形结构的子节点的操作中，终端设备通过线程，根据第一队列中的主窗口元素的可访问对象获取第一级子窗口元素的可访问对象，即在线程中使用主窗口元素的可访问对象acc_obj_top获取第一级子窗口元素的可访问对象。然后根据第一级子窗口元素的可访问对象构建与第一级子窗口元素对应的子节点。进一步地，终端设备确定第一级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第一级子窗口元素的父节点指针为根节点，设置第一级子窗口元素的的子节点指针为第二级子窗口元素，作为第一级子窗口元素的结构信息。在实际操作中，获取第一级子窗口元素的Info，RID，Rect，RectAdjust，将其pParent指向根节点tree_node_top，pChildrenList指向第二级子窗口元素。使RID映射到节点Map＝tree_node_child。从而完成树形结构的第一层子节点的构建操作。进一步地，进行第二层子节点的构建。具体地，参考图5所示，在完成第一层子节点的构建，将第一级子窗口元素的子节点的结构信息存储至内存中预先设置的第二队列，并计算第二队列中节点的数量。然后，根据预先设置的线程数量和第二队列中节点的数量，将第一级子窗口元素的子节点存储至每个线程对应的第一队列。在一个具体实例中，系统会预先分配MAXTHREADNUM数量的线程，终端设备首先获取第二队列Queue的元素个数num，那么avg＝MAXTHREADNUM/num，rem＝MAXTHREADNUM-avg*num，如果rem＞0，那么1到rem的线程分配avg+1个第二队列Queue中的元素，rem+1到MAXTHREADNUM的线程分配avg个第二队列Queue中的元素，如果rem＝＝0，所有线程都分配avg个第二队列Queue中的元素。进一步地，每个线程分配到的Queue元素放入自己的第一队列queue_in中。然后，通过每个线程，根据每个线程对应的第一队列中的第一级子窗口元素的可访问对象获取第二级子窗口元素的可访问对象，并根据第二级子窗口元素的可访问对象构建与第二级子窗口元素对应的子节点。在具体操作中，MAXTHREADNUM个线程并发执行，在每个线程中依次取出第一队列queue_in中的元素，使用第一级窗口元素的可访问对象acc_obj_child获取第二级子窗口元素的可访问对象acc_obj_grandchild。然后确定第二级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第二级子窗口元素的父节点指针为第一级子窗口元素的子节点，设置第二级子窗口元素的的子节点指针为第三级子窗口元素，作为第二级子窗口元素的子节点的结构信息。从而完成第二级子窗口元素的子节点的构建。所有线程执行完毕后，清空之前的第二队列，将每个第一队列中的元素汇总依次放入第二队列中。此处需要说明的是，可以将每个第一队列中的元素首先放入图5中的队列queue_out中，然后将每个队列queue_out中的元素依次汇总到第二队列Queue中。循环进行树形结构的下一层的构建操作，直至第一队列中的元素为空，即完成所有的窗口元素的构建操作。从而通过这种方式，在构建树形结构的子节点的过程中，可以利用多个线程并行的进行构建每一层的子节点，因此可以提升构建的效率。可选地，还包括：根据主窗口元素和至少一级子窗口元素的外包矩形对树形结构进行修正操作。具体地，正如上面内容所述的，结构信息还包括RectAdjust，其作用是为了使父节点修正后的外包刚好包含所有子节点的外包。在一个具体应用场景中可能会出现子节点的外包矩形面积大于父节点的外包矩形面积，例如：子节点是一个下拉菜单窗口元素，当下拉菜单展开的情况下，面积可能会超出上一级节点的外包矩形。因此在这种情况下还需要根据主窗口元素和至少一级子窗口元素的外包矩形对树形结构进行修正操作。在外包矩形修正的操作中，从根节点开始，上一级节点对每个相邻的下一级节点递归的调用修正方法进行修正，每个子节点修正完之后，使用父节点的外包矩形Rect和子节点修正后的外包矩形Rect进行比较，如果子节点修正后的外包没有被父节点的外包包含，那么父节点修正后的外包取子节点修正后的外包。更具体的代码实现如下所示：tree_node_parent.RectAdjust left＝min；tree_node_parent.RectAdjust.top＝min；tree_node_parent.RectAdjust.right＝max；tree_node_parent.RectAdjust.bottom＝max；从而通过这种方式，在树形结构构建完成之后，还可以对树形结构进行修正操作，因此修正后的树形结构更加的正确，使得最终抓取的窗口元素更加准确。可选地，还包括：设置监听线程对窗口元素进行监听；以及在窗口元素发生变化的情况下，根据发生变化的窗口元素对树形结构进行局部调整。具体地，窗口应用程序的窗口元素还可能会根据用户的操作而改变，例如：窗口元素可能会根据用户的拖拽操作改变窗口位置，还可能根据用户的缩放操作改变窗口大小。为了使得树形结构与窗口元素相对应，因此本方案还可以根据窗口元素的变化对树形结构进行局部调整。具体地，参考图4所示，终端设备还可以设置监听线程对窗口元素进行监听，在实际应用中，开启监听线程监听窗口元素变化，该监听线程和构建树形结构的线程做线程互斥的操作。在监听到窗口元素发生变化的情况下，通过变化的窗口元素的可访问对象acc_obj的RID，直接找到对应的树形结构节点tree_node＝Map，使用tree_node的pParent找到其父节点tree_node_parent，清除父节点tree_node_parent及其子孙节点的数据，即：清除该父节点的下层节点的数据。然后使用acc_obj对父节点对应的窗口元素及其所有子孙窗口元素根据上述的节点构建方法重新建树，由于这里只是对发生变化的窗口元素及发生变化的窗口元素的下级窗口元素进行重新建树，而不影响发生变化的窗口元素的上级窗口元素，因此是一个局部建树的过程。在局部建树完毕后，用新生成的局部树替换之前父节点tree_node_parent处的树。从而通过这种方式，可以根据窗口元素的变化对构建的树形结构进行调整，使得窗口元素的抓取更加准确。此外，在调整的过程中只是对发生变化的窗口元素进行局部调整，不需要对整个树形结构进行重新构建，因此还可以加快树形结构的调整速度，节省计算资源。可选地，响应于用户选择抓取的目标窗口元素的第二触发操作，还包括：对树形结构的节点进行遍历，确定不包含第二触发操作的位置信息并且外包矩形面积最小的窗口元素作为目标窗口元素；以及突出显示目标窗口元素。在实际应用中，有的窗口应用程序为了防止窗口元素被抓取，因此在窗口元素上覆盖一层透明的窗口元素，使得无法定位到真正的窗口元素。为了解决该问题，本方案在响应于用户选择抓取的目标窗口元素的第二触发操作中，需要确定不包含第二触发操作的位置信息并且外包矩形面积最小的窗口元素作为目标窗口元素。在实际操作中，第二触发操作例如是鼠标点P移动到窗口元素。在这种情况下，使用深度优先的方法遍历树形结构，从根节点开始，判断每一层的节点的修正后的外包矩形RectAdjust是否包含P点，如果包含则继续判断其下一层的子节点的RectAdjust是否包含P点，不包含P点则停止，记录所有RectAdjust包含P点，但其子节点不存在或不包含P的节点元素。遍历记录的所有元素，找出外包Rect包含P点且Rect面积最小的节点元素为该目标窗口元素。并且突出显示该目标窗口元素，例如：修目标窗口元素的背景颜色进行突出显示，表示此元素是当前的可抓取的元素。从而通过这种方式，可以准确的定位到需要抓取的目标窗口元素。可选地，根据树形结构确定与目标窗口元素相关的窗口元素信息，包括：根据树形结构确定目标窗口元素的元素信息和/或确定目标窗口元素在树形结构的位置信息，其中位置信息为目标窗口元素在树形结构的路径。具体地，在根据树形结构确定与目标窗口元素相关的窗口元素信息的操作中，可以确定确定目标窗口元素的元素信息，例如窗口元素类型、文本信息等。并且还可以确定目标窗口元素在树形结构的位置信息。在确定位置信息的操作中，首先确定待抓取的目标窗口元素，然后程序创建栈stack变量将当前节点压入栈中，节点元素使用pParent获取父节点将父节点压入栈中，再继续往上获取获取父节点的父节点压入栈中直到根节点也压入栈中，这样栈stack就表示了抓取元素在树形结构的位置信息，最终输出的即为该目标窗口元素在树形结构的路径。从而，最终抓取的窗口元素信息可以是窗口元素在树形结构中的路径，因此可以清楚地表示抓取的窗口元素在窗口应用程序的位置。参考图4和图5所示，以一个完整的实施例描述本方案的具体流程如下：对一个窗口程序而言，存在一个最顶层的窗口称为主窗口，主窗口内部包含大大小小的子窗口元素，子窗口元素又包含自己的子窗口元素。如果把主窗口看成根节点，子窗口元素看成子节点，那么一个窗口程序的所有窗口元素构成了一颗树形结构。每个节点内包含元素的信息，同时指向其父节点和其子节点。每个节点为以下结构体TreeNodeStruct TreeNode{Info；RID；Rect；RectAdjust；pParent；pChildrenList；}；Info包含窗口元素的元素类型，元素名称，文本信息等RID表示窗口元素的运行时ID，窗口元素从创建到销毁过程中的唯一编号Rect表示窗口元素的外包矩形，即窗口的左上角点的坐标和右下角点的坐标RectAdjust表示修正后的窗口元素外包矩形pParent指向窗口元素的父节点pChildrenList包含窗口元素所有的子节点指针。屏幕抓取主要抓取屏幕窗口元素的两个信息，一是定位被抓取窗口元素在树形结构中的位置，；二是获取被抓取元素的信息，如元素的类型，文本内容等。1)鼠标移动时获取其所在位置的主窗口句柄。开启线程，当鼠标移动时，向上逐级获取鼠标所在位置的窗口句柄直到获取到程序的最上层主窗口句柄hwnd_top。2)当鼠标进入新窗口时，对此窗口进行至顶向下的并行建树。主要包括以下步骤：a.在抓屏程序的内存中分配队列Queue用于存放总的候选窗口元素的可访问对象和树形节点；分配MAXTHREADNUM数量的线程；为每个线程分配队列queue_in用于存放当前线程候选窗口元素的可访问对象和树形节点，为每个线程分配queue_out由于存放当前线程生成的可访问对象和树形节点。在内存中分配一个Map，使每个树形节点可以通过RID直接映射到。b.构建窗口元素树形结构的第1层，调用系统API使用主窗口句柄hwnd_top作为参数获取主窗口的可访问对象acc_obj_top，在内存中创建树形结构的根节点tree_node_top，通过acc_obj_top获取主窗口的元素信息存入根节点tree_node_top的Info之中，获取主窗口的运行时IR存入RID中，获取窗口的外包矩形存入Rect和RectAdjust中，将pParent设为空。使RID映射到节点Map＝tree_node_top。将{acc_obj_top,tree_node_top}放入队列Queue中。此时队列Queue中只有一个元素，为其分配一个线程，直接将Queue的元素放入线程的queue_in中，在线程中使用acc_obj_top获取主窗口的子窗口元素的可访问对象acc_obj_child，为所有子窗口对象创建树形节点tree_node_child，获取子窗口的Info，RID，Rect，RectAdjust，将其pParent指向tree_node_top。将所有tree_node_child依次放入tree_node_top的pChildrenList中。使RID映射到节点Map＝tree_node_child。同时将所有的{acc_obj_child,tree_node_child}放入queue中。线程执行完毕后，清空之前的队列Queue in，将queue out的元素放入Queue中。c.构建窗口元素树形结构的第2层，获取队列Queue的元素个数num，那么avg＝MAXTHREADNUM/num，rem＝MAXTHREADNUM-avg*num，如果rem＞0，那么1到rem的线程分配avg+1个Queue元素，rem+1到MAXTHREADNUM的线程分配avg个Queue元素，如果rem＝＝0，所有线程都分配avg个Queue元素，每个线程分配到的Queue元素放入自己的队列queue_in中。MAXTHREADNUM个线程并发执行，在每个线程中依次取出queue_in中的元素，使用acc_obj_child获取其下一级子窗口元素的可访问对象acc_obj_grandchild，为所有子窗口对象创建树形节点tree_node_grandchild，获取下一级子窗口元素的Info，RID，Rect，RectAdjust，将其pParent指向tree_node_child。将所有tree_node_grandchild依次放入tree_node_child的pChildrenList中。使RID映射到节点Map＝tree_node_grandchild。同时将线程中所有的{acc_obj_grandchild,tree_node_grandchild}放入queue_out中。所有线程执行完毕后，清空之前的线程队列Queue，将每个线程的queue_out中的元素依次放入Queue中。d.循环构建窗口元素树形结构的第3层，第4层…一直执行到新生成的Queue的个数为0。e.对树形结构每个节点的外包信息进行修正。从根节点开始，父节点tree_node_parent对每个子节点tree_node_child递归的调用修正方法进行修正，每个子节点修正完之后，使用父节点的外包和子节点修正后的外包进行比较，如果子节点修正后的外包没有被父节点的外包包含，那么父节点修正后的外包取子节点修正后的外包。tree_node_parent.RectAdjust left＝min；tree_node_parent.RectAdjust.top＝min；tree_node_parent.RectAdjust.right＝max；tree_node_parent.RectAdjust.bottom＝max；3)监听窗口元素的变化，进行局部的建树。开启线程监听窗口元素变化，此线程和建树的线程做线程互斥的操作。如果窗口元素发生变化，通过变化窗口的可访问对象acc_obj的RID，直接找到对应的树形结构节点tree_node＝Map，使用tree_node的pParent找到其父节点tree_node_parent，清除父节点tree_node_parent及其子孙几点的数据，使用acc_obj对父节点对应的窗口元素及其所有子孙窗口元素，使用第2)部的方法重新建树，局部建树完毕后，用新生成的局部树替换之前父节点tree_node_parent处的树。4)显示鼠标所在位置的窗口元素。当鼠标点P移动到窗口元素时，使用深度优先的方法遍历树，从根节点开始，判断节点的RectAdjust是否包含P点，如果包含则继续判断其子节点的RectAdjust是否包含P点，不包含P点则停止，记录所有RectAdjust包含P点，但其子节点不存在或不包含P的节点元素。遍历记录的所有元素，找出外包Rect包含P点且Rect面积最小的节点元素为待显示的节点，修改此元素的背景颜色，表示此元素是当前的可抓取的元素。5)鼠标移动到想要获取的元素上进行抓取。当用户或抓屏程序决定对当前可抓取元素进行抓取时，程序创建栈stack变量将当前节点压入栈中，节点元素使用pParent获取父节点将父节点压入栈中，再继续往上获取获取父节点的父节点压入栈中直到根节点也压入栈中，这样栈stack就表示了抓取元素在树形结构的位置信息，输出栈和抓取节点的相关信息。6)继续步骤1的操作直到屏幕抓取程序退出。Windows系统的UIA提供了API级别的窗口元素的获取，所有窗口元素的遍历等功能。但是UIA技术将元素窗口的粒度划分的很细，大到程序的主窗口被视为UIA的窗口元素，小到一个按钮也被视为一个UIA元素，这样一个程序就包含非常多的窗口元素，特别对于UI比较复杂的程序或较复杂的网页。定位窗口元素往往会用到整个窗口元素树形结构的信息，而抓屏元素获取窗口元素的信息是通过进程间通信获取的，时间消耗较多，窗口元素一多，会导致抓屏程序运行十分缓慢，使抓屏程序不可用。此外，目前对于窗口元素数目适中的情况，直接使用UIA的API，抓屏程序在和用户进行有交互的情况下，由于有一定的人机交互时间和人的心理承受的等待时间，抓屏程序勉强能满足用户需求。但随着抓屏程序越来越朝着与用户无交互、用户无感知的智能抓屏程序发展，对抓屏程序的时效性要求越来越强，因为抓屏的延时可能造成抓取用户操作的丢失。并且某些程序为了阻止使用UIA的方式抓屏会在程序的窗口元素上加上一层透明的窗口元素使UIA的API无法真正定位到被捕获的元素。通过该方案可以解决复杂窗口程序的抓屏问题，并且能够提高抓屏程序的时效性，同时解决客户程序阻止抓屏的问题。参考图6a和图6b所示，以下结合代码的方式描述本方案的实现过程：1)启动抓屏程序，初始化UIA。进行程序的初始化，HRESULT hr＝CoInitializeEx；hr＝CoCreateInstance)；启动线程，m_hThread＝CreateThread；检测鼠标位置的变化POINT pt；GetCursorPos；。2)鼠标移动到窗口元素上获取主窗口的句柄。获取窗口元素句柄HWND hwnd＝WindowFromPoint；获取主窗口句柄HWND mainhwnd＝GetAncestor；3)当鼠标移动到新的主窗口，对主窗口并行建树。对主窗口及其子孙元素进行至顶向下的并行建树。主要包括以下步骤：a.在抓屏程序的内存中分别分配用于存放总的候选窗口元素UIA对象和树形节点的两个列表std::list＜IUIAutomationElement*＞m_pEles；std::list＜UIANode*＞m_pNodes，分配MAXTHREADNUM数量的线程m_hThreads＝CreateThread，为每个线程分配用于存放当前线程候选窗口元素UIA对象和树形节点的两个列表std::list＜IUIAutomationElement*＞m_pElesThread_in；std::list＜UIANode*＞m_pNodesThread_in，为每个线程分配用于存放当前线程生成的UIA对象和树形节点的两个列表std::list＜IUIAutomationElement*＞m_pElesThread_out；std::list＜UIANode*＞m_pNodesThread_out。在内存中分配一个Map，使每个树形节点可以通过RID直接映射到，std::map＜CString,UIANode*＞m_MapTree。b.构建窗口元素树形结构的第1层，获取主窗口的UIA对象HRESULT hr＝m_pClientUIA-＞ElementFromHandleBuildCache，在内存中创建树形结构的根节点，获取窗口元素信息、RIDRect、RectAdjust，pParent设为空：GetUIANodeValueFromCache，映射RID到节点m_MapTree＝m_pTopNode。将m_pEles、m_pNodes的元素分配放入m_pElesThread_in、m_pNodesThread_in中。开启一个线程，在线程中获取主窗口的子窗口元素的UIA对象IUIAutomationElementArray*pFound＝nullptr；HRESULT hr＝m_pTopElement-＞FindAllBuildCache，为所有子窗口对象创建树形节点，获取子窗口的信息、RID、Rect、RectAdjust，将其pParent指向m_pTopNode，将所有tree_node_child依次放入m_pTopNode的pChildrenList中：GetUIANodeValueFromCache。使RID映射到节点m_MapTree＝tree_node_child。同时将所有的acc_obj_child、tree_node_child放入中m_pElesThread_out和m_pNodesThread_out中。线程执行完毕后，清空m_pEles、m_pNodes，将m_pElesThread_out和m_pNodesThread_out的元素放入m_pEles和m_pNodes中。c.构建窗口元素树形结构的第2层，获取m_pEles和m_pNodes元素个数num，那么avg＝MAXTHREADNUM/num，rem＝MAXTHREADNUM-avg*num，如果rem＞0，那么1到rem的线程分别分配avg+1个m_pEles和m_pNodes元素，rem+1到MAXTHREADNUM的线程分别分配avg个m_pEles和m_pNodes元素，如果rem＝＝0，所有线程都分别分配avg个m_pEles和m_pNodes元素，每个线程分配到的m_pEles和m_pNodes元素放入对应第i个线程的m_pElesThread_in、m_pNodesThread_in中。MAXTHREADNUM个线程并发执行，在每个线程中依次取出m_pElesThread_in、m_pNodesThread_in中的元素，对每个子窗口元素的UIA对象m_pElesThread_in获取其下一级子窗口元素的UIA对象IUIAutomationElementArray*pFound＝nullptr；HRESULT hr＝m_pNodesThread_in-＞FindAllBuildCache，为所有子窗口对象创建树形节点，获取子窗口的信息、RID、Rect、RectAdjust，将其pParent指向m_pNodesThread_in，将所有新生成的节点依次放入m_pNodesThread_in的pChildrenList：GetUIANodeValueFromCache。使RID映射到节点m_MapTree＝tree_node_child。同时将所有的acc_obj_child、tree_node_child放入中m_pElesThread_out和m_pNodesThread_out中。线程执行完毕后，清空m_pEles、m_pNodes，将对每个线程i将m_pElesThread_out和m_pNodesThread_out的元素放入m_pEles和m_pNodes中。d.循环构建窗口元素树形结构的第3层，第4层…一直到线程执行完毕后新生成的m_pEles和m_pNodes中元素个数为0。e.对树形结构每个节点的外包矩形信息进行修正。从根节点m_pTopNode开始，父节点tree_node_parent对每个子节点tree_node_child递归的调用修正方法进行修正，每个子节点修正完之后，使用父节点的外包和子节点修正后的外包进行比较，如果子节点修正后的外包没有被父节点的外包包含，那么父节点修正后的外包取子节点修正后的外包。tree_node_parent.RectAdjust left＝min；tree_node_parent.RectAdjust.top＝min；tree_node_parent.RectAdjust.right＝max；tree_node_parent.RectAdjust.bottom＝max；4)设置主窗口变化的监听过程。开启线程一个新线程，对主窗口及其子孙窗口元素，监听其变化m_pClientUIA-＞AddPropertyChangedEventHandlerNativeArraypEHTemp,pPIDProperties,sizeof/sizeof)。5)如果窗口元素发生变化，函数HRESULT STDMETHODCALLTYPEHandlePropertyChangedEvent将被回调。通过变化窗口的UIA对象pSender的RID对应的字符串strRID，直接找到对应的树形结构节点tree_node＝m_MapTree，使用tree_node的pParent找到其父节点tree_node_parent，清除父节点tree_node_parent及其子孙节点的数据，对父节点对应的窗口元素及其所有子孙窗口元素使用第2)步的方法重新建树，局部建树完毕后，用新生成的局部树替换之前父节点tree_node_parent处的树。6)计算鼠标位置的窗口元素，显示可抓取的窗口元素。当鼠标点P移动到窗口元素时，使用深度优先的方法遍历树，从根节点开始，判断节点的RectAdjust是否包含P点，如果包含则继续判断其子节点的RectAdjust是否包含P点，不包含P点则停止，记录所有RectAdjust包含P点，但其子节点不存在或不包含P的节点元素：std::list＜UIANode*＞pNodeArr；bool bR＝_FindChildNodeIncludePoint。遍历记录的所有元素，找出外包Rect包含P点且Rect面积最小的节点元素为待显示的节点：intmid_x＝/2,mid_y＝/2；int dis＝*+*；if{pnode_sel＝*it；min_area＝area；dis_sel＝dis；}修改此元素的背景颜色，表示此元素是当前的可抓取的元素。7)鼠标移动到想要获取的元素上进行抓取。监听鼠标左键，当鼠标左键单击时，程序创建栈stack变量将当前节点压入栈中，节点元素使用pParent获取父节点将父节点压入栈中，再继续往上获取获取父节点的父节点压入栈中直到根节点也压入栈中，这样栈stack就表示了抓取元素在树形结构的位置信息，输出栈和抓取节点的相关信息。8)继续步骤1的操作直到屏幕抓取程序退出。此外，参考图1所示，根据本实施例的第二个方面，提供了一种存储介质。所述存储介质包括存储的程序，其中，在所述程序运行时由处理器执行以上任意一项所述的方法。从而根据本实施例，在进行窗口元素的抓取的过程中，首先获取待抓取的目标窗口应用程序中的窗口元素，并在内存中根据窗口元素构建树形结构。在用户选择待抓取的窗口元素时，可以从该树形结构中获取抓取的窗口元素的窗口元素信息。因此，在用户操作选择窗口元素的同时可以同时抓取窗口元素信息，相当于用户操作窗口应用程序和抓取的过程在同一个进程中进行。与现有技术中抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信相比，本方案只需要在内存中的树形结构获取窗口信息，不需要进行跨进程操作。因此可以达到提升窗口元素抓取效率的技术效果。此外，树形结构是根据窗口元素而创建的，因此即使面对复杂的窗口元素，本方案也可以快速地进行窗口元素抓取。进而解决了现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。需要说明的是，对于前述的各方法实施例，为了简单描述，故将其都表述为一系列的动作组合，但是本领域技术人员应该知悉，本发明并不受所描述的动作顺序的限制，因为依据本发明，某些步骤可以采用其他顺序或者同时进行。其次，本领域技术人员也应该知悉，说明书中所描述的实施例均属于优选实施例，所涉及的动作和模块并不一定是本发明所必须的。通过以上的实施方式的描述，本领域的技术人员可以清楚地了解到根据上述实施例的方法可借助软件加必需的通用硬件平台的方式来实现，当然也可以通过硬件，但很多情况下前者是更佳的实施方式。基于这样的理解，本发明的技术方案本质上或者说对现有技术做出贡献的部分可以以软件产品的形式体现出来，该计算机软件产品存储在一个存储介质中，包括若干指令用以使得一台终端设备执行本发明各个实施例所述的方法。实施例2图7示出了根据本实施例所述的窗口元素抓取装置700，该装置700与根据实施例1的第一个方面所述的方法相对应。参考图7所示，该装置700包括：窗口程序确定模块710，用于响应于用户选择程序的第一触发操作，确定目标窗口应用程序；树形结构构建模块720，用于获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及窗口信息抓取模块730，用于响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。可选地，窗口元素包括主窗口元素和至少一级子窗口元素，并且树形结构构建模块720，包括：根节点构建子模块，用于根据主窗口元素在内存中构建树形结构的根节点；子节点构建子模块，用于根据至少一级子窗口元素在内存中构建树形结构的子节点；以及结构构建子模块，用于根据根节点和子节点以及主窗口元素和至少一级子窗口元素在目标窗口应用程序中的排列构建树形结构。可选地，窗口元素的结构信息包括以下至少一项：窗口元素的元素信息、运行ID、外包矩形、父节点指针、子节点指针。可选地，根节点构建子模块，包括：根节点构建单元，用于在内存中构建树形结构的根节点；元素信息获取单元，用于获取与主窗口元素对应的句柄并根据句柄获取主窗口元素的可访问对象，根据可访问对象获取与主窗口元素对应的元素信息；第一确定单元，用于确定主窗口元素的运行ID和外包矩形，并设置主窗口元素的父节点指针为空，设置主窗口元素的子节点指针为第一级子窗口元素；根节点结构信息确定单元，用于将与主窗口对应的元素信息、运行ID、外包矩形、父节点指针为空、子节点指针为第一级子窗口元素作为根节点的结构信息。可选地，还包括：线程分配模块，用于为根节点分配一个线程并确定与线程对应的第一队列，并且子节点构建子模块，包括：一级子节点构建单元，用于通过线程，根据第一队列中的根节点的结构信息获取第一级子窗口元素的可访问对象，并根据第一级子窗口元素的可访问对象构建与第一级子窗口元素对应的子节点；一级子节点信息确定单元，用于确定第一级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第一级子窗口元素的父节点指针为根节点，设置第一级子窗口元素的的子节点指针为第二级子窗口元素，作为第一级子窗口元素的结构信息；一级子节点存储单元，用于将第一级子窗口元素的子节点的结构信息存储至内存中预先设置的第二队列，并计算第二队列中节点的数量；线程分配单元，用于根据预先设置的线程数量和第二队列中节点的数量，将第一级子窗口元素的子节点存储至每个线程对应的第一队列；二级子节点构建单元，用于通过每个线程，根据每个线程对应的第一队列中的第一级子窗口元素的子节点的结构信息获取第二级子窗口元素的可访问对象，并根据第二级子窗口元素的可访问对象构建与第二级子窗口元素对应的子节点；二级子节点信息确定单元，用于确定第二级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第二级子窗口元素的父节点指针为第一级子窗口元素的子节点，设置第二级子窗口元素的的子节点指针为第三级子窗口元素，作为第二级子窗口元素的结构信息；以及二级子节点存储单元，用于将每个线程的第一队列中的第二级子窗口元素的子节点的结构信息存储至第二队列。可选地，装置700还包括：修正单元，用于根据主窗口元素和至少一级子窗口元素的外包矩形对树形结构进行修正操作。可选地，装置700还包括：监听模块，用于设置监听线程对窗口元素进行监听；以及局部构建模块，用于在窗口元素发生变化的情况下，根据发生变化的窗口元素对树形结构进行局部调整。可选地，窗口信息抓取模块730，包括：窗口确定子模块，用于对树形结构的节点进行遍历，确定不包含第二触发操作的位置信息并且外包矩形面积最小的窗口元素作为目标窗口元素；以及窗口显示子模块，用于突出显示目标窗口元素。可选地，窗口信息抓取模块730，包括：路径确定子模块，用于根据树形结构确定目标窗口元素的元素信息和/或确定目标窗口元素在树形结构的位置信息，其中位置信息为目标窗口元素在树形结构的路径。从而根据本实施例，在进行窗口元素的抓取的过程中，首先获取待抓取的目标窗口应用程序中的窗口元素，并在内存中根据窗口元素构建树形结构。在用户选择待抓取的窗口元素时，可以从该树形结构中获取抓取的窗口元素的窗口元素信息。因此，在用户操作选择窗口元素的同时可以同时抓取窗口元素信息，相当于用户操作窗口应用程序和抓取的过程在同一个进程中进行。与现有技术中抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信相比，本方案只需要在内存中的树形结构获取窗口信息，不需要进行跨进程操作。因此可以达到提升窗口元素抓取效率的技术效果。此外，树形结构是根据窗口元素而创建的，因此即使面对复杂的窗口元素，本方案也可以快速地进行窗口元素抓取。进而解决了现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。实施例3图8示出了根据本实施例所述的窗口元素抓取装置800，该装置800与根据实施例1的第一个方面所述的方法相对应。参考图8所示，该装置800包括：处理器810；以及存储器820，与处理器810连接，用于为处理器810提供处理以下处理步骤的指令：响应于用户选择程序的第一触发操作，确定目标窗口应用程序；获取目标窗口应用程序包含的窗口元素，并根据窗口元素在内存中构建树形结构，其中树形结构中的节点与窗口元素在目标窗口应用程序中的排列相关并且包含窗口元素的结构信息；以及响应于用户选择抓取的目标窗口元素的第二触发操作，根据树形结构确定与目标窗口元素相关的窗口元素信息。可选地，窗口元素包括主窗口元素和至少一级子窗口元素，并且根据窗口元素在内存中构建树形结构，包括：根据主窗口元素在内存中构建树形结构的根节点；根据至少一级子窗口元素在内存中构建树形结构的子节点；以及根据根节点和子节点以及主窗口元素和至少一级子窗口元素在目标窗口应用程序中的排列构建树形结构。可选地，窗口元素的结构信息包括以下至少一项：窗口元素的元素信息、运行ID、外包矩形、父节点指针、子节点指针。可选地，根据主窗口元素在内存中构建树形结构的根节点，包括：在内存中构建树形结构的根节点；获取与主窗口元素对应的句柄并根据句柄获取主窗口元素的可访问对象，根据可访问对象获取与主窗口元素对应的元素信息；确定主窗口元素的运行ID和外包矩形，并设置主窗口元素的父节点指针为空，设置主窗口元素的子节点指针为第一级子窗口元素；将与主窗口对应的元素信息、运行ID、外包矩形、父节点指针为空、子节点指针为第一级子窗口元素作为根节点的结构信息。可选地，存储器820还用于为处理器810提供处理以下处理步骤的指令：为根节点分配一个线程并确定与线程对应的第一队列，并且根据至少一级子窗口元素在内存中构建树形结构的子节点，包括：通过线程，根据第一队列中的根节点的结构信息获取第一级子窗口元素的可访问对象，并根据第一级子窗口元素的可访问对象构建与第一级子窗口元素对应的子节点；确定第一级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第一级子窗口元素的父节点指针为根节点，设置第一级子窗口元素的的子节点指针为第二级子窗口元素，作为第一级子窗口元素的结构信息；将第一级子窗口元素的子节点的结构信息存储至内存中预先设置的第二队列，并计算第二队列中节点的数量；根据预先设置的线程数量和第二队列中节点的数量，将第一级子窗口元素的子节点存储至每个线程对应的第一队列；通过每个线程，根据每个线程对应的第一队列中的第一级子窗口元素的子节点的结构信息获取第二级子窗口元素的可访问对象，并根据第二级子窗口元素的可访问对象构建与第二级子窗口元素对应的子节点；确定第二级子窗口元素对应的元素信息、运行ID、外包矩形，并设置第二级子窗口元素的父节点指针为第一级子窗口元素的子节点，设置第二级子窗口元素的的子节点指针为第三级子窗口元素，作为第二级子窗口元素的结构信息；以及将每个线程的第一队列中的第二级子窗口元素的子节点的结构信息存储至第二队列。可选地，存储器820还用于为处理器810提供处理以下处理步骤的指令：根据主窗口元素和至少一级子窗口元素的外包矩形对树形结构进行修正操作。可选地，存储器820还用于为处理器810提供处理以下处理步骤的指令：设置监听线程对窗口元素进行监听；以及在窗口元素发生变化的情况下，根据发生变化的窗口元素对树形结构进行局部调整。可选地，响应于用户选择抓取的目标窗口元素的第二触发操作，还包括：对树形结构的节点进行遍历，确定不包含第二触发操作的位置信息并且外包矩形面积最小的窗口元素作为目标窗口元素；以及突出显示目标窗口元素。可选地，根据树形结构确定与目标窗口元素相关的窗口元素信息，包括：根据树形结构确定目标窗口元素的元素信息和/或确定目标窗口元素在树形结构的位置信息，其中位置信息为目标窗口元素在树形结构的路径。从而根据本实施例，在进行窗口元素的抓取的过程中，首先获取待抓取的目标窗口应用程序中的窗口元素，并在内存中根据窗口元素构建树形结构。在用户选择待抓取的窗口元素时，可以从该树形结构中获取抓取的窗口元素的窗口元素信息。因此，在用户操作选择窗口元素的同时可以同时抓取窗口元素信息，相当于用户操作窗口应用程序和抓取的过程在同一个进程中进行。与现有技术中抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信相比，本方案只需要在内存中的树形结构获取窗口信息，不需要进行跨进程操作。因此可以达到提升窗口元素抓取效率的技术效果。此外，树形结构是根据窗口元素而创建的，因此即使面对复杂的窗口元素，本方案也可以快速地进行窗口元素抓取。进而解决了现有技术中存在的抓屏程序要获取其他程序窗口的信息需要进行跨进程的通信，尤其是面对复杂的程序窗口，会消耗大量时间，影响窗口元素抓取效率的技术问题。上述本发明实施例序号仅仅为了描述，不代表实施例的优劣。在本发明的上述实施例中，对各个实施例的描述都各有侧重，某个实施例中没有详述的部分，可以参见其他实施例的相关描述。在本申请所提供的几个实施例中，应该理解到，所揭露的技术内容，可通过其它的方式实现。其中，以上所描述的装置实施例仅仅是示意性的，例如所述单元的划分，仅仅为一种逻辑功能划分，实际实现时可以有另外的划分方式，例如多个单元或组件可以结合或者可以集成到另一个系统，或一些特征可以忽略，或不执行。另一点，所显示或讨论的相互之间的耦合或直接耦合或通信连接可以是通过一些接口，单元或模块的间接耦合或通信连接，可以是电性或其它的形式。所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部单元来实现本实施例方案的目的。另外，在本发明各个实施例中的各功能单元可以集成在一个处理单元中，也可以是各个单元单独物理存在，也可以两个或两个以上单元集成在一个单元中。上述集成的单元既可以采用硬件的形式实现，也可以采用软件功能单元的形式实现。所述集成的单元如果以软件功能单元的形式实现并作为独立的产品销售或使用时，可以存储在一个计算机可读取存储介质中。基于这样的理解，本发明的技术方案本质上或者说对现有技术做出贡献的部分或者该技术方案的全部或部分可以以软件产品的形式体现出来，该计算机软件产品存储在一个存储介质中，包括若干指令用以使得一台计算机设备执行本发明各个实施例所述方法的全部或部分步骤。而前述的存储介质包括：U盘、只读存储器、随机存取存储器、移动硬盘、磁碟或者光盘等各种可以存储程序代码的介质。以上所述仅是本发明的优选实施方式，应当指出，对于本技术领域的普通技术人员来说，在不脱离本发明原理的前提下，还可以做出若干改进和润饰，这些改进和润饰也应视为本发明的保护范围。

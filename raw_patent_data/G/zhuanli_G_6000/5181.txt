标题title
一种基于多核处理器的并发事务处理方法及其系统
摘要abst
本申请提供了一种基于多核处理器的并发事务处理方法及其系统，通过当目标时间段内出现事务并发时，则获取在目标时间段内出现的事务的读写集合；依据读写集合确定事务之间的冲突关系以及对应于事务的执行代价；依据冲突关系确定事务对应的分区；依据冲突关系和执行代价确定事务在分区的队列类型；其中，队列类型包括无冲突队列和冲突队列；当冲突队列中的事务与其他分区中的事务存在冲突时，则冲突队列中的事务延迟处理。通过运行时调度可以降低事务的冲突，对于高冲突并发事务同样有效，通过延迟执行降低冲突，且不需要针对所有事务都考虑悲观锁，降低整体锁等待时延，对于执行代价估计偏差，可以依赖并发控制确保结果的正确性。
权利要求书clms
1.一种基于多核处理器的并发事务处理方法，其特征在于，包括步骤：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。2.根据权利要求1所述的方法，其特征在于，所述执行代价为对应的处理器执行所述事务的时间；所述依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型的步骤，包括：依据所述读写集合确定所述事务的启动时间；依据所述启动时间和所述执行代价确定所述事务的执行时间片；依据所述冲突关系确定目标分区中目标事务的执行时间片与其他分区中事务的执行时间片是否有重叠，若是，则所述目标事务在所述冲突队列中，若否，则所述目标事务在所述无冲突队列中。3.根据权利要求2所述的方法，其特征在于，所述当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理的步骤，包括：依据所述执行时间片确定所述事务在所述冲突队列中的排序；当所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片重叠时，则所述冲突队列中的事务延迟处理。4.根据权利要求3所述的方法，其特征在于，所述依据所述执行时间片确定所述事务在所述冲突队列中的排序的步骤，包括：依据所述冲突关系将所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片错峰排序。5.根据权利要求1所述的方法，其特征在于，所述依据所述冲突关系确定所述事务对应的分区的步骤，包括：依据所述读写集合确定所述事务访问的数据类型；依据所述数据类型和所述冲突关系确定所述事务的分区。6.根据权利要求1所述的方法，其特征在于，还包括：当所述冲突队列中事务的实际执行时间与对应的所述执行代价不相等时，则对所述事务进行加锁访问。7.根据权利要求1所述的方法，其特征在于，还包括：当有新事务加入处理时，依据所述新事务的读写集合确定所述新事务对应的分区及队列类型；当所述新事务在对应的队列中与其他分区中的事务存在冲突时，则所述新事务延迟处理。8.一种基于多核处理器的并发事务处理系统，其特征在于，包括：获取模块，用于当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；计算模块，用于依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；分区模块，用于依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；调度模块，用于依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；处理模块，用于当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。9.一种计算机设备，其特征在于，包括处理器、存储器及存储在所述存储器上并能够在所述处理器上运行的计算机程序，所述计算机程序被所述处理器执行时实现如权利要求1至7中任一项所述的方法。10.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质上存储计算机程序，所述计算机程序被处理器执行时实现如权利要求1至7中任一项所述的方法。
说明书desc
技术领域本申请涉及并发事务处理领域，特别是一种基于多核处理器的并发事务处理方法及其系统。背景技术之前都只有一个用户访问数据，出现多个用户访问相同数据的情况，这被称为“并发”，当一个用户企图修改另一个用户正在检索或修改的数据时，并发会成为一个问题。现代计算机系统都是基于多核架构的中央处理器，而数据库系统为了处理并发事务请求，需要将事务分配到不同CPU的核心上进行计算。不同事务间可能存在访问相同数据的情况，需要通过类似锁机制针对特定数据记录进行并发保护。而类似的锁机制仅能避免并发访问，其可能导致不同事务处理之间的等待，进而使得系统整体处理能力严重受制于事务锁粒度，扩展性较差。有一类数据库系统为了提升并行处理能力，提出了无锁并发控制，将数据分区与特定CPU核绑定，当事务仅作用于特定数据分区时，不用考虑与其他CPU核的并发访问问题，这类方法被称为乐观并发控制。但当OCC方法对于跨分区的事务其并发访问的中断重试机制成本较高，其成本相较基于锁保护的方法更高。发明内容鉴于所述问题，提出了本申请以便提供克服所述问题或者至少部分地解决所述问题的一种基于多核处理器的并发事务处理方法及其系统，包括：一种基于多核处理器的并发事务处理方法，包括步骤：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。进一步地，所述执行代价为对应的处理器执行所述事务的时间；所述依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型的步骤，包括：依据所述读写集合确定所述事务的启动时间；依据所述启动时间和所述执行代价确定所述事务的执行时间片；依据所述冲突关系确定目标分区中目标事务的执行时间片与其他分区中事务的执行时间片是否有重叠，若是，则所述目标事务在所述冲突队列中，若否，则所述目标事务在所述无冲突队列中。进一步地，所述当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理的步骤，包括：依据所述执行时间片确定所述事务在所述冲突队列中的排序；当所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片重叠时，则所述冲突队列中的事务延迟处理。进一步地，所述依据所述执行时间片确定所述事务在所述冲突队列中的排序的步骤，包括：依据所述冲突关系将所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片错峰排序。进一步地，所述依据所述冲突关系确定所述事务对应的分区的步骤，包括：依据所述读写集合确定所述事务访问的数据类型；依据所述数据类型和所述冲突关系确定所述事务的分区。进一步地，还包括：当所述冲突队列中事务的实际执行时间与对应的所述执行代价不相等时，则对所述事务进行加锁访问。进一步地，还包括：当有新事务加入处理时，依据所述新事务的读写集合确定所述新事务对应的分区及队列类型；当所述新事务在对应的队列中与其他分区中的事务存在冲突时，则所述新事务延迟处理。一种基于多核处理器的并发事务处理系统，包括：获取模块，用于当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；计算模块，用于依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；分区模块，用于依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；调度模块，用于依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；处理模块，用于当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。一种计算机设备，包括处理器、存储器及存储在所述存储器上并能够在所述处理器上运行的计算机程序，所述计算机程序被所述处理器执行时实现如上所述的一种基于多核处理器的并发事务处理方法的步骤。一种计算机可读存储介质，所述计算机可读存储介质上存储计算机程序，所述计算机程序被处理器执行时实现如上所述的一种基于多核处理器的并发事务处理方法的步骤。本申请具有以下优点：在本申请的实施例中，相对于现有技术中的“事务并发处理存在局限性”的问题，本申请提供了基于事务代价和多核架构下事务处理的调度和处理流程的解决方案，具体为：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。通过运行时调度可以降低事务的冲突，对于高冲突并发事务同样有效，通过延迟执行降低冲突，且不需要针对所有事务都考虑悲观锁，降低整体锁等待时延，对于执行代价估计偏差，可以依赖并发控制确保结果的正确性。附图说明为了更清楚地说明本申请的技术方案，下面将对本申请的描述中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本申请的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动性的前提下，还可以根据这些附图获得其他的附图。图1是本申请一实施例提供的一种基于多核处理器的并发事务处理方法的步骤流程图；图2是申请一实施例提供的一种基于多核处理器的并发事务处理方法的队列示意图；图3是申请一实施例提供的一种基于多核处理器的并发事务处理方法的方案框图；图4是本申请一实施例提供的现有技术一的读写锁兼容性示意图。图5是本申请一实施例提供的现有技术一的提交读级别下的读写锁的使用示意图。图6是本申请一实施例提供的一种基于多核处理器的并发事务处理系统的结构框图；图7是本申请一实施例提供的一种基于多核处理器的并发事务处理系统的结构框图；图8是本发明一实施例提供的一种计算机设备的结构示意图。具体实施方式为使本申请的所述目的、特征和优点能够更加明显易懂，下面结合附图和具体实施方式对本申请作进一步详细的说明。显然，所描述的实施例是本申请一部分实施例，而不是全部的实施例。基于本申请中的实施例，本领域普通技术人员在没有作出创造性劳动前提下所获得的所有其他实施例，都属于本申请保护的范围。发明人通过分析现有技术发现：现有技术一和现有技术二，下面分别阐述：现有技术一：MySQL锁技术以及MVCC基础，读写锁兼容性如图4所示。1、MySQL锁技术当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：共享锁，又叫做“读锁”，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。排他锁，又叫做“写锁”，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。通过读写锁，可以做到读读并行，但不能做到写读，写写并行。事务的隔离性就是根据读写锁来实现的。2、MVCC实现MVCC。MySQL存储引擎InnoDB的MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。根据《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。提交读级别下的读写锁的使用如图5所示，MVCC在MySQL中的实现依赖的是undolog与read view。其中，undo log：undo log中记录某行数据的多个版本的数据；readview：用来判断当前版本数据的可见性。现有技术二：Silo中的OCC事务处理，OCC事务跟踪它在线程本地存储中读写的记录。在提交时，在确认没有并发事务的写集与读集重叠之后，事务立即执行所有写记录。如果验证失败，事务将中止。Silo基于称为epoch的时间段，用于确保可序列化的恢复，以删除垃圾并提供只读快照。每个epoch都有一个epoch号。全局纪元号E对所有线程都可见。指定线程定期更新E；其他线程在提交事务时访问E。E应该经常更新，因为epoch周期会影响事务延迟，但与事务持续时间相比，epoch的变化应该很少，以便通常缓存E的值。目前的实现是40毫秒更新一次；更短的时间也可以。处理E不需要锁。TID是一个64bit的integer，被分成几个部分来表示不同的含义。最高的几个位次代表当前事务提交时的epoch E。中间位次表示基于当前epoch算出来的timestamp。最低的三个bit分别代表lock bit、lastest-version bit和absent bit。Tid是直接写到tuple里的，每条记录都包含最近修改它的事务的TID。并满足条件：1.当前epoch分配的时间戳一定小于下一个epoch分配的；2.同一个工作线程中，分配的时间戳严格单调递增；3.修改同一条记录的事务，时间戳严格单调递增。Silo的记录包含以下信息：TID word，前版本指针，数据。Commit protocol：当worker运行一个事务时，它维护一个读集，该读集标识所有被读取的记录，以及每条记录在被访问时的TID。对于已修改的记录，它维护一个写集，用于存储记录的新状态。被读取和修改的记录同时出现在读集和写集中。在正常操作中，写集中的所有记录也出现在读集中。在事务完成时，worker尝试使用以下协议提交：阶段1：检查事务的写集中的所有记录，并通过获取记录的锁位来锁定每条记录。为了避免死锁，按全局顺序锁定记录。在获得所有的写锁之后，worker使用一次内存访问获取全局纪元号的快照。为了确保读到主存。全局纪元号的快照是提交事务的序列化点。阶段2：检查事务的读集中的所有记录。如果某个记录的TID与其在执行过程中观察到的不同，不再是最新版本，或者被不同的事务锁定，那么事务将释放其锁并中止。如果所有读取记录的tid不变，那么事务就允许提交，因为知道它的所有读取都是一致的。worker使用在阶段1中获得的全局纪元号的快照为事务分配一个TID。阶段3：worker将其修改过的记录写入数据块中，并将它们的TIDs更新为上一阶段计算的事务ID。每个锁都可以在其记录被写入之后立即被释放。必须确保锁一释放，新的TID就可见。综上，面向多核的并发事务处理机制是现代OLTP数据库管理系统的关键挑战之一。数据库系统是否能随硬件核数的增加而满足更多的并行事务请求，是衡量数据库处理能力的关键指标。商业数据库Oracle和开源数据库MySQL、PostgreSQL在都是依靠传统基于锁等待的事务处理机制，其实现相对来说简单可靠，但是扩展性问题并未很好解决。在研究领域也有不少基于OCC的新型数据库系统不断尝试解决这类问题。其中比较有代表性的如麻省理工学院提出的Silo和卡内基梅隆大学提出的TICTOC等。他们验证了OCC在低冲突场景下的扩展性，但并不适用于高冲突场景。基于OCC方法跨数据分区事务导致并发访问时，需要将当前事务中断后再重试，可以将事务按分区粒度并行，但对于跨分区的事务其并发访问的中断重试机制成本较高，当事务冲突较大时可能导致大量事务反复重试。本发明重点解决在多核架构下数据库管理系统中如何高效处理并发事务，其关键是对于特定时间内的一批事务，如何能够最大程度实现并行且避免事物间的并发访问。本发明提供了支持基于事务代价的调度机制来解决上述问题，即对于特定事务集合根据其访问的数据集分配到不同的CPU核进行冲突延迟处理。对于特定CPU核来说，特定事务因与其他CPU核事务间存在冲突，并行执行的前提是时间上错峰。因此基于提前识别事务之间的冲突和代价，通过时间片延迟调度实现不同CPU核之间的并行事务处理。参照图1和图2，示出了本申请一实施例提供的一种基于多核处理器的并发事务处理方法；所述方法包括：S110、当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；S120、依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；S130、依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；S140、依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；S150、当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。在本申请的实施例中，相对于现有技术中的“事务并发处理存在局限性”的问题，本申请提供了基于事务代价和多核架构下事务处理的调度和处理流程的解决方案，具体为：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。通过运行时调度可以降低事务的冲突，对于高冲突并发事务同样有效，通过延迟执行降低冲突，且不需要针对所有事务都考虑悲观锁，降低整体锁等待时延，对于执行代价估计偏差，可以依赖并发控制确保结果的正确性。下面，将对本示例性实施例中一种基于多核处理器的并发事务处理方法作进一步地说明。如所述步骤S110所述，当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合。作为一种示例，在数据同步中，在源端数据库及目的端数据库部署同步系统，源端数据同步系统从源端数据库读取日志，而目的端数据同步系统则是负责把源端发过来的同步操作应用到目的端数据库。一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。源端数据库通过执行事务产生数据变化，每个事务中包含一个或多个数据库操作，每个操作会产生一个数据变化。操作包括读取数据、写数据、更新修改数据、删除数据等，在具体实施场景中，一个操作可以对应一个SQL语句。事务就是一系列对数据库操作的语句集合，对于特定时间段内的一批事务，数据库系统中会生成当前事务读数据的集合和写数据的集合。如所述步骤S120所述，依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价。作为一种示例，事务代价是指执行该事务对应CPU需要的时间，这个时间通常与修改的数据量有相关性。数据库系统中会生成当前事务的读写数据集合，通过这个集合可以估算其执行代价。一个事务中包含一个执行代价，执行代价是一个固定值，仅与修改数据记录相关。在确定每个事务的读写集合后，对于同一批中事务建立事物之间冲突关系图，对于任一事务可以快速查找和它冲突的事务列表，利用关系图判断相关事务是否冲突，用于后续步骤分区和调度，如果两个事务冲突了则要确保它们的运行时间不重叠。在一具体实现中，参照图2，假设一个批量任务包含有T1，T2，…，Tn个事务，先从各事务涉及的读写数据集来形成事务之间的冲突关系图Conflict Graph，其中对于每个事务包含其冲突事务的执行代价。如图2，右边中Txn*为Txn1，可以得出Txn1与Txn2、Txn4以及Txn6冲突。如所述步骤S130所述，依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同。在本发明一实施例中，可以结合下列描述进一步说明步骤S130所述“依据所述冲突关系确定所述事务对应的分区”的具体过程。如下列步骤所述，依据所述读写集合确定所述事务访问的数据类型；如下列步骤所述，依据所述数据类型和所述冲突关系确定所述事务的分区。作为一种示例，对于批量事务流程，在确定每个事务的读写集合后，根据其访问的数据集合进行划分，确保访问相同数据的事务尽量属于同一分区，避免跨分区事务之间存在冲突。为了提高目的端事务执行效率，进行数据同步时目的端对事务采用并行执行的方式，因此，需要创建多个能够并行执行的执行线程，将需要执行对应分区的事务分配至不同的执行线程进行执行。在一具体实现中，通过分区算法对冲突关系图进行分区，分区算法的目的就是让跨分区的冲突事务尽可能地少，理想状态下各分区中的事务与其他分区事务之间不会访问相同的数据。如所述步骤S140所述，依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列。在本发明一实施例中，可以结合下列描述进一步说明步骤S140所述“依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型”的具体过程。如下列步骤所述，依据所述读写集合确定所述事务的启动时间；如下列步骤所述，依据所述启动时间和所述执行代价确定所述事务的执行时间片；如下列步骤所述，依据所述冲突关系确定目标分区中目标事务的执行时间片与其他分区中事务的执行时间片是否有重叠，若是，则所述目标事务在所述冲突队列中，若否，则所述目标事务在所述无冲突队列中。作为一种示例，从所述事务的读写集合中获取每个事务的执行启动时间，再依据对应执行线程执行该事务所需的时间，即可得到每个事务的执行时间片，通过执行时间片和冲突关系图可以对分区中的事务放入不同的队列中。负责执行的线程，根据事务的执行代价和相关事务冲突信息，决定将事务放入不同队列，各分区中不与其他分区事务冲突的事务加入对应的无冲突队列P中，其中无冲突队列P中事务与其他分区的事务是完全独立的，而冲突队列Q中的事务则需要进行调度排序。由于各分区的事务都是独立的，因此执行顺序与其他分区无关，多个事务执行线程可以并行执行。在一具体实现中，队列的个数与分区数保持一致，假设有50个分区，每个分区中都有无冲突队列P和冲突队列Q两个类型的队列，则50个分区中共有100个队列，其中无冲突队列P有50个，冲突队列Q也有50个，数量与分区数相等。如所述步骤S150所述，当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。在本发明一实施例中，可以结合下列描述进一步说明步骤S150所述“当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理”的具体过程。如下列步骤所述，依据所述执行时间片确定所述事务在所述冲突队列中的排序；如下列步骤所述，当所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片重叠时，则所述冲突队列中的事务延迟处理。在本发明一实施例中，可以结合下列描述进一步说明“依据所述执行时间片确定所述事务在所述冲突队列中的排序”的具体过程。如下列步骤所述，依据所述冲突关系将所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片错峰排序。作为一种示例，在所述冲突队列Q中，需要对其中的事务进行调度排序。将冲突队列Q中的事务的时间片与其他队列中事务的时间片错开不重叠，如果仍存在特定事务已排在冲突队列Q的队尾且与其他线程的执行时间片有重叠的，则该特定事务选择延迟处理，实现无冲突并发执行。在一具体实现中，参照图2，图2中黑色阴影部分代表队列中已被其他事务占用的时间片。当事务分配到特定分区的调度队列Q中时，需要通过冲突关系图确认其他事务的执行时间片。原则上冲突事务不能有时间片重叠，才能并行执行。如T2加入Q3的启动时间晚于T1结束时间，或者T2加入Qk的结束时间早于T1的开始时间。当特定队列Q已经无法找到与冲突事务错开的时间片队列时，通过延迟启动实现无冲突并发执行。在本实施例中，所述并发事务处理方法还包括：当所述冲突队列中事务的实际执行时间与对应的所述执行代价不相等时，则对所述事务进行加锁访问。作为一种示例，对于已完成调度的事务，最终执行时需要考虑并发访问控制，通过对事务进行加锁访问，避免运行时代价偏差导致数据被多事务同时修改。加锁可以根据每个操作的唯一标识符，对每个操作构造行锁，唯一标识符的值作为行锁的值。在本实施例中，所述并发事务处理方法还包括：当有新事务加入处理时，依据所述新事务的读写集合确定所述新事务对应的分区及队列类型；当所述新事务在对应的队列中与其他分区中的事务存在冲突时，则所述新事务延迟处理。作为一种示例，对于每个即时事务，获取其读写集合，并根据其读写集合确定出即时事务与当前事务之间的冲突关系和执行代价，根据其访问的数据集合进行一定随机化处理，确定出即时事务对应的分区和队列，并将事务分配给对应的执行线程。将即时事务与当前已分区的事务一并调度。后续步骤与批量事务处理类似，若即时事务与其他分区队列中的事务的执行时间片重叠时，则该即时事务延迟处理。参照图3，为本发明的一种基于多核处理器的并发事务处理方法的方案框图。图3中，bundled workload为批量事务请求，是例行业务；unbundledtransactions为即时事务请求；Transaction-to-thread assignment为将事务分发给特定的线程；对于较重的批量请求，则考虑将事务按相关性进行分区，而对于较轻量的即时请求，可以考虑通过随机算法进行分配。将事务分区后，通过Thread-local buffers，用于保存分配给特定线程的事务。TSkd为主要用于各线程内的事务执行调度，包括调度器和延迟器两部分。它们的作用是将各线程之间存在冲突的事务执行时间片错开。具体执行单元为Execution，可以支持各类并发事务处理机制，如锁等待和OCC等。实施例1批量事务流程：1、在确定每个事务的读写集合后，对于同一批中事务建立事物之间冲突关系图，对于任一Txn可以快速查找和它冲突的事务列表，用于后续步骤分区和调度。2、在确定每个事务的读写集合后，根据其访问的数据集合进行划分，确保访问相同数据的事务尽量属于同一分区，避免跨分区事务之间存在冲突。将对应分区的事务分配给对应的执行线程。3、负责执行的线程，根据事务的执行代价和相关事务冲突信息，决定将事务放入不同队列，其中无冲突队列P中事务与其他分区的事务是完全独立的，而冲突队列Q中的事务则需要进行调度排序。4、如果存在特定事务已排在冲突队列的队尾且与其他线程仍有冲突则选择延迟处理。5、对于已完成调度的事务，最终执行时让需要考虑并发访问控制，避免运行时代价偏差导致数据被多事务同时修改。即时事务流程：对于每个即时事务，根据其访问的数据集合进行一定随机化处理，将事务分配给对应的执行线程。与当前已分区的事务一并调度。后续步骤与批量事务处理类似，不再赘述。对于系统实施例而言，由于其与方法实施例基本相似，所以描述的比较简单，相关之处参见方法实施例的部分说明即可。参照图6，示出了本申请一实施例提供的一种基于多核处理器的并发事务处理系统；具体包括：获取模块610，用于当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；计算模块620，用于依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；分区模块630，用于依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；调度模块640，用于依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；处理模块650，用于当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。在本发明一实施例中，所述执行代价为对应的处理器执行所述事务的时间；所述调度模块640，包括：启动时间确定子模块，用于依据所述读写集合确定所述事务的启动时间；时间片确定子模块，用于依据所述启动时间和所述执行代价确定所述事务的执行时间片；第一判断子模块，用于依据所述冲突关系确定目标分区中目标事务的执行时间片与其他分区中事务的执行时间片是否有重叠，若是，则所述目标事务在所述冲突队列中，若否，则所述目标事务在所述无冲突队列中。在本发明一实施例中，所述处理模块650，包括：排序子模块，用于依据所述执行时间片确定所述事务在所述冲突队列中的排序；延迟处理子模块，用于当所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片重叠时，则所述冲突队列中的事务延迟处理。在本发明一实施例中，所述排序子模块，包括：错峰排序单元，用于依据所述冲突关系将所述冲突队列中事务的执行时间片与其他分区中事务的执行时间片错峰排序。在本发明一实施例中，所述分区模块630，包括：访问类型确定子模块，用于依据所述读写集合确定所述事务访问的数据类型；分区确定子模块，用于依据所述数据类型和所述冲突关系确定所述事务的分区。在本发明一实施例中，还包括：保护模块660，用于当所述冲突队列中事务的实际执行时间与对应的所述执行代价不相等时，则对所述事务进行加锁访问。参照图7，在本发明一实施例中，所述并发事务处理系统，还包括：即时事务调度模块710，用于当有新事务加入处理时，依据所述新事务的读写集合确定所述新事务对应的分区及队列类型；即时事务处理模块720，用于当所述新事务在对应的队列中与其他分区中的事务存在冲突时，则所述新事务延迟处理。参照图8，示出了本发明的一种基于多核处理器的并发事务处理方法的计算机设备，具体可以包括如下：上述计算机设备12以通用计算设备的形式表现，计算机设备12的组件可以包括但不限于：一个或者多个处理器或者处理单元16，系统存储器28，连接不同系统组件的总线18。总线18表示几类总线18结构中的一种或多种，包括存储器总线18或者存储器控制器，外围总线18，图形加速端口，处理器或者使用多种总线18结构中的任意总线18结构的局域总线18。举例来说，这些体系结构包括但不限于工业标准体系结构总线18，微通道体系结构总线18，增强型ISA总线18、音视频电子标准协会局域总线18以及外围组件互连总线18。计算机设备12典型地包括多种计算机系统可读介质。这些介质可以是任何能够被计算机设备12访问的可用介质，包括易失性和非易失性介质，可移动的和不可移动的介质。系统存储器28可以包括易失性存储器形式的计算机系统可读介质，例如随机存取存储器30和/或高速缓存存储器32。计算机设备12可以进一步包括其他移动/不可移动的、易失性/非易失性计算机体统存储介质。仅作为举例，存储系统34可以用于读写不可移动的、非易失性磁介质。尽管图8中未示出，可以提供用于对可移动非易失性磁盘读写的磁盘驱动器，以及对可移动非易失性光盘读写的光盘驱动器。在这些情况下，每个驱动器可以通过一个或者多个数据介质界面与总线18相连。存储器可以包括至少一个程序产品，该程序产品具有一组程序模块42，这些程序模块42被配置以执行本发明各实施例的功能。具有一组程序模块42的程序/实用工具40，可以存储在例如存储器中，这样的程序模块42包括——但不限于——操作系统、一个或者多个应用程序、其他程序模块42以及程序数据，这些示例中的每一个或某种组合中可能包括网络环境的实现。程序模块42通常执行本发明所描述的实施例中的功能和/或方法。计算机设备12也可以与一个或多个外部设备14通信，还可与一个或者多个使得操作人员能与该计算机设备12交互的设备通信，和/或与使得该计算机设备12能与一个或多个其他计算设备进行通信的任何设备通信。这种通信可以通过输入/输出界面22进行。并且，计算机设备12还可以通过网络适配器20与一个或者多个网络)，广域网和/或公共网络通信。如图所示，网络适配器20通过总线18与计算机设备12的其他模块通信。应当明白，尽管图8中未示出，可以结合计算机设备12使用其他硬件和/或软件模块，包括但不限于：微代码、设备驱动器、冗余处理单元16、外部磁盘驱动阵列、RAID系统、磁带驱动器以及数据备份存储系统34等。处理单元16通过运行存储在系统存储器28中的程序，从而执行各种功能应用以及数据处理，例如实现本发明实施例所提供的一种基于多核处理器的并发事务处理方法。也即，上述处理单元16执行上述程序时实现：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。在本发明实施例中，本发明还提供一种计算机可读存储介质，其上存储有计算机程序，该程序被处理器执行时实现如本申请所有实施例提供的一种基于多核处理器的并发事务处理方法：也即，给程序被处理器执行时实现：当目标时间段内出现事务并发时，则获取在所述目标时间段内出现的事务的读写集合；依据所述读写集合确定所述事务之间的冲突关系以及对应于所述事务的执行代价；依据所述冲突关系确定所述事务对应的分区；其中，访问相同数据的所述事务对应的分区相同；依据所述冲突关系和所述执行代价确定所述事务在所述分区的队列类型；其中，所述队列类型包括无冲突队列和冲突队列；当所述冲突队列中的事务与其他分区中的事务存在冲突时，则所述冲突队列中的事务延迟处理。可以采用一个或多个计算机可读的介质的任意组合。计算机可读介质可以是计算机可读信号介质或者计算机可读存储介质。计算机可读存储介质例如可以是——但不限于——电、磁、光、电磁、红外线或半导体的系统、装置或器件，或者任意以上的组合。计算机可读存储介质的更具体的例子包括：具有一个或多个导线的电连接、便携式计算机磁盘、硬盘、随机存取存储器、只读存储器、可擦可编程只读存储器、光纤、便携式紧凑磁盘只读存储器、光存储器件、磁存储器件或者上述的任意合适的组合。在本文件中，计算机可读存储介质可以是任何包含或存储程序的有形介质，该程序可以被指令执行系统、装置或者器件使用或者与其结合使用。计算机可读的信号介质可以包括在基带中或者作为载波一部分传播的数据信号，其中承载了计算机可读的程序代码。这种传播的数据信号可以采用多种形式，包括——但不限于——电磁信号、光信号或上述的任意合适的组合。计算机可读的信号介质还可以是计算机可读存储介质以外的任何计算机可读介质，该计算机可读介质可以发送、传播或者传输用于由指令执行系统、装置或者器件使用或者与其结合使用的程序。可以以一种或多种程序设计语言或其组合来编写用于执行本发明操作的计算机程序代码，上述程序设计语言包括面向对象的程序设计语言——诸如Java、Smalltalk、C++，还包括常规的过程式程序设计语言——诸如“C”语言或类似的程序设计语言。程序代码可以完全地在操作人员计算机上执行、部分地在操作人员计算机上执行、作为一个独立的软件包执行、部分在操作人员计算机上部分在远程计算机上执行或者完全在远程计算机或者服务器上执行。在涉及远程计算机的情形中，远程计算机可以通过任意种类的网络——包括局域网或广域网——连接到操作人员计算机，或者，可以连接到外部计算机。本说明书中的各个实施例均采用递进的方式描述，每个实施例重点说明的都是与其他实施例的不同之处，各个实施例之间相同相似的部分互相参见即可。尽管已描述了本申请实施例的优选实施例，但本领域内的技术人员一旦得知了基本创造性概念，则可对这些实施例做出另外的变更和修改。所以，所附权利要求意欲解释为包括优选实施例以及落入本申请实施例范围的所有变更和修改。最后，还需要说明的是，在本文中，诸如第一和第二等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者终端设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者终端设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括所述要素的过程、方法、物品或者终端设备中还存在另外的相同要素。以上对本申请所提供的一种基于多核处理器的并发事务处理方法及其系统，进行了详细介绍，本文中应用了具体个例对本申请的原理及实施方式进行了阐述，以上实施例的说明只是用于帮助理解本申请的方法及其核心思想；同时，对于本领域的一般技术人员，依据本申请的思想，在具体实施方式及应用范围上均会有改变之处，综上所述，本说明书内容不应理解为对本申请的限制。

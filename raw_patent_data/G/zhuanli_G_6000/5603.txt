标题title
一种软件程序运行安全保护方法、系统以及存储介质
摘要abst
本申请涉及计算机数据安全领域，公开了一种软件程序运行安全保护方法、系统以及存储介质。所述方法包括：响应于已加密算法的调用请求，控制驱动程序生成第一挑战码和密钥ID，将算法ID、第一挑战码和密钥ID发送至SE芯片；SE芯片根据算法ID和密钥ID确定工作密钥；生成第二挑战码并根据两个挑战码和工作密钥生成MAC码；以及将第二挑战码、MAC码以及SE芯片的PUF值发送至智能终端；从驱动程序中确定根密钥密文和密钥加密密钥并确定根密钥；在已加密算法通过验证的情况下，根据根密钥对已加密算法执行解密操作，获得解密后的算法。公开了一种新的加密、认证手段，可保护算法的存储及运行的安全。
权利要求书clms
1.一种软件程序安全保护方法，其特征在于，应用于搭载SE芯片的智能终端，其中，在所述SE芯片中保存有所述智能终端的预设基础信息，以确保所述SE芯片和所述智能终端存在一一对应的绑定使用关系，所述方法包括：响应于已加密目标算法的调用请求，控制所述SE芯片的驱动程序确定第一挑战码和密钥ID，以及将所述已加密目标算法的算法ID、所述第一挑战码和所述密钥ID发送至所述SE芯片，以控制所述SE芯片生成第二挑战码和用于安全校验的待验证MAC码并将所述第二挑战码、所述待验证MAC码和所述SE芯片的PUF值反馈至所述智能终端以进行安全验证；其中，所述第一挑战码和所述第二挑战码均为随机数；根据预设密钥保存策略从所述驱动程序中确定根密钥密文和密钥加密密钥，并通过所述密钥加密密钥对所述根密钥密文进行解密操作以确定根密钥；根据所述根密钥、所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证；在所述已加密目标算法通过安全验证的情况下，根据所述根密钥对所述已加密目标算法执行解密操作，获得解密后的目标算法。2.根据权利要求1所述的软件程序安全保护方法，其特征在于，在所述响应于目标算法的调用请求之前，还包括：通过根密钥分别对不同的密钥ID以及目标算法的算法ID和SE芯片的PUF值执行加密操作，以确定所述目标算法的多个工作密钥；将所述多个工作密钥保存在SE芯片中，并通过所述根密钥对所述目标算法执行加密操作，获得已加密目标算法。3.根据权利要求1所述的软件程序安全保护方法，其特征在于，所述根密钥密文和所述密钥加密密钥均分散地存储在所述SE芯片的驱动程序中。4.根据权利要求1所述的软件程序安全保护方法，其特征在于，所述根据所述根密钥对所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证，包括：根据所述已加密目标算法的存储格式确定第一MAC码，在所述第一MAC码和所述待验证MAC码满足第一预设条件的情况下，判定所述已加密目标算法通过完整性验证；通过所述根密钥对所述PUF值、所述算法ID以及所述密钥ID执行加密操作生成工作密钥；并根据所述第一挑战码和所述第二挑战码以及所述工作密钥生成第二MAC码；在所述第二MAC码和所述待验证MAC码满足第二预设条件的情况下，判定所述已加密目标算法通过挑战-应答验证；在所述已加密目标算法通过完整性验证和挑战-应答验证的情况下，判定所述已加密目标算法通过安全验证。5.根据权利要求1所述的软件程序安全保护方法，其特征在于，所述已加密目标算法的存储格式，包括：在具备文件系统的情况下，以动态链接库的形式进行存储，并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；在不具备文件系统的情况下，在所述已加密目标算法前部保存所述已加密目标算法的长度值并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；或者，在所述已加密目标算法的前部保存所述已加密目标算法的长度值并将所述MAC码保存在所述已加密目标算法的后部，以及在每个已加密目标算法结尾处均设置一定长度的空白区域以使每个已加密目标算法均占用同等大小的存储空间。6.一种智能终端，其特征在于，包括存储器和处理器，所述存储器上存储有计算机程序，所述存储器和所述处理器之间互相通信连接，当所述计算机程序被所述处理器执行时，执行如权利要求1~5中任一项所述的软件程序安全保护方法。7.一种软件程序安全保护系统，其特征在于，所述软件程序安全保护系统包括如权利要求6所述的智能终端。8.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质存储的计算机程序，当被一个或多个处理器执行时，实现如权利要求1至5中任一项所述方法的步骤。
说明书desc
技术领域本申请涉及计算机数据安全技术领域，特别地涉及一种软件程序运行安全保护方法、系统以及存储介质。背景技术此处提供的背景技术描述的目的是总体地给出本申请的背景，本部分的陈述仅仅是提供了与本申请相关的背景，并不必然构成现有技术。在现实环境中，某些电子设备运行的算法和硬件设备是分别授权使用的。对于一些重要、核心的算法，其算法本身就具有极高的价值，需要进行单独的版权保护。如：生物特征识别领域：人脸识别算法、指纹识别算法、虹膜识别算法等；其他识别算法：语音识别、手写识别、车牌号码识别、交通违法行为检测等；博弈算法：围棋算法、中国象棋算法等；其他有价值的AI算法：无人驾驶算法、推荐算法等；特定领域的软件：财务类、建筑类、税务管理类等软件。由于这些算法包含了研发人员的心血，应该对其版权进行充分的保护。在现有技术中，因为目标算法通常是放在主机端、工控机等公共平台，以程序文件的形式存储在硬盘或Flash上，而且通常是使用明文的形式存储。这样一来，由于缺乏保护措施，目标算法的知识产权和安全性都难以得到保证。当前，一种被广泛使用的软件版权保护方法是软件加密狗方案。这是一种用于软件加密的小型外置硬件设备，但是在加密狗的实现方案中存在有以下缺陷：针对实现机制：普通加密狗只是做一些基于时间或挑战码的认证。高级的加密狗也只是将算法最核心的一小段内容加密，放到加密狗硬件设备中，在必要时，与运行的软件进行交互；受加密狗存储空间小和读写接口单一、读写速度慢等因素的限制，即使是高级的加密狗，也很难实现对整个软件算法进行加密保护；针对保护范围：加密狗只是为了完成对软件使用的授权，目的是使未经授权的软件，无法正常运行；而非对整个软件算法的加密保护，防止整个软件算法的泄露。因此，亟需一种新的加密、认证手段，以保护目标算法的存储及运行的安全。发明内容针对上述问题，本申请提出一种软件程序运行安全保护方法、系统以及存储介质。以至少解决如上所述的技术问题。本申请的第一个方面，提供了一种软件程序运行安全保护方法，应用于搭载SE芯片的智能终端，其中，在所述SE芯片中保存有所述智能终端的预设基础信息，以确保所述SE芯片和所述智能终端存在一一对应的绑定使用关系，所述方法包括：响应于已加密目标算法的调用请求，控制所述SE芯片的驱动程序确定第一挑战码和密钥ID，以及将所述已加密目标算法的算法ID、所述第一挑战码和所述密钥ID发送至所述SE芯片，以控制所述SE芯片生成第二挑战码和用于安全校验的待验证MAC码并将所述第二挑战码、所述待验证MAC码和所述SE芯片的PUF值反馈至所述智能终端以进行安全验证；其中，所述第一挑战码和所述第二挑战码均为随机数；根据预设密钥保存策略从所述驱动程序中确定根密钥密文和密钥加密密钥，并通过所述密钥加密密钥对所述根密钥密文进行解密操作以确定根密钥；根据所述根密钥、所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证；在所述已加密目标算法通过安全验证的情况下，根据所述根密钥对所述已加密目标算法执行解密操作，获得解密后的目标算法。进一步地，通过根密钥分别对不同的密钥ID以及目标算法的算法ID和SE芯片的PUF值执行加密操作，以确定所述目标算法的多个工作密钥；将所述多个工作密钥保存在SE芯片中，并通过所述根密钥对所述目标算法执行加密操作，获得已加密目标算法。进一步地，所述根密钥密文和所述密钥加密密钥均分散地存储在所述SE芯片的驱动程序中。进一步地，所述根据所述根密钥对所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证，包括：根据所述已加密目标算法的存储格式确定第一MAC码，在所述第一MAC码和所述待验证MAC码满足第一预设条件的情况下，判定所述已加密目标算法通过完整性验证；通过所述根密钥对所述PUF值、所述算法ID以及所述密钥ID执行加密操作生成工作密钥；并根据所述第一挑战码和所述第二挑战码以及所述工作密钥生成第二MAC码；在所述第二MAC码和所述待验证MAC码满足第二预设条件的情况下，判定所述已加密目标算法通过挑战-应答验证；在所述已加密目标算法通过完整性验证和挑战-应答验证的情况下，判定所述已加密目标算法通过安全验证。进一步地，所述已加密目标算法的存储格式，包括：在具备文件系统的情况下，以动态链接库的形式进行存储，并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；在不具备文件系统的情况下，在所述已加密目标算法前部保存所述已加密目标算法的长度值并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；或者，在所述已加密目标算法的前部保存所述已加密目标算法的长度值并将所述MAC码保存在所述已加密目标算法的后部，以及在每个已加密目标算法结尾处均设置一定长度的空白区域以使每个已加密目标算法均占用同等大小的存储空间。本申请的第二个方面，提供了一种智能终端，包括存储器和处理器，所述存储器上存储有计算机程序，所述存储器和所述处理器之间互相通信连接，当所述计算机程序被所述处理器执行时，执行如上所述的应用于搭载SE芯片的智能终端的软件程序运行安全保护方法。本申请的第三个方面，提供了一种软件程序运行安全保护系统，所述软件程序运行安全保护系统包括如上所述的智能终端。本申请的第四个方面，提供了一种计算机可读存储介质，该计算机可读存储介质存储的计算机程序，可被一个或多个处理器执行，用以实现如上所述的应用于搭载SE芯片的智能终端的软件程序运行安全保护方法或如上所述的应用于SE芯片的软件程序运行安全保护方法。与现有技术相比，本申请的技术方案具有以下优点或有益效果：目标算法以加密的形式存储在辅助硬盘或Flash上，只有运行时才进行解密；由于只有在运行的时候，才可能在内存里出现明文，因此，保证了目标算法不能被篡改或窃取；目标算法在运行时需要通过相关的认证才可以正常运行；保证了目标算法可以被正常使用，同时不会被恶意篡改；定义了目标算法在Flash上的存储结构；保证了目标算法加密方案，在没有文件管理系统的Flash上也可以使用；采用“挑战-应答式”的方式进行认证；以可靠、且易实现的方式，完成“零知识证明”；有多组密钥，可以随时选用其中的某一组进行验证；增加了安全性，可以一定程度上防止重放攻击。附图说明为了更清楚地说明本申请实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作简单的介绍，显而易见地，下面描述中的附图仅仅是本申请的实施例，对于所属领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据提供的附图获得其他的附图。另外还需要说明的是，为了便于描述，附图中仅示出了与有关本公开相关的部分。构成本申请的一部分的说明书附图用来提供对本申请的进一步理解，本申请中的示意性实施例及其说明用于解释本申请，并不构成对本申请的不当限定，在附图中：图1为本申请实施例提供的一种认证过程时序图；图2为本申请实施例提供的一种软件程序运行安全保护方法的流程图；图3为本申请实施例提供的一种SE芯片的工作密钥存储结构示意图；图4为本申请实施例提供的一种目标算法文件的存储结构示意图；图5为本申请实施例提供的一种目标算法文件在Flash中的存储结构示意图；图6为本申请实施例提供的另一种目标算法文件在Flash中的存储结构示意图；图7为本申请实施例提供的另一种软件程序运行安全保护方法的流程图；图8为本申请实施例提供的又一种软件程序运行安全保护方法的流程图。具体实施方式以下将结合附图及实施例来详细说明本申请的实施方式，借此对本申请如何应用技术手段来解决技术问题，并达到相应技术效果的实现过程能充分理解并据以实施。本申请实施例以及实施例中的各个特征，在不相冲突的前提下可以相互结合，所形成的技术方案均在本申请的保护范围之内。应当明确的是，以下所描述的实施例仅仅是本申请的一部分实施例，而不是全部的实施例。基于本申请中的实施例，所属领域技术人员在没有做出创造性劳动的前提下所获得的所有其他实施例，都属于本申请保护的范围内。以下，先对本申请实施例和/或现有技术中的部分技术用语进行解释说明，以便于所属领域技术人员理解本申请的技术方案：普通PC：PC电脑，也称个人计算机；其中，普通PC可包括：台式机，一体机，笔记本电脑。工控机：工控机是一种加固的增强型个人计算机，它可以作为一个工业控制器在工业环境中可靠运行。驱动程序：驱动程序的全称为“设备驱动程序”，是一种可以使计算机和设备通信的特殊程序；它创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线或其它沟通子系统与硬件形成连接的机制，这样的机制使得硬件设备上的数据交换成为可能。驱动程序相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作。SE芯片：安全元件芯片，通常以芯片形式提供。为防止外部恶意解析攻击，保护数据安全，在芯片中具有加密/解密逻辑电路，可以实现数据安全存储、加解密运算等功能。MAC码：消息认证码。在密码学中，通信实体双方使用的一种验证机制，保证消息数据完整性的一种工具。安全性依赖于Hash函数和密钥，故也称带密钥的Hash函数。消息认证码是基于密钥和消息摘要，所获得的一个值，可用于数据源的认证和完整性校验。PUF：物理不可克隆功能。物理不可克隆功能是一种硬件安全技术，它利用固有的设备变化来对给定的输入产生不可克隆的唯一设备响应。实施例一本实施例提供一种软件程序运行安全保护方法，可以应用于/应用在搭载SE芯片的智能终端中。在本申请中所述的智能终端包括搭载有智能OS的电子设备，比如：个人电脑、工控机以及智能移动终端等等。在本文后续部分中的主机或主机端也即所述智能终端。在本申请中所述的操作系统包括Windows、Linux等通用的操作系统，也可以是其他的实时操作系统，甚至还可以是Bootloader等芯片的启动管理系统。在本实施例中，在所述SE芯片中保存有所述智能终端的预设基础信息以确保所述SE芯片和所述智能终端存在一一对应的绑定使用关系。本方案通过引入SE芯片和一系列加密、认证手段，进而实现目标算法的存储、运行的安全性进行保护。主要表现在对以下方面攻击的预防：1、被动攻击：目标算法是很容易被攻击者窃取，进行分析和使用；本方案通过对存储在公共平台上的目标算法进行加密，来实现目标算法的保密性保护，即防止被动攻击；2、主动攻击：目标算法也容易被攻击者进行恶意篡改，导致运行异常；本方案通过引入MAC，来实现对目标算法的完整性保护，即防止主动攻击；3、密钥攻击：仅仅对目标算法文件加密还是不够的，还需要考虑加密密钥的保护；密钥是加密算法中的核心，它直接决定了加密算法的安全性和可靠性，针对密钥的攻击有很多方面，本方案主要考虑涉及以下攻击方式的防护：针对密钥的实现方式的攻击：本申请采用密钥协商的方式来生成密钥。相对于随机生成密钥、密码短语生成密钥、公钥密码体制中生成密钥，具有很高的安全性。主要是建立在身份认证的基础上来实现的；针对密钥的存储攻击：由于SE芯片本身有很多安全措施，可以防物理破解、侧信道攻击、计时攻击等。因此，本申请将密钥存储到硬件SE芯片上，相对于将密钥存储在操作系统上，具有更高的安全性。在本申请的技术方案中，SE芯片和存储目标算法的主机是一一对应且绑定使用的。客户购买了多少个SE芯片，也就只能在多少主机上使用被保护的算法。目标算法是加密的，相当于防止了对目标算法的非法剽窃。但是，还需要提供SE芯片和主机绑定，才能控制对SE芯片的非法复制。可提供2种保护措施：第一种保护措施是：从形态上看，SE芯片是板载的，其接口可以为SPI、I2C等接口。所谓板载，即集成，指整合于主板芯片中的功能或硬件板就是指的主板，主板上搭载的硬件，就是跟主板集成在一路的硬件板载是整合于主板芯片中的成果或硬件。由于板载芯片必须固定在主机主板上，难以热插拔，转移到另一台主机上使用代价较大。这在一定程度上对SE芯片和主机的绑定关系提供了保护。但是，这仍然无法从原理上提供SE芯片和主机的绑定关系。同样的SE芯片，放在哪个主机上，理论它都是可以一样工作的。因为，密钥都在驱动程序和SE芯片里。跟主机的其他部分，没有任何关系。所以，只需要重装驱动，就可以使用SE芯片了。第二种保护措施是：把主机的MAC地址、机器码、硬盘序列号或者其他的固定软、硬件特征，写到SE芯片里，并进行验证。可以理解的是，智能终端的预设基础信息包括：主机的MAC地址、机器码以及硬盘序列号等信息。具体的预设基础信息也可根据实际需求进行设定，此处不做特殊限定。SE芯片开始认证前，它会判断是否为第一次使用，在第一次使用前，主机信息存储为特殊值：比如为全0值。如果是第一次使用，SE芯片就会读取主机信息，将读取到的主机信息，并存储到SE芯片上；如果不是第一次使用，SE芯片的驱动程序，会先验证当前主机与存储的主机信息是否一致。如果不一致，则认证失败，算法无法正确工作；如果一致，则继续下面的认证。要在主机端的操作系统上，完成SE芯片的认证。首先，需要使用驱动程序的安装包，在主机端操作系统上，安装SE芯片的驱动程序。需要说明的是，常说的驱动程序分两种：驱动程序的安装包；在主机端安装后可运行的驱动程序。本文所述的驱动程序，非特殊说明，均指“在主机端安装后可运行的驱动程序”。在本实施例中，SE芯片的驱动程序，其主要作用包括以下几点：将加密后的根密钥、密钥加密密钥，分散存储在驱动程序中；存储和验证绑定的主机信息是否正确；完成认证功能；验证算法的完整性；解密算法；运行算法。可以理解的是，挑战应答方式是零知识证明的认证方式。在本实施例中使用基于挑战/应答方式，主要是为了完成对SE芯片的认证。身份认证系统就是每次认证时，操作系统都向SE芯片发送一个不同的“挑战”字串，SE芯片收到这个“挑战”字串后，做出相应的“应答”，以此机制而研制的系统。为了便于理解本申请中的认证可参考图1，图1为本申请实施例提供的一种认证过程时序图。作为一个示例，图2为本申请实施例提供的一种软件程序运行安全保护方法的流程图，如图2所示，本实施例所公开的方法包括以下步骤：步骤210、响应于已加密目标算法的调用请求，控制所述SE芯片的驱动程序确定第一挑战码和密钥ID，以及将所述已加密目标算法的算法ID、所述第一挑战码和所述密钥ID发送至所述SE芯片，以控制所述SE芯片生成第二挑战码和用于安全校验的待验证MAC码并将所述第二挑战码、所述待验证MAC码和所述SE芯片的PUF值反馈至所述智能终端以进行安全验证；其中，所述第一挑战码和所述第二挑战码均为随机数。在一些实施例中，在所述响应于目标算法的调用请求之前，还包括：通过根密钥分别对不同的密钥ID以及目标算法的算法ID和SE芯片的PUF值执行加密操作，以确定所述目标算法的多个工作密钥；将所述多个工作密钥保存在SE芯片中，并通过所述根密钥对所述目标算法执行加密操作，获得已加密目标算法。作为一个示例，在进行初始化生产时，因为在安全环境里，可以直接使用明文的根密钥进行操作。。可选的，针对SE芯片的工作密钥初始化可包括：SE芯片中，针对每个保护的目标算法，都有多组工作密钥；使用根密钥对SE芯片的PUF，算法ID以及密钥ID一起进行加密，得到一个保护目标算法的一组工作密钥；总计，SE芯片中有，N*M组工作密钥；算法ID和密钥ID都可以是从1开始计数，比如，可依次为和。举例说明，针对需要保护的目标算法，在确定其多个工作密钥时：首先，通过根密钥对密钥ID、目标算法的算法ID和SE芯片的PUF值执行加密操作，获得第一组工作密钥；然后，再通过根密钥对密钥ID、目标算法的算法ID和SE芯片的PUF值执行加密操作，获得另一组工作密钥；依次类推，进而便可以确定该目标算法的多组工作密钥。可选的，针对主机端驱动程序的初始化可包括：出厂时，将密钥加密密钥以明文形式分散成K份，存储在驱动程序的安装程序中；出厂时，使用KEK对根密钥进行加密，并分散成K份，存储到驱动程序的安装程序中；使用驱动程序安装程序，安装SE芯片驱动，将KEK分散存储到驱动程序中；将加密后的根密钥也分散存储到驱动程序中。在一些实施例中，在所述响应于目标算法的调用请求之前，还包括：响应于已加密目标算法的调用请求，将所述智能终端的预设基础信息发送至所述SE芯片，以使所述SE芯片对所述预设基础信息进行验证。进一步地，在所述预设基础信息通过验证之后，控制所述SE芯片生成第二挑战码和用于安全校验的待验证MAC码并将所述第二挑战码、所述待验证MAC码和所述SE芯片的PUF值反馈至所述智能终端以进行安全验证。作为一个示例，第一挑战码为一随机数，密钥ID可为1~16中的某一个数。步骤220、根据预设密钥保存策略从所述驱动程序中确定根密钥密文和密钥加密密钥，并通过所述密钥加密密钥对所述根密钥密文进行解密操作以确定根密钥。在一些实施例中，所述根密钥密文和所述密钥加密密钥均分散地存储在所述SE芯片的驱动程序中。作为一个示例，在主机端必须有KEK和使用KEK加密后的根密钥，在主机端均是以多处分散的方式进行存储的。结合密钥的预设密钥保存策略将密钥保存在SE芯片的驱动程序中，比如：一个密钥Key= Key1+Key2+...+Keyn组成。本方案将KEK和根密钥密文分别分成n个分量，然后再根据预设密钥保存策略分别保存在驱动程序中的不同的n个位置。在使用时，先读取再合并即可获得相应的密钥，这样能够进一步增加密钥的安全性。需要说明的是，如何分散地存储可根据实际需求进行设定，预设密钥保存策略可根据实际需求进行设定。在一些实施例中，所述已加密目标算法的存储格式，包括：在具备文件系统的情况下，以动态链接库的形式进行存储，并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；在不具备文件系统的情况下，在所述已加密目标算法前部保存所述已加密目标算法的长度值并将所述已加密目标算法的MAC码保存在所述已加密目标算法的后部；或者，在所述已加密目标算法的前部保存所述已加密目标算法的长度值并将所述MAC码保存在所述已加密目标算法的后部，以及在每个已加密目标算法结尾处均设置一定长度的空白区域以使每个已加密目标算法均占用同等大小的存储空间。作为一个示例，在主机端可包括三种类型的密钥：根密钥：在SE芯片的驱动程序中，分散存储。使用下面的KEK密钥，加密存储。安装SE驱动程序时，使用KEK加密后，写入驱动程序。用于生成主机端的工作密钥。所有的驱动程序都使用同一个根密钥；密钥加密密钥：在SE芯片的驱动程序中，分散存储，直接存储，未加密；安装SE驱动程序时，写入驱动程序，用于保护根密钥；工作密钥：是一种临时产生和使用的密钥；认证过程中，由根密钥对SE芯片的PUF值，算法ID以及密钥ID一起进行加密生成。作为一个示例，在SE芯片端只有一种密钥：工作密钥： SE芯片端虽然只有一种密钥，但该密钥的个数有多组。在安全生产环境，对SE芯片进行出厂初始化设置时，将N个算法的M组密钥，分别写入其中。因为SE芯片本身就是从硬件上实现了一系列的保密措施，攻击者无法通过正常手段读出密钥相关信息。因此，这里“在SE芯片中保存工作密钥”是安全的。由于，本方案采用了多组密钥，这样对于同一系列的多组对，其密钥空间，由原来的2^n种，变成2^。从而，进一步增加了穷举攻击的难度。另外，在实际场景中除了有技术破解，还会存在社会环境破解。多组密钥方案还可以对多种多样的社会环境攻击起到一定防范作用。例如，实际工作中由于单个密钥有泄露的风险；而在具备多组密钥的请款修改，如果一组密钥被泄露，还有其他的密钥可以使用，以延期到将所有密钥以及加密系统更换为止。工作密钥的存储结构可参考图3，图3为本申请实施例提供的一种SE芯片的工作密钥存储结构示意图。作为一个示例，从驱动程序中，读取密钥加密密钥KEK和根密钥的密文。通过使用KEK对根密钥解密，得到根密钥；使用根密钥，对SE芯片的PUF值、算法ID以及密钥ID进行加密，即可得到对应的工作密钥。步骤230、根据所述根密钥、所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证。在一些实施例中，所述根据所述根密钥对所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证，包括：根据所述已加密目标算法的存储格式确定第一MAC码，在所述第一MAC码和所述待验证MAC码满足第一预设条件的情况下，判定所述已加密目标算法通过完整性验证；通过所述根密钥对所述PUF值、所述算法ID以及所述密钥ID执行加密操作生成工作密钥；并根据所述第一挑战码和所述第二挑战码以及所述工作密钥生成第二MAC码；在所述第二MAC码和所述待验证MAC码满足第二预设条件的情况下，判定所述已加密目标算法通过挑战-应答验证；在所述已加密目标算法通过完整性验证和挑战-应答验证的情况下，判定所述已加密目标算法通过安全验证。需要说明的是，第一预设条件和第二预设条件可根据实际需求进行设定；比如，第一预设条件可设置为第一MAC码和待验证MAC码一致，第二预设条件可设置为第二MAC码和待验证MAC码一致。作为一个示例，在进行挑战-应答认证时：初始状态下，目标算法以密文的形式存储在硬盘或Flash上。个人电脑/工控机上安装有操作系统，操作系统可以启动某应用程序，该应用程序会调用硬盘和Flash上存储的目标算法。具体工作步骤，可包括如下步骤：个人电脑/工控机上电启动；加载操作系统，完成系统启动；操作系统在接收到指令，用于启动某个应用程序之前，需要和SE芯片做一个认证；如果认证失败，操作系统就会控制应用程序不启动。认证失败的原因可包括以下几种类别：硬件异常：发现缺少相关硬件模块；软件异常：SE芯片认证结果异常，；完整性验证失败：目标算法的内容被修改，具体实现可以通过验证MAC码值来实现；其他原因的认证结果失败；如果认证成功，由于认证的过程也同时是一个协商的过程，认证完成，协商也会完成。协商完成后，使用协商出来的密钥，将存储在硬盘或Flash上的目标算法解密。作为一个示例，在进行完整性认证时：认证通过后，将目标算法程序从硬盘、Flash或其他的存储器上，载入到RAM内存。主要利用如下数据结构，验证MAC来实现目标算法的完整性保护。在这一步中，需要做好以下准备：一种HASH算法：通用的满足安全级别的HASH算法均可，如国际算法SHA-1、SHA-256、国密算法SM3等HASH算法；一个MAC密钥K：密钥K的长度大于上述HASH函数的输出；存储格式：这里分为有文件系统的外部硬盘和没有文件系统的Flash存储芯片两种情况讨论。对于有文件系统的外部硬盘和有操作系统的软件环境，可以将目标算法存储成文件形式。如下图所示。为了方便与操作系统无缝接入，一种可供参考的实现是，将目标算法可以存储成加密后的动态链接库的形式。如，Linux下，存储成*.so库；Windows下，存储成*.dll库。这样，当应用程序需要调用相关库函数时，就会触发操作系统，调用SE芯片的驱动程序，将对加密后的目标算法文件进行验证合法性，并将其进行解密，生成应用程序需要的，*.so或*.dll文件，完成调用；具体的存储结构可参考图4，图4为本申请实施例提供的一种目标算法文件的存储结构示意图。对于没有文件系统的Flash中，可以定义更加严格的存储结构，具体可参考图5和图6。其中，图5为本申请实施例提供的一种目标算法文件在Flash中的存储结构示意图，图6为本申请实施例提供的另一种目标算法文件在Flash中的存储结构示意图。其中，如图5所示的存储结构的存储效率较高，适用于存储空间宝贵、且算法升级不频繁的应用场景。在图6中：通过在每个算法结尾加一个不定长的空白区域，以确保每个目标算法所占用的存储空间大小是一样的；图6所述的存储结构具备有以下优势：读取效率高：因为可以直接根据算法ID定义，定位到其存储的起始位置直接进行读取，从而可以得到更高的读取效率；容错性好：由于读取某个算法，只需要通过算法ID就可以映射到该算法地址。因此，各个算法存储并不相互影响，所以容错性较好。当某个“算法长度”字段发生错误，并不会影响到后续算法的读取。在以上这两种存储结构中，都引入了“算法ID”字段，均可以用于存储数据对检查。在这两种方案中，每次读取到一个算法，可以采用预期的“算法ID”和读取到的“算法ID”字段进行比较。如果比较一致，可以继续读取使用；如果比较不一致，说明该算法的存储结构被破坏，需要修复，不可以继续读取使用。这样就可以增加对Flash存储结构的出错检测能力。可选的，目标算法的“算法ID”是一个从1开始顺序递增的数字序列。目标算法在Flash中的存储也可以是按照“算法ID”的顺序进行依次存储。需要说明的是，在实际使用的过程中，可以结合要保护的目标算法的特点以及实际需求来决定采取哪种具体的存储结构，具体此处不做特殊限定。进一步需要说明的是，如果在认证过程中出现异常情况，将会导致认证失败。在出现异常情况下，主机端的操作系统会控制要启动的目标算法程序直接退出，不会执行目标算法。作为一个示例，在具体实现时，主机端的程序还可以根据实际需求设置相应的应答条件，比如：SE芯片的响应最大时长：如果SE芯片的响应时间超过MRT，则判定为SE芯片响应超时，认证过程失败；SE芯片的允许应答错误的最大次数：如果SE芯片连续MNoARE次失败，则判定为认证失败。步骤240、在所述已加密目标算法通过安全验证的情况下，根据所述根密钥对所述已加密目标算法执行解密操作，获得解密后的目标算法。作为一个示例，在完成整体的安全性验证后，需要对目标算法进行解密操作。这一步由于数据量较大，一般使用对称加密算法。原因是同等安全性前提下，这类算法快速且简单。在这一步中需要：一种对称加密算法：如国际算法DES，3DES，AES，RC2，RC4， RC5，国密算法SM4等；一个加密算法密钥：根据加密算法和对安全性的要求不同，可以采用不同长度的密钥。进一步地，解密完成后即可在主机端或工控机上运该目标算法。更进一步地，当目标算法后续需要进行更新或升级时，我们可通过以下步骤来进行操作：将新的目标算法加密生成新的加密算法程序；将需要更新的密钥值写入驱动程序，生成新的驱动程序；将新的加密算法程序、新的驱动程序打包，下发给主机端；将新的算法加密程序和新的驱动程序打包，在主机端一并解压修改，以完成更新。在本申请的技术方案中，实现了对算法的存储以及运行安全的保护，具体的：针对算法的存储保护：通过上述的加密措施，保证算法程序仅以密文的形式存储在公共区域，从而实现了对算法程序的静态存储保护；针对算法的运行安全保护：通过对SE芯片认证，实现了只有在认证通过后的安全环境中的合法人员才能成功解密目标算法并合法的运行算法程序，从而实现了对目标算法的动态运行保护。实施例二本实施例提供一种软件程序运行安全保护方法，可以应用于/应用在SE芯片中。图7为本申请实施例提供的另一种软件程序运行安全保护方法的流程图，如图7所示，本实施例所公开的方法包括以下步骤：步骤710、响应于接收到智能终端发送的算法ID、第一挑战码和密钥ID，根据所述算法ID和所述密钥ID确定工作密钥；步骤720、生成第二挑战码，并根据所述第一挑战码和所述第二挑战码以及所述工作密钥生成待验证MAC码；步骤730、将所述第二挑战码、所述待验证MAC码以及所述SE芯片的PUF值发送至所述智能终端，以使所述智能终端进行安全验证。作为一个示例，第二挑战码为一随机数；SE芯片通过以下方式来确定MAC码的值：主机和SE芯片，事先约定的哈希算法；由于本方案可以同时保护多种目标算法，而且对于同一目标算法SE芯片会存储多组密钥。所以，必须使用主机发送过来的这两组信息，才能确认SE芯片中存储的哪组工作密钥，作为计算MAC码值的密钥。有了上述这些信息SE芯片就可以计算出第一挑战码和第二挑战码连接在一起的MAC码值。然后，再按照芯片提供的接口，读取SE芯片的PUF值；并将第二挑战码，MAC码，SE芯片的PUF值这些信息发送给主机端。实施例三本实施例提供一种软件程序运行安全保护方法，可以应用于/应用在搭载SE芯片的智能终端和SE芯片中。图8为本申请实施例提供的又一种软件程序运行安全保护方法的流程图，如图8所示，本实施例所公开的方法包括以下步骤：步骤810、响应于已加密目标算法的调用请求，通过智能终端控制SE芯片的驱动程序生成第一挑战码和密钥ID，以及将所述已加密目标算法的算法ID、所述第一挑战码和所述密钥ID发送至所述SE芯片；步骤820、所述SE芯片响应于接收到所述智能终端发送的算法ID、第一挑战码和密钥ID，根据所述算法ID和所述密钥ID确定工作密钥；生成第二挑战码，并根据所述第一挑战码和所述第二挑战码以及所述工作密钥生成待验证MAC码；以及将所述第二挑战码、所述待验证MAC码以及所述SE芯片的PUF值发送至所述智能终端以进行安全验证；步骤830、根据预设密钥保存策略通过所述智能终端从所述驱动程序中确定根密钥密文和密钥加密密钥，并通过所述密钥加密密钥对所述根密钥密文进行解密操作以确定根密钥；步骤840、根据所述根密钥、所述PUF值、所述算法ID、所述密钥ID以及所述待验证MAC码，判定所述已加密目标算法是否通过安全验证；步骤850、在所述已加密目标算法通过验证的情况下，根据所述根密钥通过所述智能终端对所述已加密目标算法执行解密操作，获得解密后的目标算法。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，本实施例在此不再进行重复赘述。对于本实施例中未提到的部分可参考前述的实施例一和实施例二。实施例四本实施例提供一种智能终端。该智能终端包括存储器和处理器，所述存储器上存储有计算机程序，所述存储器和所述处理器之间互相通信连接，当所述计算机程序被所述处理器执行时，执行如施例一中所述的软件程序运行安全保护方法。本智能终端实施例可以用于执行本申请实施例一种方法的全部或部分步骤，对于本智能终端实施例中未披露的细节，请参照本申请实施例一中的方法步骤。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，本实施例在此不再进行重复赘述。实施例五本实施例提供一种SE芯片。该SE芯片包括存储器和处理器，所述存储器上存储有计算机程序，所述存储器和所述处理器之间互相通信连接，当所述计算机程序被所述处理器执行时，执行如施例二中所述的软件程序运行安全保护方法。本智能终端实施例可以用于执行本申请实施例二中方法的全部或部分步骤，对于本智能终端实施例中未披露的细节，请参照本申请实施例二中的方法步骤。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，本实施例在此不再进行重复赘述。实施例六本实施例提供一种软件程序运行安全保护系统，该软件程序运行安全保护系统包括如实施例四所述的智能终端和如实施例五所述的SE芯片。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，所述智能终端和所述SE芯片的具体工作过程，可以参考前述对应方法实施例中的对应过程，本实施例在此不再进行重复赘述。实施例七本实施例提供一种计算机可读存储介质。该计算机可读存储介质中存储有计算机程序，该计算机程序被处理器执行时可以实现如前述方法实施例中的方法步骤，本实施例在此不再重复赘述。其中，计算机可读存储介质还可单独包括计算机程序、数据文件、数据结构等，或者包括其组合。计算机可读存储介质或计算机程序可被计算机软件领域的技术人员具体设计和理解，或计算机可读存储介质对计算机软件领域的技术人员而言可以是公知和可用的。计算机可读存储介质的示例包括：磁性介质，例如硬盘、软盘和磁带；光学介质，例如，CDROM盘和DVD；磁光介质，例如，光盘；和硬件装置，具体被配置以存储和执行计算机程序，例如，只读存储器、随机存取存储器、闪存；或服务器、app应用商城等。计算机程序的示例包括机器代码和包含高级代码的文件，可由计算机通过使用解释器来执行高级代码。所描述的硬件装置可被配置为用作一个或多个软件模块，以执行以上描述的操作和方法，反之亦然。另外，计算机可读存储介质可分布在联网的计算机系统中，可以分散的方式存储和执行程序代码或计算机程序。实施例八本实施例提供一种计算机程序产品。该计算机程序产品包括计算机程序或指令，该计算机程序或指令被处理器执行时实现如前述方法实施例中方法的全部或部分步骤，本实施例在此不再重复赘述。进一步地，该计算机程序产品可以包括在运行程序时被配置为执行实施例的一个或多个计算机可执行组件；该计算机程序产品还可包括有形地包含在及其可读介质上的计算机程序，所述计算机程序包含用于执行本公开实施方式中任一方法的程序代码。在这样的实施方式中，该计算机程序可以通过通信部分从网络上被下载和安装，和/或从可拆卸介质被安装。综上，本申请提供了一种软件程序安全保护方法、系统以及计算机可读存储介质。公开了一种新的加密、认证手段，以保护目标算法的存储及运行的安全，具体的：目标算法以加密的形式存储在辅助硬盘或Flash上，只有运行时才进行解密；由于只有在运行的时候，才可能在内存里出现明文，因此，保证了目标算法不能被篡改或窃取；目标算法在运行时需要通过相关的认证才可以正常运行；保证了目标算法可以被正常使用，同时不会被恶意篡改；定义了目标算法在Flash上的存储结构；保证了目标算法加密方案，在没有文件管理系统的Flash上也可以使用；采用“挑战-应答式”的方式进行认证；以可靠、且易实现的方式，完成“零知识证明”；有多组密钥，可以随时选用其中的某一组进行验证；增加了安全性，可以一定程度上防止重放攻击。另外应该理解到，在本申请所提供的实施例中所揭露的方法或系统，也可以通过其他的方式实现。以上所描述的方法或系统实施例仅仅是示意性的，例如，附图中的流程图和框图显示了根据本申请的多个实施例的方法和系统的可能实现的体系架构、功能和操作。在这点上，流程图或框图中的每个方框可以代表一个模块、计算机程序段或计算机程序的一部分，模块、计算机程序段或计算机程序的一部分包含一个或多个用于实现规定的逻辑功能的计算机程序。也应当注意，在有些作为替换的实现方式中，方框中所标注的功能也可以以不同于附图中所标注的顺序发生，实际上也可以基本并行地执行，它们有时也可以按相反的顺序执行，这依所涉及的功能而定。也要注意的是，框图和/或流程图中的每个方框、以及框图和/或流程图中的方框的组合，可以用执行规定的功能或动作的专用的基于硬件的系统来实现，或者可以用专用硬件与计算机程序的组合来实现。在本申请中，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括要素的过程、方法、装置或者设备中还存在另外的相同要素；如果有描述到“第一”、“第二”等仅用于描述目的，而不能理解为指示或暗示相对重要性或者隐含指明所指示的技术特征的数量或者隐含指明所指示的技术特征的先后关系；在本申请的描述中，除非另有说明，术语“多个”、“多”的含义是指至少两个；如果有描述到服务器，需要说明的是，服务器可以是独立的物理服务器或终端，也可以是多个物理服务器构成的服务器集群，可以是能够提供云服务器、云数据库、云存储和CDN等基础云计算服务的云服务器；在本申请中如果有描述到智能终端或移动设备，需要说明的是，智能终端或移动设备可以是手机、平板电脑、智能手表、上网本、可穿戴电子设备、个人数字助理、增强现实技术设备、虚拟现实设备、智能电视、智能音响、个人计算机等，但并不局限于此，本申请对智能终端或移动设备的具体形式不做特殊限定。最后需要说明的是，在本说明书的描述中，参考术语“一个实施例”、“一些实施例”、“示例”、“一个示例”或“一些示例”等的描述意指结合该实施例或示例描述的具体特征、结构、材料或者特点包含于本申请的至少一个实施例或示例中。在本说明书中，对上述术语的示意性表述不一定指的是相同的实施例或示例。而且，描述的具体特征、结构、材料或者特点可以在任何的一个或多个实施例或示例中以合适的方式进行结合。尽管上面已经示出和描述了本申请的实施例，可以理解的是，上述实施例都是示例性的，所述的内容只是为了便于理解本申请而采用的实施方式，并非用以限定本申请。任何本申请所属技术领域内的技术人员，在不脱离本申请所公开的精神和范围的前提下，可以在实施的形式上及细节上作任何的修改与变化，但本申请的保护范围，仍须以所附的权利要求书所界定的范围为准。

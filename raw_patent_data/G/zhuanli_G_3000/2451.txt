标题title
一种数据处理方法、装置、设备以及可读存储介质
摘要abst
本申请公开了一种数据处理方法、装置、设备以及可读存储介质，方法包括：在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求；对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态；在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常，对内核进行卸载处理。采用本申请，可以针对性地识别存在异常的内核，提升异常内核的异常处理及时性。
权利要求书clms
1.一种数据处理方法，其特征在于，包括：在到达目标内核检测时刻时，读取关于内核的请求记录文件；所述请求记录文件记录有通过所述内核访问分布式存储系统中块存储组件的访问请求；对所述请求记录文件中的访问请求进行请求检测处理，确定所述请求记录文件中访问请求的请求等待状态；在所述请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定所述内核存在异常，对所述内核进行卸载处理。2.根据权利要求1所述的方法，其特征在于，所述对所述请求记录文件中的访问请求进行请求检测处理，确定所述请求记录文件中访问请求的请求等待状态，包括：获取所述请求记录文件中具有最小发送时间戳的访问请求，将所述请求记录文件中具有最小发送时间戳的访问请求，确定为所述目标内核检测时刻对应的目标最早访问请求；将所述目标内核检测时刻的上一个内核检测时刻，确定为所述目标内核检测时刻的历史内核检测时刻；获取所述历史内核检测时刻对应的历史最早访问请求，根据所述目标内核检测时刻对应的目标最早访问请求以及所述历史内核检测时刻对应的历史最早访问请求，确定所述请求记录文件中访问请求的请求等待状态。3.根据权利要求2所述的方法，其特征在于，所述根据所述目标内核检测时刻对应的目标最早访问请求以及所述历史内核检测时刻对应的历史最早访问请求，确定所述请求记录文件中访问请求的请求等待状态，包括：将所述目标最早访问请求与所述历史最早访问请求进行比较；若确定所述目标最早访问请求与所述历史最早访问请求相同，则基于所述目标内核检测时刻与所述历史内核检测时刻之间的时间段，确定所述请求记录文件中访问请求的请求等待状态；若确定所述目标最早访问请求与所述历史最早访问请求不同，则确定所述请求记录文件中访问请求的请求等待状态为合理等待状态。4.根据权利要求3所述的方法，其特征在于，所述基于所述目标内核检测时刻与所述历史内核检测时刻之间的时间段，确定所述请求记录文件中访问请求的请求等待状态，包括：确定所述目标内核检测时刻与所述历史内核检测时刻之间的时间段；将所述目标内核检测时刻与所述历史内核检测时刻之间的时间段，确定为所述内核在所述目标内核检测时刻时的增量阻塞时长；获取所述内核在所述历史内核检测时刻时的历史请求阻塞时长，将所述增量阻塞时长与所述历史请求阻塞时长进行相加运算处理，得到所述内核在所述目标内核检测时刻时的目标请求阻塞时长；在所述目标请求阻塞时长大于时长阈值时，确定所述请求记录文件中访问请求的请求等待状态为持续异常等待状态。5.根据权利要求1所述的方法，其特征在于，所述对所述内核进行卸载处理，包括：获取所述内核所对应的内核版本；按照所述内核版本所属的版本区间，确定所述内核的内核卸载规则；按照所述内核卸载规则对所述内核进行卸载处理。6.根据权利要求5所述的方法，其特征在于，所述按照所述内核版本所属的版本区间，确定所述内核的内核卸载规则，包括：在所述内核版本所属的版本区间为第一区间时，将配置卸载规则集合中的低版本卸载规则确定为所述内核的内核卸载规则；在所述内核版本所属的版本区间为第二区间时，将所述配置卸载规则集合中的高版本卸载规则确定为所述内核的内核卸载规则；所述第一区间低于所述第二区间。7.根据权利要求5所述的方法，其特征在于，所述内核卸载规则为低版本卸载规则；所述请求记录文件中包含访问请求Si，i为正整数；所述按照所述内核卸载规则对所述内核进行卸载处理，包括：按照所述低版本卸载规则将所述访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求成功状态；当确定所述请求记录文件中，每个访问请求的请求状态均为请求成功状态时，将所述请求记录文件中包含的访问请求进行清空处理；在确定所述请求记录文件中未包含访问请求时，通过内核卸载指令对所述内核进行卸载处理。8.根据权利要求7所述的方法，其特征在于，所述按照所述低版本卸载规则将所述访问请求Si进行请求设置处理，包括按照所述低版本卸载规则，获取所述访问请求Si的请求标识；获取所述低版本卸载规则对应的第一请求终止逻辑代码，根据所述第一请求终止逻辑代码与所述访问请求Si的请求标识，生成针对所述访问请求Si的第一请求终止命令；按照所述第一请求终止命令，将所述请求记录文件中的所述访问请求Si的请求执行状态设置为执行完成状态，将所述访问请求Si的完成码设置为第一完成码；所述第一完成码用于指示所述访问请求Si已正常执行完成。9.根据权利要求5所述的方法，其特征在于，所述内核卸载规则为高版本卸载规则；所述请求记录文件中包含访问请求Si，i为正整数；所述按照所述内核卸载规则对所述内核进行卸载处理，包括：按照所述高版本卸载规则将所述访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求失败状态；当确定所述请求记录文件中，每个访问请求的请求状态均为请求失败状态时，将所述请求记录文件中包含的访问请求进行清空处理；在确定所述请求记录文件中未包含访问请求时，通过内核卸载指令对所述内核进行卸载处理。10.根据权利要求9所述的方法，其特征在于，所述按照所述高版本卸载规则将所述访问请求Si进行请求设置处理，包括：按照所述高版本卸载规则，获取所述访问请求Si的请求标识；获取所述高版本卸载规则对应的第二请求终止逻辑代码，根据所述第二请求终止逻辑代码与所述访问请求Si的请求标识，生成针对所述访问请求Si的第二请求终止命令；按照所述第二请求终止命令，将所述请求记录文件中的所述访问请求Si的请求执行状态设置为执行失败状态，将所述访问请求Si的完成码设置为第二完成码；所述第二完成码用于指示所述访问请求Si未正常执行完成。11.根据权利要求1所述的方法，其特征在于，所述内核部署于应用服务器中；在确定所述内核存在异常之后，所述方法还包括：将所述应用服务器所部署的每个内核均确定为部署内核，得到部署内核集合；将所述部署内核集合中在所述目标内核检测时刻时存在异常的部署内核，确定为异常内核；基于所述部署内核集合中包含的异常内核的第一数量，确定所述分布式存储系统的系统运行属性；在所述分布式存储系统的系统运行属性为异常运行属性时，将针对所述分布式存储系统的故障警示信息推送至所述分布式存储系统的系统维护对象，以使所述系统维护对象基于所述故障警示信息对所述分布式存储系统进行系统维护处理。12.根据权利要求11所述的方法，其特征在于，所述基于所述部署内核集合中包含的异常内核的第一数量，确定所述分布式存储系统的系统运行属性，包括：统计所述部署内核集合中包含的异常内核的第一数量，以及所述部署内核集合中包含的部署内核的第二数量；确定所述第一数量与所述第二数量之间的数量比值；若所述数量比值大于比值阈值，则确定所述分布式存储系统的系统运行属性为异常运行属性；若所述数量比值小于所述比值阈值，则确定所述分布式存储系统的系统运行属性为正常运行属性。13.一种数据处理装置，其特征在于，包括：文件读取模块，用于在到达目标内核检测时刻时，读取关于内核的请求记录文件；所述请求记录文件记录有通过所述内核访问分布式存储系统中块存储组件的访问请求；请求检测模块，用于对所述请求记录文件中的访问请求进行请求检测处理，确定所述请求记录文件中访问请求的请求等待状态；异常确定模块，用于在所述请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定所述内核存在异常；内核卸载模块，用于对所述内核进行卸载处理。14.一种计算机设备，其特征在于，包括：处理器、存储器以及网络接口；所述处理器与所述存储器、所述网络接口相连，其中，所述网络接口用于提供网络通信功能，所述存储器用于存储计算机程序，所述处理器用于调用所述计算机程序，以使所述计算机设备执行权利要求1-12任一项所述的方法。15.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质中存储有计算机程序，所述计算机程序适于由处理器加载并执行权利要求1-12任一项所述的方法。
说明书desc
技术领域本申请涉及计算机技术领域，尤其涉及一种数据处理方法、装置、设备以及可读存储介质。背景技术Ceph是一种开源的分布式存储系统，能同时提供对象、文件以及块存储服务。Ceph具体可通过块存储组件提供分布式存储服务，其可以类似服务器上的一个物理硬盘。其中，RBD可以通过两种方式对外提供服务，一种是通过librbd提供用户态的访问，另一种则是通过内核组件提供内核态的访问。对于内核态访问而言，由于使用内核组件所以性能更好，所以对于一些性能要求比较高的业务应用会通过内核组件来对RBD进行内核态的访问。然而，通过内核组件来进行内核态访问的方式，在Ceph存储系统出现故障的时候，Ceph存储系统会无法及时处理相关的请求，导致内核组件发出的请求一直得不到响应，出现卡顿， 那么这些请求相关的应用进程会一直处于得不到响应的状态，从而使得大量的应用进程无法顺利进行、也无法终止，只能维持卡顿的状态。而为了解决内核卡顿、应用进程卡顿的情况，相关技术只能采用强制硬重启的方式来将业务应用所在的物理服务器进行强制重启，由此来终止掉物理服务器上运行的所有内核，从而将运行的所有应用进程进行终止。这种强制硬重启物理服务器的方式，虽然可以一劳永逸解决应用进程卡顿的问题，但是一般需要由人工操作，可能存在滞后性；同时，物理服务器上可能还存在有其他服务的应用进程，一刀切的硬重启方式会使得其他正常运行的应用进程得到终止。可见，当前亟需一种可以解决存在卡顿的应用进程且不影响其他正常运行的应用进程继续运行的方式。发明内容本申请实施例提供一种数据处理方法、装置、设备以及可读存储介质，可以针对性地识别存在异常的内核，提升异常内核的异常处理及时性。本申请实施例一方面提供了一种数据处理方法，包括：在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求；对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态；在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常，对内核进行卸载处理。本申请实施例一方面提供了一种数据处理装置，包括：文件读取模块，用于在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求；请求检测模块，用于对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态；异常确定模块，用于在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常；内核卸载模块，用于对内核进行卸载处理。在一个实施例中，请求检测模块对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：获取请求记录文件中具有最小发送时间戳的访问请求，将请求记录文件中具有最小发送时间戳的访问请求，确定为目标内核检测时刻对应的目标最早访问请求；将目标内核检测时刻的上一个内核检测时刻，确定为目标内核检测时刻的历史内核检测时刻；获取历史内核检测时刻对应的历史最早访问请求，根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，确定请求记录文件中访问请求的请求等待状态。在一个实施例中，请求检测模块根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：将目标最早访问请求与历史最早访问请求进行比较；若确定目标最早访问请求与历史最早访问请求相同，则基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态；若确定目标最早访问请求与历史最早访问请求不同，则确定请求记录文件中访问请求的请求等待状态为合理等待状态。在一个实施例中，请求检测模块基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：确定目标内核检测时刻与历史内核检测时刻之间的时间段；将目标内核检测时刻与历史内核检测时刻之间的时间段，确定为内核在目标内核检测时刻时的增量阻塞时长；获取内核在历史内核检测时刻时的历史请求阻塞时长，将增量阻塞时长与历史请求阻塞时长进行相加运算处理，得到内核在目标内核检测时刻时的目标请求阻塞时长；在目标请求阻塞时长大于时长阈值时，确定请求记录文件中访问请求的请求等待状态为持续异常等待状态。在一个实施例中，内核卸载模块对内核进行卸载处理的具体实现方式，包括：获取内核所对应的内核版本；按照内核版本所属的版本区间，确定内核的内核卸载规则；按照内核卸载规则对内核进行卸载处理。在一个实施例中，内核卸载模块按照内核版本所属的版本区间，确定内核的内核卸载规则的具体实现方式，包括：在内核版本所属的版本区间为第一区间时，将配置卸载规则集合中的低版本卸载规则确定为内核的内核卸载规则；在内核版本所属的版本区间为第二区间时，将配置卸载规则集合中的高版本卸载规则确定为内核的内核卸载规则；第一区间低于第二区间。在一个实施例中，内核卸载规则为低版本卸载规则；请求记录文件中包含访问请求Si，i为正整数；内核卸载模块按照内核卸载规则对内核进行卸载处理的具体实现方式，包括：按照低版本卸载规则将访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求成功状态；当确定请求记录文件中，每个访问请求的请求状态均为请求成功状态时，将请求记录文件中包含的访问请求进行清空处理；在确定请求记录文件中未包含访问请求时，通过内核卸载指令对内核进行卸载处理。在一个实施例中，内核卸载模块按照低版本卸载规则将访问请求Si进行请求设置处理的具体实现方式，包括：按照低版本卸载规则，获取访问请求Si的请求标识；获取低版本卸载规则对应的第一请求终止逻辑代码，根据第一请求终止逻辑代码与访问请求Si的请求标识，生成针对访问请求Si的第一请求终止命令；按照第一请求终止命令，将请求记录文件中的访问请求Si的请求执行状态设置为执行完成状态，将访问请求Si的完成码设置为第一完成码；第一完成码用于指示访问请求Si已正常执行完成。在一个实施例中，内核卸载规则为高版本卸载规则；请求记录文件中包含访问请求Si，i为正整数；内核卸载模块按照内核卸载规则对内核进行卸载处理的具体实现方式，包括：按照高版本卸载规则将访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求失败状态；当确定请求记录文件中，每个访问请求的请求状态均为请求失败状态时，将请求记录文件中包含的访问请求进行清空处理；在确定请求记录文件中未包含访问请求时，通过内核卸载指令对内核进行卸载处理。在一个实施例中，内核卸载模块按照高版本卸载规则将访问请求Si进行请求设置处理的具体实现方式，包括：按照高版本卸载规则，获取访问请求Si的请求标识；获取高版本卸载规则对应的第二请求终止逻辑代码，根据第二请求终止逻辑代码与访问请求Si的请求标识，生成针对访问请求Si的第二请求终止命令；按照第二请求终止命令，将请求记录文件中的访问请求Si的请求执行状态设置为执行失败状态，将访问请求Si的完成码设置为第二完成码；第二完成码用于指示访问请求Si未正常执行完成。在一个实施例中，内核部署于应用服务器中；在异常确定模块确定内核存在异常之后，数据处理装置还包括：集合确定模块，用于将应用服务器所部署的每个内核均确定为部署内核，得到部署内核集合；异常内核确定模块，用于将部署内核集合中在目标内核检测时刻时存在异常的部署内核，确定为异常内核；运行属性确定模块，用于基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性；信息推送模块，用于在分布式存储系统的系统运行属性为异常运行属性时，将针对分布式存储系统的故障警示信息推送至分布式存储系统的系统维护对象，以使系统维护对象基于故障警示信息对分布式存储系统进行系统维护处理。在一个实施例中，运行属性确定模块基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性的具体实现方式，包括：统计部署内核集合中包含的异常内核的第一数量，以及部署内核集合中包含的部署内核的第二数量；确定第一数量与第二数量之间的数量比值；若数量比值大于比值阈值，则确定分布式存储系统的系统运行属性为异常运行属性；若数量比值小于比值阈值，则确定分布式存储系统的系统运行属性为正常运行属性。本申请实施例一方面提供了一种计算机设备，包括：处理器和存储器；存储器存储有计算机程序，计算机程序被处理器执行时，使得处理器执行本申请实施例中的方法。本申请实施例一方面提供了一种计算机可读存储介质，计算机可读存储介质存储有计算机程序，计算机程序包括程序指令，程序指令当被处理器执行时，执行本申请实施例中的方法。本申请的一个方面，提供了一种计算机程序产品，该计算机程序产品包括计算机程序，该计算机程序存储在计算机可读存储介质中。计算机设备的处理器从计算机可读存储介质读取该计算机程序，处理器执行该计算机程序，使得该计算机设备执行本申请实施例中一方面提供的方法。在本申请实施例中，在通过内核使用分布式存储系统的块存储服务时，提出一种在出现异常的情况下卸载内核的方法，由此可以针对性地将内核所指示的应用进程进行及时地终止，从而可以减少对其他正常运行的应用进程的影响。具体的，对于某个内核而言，本申请可以定期读取关于该内核的请求记录文件，例如，在到达目标内核检测时刻时，可以读取该内核的请求记录文件，随后可以对该请求记录文件中的访问请求进行请求检测处理，通过请求检测处理可以确定出该请求记录文件中所包含的访问请求的请求等待状态；在这些访问请求的请求等待状态为持续异常等待状态时，即可确定该内核的相关访问请求，分布式存储系统并未及时进行处理，该内核的访问请求持续在进行等待，由此可以确定该内核存在异常，此时可以针对性的将该内核进行卸载处理。应当理解，本申请通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止。综上，本申请可以针对性地识别存在异常的内核，提升异常内核的异常处理及时性。附图说明为了更清楚地说明本发明实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。图1是本申请实施例提供的一种数据处理系统的网络架构图；图2是本申请实施例提供的一种通过硬重启的方式终止应用进程的示意图；图3是本申请实施例提供的一种数据处理方法的流程示意图；图4是本申请实施例提供的一种对内核进行自动检测并进行异常告警的架构示意图；图5是本申请实施例提供的一种自动检测服务的架构示意图；图6是本申请实施例提供的一种对内核进行卸载处理的流程示意图；图7是本申请实施例提供的一种卸载内核的整体逻辑架构图；图8是本申请实施例提供的一种对低版本内核进行卸载处理的架构示意图；图9是本申请实施例提供的一种对高版本内核进行卸载处理的架构示意图；图10是本申请实施例提供的一种基于存在异常的内核，对分布式存储系统进行维护处理的流程示意图；图11是本申请实施例提供的一种内核卸载的系统流程示意图；图12是本申请实施例提供的一种数据处理装置的结构示意图；图13是本申请实施例提供的一种计算机设备的结构示意图。具体实施方式下面将结合本申请实施例中的附图，对本申请实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例仅仅是本申请一部分实施例，而不是全部的实施例。基于本申请中的实施例，本领域普通技术人员在没有作出创造性劳动前提下所获得的所有其他实施例，都属于本申请保护的范围。本申请实施例涉及Ceph以及相关技术，为便于理解，以下将优先对Ceph以及相关技术概念进行简要阐述：Ceph：Ceph是一种开源的分布式存储系统，能同时提供对象存储服务、文件系统存储服务以及块存储服务等。Ceph具有高扩展性、高性能以及高可靠性等优点，Ceph在存储的时候充分利用存储节点的计算能力，在存储每一个数据时都会计算得出该数据的位置，尽量的分布均衡。RBD：RBD全称是Rados block device，其是Ceph的块存储组件，Ceph可以通过RBD提供块存储服务。KRBD：KRBD可以理解为一个内核组件，Ceph可以以KRBD的方式实现，通过内核方式可以使用Ceph的块存储服务。可以理解的是，Ceph是分布式的存储系统，通过RBD可以提供分布式块存储服务，而RBD可以通过KRBD提供内核态的访问。也就是说，对于不同的业务应用而言，其可以通过安装部署KRBD的方式，来对Ceph进行访问。为便于理解，请参见图1，图1是本申请实施例提供的一种数据处理系统的网络架构图。如图1所示，该网络架构可以包括业务服务器1000和终端设备集群，终端设备集群可以包括一个或者多个终端设备，这里将不对终端设备的数量进行限制。如图1所示，多个终端设备可以包括终端设备100a、终端设备100b、终端设备100c、…、终端设备100n；如图1所示，终端设备100a、终端设备100b、终端设备100c、…、终端设备100n可以分别与业务服务器1000进行网络连接，以便于每个终端设备可以通过该网络连接与业务服务器1000之间进行数据交互。另外，终端设备集群100中的任一终端设备可以是指运行有操作系统的智能设备，本申请实施例对终端设备的操作系统不进行具体限定。如图1所示的数据处理系统中的终端设备可以为智能手机、平板电脑、笔记本电脑、掌上电脑、台式计算机、移动互联网设备、POS机、智能音箱、智能电视、智能手表、智能车载终端、虚拟现实设备、增强现实设备等，但并不局限于此。终端设备往往配置有显示装置，显示装置可以为显示器、显示屏、触摸屏等等，触摸屏可以为触控屏、触控面板等等。如图1所示的数据处理系统中的业务服务器可以是单个的物理服务器，也可以是多个物理服务器构成的服务器集群或者分布式系统，还可以是提供云服务、云数据库、云计算、云函数、云存储、网络服务、云通信、中间件服务、域名服务、安全服务、CDN、以及大数据和人工智能平台等基础云计算服务的云服务器。终端设备与业务服务器可以通过有线或无线通信方式进行直接或间接地连接，本申请在此不做限制。在一种可能的实现方式中，终端设备中运行有客户端，如视频客户端、浏览器客户端、游戏客户端、教育客户端、网盘客户端等，这里将不对客户端进行一一举例说明。在本申请实施例中，以游戏客户端为例进行说明。使用对象在运行游戏客户端时，会产生大量的游戏数据，而业务服务器1000可以是指该游戏客户端对应的服务器，该业务服务器1000可以获取到这些游戏数据，业务服务器1000可以将这些游戏数据存储至Ceph系统中，具体的，可以在业务服务器1000中部署内核，那么该游戏客户端的相关应用进程可以运行于内核中，而业务服务器1000可以通过内核来访问该分布式存储系统，例如，业务服务器1000可以通过内核向分布式存储系统发起针对相关游戏数据的写入请求，以将这些游戏数据存储至该分布式存储系统中；当然，在使用对象在游戏客户端中存在有针对某些游戏数据的查询请求时，业务服务器1000也可以通过内核向分布式存储系统来发起针对这些游戏数据的读取请求，以从分布式存储系统中读取到这些游戏数据并显示于该使用对象进行查看。基于上述可知，本申请中可以利用Ceph系统这种分布式存储系统来存储相关业务应用的业务数据，而业务应用对应的业务服务器可以通过内核来对该分布式存储系统进行访问。然而，通过内核组件来进行内核态访问的方式，在Ceph存储系统出现故障的时候，Ceph存储系统会无法及时处理内核组件发出的请求，导致这些请求关联的应用进程会一直处于得不到响应的状态，从而使得业务服务器中大量的应用进程无法顺利进行、也无法得到终止，只能维持卡顿的状态。相关技术中，为了解决内核卡顿、应用进程卡顿的问题，会采用对服务器进行硬重启的方式来进行强制重启，由此可以强制终止掉服务器上运行的所有内核，从而将所有应用进程都进行终止。为便于理解，请一并参见图2，图2是本申请实施例提供的一种通过硬重启的方式终止应用进程的示意图。如图2所示，对于业务应用通过内核访问分布式存储系统的流程可以至少包括以下步骤：1）内核态的KRBD通过挂载向用户态暴露块存储组件；2）对块存储组件进行格式化文件系统，并将文件系统mount到块存储组件；3）业务应用发送文件系统访问请求，该文件系统访问请求会转化为块请求bio到达块存储组件，随后，内核KRBD会将该块请求bio转化为Ceph存储系统中块存储组件的块请求，并通过网络发送至Ceph存储系统。基于上述可知，当Ceph存储系统出现故障，那么内核发送的请求会在Ceph存储系统无法处理，导致卡住无法完成，而内核会持续等待该请求完成，导致这些请求所对应的业务应用的应用进程处于一个无法响应外部事件的状态，相关技术只能通过对业务应用所在的业务服务器进行硬重启，来将所有的应用进程进行终止。也就是说，采用硬重启业务服务器的方式，会卸载掉业务服务器中所部署的所有内核，从而终止运行各个内核上的所有应用进程。但是，对业务服务器进行硬重启需要由专业人员进行操作，可能存在操作滞后性；此外，由于业务服务器可能还存在其他服务的应用进程，强制硬重启的方式也会使得其他应用进程得到终止，对其他正常运行的应用进程产生影响。为了针对性地且及时地将存在卡顿的内核进行卸载，从而减少对其他正常运行的应用进程的影响，本申请提出一种针对性卸载内核的方法，具体的，本申请可以定期对各个内核进行检测，以检测存在异常的内核，对于存在异常的内核，可以基于内核的版本来进行卸载处理。具体的，在到达某个检测时刻时，业务服务器1000可以读取关于某个内核的请求记录文件，其中，这里的请求记录文件记录有通过该内核访问分布式存储系统中块存储组件的访问请求；随后，业务服务器1000可以对该请求记录文件中的访问请求进行请求检测处理，以确定该请求记录文件中的访问请求的请求等待状态；其中，这里的请求等待状态可以包含持续异常等待状态以及合理等待状态，在请求记录文件中的访问请求的请求等待状态为持续异常等待状态时，即可确定这些访问请求持续等待未得到分布式存储系统的处理，该分布式存储系统可能存在故障，并可以确定该内核存在卡顿，可以对内核进行卸载处理。其中，对该请求记录文件中的访问请求进行请求检测处理，以确定该请求记录文件中的访问请求的请求等待状态的具体方式，可以基于请求记录文件中各个访问请求的请求发送时间来确定，而对内核进行卸载处理的具体方式，可以基于内核的版本来进行卸载处理，其具体实现方式可以参见后续图3所对应实施例中的描述。应当理解，本申请通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止，减少对正常运行的应用进程的影响。可以理解的是，本申请实施例所提供的方法可以由计算机设备执行，计算机设备包括但不限于图1中所提及的终端设备或业务服务器。需要说明的是，在本申请的具体实施方式中，涉及到用户信息、用户数据等相关的数据，均是需要经过用户手动授权许可才进行获取得到的。也就是说，当本申请以上实施例运用到具体产品或技术中时，本申请实施例所提供的方法与相关功能是在获得用户许可或者同意下所运行的，且相关数据的收集、使用和处理需要遵守相关国家和地区的相关法律法规和标准。为便于理解，接下来将结合附图对本申请实施例提供的数据处理方法进行详细描述。请参见图3，图3是本申请实施例提供的一种数据处理方法的流程示意图。其中，该方法可以由终端设备执行，也可以由服务器所执行，还可以由终端设备和服务器共同执行。为便于理解，本实施例以该方法由服务器执行为例进行说明。如图3所示，该数据处理方法至少可以包括以下步骤S101-步骤S103：步骤S101，在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求。本申请中，分布式存储系统可以是指Ceph存储系统，是一种开源的分布式存储系统，能同时提供对象、文件以及块存储服务。Ceph具体可通过块存储组件提供分布式存储服务，其可以类似服务器上的一个物理硬盘。其中，块存储组件可以通过两种方式对外提供服务，一种是通过librbd提供用户态的访问，另一种则是通过内核组件提供内核态的访问。换言之，对于本申请中的分布式存储系统，可以通过内核来进行访问，而对于分布式存储系统的访问，可以是指对分布式存储系统中块存储组件的访问，通过对块存储组件的访问来实现将业务应用的业务数据存储至分布式存储系统中，或者从分布式存储系统中读取相关的业务数据。应当理解，业务应用对于分布式存储系统的访问请求，可以通过内核来进行转发，也就是说，业务应用可以通过内核来访问分布式存储系统中块存储组件，对于通过内核来访问分布式存储系统中块存储组件的不同访问请求，可以由一个文件来进行记录，这个文件可以称之为关于内核的请求记录文件。为便于理解，请一并参见表1，表1是本申请实施例提供的一种对于请求记录文件的示例性说明，如表1所示：表1其中，如表1所示的每一行可以用于表征一个访问请求，例如，“500，AAA，AAA，rbd_data.123456.AAAA AAAA”可以是指一个访问请求。每个访问请求中均包含一个请求编号，访问请求的请求编号的大小可以用于表征访问请求的发送早晚顺序，例如，访问请求“500，AAA，AAA，rbd_data.123456.AAAA AAAA”中，请求编号可以是指500，访问请求“501，AAA，AAA，rbd_data.123456.AAAA AAAA”中，请求编号可以是指501，访问请求“502，AAA，AAA，rbd_data.123456.AAAA AAAA”中，请求编号可以是指502，由于请求编号500小于请求编号501，请求编号501小于请求编号502，那么可以看出，发送访问请求“500，AAA，AAA，rbd_data.123456.AAAA AAAA”的时间，早于发送访问请求“501，AAA，AAA，rbd_data.123456.AAAA AAAA”的时间，且发送访问请求“501，AAA，AAA，rbd_data.123456.AAAAAAAA”的时间，早于发送访问请求“502，AAA，AAA，rbd_data.123456.AAAA AAAA”的时间。每个访问请求中还包含有操作的RBD块存储组件的组件编号，例如，如表1所示的访问请求中，每个访问请求中包含的块存储组件的组件编号均为“123456”，其可以表征对同一个块存储组件进行操作。应当理解，本申请可以在服务器中部署一个自动检测组件，该自动检测组件可以定期读取每个内核的请求记录文件，然后再基于某个内核的请求记录文件中包含的访问请求，来检测该内核是否存在卡顿这种异常情况。而这里的目标内核检测时刻，可以是指任一个用于对内核进行检测的时刻，例如，假设从a时刻开始，每隔5s需要对内核进行一次检测，那么这里的目标内核检测时刻可以是指a时刻、a时刻+5s、a时刻+10s……每当到达目标内核检测时刻时，需要读取关于内核的请求记录文件，以通过请求记录文件中记录的访问请求，来检测该内核是否存在异常。步骤S102，对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态。本申请中，可以通过对请求记录文件中的访问请求进行请求检测处理，来确定请求记录文件中访问请求的请求等待状态。对于对请求记录文件中的访问请求进行请求检测处理的具体方式，可以通过各个访问请求的请求发送时间来进行请求检测，具体的，对于对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态的具体实现方式可为：可以获取请求记录文件中具有最小发送时间戳的访问请求，随后可以将请求记录文件中具有最小发送时间戳的访问请求，确定为目标内核检测时刻对应的目标最早访问请求；进一步地，可以将目标内核检测时刻的上一个内核检测时刻，确定为目标内核检测时刻的历史内核检测时刻；可以获取历史内核检测时刻对应的历史最早访问请求，根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，即可确定请求记录文件中访问请求的请求等待状态。可以理解的是，对于每个内核检测时刻，本申请均可以获取到请求记录文件中具有最小发送时间戳的访问请求，该访问请求即为该内核检测时刻时的最早访问请求，而本申请可以基于某个内核检测时刻与上一个内核检测时刻分别对应的最早访问请求，来确定该内核检测时刻时，请求记录文件中访问请求的请求等待状态。那么对于目标内核检测时刻而言，在目标内核检测时刻时，可以将请求记录文件中具有最小发送时间戳的访问请求，称为目标最早访问请求；而对于目标内核检测时刻的上一个内核检测时刻而言，可以将该上一个内核检测时刻称为历史内核检测时刻，在该历史内核检测时刻时，可以将请求记录文件中具有最小发送时间错的访问请求，称为历史最早访问请求。而基于该目标最早访问请求与该历史最早访问请求，即可共同确定目标内核检测时，请求记录文件中访问请求的请求等待状态。具体的，对于根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，确定请求记录文件中访问请求的请求等待状态的具体实现方式可为：可以将目标最早访问请求与历史最早访问请求进行比较；若确定目标最早访问请求与历史最早访问请求相同，则可以基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态；而若确定目标最早访问请求与历史最早访问请求不同，则可以直接确定请求记录文件中访问请求的请求等待状态为合理等待状态。可以理解的是，对于内核先后发送至分布式存储系统的访问请求，可以包含数据读取请求、也可以包括数据写入请求，而分布式存储系统可以先后将各个访问请求进行处理，分布式存储系统每处理完成一个访问请求，内核则会接收到处理完成的反馈消息，随后便可将该已经处理完成的访问请求进行标记并清除，相应的，请求记录文件中也会将分布式存储系统处理完成的访问请求进行清理。那么可见，若前后两个内核检测时刻时，请求记录文件中的最早访问请求不同，则可以反映分布式存储系统一直在持续处理访问请求，前后两次的最早访问请求是不一样的，历史内核检测时刻对应的历史最早访问请求已被处理完成，那么请求记录文件中所包含的访问请求是正常等待状态，每个访问请求均需要等待分布式存储系统将发送时间更早的访问请求依次处理完成，那么此时可以直接将该请求记录文件中访问请求的请求等待状态确定为合理等待状态。而若前后两个内核检测时刻时，请求记录文件中的最早访问请求相同，那么可以反映分布式存储系统在一段时间内，都未将历史内核检测时刻时的历史最早访问请求处理完成，换言之，分布式存储系统至少在前后两个内核检测时刻之间的时间段内，都未将历史最早访问请求处理完成，此时可以基于前后两个内核检测时刻之间的时间段，确定出该历史最早访问请求对应的请求等待时长，该请求等待时长可以理解为分布式存储系统在目标内核检测时刻时的请求阻塞时长，若该请求阻塞时长大于时长阈值，则可以确定该请求记录文件中访问请求的请求等待状态为持续异常等待状态。具体的，基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态的具体实现方式可为：可以确定目标内核检测时刻与历史内核检测时刻之间的时间段；随后，可以将目标内核检测时刻与历史内核检测时刻之间的时间段，确定为内核在目标内核检测时刻时的增量阻塞时长；可以获取内核在历史内核检测时刻时的历史请求阻塞时长，可以将增量阻塞时长与历史请求阻塞时长进行相加运算处理，由此可以得到内核在目标内核检测时刻时的目标请求阻塞时长；在目标请求阻塞时长大于时长阈值时，可以确定请求记录文件中访问请求的请求等待状态为持续异常等待状态。而在目标请求阻塞时长小于时长阈值时，可以确定请求记录文件中访问请求的请求等待状态为合理等待状态。可以理解的是，在目标内核检测时刻为首个内核检测时刻时，该目标内核检测时刻并不存在历史内核检测时刻，那么无法比较前后两个内核检测时刻的最早访问请求是否相同，基于此，本申请的目标内核检测时刻可以理解为第二个内核检测时刻及之后的任一个内核检测时刻，在目标内核检测时刻为第二个内核检测时刻时，历史内核检测时刻则可为首个内核检测时刻，若前后两个内核检测时刻时的最早访问请求相同，则可以将第一个内核检测时刻与第二个内核检测时刻之间的时间段确定为增量阻塞时长，由于该历史内核检测时刻为首个内核检测时刻，并不存在历史请求阻塞时长，那么该首个内核检测时刻时的请求阻塞时长可为0，基于此，可以直接将该第一个内核检测时刻与第二个内核检测时刻之间的时间段12，确定为第二个内核检测时刻时的请求阻塞时长，也就是说，在目标内核检测时刻为第二个内核检测时刻时，该目标内核检测时刻对应的目标请求阻塞时长为时间段12。相应的，在目标内核检测时刻为第三个内核检测时刻时，该目标内核检测时刻的历史内核检测时刻可理解为首个内核检测时刻，此时可以比较内核检测时刻2时的最早访问请求与内核检测时刻3时的最早访问请求是否相同，若相同，则可以基于内核检测时刻2与内核检测时刻3之间的时间段23确定为增量阻塞时长，可以将内核检测时刻2时的请求阻塞时长确定为历史请求阻塞时长，将该增量阻塞时长与该历史请求阻塞时长进行相加运算处理，即可得到该内核检测时刻3时的请求阻塞时长。基于上述可知，按照上述所描述的方式，可以确定出各个内核检测时刻时的请求阻塞时长，对于每个内核检测时刻，可以确定出内核在此时刻时的请求阻塞时长，若内核在某个内核检测时刻时的请求阻塞时长大于了时长阈值，则可以确定请求记录文件中访问请求的请求等待状态为持续异常等待状态，可以认为该内核在该内核检测时刻时存在异常，应当对该内核进行卸载处理，无需再对该内核进行后续检测。换言之，一旦在某个内核检测时刻时，检测出该内核存在异常，那么后续无需再对该内核进行继续检测。步骤S103，在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常，对内核进行卸载处理。本申请中，在确定请求记录文件中访问请求的请求等待状态为持续异常等待状态时，可以确定分布式存储系统未及时处理这些访问请求，这些访问请求一直处于异常等待的状态，这些访问请求出现卡顿的情况，即该内核存在卡顿的情况，基于此，可以确定该内核存在异常，此时可以对内核进行卸载处理。需要说明的是，本申请中，针对内核版本的不同，提出不同的策略进行卸载，对于对内核进行卸载处理的具体实现方式，可以参见后续实施例中的描述。可选的，可以理解的是，本申请可以预设一个监测告警服务，用于在检测出存在异常的内核后，发出针对异常内核的异常告警信息至内核维护对象，以使内核维护对象对内核进行进一步维护处理。为便于理解，请一并参见图4，图4是本申请实施例提供的一种对内核进行自动检测并进行异常告警的架构示意图。如图4所示，该架构可以至少包括业务服务器、监测服务以及分布式存储系统。为便于理解，以下将对架构中的各个部分进行阐述：业务服务器：基于前文实施例可知，业务服务器可以是指业务应用对应的服务器，对于业务应用通过内核访问分布式存储系统的流程可以至少包括以下步骤：1）内核态的KRBD通过挂载向用户态暴露块存储组件；2）对块存储组件进行格式化文件系统，并将文件系统mount到块存储组件；3）业务应用发送文件系统访问请求，该文件系统访问请求会转化为块请求bio到达块存储组件，随后，内核KRBD会将该块请求bio转化为Ceph存储系统中块存储组件的块请求，并通过网络发送至Ceph存储系统。而业务服务器中可以部署有自动检测组件，通过内核暴露至用户态的通信组件来罗列出关于某个内核的请求记录文件，并统计该请求记录文件中发送时间最早的访问请求，由此可以得到每个请求记录文件中的最早访问请求。而基于各个内核检测时刻下的最早访问请求，可以确定出内核发送的访问请求的请求等待状态，若访问请求的请求等待状态为持续异常等待状态，则可以确定这些访问请求呈现卡顿的情况，该内核存在卡顿的异常问题。为便于理解自动检测组件对于自动检测内核异常的流程，请一并参见图5，图5是本申请实施例提供的一种自动检测服务的架构示意图。如图5所示，该自动检测服务中可以包括请求检测组件，该请求检测组件可以通过内核暴露至用户态的通信组件，罗列出内核发送至分布式存储系统的访问请求队列，由此可以形成一个关于内核的请求记录文件。其中，应当理解，该通信组件可以用于在用户态与内核态进行通信，具体的，内核可以通过请求发送组件发送访问请求至分布式存储系统，因此内核所发送的所有访问请求均能从该请求发送组件中获取得到，而内核会将所有的osdc请求均写入到debugfs相关的osdc文件中，那么通过该osdc文件中所记录的有关于内核发送的访问请求，请求检测组件即可罗列出关于该内核的所有访问请求队列，由此得到请求记录文件。通过请求记录文件，请求检测组件可以统计每个内核发送时间最早的访问请求，由此可以得到每个内核对应的最早访问请求。而基于上述可知，每个访问请求中均会包含一个请求编号，访问请求的请求编号可以用于反映其发送时间，例如，请求编号越小则可反映发送时间越早，那么请求检测组件在统计某个请求记录文件中的最早访问请求时，可以通过直接比较访问请求的请求编号的方式，来确定出一个最早编号，在最早编号所指示的访问请求即可为最早访问请求。需要说明的是，对于通过内核访问分布式存储系统而言，可以理解为是通过内核访问分布式存储系统中的块存储组件，而一个内核可以对应一个块存储组件，那么通过对各个请求记录文件进行请求统计的方式，可以对每个挂载的块存储组件均统计出一个最早编号。例如，如图5所示，对于块存储组件0而言，通过进行请求统计，所确定出的最早编号为最早编号0；对于块存储组件1而言，通过进行请求统计，所确定出的最早编号为最早编号1；对于块存储组件2而言，通过进行请求统计，所确定出的最早编号为最早编号2。应当理解，对于内核，可以对应有不同的内核检测时刻，而请求检测组件可以统计出每个内核在各个内核检测时刻下的最早访问请求，而持久存储组件可以将请求检测组件所统计得到的各个内核检测时刻下的最早访问请求进行持久化存储，那么基于持久存储组件中所存储的各个内核检测时刻下的最早访问请求，在到达下一个内核检测时刻时，请求检测组件即可基于前后两个内核检测时刻的最早访问请求，来确定该内核是否存在卡顿的异常情况。若检测到某个内核存在异常，那么请求检测组件即可通过报告组件，将该存在异常的内核上报至监测服务，由该监测服务生成针对异常内核的异常警示信息并发送至内核维护对象。监测服务：业务服务器中的自动检测组件在检测到存在异常的内核后，可以上报至监测服务的统计组件，而该统计组件可以上报至告警组件，告警组件可以生成针对异常内核的异常警示信息，并将该异常警示信息发送至内核维护对象，以使内核维护对象明确该内核存在异常，可能需要进行一定的维护处理。分布式存储系统：可以用于对内核发送的访问请求进行请求处理。需要说明的是，对于存在异常的内核，本申请可以对其进行卸载处理，而在对内核进行卸载处理前，可以先发送异常警示信息至内核维护对象，由内核维护对象下达对该异常内核的卸载指令后，再对该内核进行卸载处理；当然，在检测到存在异常的内核后，也可以自动对该存在异常的内核进行卸载处理，由此可以无需人工参与，全程自动化，减少内核卸载的滞后性。综上可知，本申请中的自动检测服务可以每隔一段固定时间变通过debugfs读取osdc中存储访问请求，从而可以罗列得到关于内核的请求记录文件，而通过对请求记录文件进行逐条分析统计，可以统计得到每个内核在各个时刻下的最早访问请求，将某个时刻的最早访问请求与持久化存储的上个检测时刻下的最早访问请求进行比较，可以确定出分布式存储系统是否正常对这些访问请求进行处理，若连续多个时刻下的最早访问请求均相同，那么可以表示该最早访问请求在连续一段时间段内一直未得到处理，那么此时即可确定该分布式存储存在故障，导致该内核存在卡顿，需要对这个内核进行卸载处理。在本申请实施例中，在通过内核使用分布式存储系统的块存储服务时，提出一种在出现异常的情况下卸载内核的方法，由此可以针对性地将内核所指示的应用进程进行及时地终止，从而可以减少对其他正常运行的应用进程的影响。具体的，对于某个内核而言，本申请可以定期读取关于该内核的请求记录文件，例如，在到达目标内核检测时刻时，可以读取该内核的请求记录文件，随后可以对该请求记录文件中的访问请求进行请求检测处理，通过请求检测处理可以确定出该请求记录文件中所包含的访问请求的请求等待状态；在这些访问请求的请求等待状态为持续异常等待状态时，即可确定该内核的相关访问请求，分布式存储系统并未及时进行处理，该内核的访问请求持续在进行等待，由此可以确定该内核存在异常，此时可以针对性的将该内核进行卸载处理。应当理解，本申请通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止。进一步地，请参见图6，图6是本申请实施例提供的一种对内核进行卸载处理的流程示意图。该流程可以对应于上述图3所对应实施例中，对于对内核进行卸载处理的流程。如图6所示，该流程可以至少包括以下步骤S601-步骤S603：步骤S601，获取内核所对应的内核版本。具体的，不同的内核对应有不同的内核版本，某些内核的内核版本较高，而某些内核的内核版本较低。本申请可以基于不同的内核版本，采取不同的卸载策略对内核进行卸载处理。步骤S602，按照内核版本所属的版本区间，确定内核的内核卸载规则。具体的，基于前文实施例可知，内核可以通过osdc向分布式存储系统发送访问请求，若分布式存储系统故障，那么该分布式存储系统则无法正常处理这些访问请求，分布式存储系统则无法返回完成响应的通知信息至内核，而内核在没有接收到分布式存储系统返回的针对访问请求的完成响应的通信信息时，该访问请求会一直等待分布式存储系统处理直至接收到分布式存储系统返回的完成响应的通知信息。基于此，本申请在对内核进行卸载时，需要先将osdc中没有处理完成的访问请求先进行清理释放，在释放完所有未处理完成的访问请求后，才可以将内核进行卸载处理。为便于理解，请一并参见图7，图7是本申请实施例提供的一种卸载内核的整体逻辑架构图。如图7所示，该整体架构可以至少包括命令写入组件、通信组件以及内核。为便于理解，以下将对各个组件实现的功能进行阐述：命令写入组件：该命令写入组件可以是通信组件暴露至用户态的用于写入计算机命令的组件，该命令写入组件具体可以是指remove_single_major文件，用户态可以通过该命令写入组件写入请求终止命令，该请求终止命令中可以包括需要卸载的内核的编号以及针对访问请求的终止指令。通信组件：用于在用户态与内核态之间进行通信。内核：内核接收到请求终止命令后，则可以通过内核编号找到对应的osdc组件。通过遍历该osdc中包含的访问请求来将每个访问请求均进行终止。例如，如图7所示，该osdc中包含的请求队列中包含访问请求701，在卸载该内核时，需要将该访问请求701进行终止，将该访问请求701标记为处理完成，并为该访问请求设置相应的完成码。直到请求队列中所有的访问请求都标记为处理完成后，随后即可通过正常的卸载指令将内核进行卸载。可以理解的是，本申请中，对于访问请求的完成码，可以设置为用于表征执行失败的码，例如，该完成码可为“ERROR IO”，通过该完成码即可向上层的文件系统反映该访问请求虽然被标记为处理完成，但该访问请求并未成功执行。然而，在内核的内核版本较低时，部分文件系统存在无法正常识别处理元数据“IO”的情况，这可能会导致存在于块存储组件上的文件系统遭到损坏，进而导致整个文件系统不可用。那么为了改善这个问题，本申请为不同的内核版本配置不同的内核卸载规则，在对内核进行卸载处理时，按照内核版本所属的版本区间，可以先确定内核的内核卸载规则，然后再按照相应的内核卸载规则来对内核进行卸载处理。具体的，对于按照内核版本所属的版本区间，确定内核的内核卸载规则的具体实现方式可为：在内核版本所属的版本区间为第一区间时，可以将配置卸载规则集合中的低版本卸载规则确定为内核的内核卸载规则；而在内核版本所属的版本区间为第二区间时，可以将配置卸载规则集合中的高版本卸载规则确定为内核的内核卸载规则；其中，第一区间低于第二区间。可以理解的是，本申请中的第一区间可以为低版本区间，第二区间可以为高版本区间，具体可以将低于3.5x版本的区间确定为第一区间，将高于3.5x版本的区间确定为第二区间。本申请可以为为低版本区间配置一个低版本卸载规则，对高版本区间配置一个高版本卸载规则，低版本卸载规则与高版本卸载规则均可以确定为配置卸载规则，从而可以组成一个配置卸载规则集合，若内核版本所属的版本区间为第一区间，那么即可将配置卸载规则集合中的低版本卸载规则确定为内核的内核卸载规则；而若内核版本所属的版本区间为第二区间，在可以将配置卸载规则集合中的高版本卸载规则确定为内核的内核卸载规则。步骤S603，按照内核卸载规则对内核进行卸载处理。具体的，这里的内核卸载规则包含有低版本卸载规则与高版本卸载规则。在内核卸载规则为低版本卸载规则时，以请求记录文件中包含访问请求Si为例，对于按照内核卸载规则对内核进行卸载处理的具体实现方式可为：按照低版本卸载规则，可以先将访问请求Si进行请求设置处理，并将请求设置处理后的访问请求Si的请求状态确定为请求成功状态；当确定请求记录文件中，每个访问请求的请求状态均为请求成功状态时，即可将请求记录文件中包含的访问请求进行清空处理；随后在确定请求记录文件中未包含访问请求时，即可通过内核卸载指令对内核进行卸载处理。其中，对于按照低版本卸载规则将访问请求Si进行请求设置处理的具体实现方式可为：按照低版本卸载规则，可以获取访问请求Si的请求标识；随后，可以获取低版本卸载规则对应的第一请求终止逻辑代码，根据第一请求终止逻辑代码与访问请求Si的请求标识，可以生成针对访问请求Si的第一请求终止命令；按照第一请求终止命令，可以将请求记录文件中的访问请求Si的请求执行状态设置为执行完成状态，并将访问请求Si的完成码设置为第一完成码；其中，第一完成码用于指示访问请求Si已正常执行完成。基于上述可知，对于访问请求的完成码，是用于上层的文件系统感知访问请求是否正常执行完成的，在内核存在异常时，可以将完成码设置为用于表征执行失败的码，例如，该完成码可为“ERROR IO”，通过该完成码即可向上层的文件系统反映该访问请求虽然被标记为处理完成，但该访问请求并未成功执行。然而，在内核的内核版本较低时，部分文件系统存在无法正常识别处理元数据“IO”的情况，这可能会导致存在于块存储组件上的文件系统遭到损坏，进而导致整个文件系统不可用。基于此，在内核版本处于第一区间时，可以按照低版本卸载规则获取到对应的请求终止逻辑代码，再基于需要进行终止的访问请求的请求标识，生成相应的请求终止命令并下发，基于该第一请求终止命令，可以逐个将每个访问请求的请求执行状态设置为执行完成状态，并将完成码设置为第一完成码，也就是说，该第一完成码可以用于表征执行成功的码，例如，该完成码可为“0”，通过该第一完成码即可向上层的文件系统反映该访问请求被标记为处理完成，且该访问请求已成功执行。应当理解，虽然每个访问请求被标记为处理完成，且完成码被设置为第一完成码，但是该访问请求实际上并未得到正常的处理，那么文件系统层所操作的数据或元数据实际上并没有持久化到远端的分布式存储系统中，那么在下次从分布式存储系统中读取数据时，仍然无法正常读取数据或读取到的数据为老数据。也就是说，对于这些访问请求所指示的相关业务数据，并未持久化存储至分布式存储系统中，虽然会造成分布式存储系统中部分数据的缺失，但是相比于损坏整个文件系统，将访问请求的完成码设置为第一完成码的损失更低，基于此，在内核版本较低的内核卸载过程中，本申请采用将各个访问请求的完成码设置为第一完成码。为便于理解，请一并参见图8，图8是本申请实施例提供的一种对低版本内核进行卸载处理的架构示意图。如图8所示，该架构可以至少包括命令写入组件、通信组件以及内核。为便于理解，以下将对各个组件实现的功能进行阐述：命令写入组件：该命令写入组件可以是通信组件暴露至用户态的用于写入计算机命令的组件，该命令写入组件具体可以是指remove_single_major文件，用户态可以通过该命令写入组件写入请求终止命令，该请求终止命令中可以包括需要卸载的内核的编号以及针对访问请求的终止指令。而这里的请求终止命令可以是指第一请求终止命令，对于该第一请求终止命令，也可以基于第一请求终止逻辑代码来生成。通信组件：可以在用户态与内核态之间进行通信。内核：内核接收到第一请求终止命令后，则可以通过内核编号找到对应的osdc组件。通过遍历该osdc中包含的访问请求来将每个访问请求均进行终止。例如，如图8所示，该osdc中包含的请求队列中包含访问请求701，在卸载该内核时，需要将该访问请求701进行终止，将该访问请求701标记为处理完成，并将访问请求701的完成码设置第一完成码。而内核可以将该第一完成码通过块组件层返回至文件系统层，文件系统层即可通过该第一完成码确定访问请求已成功执行。在内核卸载规则为高版本卸载规则时，以请求记录文件中包含访问请求Si为例，对于按照内核卸载规则对内核进行卸载处理的具体实现方式可为：按照高版本卸载规则可以将访问请求Si进行请求设置处理，随后可以将请求设置处理后的访问请求Si的请求状态确定为请求失败状态；当确定请求记录文件中，每个访问请求的请求状态均为请求失败状态时，可以将请求记录文件中包含的访问请求进行清空处理；随后，在确定请求记录文件中未包含访问请求时，即可通过内核卸载指令对内核进行卸载处理。其中，对于按照高版本卸载规则将访问请求Si进行请求设置处理的具体实现方式可为：按照高版本卸载规则，可以获取访问请求Si的请求标识；随后，可以获取高版本卸载规则对应的第二请求终止逻辑代码，根据第二请求终止逻辑代码与访问请求Si的请求标识，可以生成针对访问请求Si的第二请求终止命令；按照第二请求终止命令，可以将请求记录文件中的访问请求Si的请求执行状态设置为执行失败状态，并将访问请求Si的完成码设置为第二完成码；其中，第二完成码用于指示访问请求Si未正常执行完成。基于上述可知，对于访问请求的完成码，是用于上层的文件系统感知访问请求是否正常执行完成的，在内核存在异常时，可以将完成码设置为用于表征执行失败的码，例如，该完成码可为“ERROR IO”，通过该完成码即可向上层的文件系统反映该访问请求虽然被标记为处理完成，但该访问请求并未成功执行。而这里的执行失败的码，即可为本申请的第二完成码，在内核版本处于第二区间时，可以按照高版本卸载规则获取到对应的请求终止逻辑代码，再基于需要进行终止的访问请求的请求标识，生成相应的请求终止命令并下发，基于该第二请求终止命令，可以逐个将每个访问请求的请求执行状态设置为执行失败状态，并将完成码设置为第二完成码，也就是说，该第二完成码可以用于表征执行失败的码，通过该第二完成码即可向上层的文件系统反映该访问请求被标记为处理完成，且该访问请求失败执行。为便于理解，请一并参见图9，图9是本申请实施例提供的一种对高版本内核进行卸载处理的架构示意图。如图9所示，该架构可以至少包括命令写入组件、通信组件以及内核。为便于理解，以下将对各个组件实现的功能进行阐述：命令写入组件：该命令写入组件可以是通信组件暴露至用户态的用于写入计算机命令的组件，该命令写入组件具体可以是指remove_single_major文件，用户态可以通过该命令写入组件写入请求终止命令，该请求终止命令中可以包括需要卸载的内核的编号以及针对访问请求的终止指令。而这里的请求终止命令可以是指第二请求终止命令，对于该第二请求终止命令，也可以基于第二请求终止逻辑代码来生成。通信组件：可以在用户态与内核态之间进行通信。内核：内核接收到第二请求终止命令后，则可以通过内核编号找到对应的osdc组件。通过遍历该osdc中包含的访问请求来将每个访问请求均进行终止。例如，如图9所示，该osdc中包含的请求队列中包含访问请求701，在卸载该内核时，需要将该访问请求701进行终止，将该访问请求701标记为处理完成，并将访问请求701的完成码设置第二完成码。而内核可以将该第二完成码通过块组件层返回至文件系统层，文件系统层即可通过该第二完成码确定访问请求执行失败。可以理解的是，文件系统层在确定访问请求执行失败后，可以冻结住后续将下发至内核的访问请求，由此可以避免更多的访问请求在该内核处得到卡顿的情况。在本申请实施例中，通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止。此外，本申请为不同版本的内核，配置不同的内核卸载规则，从而可以基于内核版本的高低来减少因为内核卸载而造成的文件系统损失。可以理解的是，基于上述可知，业务服务器中可以部署有内核，而业务服务器可以通过内核对分布式存储系统进行访问，将业务应用的相关业务数据存储至分布式存储系统，或者从分布式存储系统中读取相关业务数据。而业务服务器中可以部署有多个不同的内核，本申请可以定期对每个内核进行检测，以检测出存在异常的内核，而对于存在异常的内核，本申请可以将其进行卸载处理。其中，对于内核的卡顿，通常是由于分布式存储系统存在故障所造成的，由于分布式存储系统存在故障，导致无法及时处理内核发送的访问请求，从而使得访问请求持续等待处理，进而使得内核产生卡顿。而一旦分布式存储系统存在故障，那么业务服务器中部署的大部分内核都会发生卡顿的问题，基于此，本申请需要通过统计存在异常的内核的数量，来确定是否需要对分布式存储系统进行系统维护处理，若业务服务器中存在异常的内核的数量较少，那么可以认为分布式存储系统即使存在故障，但故障产生的影响较小，此时只需将内核进行针对性卸载处理即可，无需将分布式存储系统进行维护处理，或者说，若业务服务器中存在异常的内核的数量较少，可以认为可能是内核自身出现了问题，此时无需将分布式存储系统进行维护处理；而若业务服务器中存在异常的内核的数量较多，那么可以认为分布式存储系统存在故障，且故障产生的影响较大，此时除了需要将存在异常的内核进行针对性卸载处理以外，还需要将分布式存储系统进行维护处理，以使得分布式存储系统能够正常运行，及时处理各个内核发送的访问请求。也就是说，本申请中的各个内核时部署于业务应用所对应的业务服务器中的，而在确定内核存在异常之后，本申请还可以基于应用服务器中存在异常的内核的数量，来决定是否对分布式存储系统进行系统维护处理。为便于理解，请一并参见图10，图10是本申请实施例提供的一种基于存在异常的内核，对分布式存储系统进行维护处理的流程示意图。该流程可以对应于上述图3所对应实施例中，在确定内核存在异常之后的流程。如图10所示，该流程可以至少包括以下步骤S201-步骤S204：步骤S201，将应用服务器所部署的每个内核均确定为部署内核，得到部署内核集合。具体的，可以将部署于应用服务器中的每个内核均命名为部署内核，各个部署内核可以组成一个集合，该集合可称之为部署内核集合。步骤S202，将部署内核集合中在目标内核检测时刻时存在异常的部署内核，确定为异常内核。具体的，可以将部署内核集合中，在目标内核检测时存在异常的部署内核确定为异常内核。步骤S203，基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性。具体的，对于基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性的具体实现方式可为：可以统计部署内核集合中包含的异常内核的第一数量，以及部署内核集合中包含的部署内核的第二数量；随后，可以确定第一数量与第二数量之间的数量比值；若数量比值大于比值阈值，则可以确定分布式存储系统的系统运行属性为异常运行属性；而若数量比值小于比值阈值，则可以确定分布式存储系统的系统运行属性为正常运行属性。可以理解的是，若部署内核集合中，存在异常的内核的占比，超过一定阈值，那么即可确定该分布式存储系统存在故障了，该分布式存储系统的系统运行属性为异常运行属性；而若部署内核集合中，存在异常的内核的占比，未超过预设阈值，那么可确定该分布式存储系统未存在故障，该分布式存储系统的系统运行属性为正常运行属性。步骤S204，在分布式存储系统的系统运行属性为异常运行属性时，将针对分布式存储系统的故障警示信息推送至分布式存储系统的系统维护对象，以使系统维护对象基于故障警示信息对分布式存储系统进行系统维护处理。具体的，在分布式存储系统的系统运行属性为异常运行属性时，可以生成针对该分布式存储系统的故障警示信息，并将该故障警示信息推送至分布式存储系统的系统维护对象，系统维护对象可以基于该故障警示信息对该分布式存储系统进行问题排查，并进行系统维护处理。可选的，可以理解的是，对于分布式存储系统而言，可以将其划分为多个子部分来分别为不同的业务应用提供服务，那么对于某个业务应用对应的应用服务器而言，在存在异常的内核的数量较多时，那么可以认为是该分布式存储系统中相应的子部分发生了故障，可以生成针对该子部分的故障警示信息并推送至系统维护对象，由此系统维护对象可以对该部分子系统进行小范围的排查，而不用排查整个分布式存储系统，由此可以提升排查效率，并提升系统维护的效率与及时性。在本申请实施例中，通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止。此外，本申请可以基于检测出的存在异常的内核的数量，判断分布式存储系统是否存在故障，由此可以提升分布式存储系统的维护及时性，进而提升分布式存储系统的运行稳定性。进一步地，请参见图11，图11是本申请实施例提供的一种内核卸载的系统流程示意图。如图11所示，该系统流程可以至少包括以下步骤S21-步骤S30：步骤S21，读取请求记录文件。具体的，在到达目标内核检测时刻时，可以通过debugfs罗列得到请求记录文件，通过读取请求记录文件可以获取到关于内核的每个访问请求，对于每个访问请求可以逐个进行遍历获取到其发送时间，从而基于各个访问请求的发送时间确定出最早访问请求。步骤S22，确定是否为文件最后一个访问请求。具体的，由于需要读取请求记录文件以获取到最早访问请求，所以需要遍历完成所有的访问请求，那么对于遍历的每个访问请求而言，需要先判断其是否为最后一个访问请求。若是遍历中的最后一个访问请求，则可以执行后续步骤S24；而若不是最后一个访问请求，则可执行后续步骤S23。步骤S23，解析发送时间和对应的块存储组件。具体的，可以对访问请求的发送时间进行解析，也可以获取到该访问请求所期望访问的块存储组件是哪一个。步骤S24，确定发送时间是否小于当前最早访问请求的发送时间。具体的，对于每个访问请求，可以将其与当前最早访问请求的发送时间相比，若小于，则可以执行后续步骤S25；而若大于，则可以执行后续步骤S26。步骤S25，更新最早访问请求。具体的，若当前遍历获取到的访问请求的发送时间，小于当前最早访问请求的发送时间，那么可以将该访问请求更新为当下的最早访问请求。步骤S26，统计最早访问请求是否与上次保存的内容相同。具体的，通过上述步骤可以依次比较直至遍历完最后一个访问请求，由此可以确定出请求记录文件中的最早访问请求，而在确定出请求记录文件中的最早访问请求后，可以将最早访问请求与上次的最早访问请求进行比较，确定两者是否相同，若相同，则可以执行后续步骤S27；如若不相同，则可以执行后续步骤S28。步骤S27，将请求阻塞时长进行累积。具体的，在上述两个最早访问请求相同时，可以将内核的请求阻塞时长进行累积，例如，可以将历史内核检测时刻时的历史请求阻塞时长，与目标内核检测时刻时的增量阻塞时长进行相加，由此可以得到目标内核检测时刻的目标请求阻塞时长。步骤S28，确定累积的请求阻塞时长是否大于阈值。具体的，可以判断累积的请求阻塞时长是否大于时长阈值，若大于，则可以执行后续步骤S29；而若小于，则可以执行后续步骤S30。S29，确定内核存在异常。具体的，若累积的请求阻塞时长大于时长阈值，则可以确定内核存在异常，可以将内核进行卸载处理。步骤S30，确定内核未存在异常。具体的，若累积的请求阻塞时长小于时长阈值，则可以确定内核未出现异常。对于步骤S21-步骤S30的具体实现方式，可以参见前文实施例所描述的内容，这里将不再进行赘述，对于其带来的有益效果，这里也将不再进行赘述。进一步地，请参见图12，图12是本申请实施例提供的一种数据处理装置的结构示意图。该数据处理装置可以是运行于计算机设备中的一个计算机程序，例如该数据处理装置为一个应用软件；该数据处理装置可以用于执行图3所示的方法。如图12所示，该数据处理装置1可以包括：文件读取模块11、请求检测模块12、异常确定模块13以及内核卸载模块14。文件读取模块11，用于在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求；请求检测模块12，用于对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态；异常确定模块13，用于在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常；内核卸载模块14，用于对内核进行卸载处理。其中，文件读取模块11、请求检测模块12、异常确定模块13以及内核卸载模块14的具体实现方式，可以参见上述图3所对应实施例中步骤S101-步骤S103的描述，这里将不再进行赘述。在一个实施例中，请求检测模块12对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：获取请求记录文件中具有最小发送时间戳的访问请求，将请求记录文件中具有最小发送时间戳的访问请求，确定为目标内核检测时刻对应的目标最早访问请求；将目标内核检测时刻的上一个内核检测时刻，确定为目标内核检测时刻的历史内核检测时刻；获取历史内核检测时刻对应的历史最早访问请求，根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，确定请求记录文件中访问请求的请求等待状态。在一个实施例中，请求检测模块12根据目标内核检测时刻对应的目标最早访问请求以及历史内核检测时刻对应的历史最早访问请求，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：将目标最早访问请求与历史最早访问请求进行比较；若确定目标最早访问请求与历史最早访问请求相同，则基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态；若确定目标最早访问请求与历史最早访问请求不同，则确定请求记录文件中访问请求的请求等待状态为合理等待状态。在一个实施例中，请求检测模块12基于目标内核检测时刻与历史内核检测时刻之间的时间段，确定请求记录文件中访问请求的请求等待状态的具体实现方式，包括：确定目标内核检测时刻与历史内核检测时刻之间的时间段；将目标内核检测时刻与历史内核检测时刻之间的时间段，确定为内核在目标内核检测时刻时的增量阻塞时长；获取内核在历史内核检测时刻时的历史请求阻塞时长，将增量阻塞时长与历史请求阻塞时长进行相加运算处理，得到内核在目标内核检测时刻时的目标请求阻塞时长；在目标请求阻塞时长大于时长阈值时，确定请求记录文件中访问请求的请求等待状态为持续异常等待状态。在一个实施例中，内核卸载模块14对内核进行卸载处理的具体实现方式，包括：获取内核所对应的内核版本；按照内核版本所属的版本区间，确定内核的内核卸载规则；按照内核卸载规则对内核进行卸载处理。在一个实施例中，内核卸载模块14按照内核版本所属的版本区间，确定内核的内核卸载规则的具体实现方式，包括：在内核版本所属的版本区间为第一区间时，将配置卸载规则集合中的低版本卸载规则确定为内核的内核卸载规则；在内核版本所属的版本区间为第二区间时，将配置卸载规则集合中的高版本卸载规则确定为内核的内核卸载规则；第一区间低于第二区间。在一个实施例中，内核卸载规则为低版本卸载规则；请求记录文件中包含访问请求Si，i为正整数；内核卸载模块14按照内核卸载规则对内核进行卸载处理的具体实现方式，包括：按照低版本卸载规则将访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求成功状态；当确定请求记录文件中，每个访问请求的请求状态均为请求成功状态时，将请求记录文件中包含的访问请求进行清空处理；在确定请求记录文件中未包含访问请求时，通过内核卸载指令对内核进行卸载处理。在一个实施例中，内核卸载模块14按照低版本卸载规则将访问请求Si进行请求设置处理的具体实现方式，包括：按照低版本卸载规则，获取访问请求Si的请求标识；获取低版本卸载规则对应的第一请求终止逻辑代码，根据第一请求终止逻辑代码与访问请求Si的请求标识，生成针对访问请求Si的第一请求终止命令；按照第一请求终止命令，将请求记录文件中的访问请求Si的请求执行状态设置为执行完成状态，将访问请求Si的完成码设置为第一完成码；第一完成码用于指示访问请求Si已正常执行完成。在一个实施例中，内核卸载规则为高版本卸载规则；请求记录文件中包含访问请求Si，i为正整数；内核卸载模块14按照内核卸载规则对内核进行卸载处理的具体实现方式，包括：按照高版本卸载规则将访问请求Si进行请求设置处理，将请求设置处理后的访问请求Si的请求状态确定为请求失败状态；当确定请求记录文件中，每个访问请求的请求状态均为请求失败状态时，将请求记录文件中包含的访问请求进行清空处理；在确定请求记录文件中未包含访问请求时，通过内核卸载指令对内核进行卸载处理。在一个实施例中，内核卸载模块14按照高版本卸载规则将访问请求Si进行请求设置处理的具体实现方式，包括：按照高版本卸载规则，获取访问请求Si的请求标识；获取高版本卸载规则对应的第二请求终止逻辑代码，根据第二请求终止逻辑代码与访问请求Si的请求标识，生成针对访问请求Si的第二请求终止命令；按照第二请求终止命令，将请求记录文件中的访问请求Si的请求执行状态设置为执行失败状态，将访问请求Si的完成码设置为第二完成码；第二完成码用于指示访问请求Si未正常执行完成。在一个实施例中，内核部署于应用服务器中；在异常确定模块13确定内核存在异常之后，数据处理装置1还包括：集合确定模块15、异常内核确定模块16、运行属性确定模块17以及信息推送模块18。集合确定模块15，用于将应用服务器所部署的每个内核均确定为部署内核，得到部署内核集合；异常内核确定模块16，用于将部署内核集合中在目标内核检测时刻时存在异常的部署内核，确定为异常内核；运行属性确定模块17，用于基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性；信息推送模块18，用于在分布式存储系统的系统运行属性为异常运行属性时，将针对分布式存储系统的故障警示信息推送至分布式存储系统的系统维护对象，以使系统维护对象基于故障警示信息对分布式存储系统进行系统维护处理。其中，集合确定模块15、异常内核确定模块16、运行属性确定模块17以及信息推送模块18的具体实现方式，可以参见上述图10所对应实施例中步骤S201-步骤S204的描述，这里将不再进行赘述。在一个实施例中，运行属性确定模块17基于部署内核集合中包含的异常内核的第一数量，确定分布式存储系统的系统运行属性的具体实现方式，包括：统计部署内核集合中包含的异常内核的第一数量，以及部署内核集合中包含的部署内核的第二数量；确定第一数量与第二数量之间的数量比值；若数量比值大于比值阈值，则确定分布式存储系统的系统运行属性为异常运行属性；若数量比值小于比值阈值，则确定分布式存储系统的系统运行属性为正常运行属性。在本申请实施例中，通过定期自动检测内核是否存在异常的方式，可以针对性且及时确定出存在异常的内核，由此可以针对性地且及时地将存在异常的内核进行卸载处理，无需一刀切地强重启物理服务器，可以在保护物理服务器上的正常运行的应用进程继续正常运行的同时，将存在异常的内核所指示的相关应用进程进行及时终止。此外，本申请为不同版本的内核，配置不同的内核卸载规则，从而可以基于内核版本的高低来减少因为内核卸载而造成的文件系统损失。进一步地，请参见图13，图13是本申请实施例提供的一种计算机设备的结构示意图。如图13所示，上述计算机设备8000可以包括：处理器8001，网络接口8004和存储器8005，此外，上述计算机设备8000还包括：用户接口8003，和至少一个通信总线8002。其中，通信总线8002用于实现这些组件之间的连接通信。其中，用户接口8003可以包括显示屏、键盘，可选用户接口8003还可以包括标准的有线接口、无线接口。网络接口8004可选的可以包括标准的有线接口、无线接口。存储器8005可以是高速RAM存储器，也可以是非不稳定的存储器，例如至少一个磁盘存储器。存储器8005可选的还可以是至少一个位于远离前述处理器8001的存储装置。如图13所示，作为一种计算机可读存储介质的存储器8005中可以包括操作系统、网络通信模块、用户接口模块以及设备控制应用程序。在图13所示的计算机设备8000中，网络接口8004可提供网络通讯功能；而用户接口8003主要用于为用户提供输入的接口；而处理器8001可以用于调用存储器8005中存储的设备控制应用程序，以实现：在到达目标内核检测时刻时，读取关于内核的请求记录文件；请求记录文件记录有通过内核访问分布式存储系统中块存储组件的访问请求；对请求记录文件中的访问请求进行请求检测处理，确定请求记录文件中访问请求的请求等待状态；在请求记录文件中访问请求的请求等待状态为持续异常等待状态时，确定内核存在异常，对内核进行卸载处理。应当理解，本申请实施例中所描述的计算机设备8000可执行前文图3到图10所对应实施例中对该数据处理方法的描述，也可执行前文图12所对应实施例中对该数据处理装置1的描述，在此不再赘述。另外，对采用相同方法的有益效果描述，也不再进行赘述。此外，这里需要指出的是：本申请实施例还提供了一种计算机可读存储介质，且上述计算机可读存储介质中存储有前文提及的数据处理的计算机设备8000所执行的计算机程序，且上述计算机程序包括程序指令，当上述处理器执行上述程序指令时，能够执行前文图3到图10所对应实施例中对上述数据处理方法的描述，因此，这里将不再进行赘述。另外，对采用相同方法的有益效果描述，也不再进行赘述。对于本申请所涉及的计算机可读存储介质实施例中未披露的技术细节，请参照本申请方法实施例的描述。上述计算机可读存储介质可以是前述任一实施例提供的数据处理装置或者上述计算机设备的内部存储单元，例如计算机设备的硬盘或内存。该计算机可读存储介质也可以是该计算机设备的外部存储设备，例如该计算机设备上配备的插接式硬盘，智能存储卡，安全数字卡，闪存卡等。进一步地，该计算机可读存储介质还可以既包括该计算机设备的内部存储单元也包括外部存储设备。该计算机可读存储介质用于存储该计算机程序以及该计算机设备所需的其他程序和数据。该计算机可读存储介质还可以用于暂时地存储已经输出或者将要输出的数据。本申请的一个方面，提供了一种计算机程序产品，该计算机程序产品包括计算机程序，该计算机程序存储在计算机可读存储介质中。计算机设备的处理器从计算机可读存储介质读取该计算机程序，处理器执行该计算机程序，使得该计算机设备执行本申请实施例中一方面提供的方法。本申请实施例的说明书和权利要求书及附图中的术语“第一”、“第二”等是用于区别不同对象，而非用于描述特定顺序。此外，术语“包括”以及它们任何变形，意图在于覆盖不排他的包含。例如包含了一系列步骤或单元的过程、方法、装置、产品或设备没有限定于已列出的步骤或模块，而是可选地还包括没有列出的步骤或模块，或可选地还包括对于这些过程、方法、装置、产品或设备固有的其他步骤单元。本领域普通技术人员可以意识到，结合本文中所公开的实施例描述的各示例的单元及算法步骤，能够以电子硬件、计算机软件或者二者的结合来实现，为了清楚地说明硬件和软件的可互换性，在上述说明中已经按照功能一般性地描述了各示例的组成及步骤。这些功能究竟以硬件还是软件方式来执行，取决于技术方案的特定应用和设计约束条件。专业技术人员可以对每个特定的应用来使用不同方法来实现所描述的功能，但是这种实现不应认为超出本申请的范围。本申请实施例提供的方法及相关装置是参照本申请实施例提供的方法流程图和/或结构示意图来描述的，具体可由计算机程序指令实现方法流程图和/或结构示意图的每一流程和/或方框、以及流程图和/或方框图中的流程和/或方框的结合。这些计算机程序指令可提供到通用计算机、专用计算机、嵌入式处理机或其他可编程数据处理设备的处理器以产生一个机器，使得通过计算机或其他可编程数据处理设备的处理器执行的指令产生用于实现在流程图一个流程或多个流程和/或结构示意图一个方框或多个方框中指定的功能的装置。这些计算机程序指令也可存储在能引导计算机或其他可编程数据处理设备以特定方式工作的计算机可读存储器中，使得存储在该计算机可读存储器中的指令产生包括指令装置的制造品，该指令装置实现在流程图一个流程或多个流程和/或结构示意图一个方框或多个方框中指定的功能。这些计算机程序指令也可装载到计算机或其他可编程数据处理设备上，使得在计算机或其他可编程设备上执行一系列操作步骤以产生计算机实现的处理，从而在计算机或其他可编程设备上执行的指令提供用于实现在流程图一个流程或多个流程和/或结构示意一个方框或多个方框中指定的功能的步骤。以上所揭露的仅为本申请较佳实施例而已，当然不能以此来限定本申请之权利范围，因此依本申请权利要求所作的等同变化，仍属本申请所涵盖的范围。

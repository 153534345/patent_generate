标题title
卷积运算的优化方法、装置及处理器
摘要abst
本申请涉及一种卷积运算的优化方法、装置及处理器，处理器包括一级缓存，该方法包括：在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；将所述左矩阵划分为多个加载矩阵，所述加载矩阵的尺寸基于所述一级缓存的容量确定；将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算；将所述多个加载矩阵对应的计算结果累加，得到所述卷积运算的结果，不需要增加输入张量的存储空间，解决了相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题。
权利要求书clms
1.一种卷积运算的优化方法，应用于处理器，所述处理器包括一级缓存，其特征在于，所述方法包括：在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；将所述左矩阵划分为多个加载矩阵，所述加载矩阵的尺寸基于所述一级缓存的容量确定；将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算；将所述多个加载矩阵对应的计算结果累加，得到所述卷积运算的结果。2.根据权利要求1所述的方法，其特征在于，所述处理器包括寄存器，所述将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算包括：将加载至所述一级缓存的加载矩阵划分为至少一个行向量；对所述行向量和所述右矩阵分别执行寻址操作，得到多个行数据和矩阵数据并存入所述寄存器；基于预先设置的对应关系，将所述行数据和矩阵数据对应相乘并累加，得到所述行向量对应的计算结果；将所述至少一个行向量对应的计算结果累加，得到所述加载矩阵对应的计算结果。3.根据权利要求2所述的方法，其特征在于，所述加载矩阵的行数为所述输入张量的通道数，所述对所述行向量和所述右矩阵分别执行寻址操作，得到多个行数据和矩阵数据包括：基于所述加载矩阵的列数、所述卷积运算的步长、所述输入张量的宽度及所述卷积运算的输出张量的高度，确定所述行向量的寻址次数；基于所述寻址次数，对所述行向量进行多次寻址，获取对应的多个行数据组，所述行数据组中的行数据数量为所述卷积核的宽度的整数倍；基于所述寻址次数，对所述右矩阵进行多次寻址，获取对应的多个矩阵数据组，所述矩阵数据组与所述行数据组一一对应，且所述矩阵数据组中矩阵数据的数量与对应的行数据组中行数据的数量相等。4.根据权利要求3所述的方法，其特征在于，所述基于所述寻址次数，对所述行向量进行多次寻址，获取对应的多个行数据组包括：基于所述输入张量和输出张量的宽度，以及所述卷积运算的步长，获取每次寻址对应的地址偏移量；基于所述行向量的首地址和所述地址偏移量，获取每次寻址对应的行数据组的首地址；基于所述行数据组的首地址和所述卷积核的宽度，获取每次寻址对应的行数据组。5.根据权利要求4所述的方法，其特征在于，所述基于所述行数据组的首地址和所述卷积核的宽度，获取每次寻址对应的行数据组包括：基于所述行数据组的首地址和所述卷积核的宽度，得到所述行数据组中的首个数据块；确定所述数据块的地址是否超出所述行向量的边界地址；在超出所述边界地址的情况下，舍弃所述数据块并结束本次寻址；在未超出所述边界地址的情况下，依次读取所述行向量中的所有数据块，直至到达所述边界地址。6.根据权利要求5所述的方法，其特征在于，所述边界地址基于所述行数据组的首地址、所述输入张量和输出张量的宽度、所述卷积运算的步长，以及所述寻址次数确定。7.根据权利要求3所述的方法，其特征在于，所述基于预先设置的对应关系，将所述行数据和矩阵数据对应相乘并累加，得到所述行向量对应的计算结果包括：将所述行数据组中的行数据与对应的矩阵数据组中的矩阵数据一一对应相乘并对乘积进行累加，得到所述行数据组对应的累加值；将多个行数据组对应的累加值依次排列，得到所述行向量对应的计算结果数组或计算结果矩阵。8.根据权利要求1所述的方法，其特征在于，所述在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵包括：将所述输入张量重排为左矩阵，所述左矩阵的行数为所述输入张量的通道数；所述左矩阵的列数为所述输入张量的宽度与高度的乘积；将所述卷积核重排为右矩阵，所述右矩阵的数量为所述输入张量的通道数，所述右矩阵的行数为所述卷积核的宽度与高度的乘积，所述右矩阵的列数为所述卷积核的数量。9.一种卷积运算的优化装置，应用于处理器，所述处理器包括一级缓存，其特征在于，所述装置包括：转换模块，用于在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；划分模块，用于将所述左矩阵划分为多个加载矩阵，所述加载矩阵的尺寸基于所述一级缓存的容量确定；计算模块，用于将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算；累加模块，用于将所述多个加载矩阵对应的计算结果累加，得到所述卷积运算的结果。10.一种处理器，其特征在于，所述处理器包括一级缓存，以及如权利要求9所述的卷积运算的优化装置。
说明书desc
技术领域本申请涉及硬件计算技术领域，特别是涉及一种卷积运算的优化方法、装置及处理器。背景技术卷积神经网络成功应用于图像分类、目标检测和视频处理等计算机视觉领域，其主要的计算在于卷积层中的多卷积核多通道的卷积运算。卷积运算是一种典型的计算密集型问题，因此对实现代码进行细致调优以充分利用硬件资源是十分重要的。由于众多硬件算子库中对通用矩阵乘进行了大量的优化工作，因此在卷积算子实现中，目前使用最广泛的方法是将图像转换为列矩阵，对矩阵乘计算再复用优化程度很高的GEMM库进行计算实现。然而，在众多应用场景中，卷积核在输入数据上有大量重叠区域，通过img2col算法转换会大大增加输入数据的内存占用，其将输入图像分解为更大的列矩阵，这很容易引起空间爆炸，嵌入式等端边系统的内存很难满足；另一方面，转换过程中的冗余数据加载也在很大程度上降低了数据内存的局部性，使得卷积算子的性能损失较大。针对现有技术中将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题，目前还没有提出有效的解决方案。发明内容在本实施例中提供了一种卷积运算的优化方法、装置及处理器，以解决相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题。第一个方面，在本实施例中提供了一种卷积运算的优化方法，应用于处理器，所述处理器包括一级缓存，所述方法包括：在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；将所述左矩阵划分为多个加载矩阵，所述加载矩阵的尺寸基于所述一级缓存的容量确定；将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算；将所述多个加载矩阵对应的计算结果累加，得到所述卷积运算的结果。在其中的一些实施例中，所述处理器包括寄存器，所述将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算包括：将加载至所述一级缓存的加载矩阵划分为至少一个行向量；对所述行向量和所述右矩阵分别执行寻址操作，得到多个行数据和矩阵数据并存入所述寄存器；基于预先设置的对应关系，将所述行数据和矩阵数据对应相乘并累加，得到所述行向量对应的计算结果；将所述至少一个行向量对应的计算结果累加，得到所述加载矩阵对应的计算结果。在其中的一些实施例中，所述加载矩阵的行数为所述输入张量的通道数，所述对所述行向量和所述右矩阵分别执行寻址操作，得到多个行数据和矩阵数据包括：基于所述加载矩阵的列数、所述卷积运算的步长、所述输入张量的宽度及所述卷积运算的输出张量的高度，确定所述行向量的寻址次数；基于所述寻址次数，对所述行向量进行多次寻址，获取对应的多个行数据组，所述行数据组中的行数据数量为所述卷积核的宽度的整数倍；基于所述寻址次数，对所述右矩阵进行多次寻址，获取对应的多个矩阵数据组，所述矩阵数据组与所述行数据组一一对应，且所述矩阵数据组中矩阵数据的数量与对应的行数据组中行数据的数量相等。在其中的一些实施例中，所述基于所述寻址次数，对所述行向量进行多次寻址，获取对应的多个行数据组包括：基于所述输入张量和输出张量的宽度，以及所述卷积运算的步长，获取每次寻址对应的地址偏移量；基于所述行向量的首地址和所述地址偏移量，获取每次寻址对应的行数据组的首地址；基于所述行数据组的首地址和所述卷积核的宽度，获取每次寻址对应的行数据组。在其中的一些实施例中，所述基于所述行数据组的首地址和所述卷积核的宽度，获取每次寻址对应的行数据组包括：基于所述行数据组的首地址和所述卷积核的宽度，得到所述行数据组中的首个数据块；确定所述数据块的地址是否超出所述行向量的边界地址；在超出所述边界地址的情况下，舍弃所述数据块并结束本次寻址；在未超出所述边界地址的情况下，依次读取所述行向量中的所有数据块，直至到达所述边界地址。在其中的一些实施例中，所述边界地址基于所述行数据组的首地址、所述输入张量和输出张量的宽度、所述卷积运算的步长，以及所述寻址次数确定。在其中的一些实施例中，所述基于预先设置的对应关系，将所述行数据和矩阵数据对应相乘并累加，得到所述行向量对应的计算结果包括：将所述行数据组中的行数据与对应的矩阵数据组中的矩阵数据一一对应相乘并对乘积进行累加，得到所述行数据组对应的累加值；将多个行数据组对应的累加值依次排列，得到所述行向量对应的计算结果数组或计算结果矩阵。在其中的一些实施例中，所述在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵包括：将所述输入张量重排为左矩阵，所述左矩阵的行数为所述输入张量的通道数；所述左矩阵的列数为所述输入张量的宽度与高度的乘积；将所述卷积核重排为右矩阵，所述右矩阵的数量为所述输入张量的通道数，所述右矩阵的行数为所述卷积核的宽度与高度的乘积，所述右矩阵的列数为所述卷积核的数量。第二个方面，在本实施例中提供了一种卷积运算的优化装置，应用于处理器，所述处理器包括一级缓存，所述装置包括：转换模块，用于在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；划分模块，用于将所述左矩阵划分为多个加载矩阵，所述加载矩阵的尺寸基于所述一级缓存的容量确定；计算模块，用于将所述多个加载矩阵依次从所述内存加载至所述一级缓存，与所述右矩阵执行矩阵乘计算；累加模块，用于将所述多个加载矩阵对应的计算结果累加，得到所述卷积运算的结果。第三个方面，在本实施例中提供了一种处理器，所述处理器包括一级缓存，以及如第二个方面所述的卷积运算的优化装置。与相关技术相比，在本实施例中提供的卷积运算的优化方法，通过在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵，不需要对输入张量进行滑动匹配，而是直接将输入张量在内存中重排为二维矩阵，该过程不需要增加输入张量的存储空间；通过将左矩阵划分为多个加载矩阵，该加载矩阵的尺寸基于一级缓存的容量确定，加载数据没有重复且对每次加载的数据块进行全量计算；通过将多个加载矩阵依次从内存加载至一级缓存，与右矩阵执行矩阵乘计算，最大限度利用内存的局部性，将卷积运算转换为矩阵乘计算以提高计算效率；通过将多个加载矩阵对应的计算结果累加，得到卷积运算的结果，解决了相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题。本申请的一个或多个实施例的细节在以下附图和描述中提出，以使本申请的其他特征、目的和优点更加简明易懂。附图说明此处所说明的附图用来提供对本申请的进一步理解，构成本申请的一部分，本申请的示意性实施例及其说明用于解释本申请，并不构成对本申请的不当限定。在附图中：图1是本申请一些实施例的卷积运算的优化方法的计算机硬件结构框图；图2是本申请一些实施例的卷积运算的优化方法的流程图；图3是本申请一些实施例的输入张量、卷积核及输出张量的示意图；图4是本申请一些实施例的加载矩阵与右矩阵执行矩阵乘计算的流程图；图5是本申请一些实施例的加载矩阵与右矩阵执行矩阵乘计算的示意图；图6是本申请一些实施例的对行向量和右矩阵执行寻址操作的流程图；图7是本申请一些实施例的对行向量寻址获取行数据组的流程图；图8是本申请一些实施例的基于行数据组的首地址和卷积核宽度获取行数据组的流程图；图9是本申请一些实施例的行数据和矩阵数据进行乘累加得到计算结果的流程图；图10是本申请一些实施例的输入张量和卷积核内存重排的流程图；图11是本申请一些具体实施例的卷积运算的优化方法的流程图；图12是本申请一些具体实施例的对行向量和右矩阵执行寻址和乘累加操作的示意图；图13是本申请一些具体实施例的卷积运算的优化装置的结构框图。具体实施方式为更清楚地理解本申请的目的、技术方案和优点，下面结合附图和实施例，对本申请进行了描述和说明。应当理解，此处描述的具体实施例仅仅用以解释本申请，并不用于限定本申请。除另作定义外，本申请所涉及的技术术语或者科学术语应具有本申请所属技术领域具备一般技能的人所理解的一般含义。在本申请中的“一”、“一个”、“一种”、“该”、“这些”等类似的词并不表示数量上的限制，它们可以是单数或者复数。在本申请中所涉及的术语“包括”、“包含”、“具有”及其任何变体，其目的是涵盖不排他的包含；例如，包含一系列步骤或模块的过程、方法和系统、产品或设备并未限定于列出的步骤或模块，而可包括未列出的步骤或模块，或者可包括这些过程、方法、产品或设备固有的其他步骤或模块。在本申请中所涉及的“连接”、“相连”、“耦接”等类似的词语并不限定于物理的或机械连接，而可以包括电气连接，无论是直接连接还是间接连接。在本申请中所涉及的“多个”是指两个或两个以上。“和/或”描述关联对象的关联关系，表示可以存在三种关系，例如，“A和/或B”可以表示：单独存在A，同时存在A和B，单独存在B这三种情况。通常情况下，字符“/”表示前后关联的对象是一种“或”的关系。在本申请中所涉及的术语“第一”、“第二”、“第三”等，只是对相似对象进行区分，并不代表针对对象的特定排序。本申请实施例提供的卷积运算的优化方法，可以在服务器、计算机、终端或者类似的运算装置的处理器中执行。图1是本申请一些实施例的卷积运算的优化方法的计算机硬件结构框图。如图1所示，处理器是指图中示出的CPU，包括2个核心Core，每个核心Core包括二级缓存、一级数据缓存、一级指令缓存和寄存器。其中，寄存器保存着从一级数据缓存和一级指令缓存中取出的数据和指令，一级数据缓存和一级指令缓存保存着从二级缓存中取出的数据和指令；以此类推，三级缓存保存着从内存中取出的数据和指令。CPU与内存之间通过BUS总线连接。本领域普通技术人员可以理解，图1所示的结构仅为示意，其并不对上述处理器和内存的结构造成限制。例如，处理器还可包括比图1中所示更多或者更少的计算核心，或者一级缓存、二级缓存或三级缓存具有与图1所示出的不同配置。在本实施例中提供了一种卷积运算的优化方法，应用于处理器，处理器包括一级缓存。图2是本申请一些实施例的卷积运算的优化方法的流程图，如图2所示，该流程包括如下步骤：步骤S201，在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵。图3是本申请一些实施例的输入张量、卷积核及输出张量的示意图，如图3所示，对维度为Ric×ih×iw的输入张量31，维度为Roc×ic×kh×kw的卷积核32，执行多通道多卷积核的卷积计算，得到维度为Roc×oh×ow的输出张量33。其中，ic为输入张量31的通道数，ih为输入张量31的高度，iw为输入张量31的宽度。oc为卷积核32的数量，也是输出张量33的通道数，卷积核32的宽度kw和高度kh的值均为k。oh为输出张量33的高度，ow为输出张量33的宽度。以上参数值均已知。将输入张量31进行二维展开，转化为ic×ih×iw的左矩阵存储在内存中。例如，左矩阵的行数可以为ic，列数可以为ih×iw。类似地，将卷积核32进行二维展开，转化为oc×ic×k×k的右矩阵存储在内存中，例如，右矩阵可以为ic个行数为k2，列数为oc的矩阵。步骤S202，将左矩阵划分为多个加载矩阵，加载矩阵的尺寸基于一级缓存的容量确定。本实施例中，将卷积运算转化为矩阵乘运算做进一步处理。在GEMM计算过程中，基于一级缓存的容量来确定左矩阵每次加载的数据量，并对每次缓存加载的数据块进行全量计算。一级缓存可以是一级数据缓存。每次加载的数据容量完全等于卸载的数据容量，即左矩阵的数据加载没有重复。步骤S203，将多个加载矩阵依次从内存加载至一级缓存，与右矩阵执行矩阵乘计算。左矩阵是由输入张量直接重排生成，与右矩阵各元素并没有基于卷积运算的规则顺序对应。因此，在进行矩阵乘运算之前，可通过对加载矩阵和右矩阵进行寻址操作来保证左右矩阵元素对应相乘的正确性。步骤S204，将多个加载矩阵对应的计算结果累加，得到卷积运算的结果。按照左矩阵中各加载矩阵的排列顺序，依次将各个加载矩阵加载到一级缓存中。在一级缓存中将加载矩阵作为计算域，通过寻址操作将加载矩阵和右矩阵的元素对应相乘，得到对应的结果矩阵。完成该加载矩阵的计算后，将该加载矩阵从一级缓存卸载，并加载下一个加载矩阵再次计算，并将得到的结果矩阵与之前的结果矩阵累加，直至所有加载矩阵计算完成，得到的结果矩阵即为卷积运算的结果。通过步骤S201~S204，通过在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵，不需要对输入张量进行滑动匹配，而是直接将输入张量在内存中重排为二维矩阵，该过程不需要增加输入张量的存储空间；通过将左矩阵划分为多个加载矩阵，该加载矩阵的尺寸基于一级缓存的容量确定，加载数据没有重复且对每次加载的数据块进行全量计算；通过将多个加载矩阵依次从内存加载至一级缓存，与右矩阵执行矩阵乘计算，最大限度利用内存的局部性，将卷积运算转换为矩阵乘计算以提高计算效率；通过将多个加载矩阵对应的计算结果累加，得到卷积运算的结果，解决了相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题，减少了数据读写操作的性能损耗，提高了运算效率。在一些实施例中，处理器包括寄存器，图4是本申请一些实施例的加载矩阵与右矩阵执行矩阵乘计算的流程图，如图4所示，该流程包括如下步骤：步骤S401，将加载至一级缓存的加载矩阵划分为至少一个行向量。图5是本申请一些实施例的加载矩阵与右矩阵执行矩阵乘计算的示意图，如图5所示，将维度为Ric×ih×iw的输入张量转换为行数为ic，列数为ih×iw的左矩阵51。假设计算域在ic维度上是全载，在ih×iw维度上加载系数是α，即一次加载和卸载的数据量是ic×α×，即加载矩阵52的行数为ic，列数为α×，并将一个加载矩阵所在的存储空间作为计算域。在执行矩阵乘计算前，将加载矩阵划分为ic个行向量，每个行向量包括α×个数据元素。步骤S402，对行向量和右矩阵分别执行寻址操作，得到多个行数据和矩阵数据并存入寄存器。将ic维度作为通用矩阵乘问题的规约维，也即GEMM最外层进行累加处理的维度，对于结果矩阵来讲，如图5所示，是将ic个维度为的结果矩阵54进行累加获得最终结果。因此，对于每个行向量中的规模更小的GEMM运算，可通过寻址处理得到正确位置的行数据，从而进行正确的矩阵乘计算。另一方面，还可以对每个行数据对应的卷积核进行寻址，得到对应的矩阵数据。将行数据和矩阵数据存入寄存器，便于执行GEMM操作。步骤S403，基于预先设置的对应关系，将行数据和矩阵数据对应相乘并累加，得到行向量对应的计算结果。行向量的维度为，而右矩阵53的维度为，要获得维度为的结果矩阵54，假设右矩阵对规约维k2是进行全载，则可以在维度上将行向量处理为的形式，即通过寻址找到行向量中特定位置的行数据，与右矩阵中对应的k2个矩阵数据对应相乘并累加，得到该行向量对应的计算结果。步骤S404，将至少一个行向量对应的计算结果累加，得到加载矩阵对应的计算结果。加载矩阵包括ic个行向量，将每个行向量对应的计算结果累加，得到该加载矩阵对应的计算结果。通过步骤S401~S404，通过将加载至一级缓存的加载矩阵划分为至少一个行向量，对每个行向量进行逐行寻址，以统一规约维并达到非规约维与结果矩阵对齐的效果；通过对行向量和右矩阵分别执行寻址操作，得到多个行数据和矩阵数据并存入寄存器，减少了数据读写操作的性能损耗；通过基于预先设置的对应关系，将行数据和矩阵数据对应相乘并累加，得到行向量对应的计算结果，保证了矩阵乘计算的正确性；通过将至少一个行向量对应的计算结果累加，得到加载矩阵对应的计算结果，实现了卷积运算到矩阵乘运算的转换，提高了卷积运算的效率。在一些实施例中，加载矩阵的行数为输入张量的通道数，图6是本申请一些实施例的对行向量和右矩阵执行寻址操作的流程图，如图6所示，该流程包括如下步骤：步骤S601，基于加载矩阵的列数、卷积运算的步长、输入张量的宽度及卷积运算的输出张量的高度，确定行向量的寻址次数。进行矩阵乘计算所需要的行数据并不是连续存储的，而右矩阵的矩阵数据尽管是连续存储，但由于左矩阵的分段加载所对应的卷积核元素不同，因此可以通过对行向量和右矩阵的分别寻址，获得对应的数据元素。假设每个行向量的总寻址次数为N，由于加载系数α是根据一级缓存的容量确定的，因此在每次寻址中都是定值，因此N也为定值。假设以行主序进行内存数据排列，则N可通过下式确定：。其中，代表向下取整，%代表求余，ih为输入张量的高度，iw为输入张量的宽度，stride为卷积计算的步长，α为加载矩阵的加载系数，α为加载矩阵的列数，oh为输出张量的高度。步骤S602，基于寻址次数，对行向量进行多次寻址，获取对应的多个行数据组，行数据组中的行数据数量为卷积核的宽度的整数倍。基于寻址次数对同一个行向量进行多次寻址处理，每次寻址获得一个行数据组，且每个行数据组中的行数据数量为卷积核宽度k的整数倍，以满足将行向量处理为形式的要求。根据卷积运算的规则可知，每个行数据组中可以包括一个或多个行数据块，每个行数据块间隔分布，间隔的距离根据卷积运算的步长确定。行数据块的长度等于卷积核的宽度k。步骤S603，基于寻址次数，对右矩阵进行多次寻址，获取对应的多个矩阵数据组，矩阵数据组与行数据组一一对应，且矩阵数据组中矩阵数据的数量与对应的行数据组中行数据的数量相等。右矩阵的寻址次数与行向量的寻址次数N相同。每次寻址获得一个矩阵数据组，该矩阵数据组也包括一个或多个矩阵数据块，与行数据组中的行数据块一一对应，矩阵数据块的长度也等于卷积核的宽度k。右矩阵的内存地址是连续的，因此每次寻址是根据首地址连续寻址k个地址即可得到一个矩阵数据块，且每个矩阵数据块之间也是连续的。而首地址的确定可采用如下方式计算：。其中，i代表行向量序号，j代表寻址次数序号，j≤N，k_addri,j为当前行向量第j次寻址对应的首地址，k_addri-1,j为上个行向量第j次寻址对应的首地址。offset为上个行向量第j次寻址的地址偏移量，也即上个行向量第j次寻址获取的矩阵数据的数量。通过步骤S601~S603，通过基于加载矩阵的列数、卷积运算的步长、输入张量的宽度及卷积运算的输出张量的高度，确定行向量的寻址次数，对行向量进行维度处理，便于后续进行矩阵乘操作；通过基于寻址次数，对行向量进行多次寻址，获取对应的多个行数据组，保证了矩阵乘的左矩阵数据正确性；通过基于寻址次数，对右矩阵进行多次寻址，获取对应的多个矩阵数据组，保证了矩阵乘的右矩阵数据正确性。在一些实施例中，图7是本申请一些实施例的对行向量寻址获取行数据组的流程图，如图7所示，该流程包括如下步骤：步骤S701，基于输入张量和输出张量的宽度，以及卷积运算的步长，获取每次寻址对应的地址偏移量。地址偏移量addrstart可根据如下公式确定：。其中，代表向下取整，%代表求余，n为行向量的寻址次数序号，n=0，1，…，N-1。ow为输出张量的宽度，iw为输入张量的宽度，stride为卷积计算的步长。步骤S702，基于行向量的首地址和地址偏移量，获取每次寻址对应的行数据组的首地址。在行向量的每次寻址过程中，可采用如下公式计算行数据组的首地址：。其中，addri+1为本次寻址的行数据组的首地址，addri为当前行向量的首地址，addrstart为步骤S701中获取的地址偏移量。步骤S703，基于行数据组的首地址和卷积核的宽度，获取每次寻址对应的行数据组。基于行数据组的首地址和卷积核的宽度，对当前行向量进行N次寻址，每次寻址获得一个行数据组。每个行数据组中包括一个或多个行数据块。通过步骤S701~S703，通过基于输入张量和输出张量的宽度，以及卷积运算的步长，获取每次寻址对应的地址偏移量，为后续的寻址提供必要数据；通过基于行向量的首地址和地址偏移量，获取每次寻址对应的行数据组的首地址，作为数据读取的起点；通过基于行数据组的首地址和卷积核的宽度，获取每次寻址对应的行数据组，将行向量转换为满足矩阵乘操作需求的行数据，保证了矩阵乘操作的正确性。在一些实施例中，图8是本申请一些实施例的基于行数据组的首地址和卷积核宽度获取行数据组的流程图，如图8所示，该流程包括如下步骤：步骤S801，基于行数据组的首地址和卷积核的宽度，得到行数据组中的首个数据块。根据行数据组的首地址连续进行k个寻址，k为卷积核的宽度，即可得到当前行数据组的第一个数据块，数据块中包含k个行数据。步骤S802，确定数据块的地址是否超出行向量的边界地址。根据行向量的长度α×可知，读取的最后一个数据地址不能超过边界地址，否则数据无效。边界地址可基于行数据组的首地址、输入张量和输出张量的宽度、卷积运算的步长，以及寻址次数确定。进一步地，边界地址addrj可采用如下公式计算：。其中，代表向下取整，%代表求余，addri为当前行数据组的首地址，且addrj-addri≤ α×；j为当前行数据组对应的寻址次数序号，iw为输入张量的宽度，ow为输出张量的宽度，stride为卷积计算的步长。步骤S803，在超出边界地址的情况下，舍弃数据块并结束本次寻址。如果数据块的地址超出边界地址，则该数据块无效，舍弃数据块并结束本次寻址。步骤S804，在未超出边界地址的情况下，依次读取行向量中的所有数据块，直至到达边界地址。如果数据块的地址未超出边界地址，则数据块有效，并继续读取行向量中的所有数据块，并在每次读取后检查是否超出边界地址。行向量中的各个数据块之间间隔排列，间隔长度等于卷积运算的步长。在步长stride=1的情况下，同一个行向量中依次排列的数据块的首地址等于上一个数据块的首地址加k+1。通过步骤S801~S804，通过基于行数据组的首地址和卷积核的宽度，得到行数据组中的首个数据块，实现行数据的读取；通过确定数据块的地址是否超出行向量的边界地址，验证行数据是否有效；通过在超出边界地址的情况下，舍弃数据块并结束本次寻址，在无效情况下舍弃数据；通过在未超出边界地址的情况下，依次读取行向量中的所有数据块，直至到达边界地址，获取行数据组的所有数据，为后续的矩阵乘计算提供了正确的行数据。在一些实施例中，图9是本申请一些实施例的行数据和矩阵数据进行乘累加得到计算结果的流程图，如图9所示，该流程包括如下步骤：步骤S901，将行数据组中的行数据与对应的矩阵数据组中的矩阵数据一一对应相乘并对乘积进行累加，得到行数据组对应的累加值；经过对行向量和右矩阵的N次寻址，分别得到N个行数据组和N个矩阵数据组，且相同序号的行数据组和矩阵数据组中数据数量相同。例如，第1个行数据组和第1个矩阵数据组中都包含3个数据，第2个行数据组和第2个矩阵数据组中都包含6个数据。将相同序号的行数据组和矩阵数据组中的数据按顺序对应相乘并累加，得到该行数据组对应的累加值。步骤S902，将多个行数据组对应的累加值依次排列，得到行向量对应的计算结果数组或计算结果矩阵。多个行数据组对应的累加值依次排列，如果排列为一维数组，则可以得到该行向量对应的计算结果数组；如果排列为二维矩阵，则可以得到该行向量对应的计算结果矩阵。通过步骤S901~S902，通过将行数据组中的行数据与对应的矩阵数据组中的矩阵数据一一对应相乘并对乘积进行累加，得到行数据组对应的累加值，通过将多个行数据组对应的累加值依次排列，得到行向量对应的计算结果数组或计算结果矩阵，实现了行向量与卷积核的矩阵乘。在一些实施例中，图10是本申请一些实施例的输入张量和卷积核内存重排的流程图，如图10所示，该流程包括如下步骤：步骤S1001，将输入张量重排为左矩阵，左矩阵的行数为输入张量的通道数；左矩阵的列数为输入张量的宽度与高度的乘积。对维度为Ric×ih×iw的输入张量，其中，ic为输入张量的通道数，ih为输入张量的高度，iw为输入张量的宽度。将输入张量进行二维展开，转化为ic×ih×iw的左矩阵存储在内存中，其中左矩阵的行数为ic，列数为ih×iw。步骤S1002，将卷积核重排为右矩阵，右矩阵的数量为输入张量的通道数，右矩阵的行数为卷积核的宽度与高度的乘积，右矩阵的列数为卷积核的数量。对维度为Roc×ic×kh×kw的卷积核张量，其中oc为卷积核的数量，也是输出张量的通道数，卷积核的宽度kw和高度kh的值均为k。将卷积核进行二维展开，转化为oc×ic×k×k的右矩阵存储在内存中，其中，右矩阵可分为ic个行数为k2，列数为oc的矩阵。通过步骤S1001~S1002，通过将输入张量重排为左矩阵，左矩阵的行数为输入张量的通道数；左矩阵的列数为输入张量的宽度与高度的乘积，不需要对输入张量进行滑动匹配，而是直接将输入张量在内存中重排为二维矩阵，该过程不需要增加输入张量的存储空间；通过将卷积核重排为右矩阵，右矩阵的数量为输入张量的通道数，右矩阵的行数为卷积核的宽度与高度的乘积，右矩阵的列数为卷积核的数量，将输入张量的通道数作为规约维进行累加处理，保证了矩阵乘计算的正确性，提高了卷积运算的效率。下面通过具体实施例对本实施例进行描述和说明。图11是本申请一些具体实施例的卷积运算的优化方法的流程图，如图11所示，该流程包括如下步骤：步骤S1101，在内存中将输入张量重排为左矩阵，将卷积核重排为右矩阵；图12是本申请一些具体实施例的卷积运算的优化方法的示意图，如图12所示，对于单通道的4×4输入张量，其16个元素值分别为a~p；单卷积核大小为3×3，其9个元素分别是β~κ；采用填充padding=0，步长stride=1，扩张dilation=1的卷积参数获得2×2的输出矩阵，其4个元素值分别是x~w。步骤S1102，将左矩阵划分为多个加载矩阵，加载矩阵的尺寸基于一级缓存的容量确定；现假设一级缓存容量规划中每次左矩阵的加载量是8，那么以行主序作为内存读写数据规则，在第一次数据加载中左矩阵写入一级缓存的数据为a~h。步骤S1103，将加载至一级缓存的加载矩阵划分为至少一个行向量；本实施例中输入张量通道数ic=1，因此行向量的数量为1。步骤S1104，基于加载矩阵的列数、卷积运算的步长、输入张量的宽度及卷积运算的输出张量的高度，确定行向量的寻址次数；根据下述公式计算寻址次数N：。其中，代表向下取整，%代表求余，ih为输入张量的高度，iw为输入张量的宽度，stride为卷积计算的步长，α为加载矩阵的加载系数，α为加载矩阵的列数，oh为输出张量的高度。本实施例中行向量的N=4，并通过4个寄存器R1~R4分别对行向量寻址后的数据进行存储。图12中通过4行a~h的数据表示行向量a~h的四次寻址；通过4行i~p的数据表示行向量i~p的四次寻址。步骤S1105，基于输入张量和输出张量的宽度，以及卷积运算的步长，获取每次寻址对应的地址偏移量；地址偏移量addrstart可根据如下公式确定：。其中，代表向下取整，%代表求余，n为行向量的寻址次数序号，n=0，1，…，N-1。ow为输出张量的宽度，iw为输入张量的宽度，stride为卷积计算的步长。本实施例中n分别取0、1、2、3时，对应的addrstart为0，1，4，5。即图12中4次寻址的地址偏移量分别为0，1，4，5。步骤S1106，基于行向量的首地址和地址偏移量，获取每次寻址对应的行数据组的首地址；图12中对行向量a~h的4次寻址，其行数据组的首地址分别为a、b、e、f所在地址。步骤S1107，基于行数据组的首地址和卷积核的宽度，依次获取每次寻址对应的行数据组中的数据块，并确定数据块的地址是否超出行向量的边界地址；图12中对行向量a~h的4次寻址，获取的4个行数据组分别是：；；；，对应存入寄存器R1~R4。步骤S1108，在超出边界地址的情况下，舍弃该数据块并结束本次寻址；步骤S1109，在未超出边界地址的情况下，读取行向量中的下一个数据块，直至到达边界地址；步骤S1110，基于寻址次数，对右矩阵进行多次寻址，获取对应的多个矩阵数据组，矩阵数据组与行数据组一一对应，且矩阵数据组中矩阵数据的数量与对应的行数据组中行数据的数量相等；对图12中的卷积核进行寻址，对应得到的4个矩阵数据组分别是：；；；，存入寄存器R0。步骤S1111，将行数据组中的行数据与对应的矩阵数据组中的矩阵数据一一对应相乘并对乘积进行累加，得到行数据组对应的累加值；；；；。步骤S1112，将多个行数据组对应的累加值依次排列，得到行向量对应的计算结果数组或计算结果矩阵；从图12中可以看到，数据b、c、e、h进行了两次寄存器载入，数据f、g进行了四次寄存器数据载入，其他数据仅进行了一次寄存器载入。可以看出，x1、y1、z1、w1均为最终计算结果的部分和，x1、y1为卷积核感受野的前两行数据计算结果，z1、w1为卷积核感受野的第一行数据计算结果。可将本次数据载入所计算的结果放入累加器中，等待其他数据部分的计算完成进行累加从而获得完整的卷积计算结果。步骤S1113，将至少一个行向量对应的计算结果累加，得到加载矩阵对应的计算结果；步骤S1114，将多个加载矩阵对应的计算结果累加，得到卷积运算的结果。在一次数据计算完成后，对输入数据进行旧数据换出和新数据载入操作。在图12中，输入数据中的a~h被换出，重新载入剩余数据i~p；根据步骤S1103~S1113，对载入的新输入数据完成矩阵乘计算，得到结果中剩余的部分和：；；；。完成如下累加器上的计算即可获得完整的卷积计算结果：。通过步骤S1101~S1114，通过内存重排，在不增加冗余数据和内存空间占用的情况下将输入张量和卷积核转换为二维矩阵；基于一级缓存的容量确定加载矩阵的尺寸并对每次加载的数据块进行全量计算，增加了内存的局部性，减少了数据读写操作的性能损耗；通过将加载矩阵划分为多个行向量，对每个行向量进行多次寻址，以统一规约维并达到非规约维与结果矩阵对齐的效果；对右矩阵执行与行向量对应次数的寻址，通过分别寻址找到对应的矩阵乘数据，保证了矩阵乘运算的结果正确性；通过边界地址的计算得到每个行向量完整的行数据；通过将至少一个行向量对应的计算结果累加，得到加载矩阵对应的计算结果，将多个加载矩阵对应的计算结果累加，得到卷积运算的结果，实现了卷积运算到矩阵乘运算的转换，提高了卷积运算的效率。需要说明的是，在上述流程中或者附图的流程图中示出的步骤可以在诸如一组计算机可执行指令的计算机系统中执行，并且，虽然在流程图中示出了逻辑顺序，但是在某些情况下，可以以不同于此处的顺序执行所示出或描述的步骤。在一些实施例中，本申请还提供了一种卷积运算的优化装置，该装置应用于处理器，处理器包括一级缓存。该卷积运算的优化装置用于实现上述实施例及优选实施方式，已经进行过说明的不再赘述。以下所使用的术语“模块”、“单元”、“子单元”等可以实现预定功能的软件和/或硬件的组合。在一些实施例中，图13是本实施例的卷积运算的优化装置的结构框图，如图13所示，该装置包括：转换模块1301，用于在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵；划分模块1302，用于将左矩阵划分为多个加载矩阵，加载矩阵的尺寸基于一级缓存的容量确定；计算模块1303，用于将多个加载矩阵依次从内存加载至一级缓存，与右矩阵执行矩阵乘计算；累加模块1304，用于将多个加载矩阵对应的计算结果累加，得到卷积运算的结果。本实施例的卷积运算的优化装置，通过转换模块1301在内存中将卷积运算的输入张量重排为左矩阵，将卷积核重排为右矩阵，不需要对输入张量进行滑动匹配，而是直接将输入张量在内存中重排为二维矩阵，该过程不需要增加输入张量的存储空间；通过划分模块1302将左矩阵划分为多个加载矩阵，该加载矩阵的尺寸基于一级缓存的容量确定，加载数据没有重复且对每次加载的数据块进行全量计算；通过计算模块1303将多个加载矩阵依次从内存加载至一级缓存，与右矩阵执行矩阵乘计算，最大限度利用内存的局部性，将卷积运算转换为矩阵乘计算以提高计算效率；通过累加模块1304将多个加载矩阵对应的计算结果累加，得到卷积运算的结果，解决了相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题，减少了数据读写操作的性能损耗，提高了运算效率。此外，本实施例还提供了一种处理器，该处理器包括一级缓存，以及上述实施例中的卷积运算的优化装置。本实施例的处理器，通过卷积运算的优化装置对卷积运算的输入张量和卷积核进行重排处理，并将处理后的矩阵数据加载至一级缓存转换为矩阵乘运算，得到卷积运算的结果，重排过程不需要增加输入张量的存储空间；最大限度利用内存的局部性，将卷积运算转换为矩阵乘计算，解决了相关技术中存在的将卷积运算转换为矩阵乘计算过程中产生的冗余数据导致内存占用增加和内存局部性较低的问题，减少了数据读写操作的性能损耗，提高了运算效率。需要说明的是，在本实施例中的具体示例可以参考上述实施例及可选实施方式中所描述的示例，在本实施例中不再赘述。应该明白的是，这里描述的具体实施例只是用来解释这个应用，而不是用来对它进行限定。根据本申请提供的实施例，本领域普通技术人员在不进行创造性劳动的情况下得到的所有其它实施例，均属本申请保护范围。显然，附图只是本申请的一些例子或实施例，对本领域的普通技术人员来说，也可以根据这些附图将本申请适用于其他类似情况，但无需付出创造性劳动。另外，可以理解的是，尽管在此开发过程中所做的工作可能是复杂和漫长的，但是，对于本领域的普通技术人员来说，根据本申请披露的技术内容进行的某些设计、制造或生产等更改仅是常规的技术手段，不应被视为本申请公开的内容不足。“实施例”一词在本申请中指的是结合实施例描述的具体特征、结构或特性可以包括在本申请的至少一个实施例中。该短语出现在说明书中的各个位置并不一定意味着相同的实施例，也不意味着与其它实施例相互排斥而具有独立性或可供选择。本领域的普通技术人员能够清楚或隐含地理解的是，本申请中描述的实施例在没有冲突的情况下，可以与其它实施例结合。以上所述实施例仅表达了本申请的几种实施方式，其描述较为具体和详细，但并不能因此而理解为对专利保护范围的限制。应当指出的是，对于本领域的普通技术人员来说，在不脱离本申请构思的前提下，还可以做出若干变形和改进，这些都属于本申请的保护范围。因此，本申请的保护范围应以所附权利要求为准。

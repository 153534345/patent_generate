标题title
负荷曲线数据存取方法
摘要abst
本发明公开了一种负荷曲线数据存取方法。存储时：将捕获时间与负荷数值分别存放在时间存储区和数值存储区；捕获时间按时间片段的结构形式存储，每个时间片段对应一个负荷数值集合，负荷数值集合包含一个负荷数值或者两个以上连续的负荷数值；时间片段中包含与负荷数值集合对应的时间区间数据，还包含指向所对应的负荷数值集合在数值存储区中的存储位置的数值索引数据。查找时：先将查找的时间段与时间片段的时间区间数据比较，定位到时间片段，再根据时间片段的数值索引数据定位到数值存储区中的目标负荷数值。本发明解决了向前修改时间的情况下，数据记录的查找与完整性之间存在的不可调和的矛盾，同时也避免了无效数据对数据查找的影响。
权利要求书clms
1.一种负荷曲线数据存取方法，负荷曲线数据包括负荷数值以及与负荷数值相对应的捕获时间，其特征在于：存储时：将捕获时间与负荷数值分别存放在时间存储区和数值存储区；其中，捕获时间按时间片段的结构形式存储，每个时间片段对应一个负荷数值集合，负荷数值集合包含一个负荷数值或者两个以上连续的负荷数值；时间片段中包含与负荷数值集合对应的时间区间数据，还包含指向所对应的负荷数值集合在数值存储区中的存储位置的数值索引数据；查找时：先将查找的时间段与时间片段的时间区间数据比较，定位到时间片段，再根据时间片段的数值索引数据定位到数值存储区中的目标负荷数值。2.如权利要求1所述的负荷曲线数据存取方法，其特征在于：存储时，先存储负荷数值，如果负荷数值存储成功，则存储或更新对应的时间片段，否则直接结束本次存储。3.如权利要求1所述的负荷曲线数据存取方法，其特征在于：所述负荷数值在数值存储区中循环存储，即数值存储区存满之后，返回到数值存储区的起始端覆盖最早的数据记录继续存储。4.如权利要求3所述的负荷曲线数据存取方法，其特征在于：所述时间区间数据包括起始时间start_time和时间间隔interval；起始时间start_time是指该时间片段对应的负荷数值集合中第一条负荷数值对应的捕获时间，时间间隔interval是负荷数值的捕获周期；所述数值索引数据包括区间起始索引start_index，其指向该时间片段对应的负荷数值集合中第一条负荷数值在数值存储区的存储位置；时间片段还包含条数值count，它是指负荷数值集合中负荷数值的数量。5.如权利要求4所述的负荷曲线数据存取方法，其特征在于：所述时间片段在时间存储区中循环存储，即时间存储区存满之后，返回到时间存储区的起始端覆盖最早的数据记录继续存储。6.如权利要求5所述的负荷曲线数据存取方法，其特征在于：使用时间片段起始索引start_valid_index和当前时间片段索引cur_index指向有效的时间片段；其中，时间片段起始索引start_valid_index指向时间存储区中第一条有效的时间片段，当前时间片段索引cur_index指向时间存储区中最新存储的有效的时间片段。7.如权利要求6所述的负荷曲线数据存取方法，其特征在于：新增负荷曲线数据时执行以下步骤：A-1、将负荷数值和捕获时间分开；A-2、将负荷数值保存到数值存储区，如果保存成功，执行步骤A-3，否则结束新增负荷曲线数据的操作；A-3、判断当前新增的负荷数值的捕获时间capture_time与最新的有效的时间片段是否匹配，判断条件为：capture_time＝start_time+interval*式中，start_time、interval和count分别为最新的有效的时间片段的起始时间、时间间隔和条数值；满足该条件则执行步骤A-4，否则执行步骤A-5；A-4、将最新的有效的时间片段的条数值count加1；然后执行步骤A-6；A-5、在时间存储区中新建一条时间片段，该时间片段的起始时间start_time等于新增的负荷数值的捕获时间capture_time，时间间隔interval等于当前的捕获周期，区间起始索引start_index等于新增的负荷数值的存储位置，条数值count等于1；然后执行步骤A-6；A-6、根据间片段起始索引start_valid_index找到第一个有效的时间片段，判断新增的负荷数值的存储位置是否在该时间片段所对应的数值存储区的区间内；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index不等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1；再判断此时的count是否小于0，如果小于0，则将start_valid_index值加1；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1。8.如权利要求6所述的负荷曲线数据存取方法，其特征在于：查询负荷曲线数据时执行以下步骤：S-1、根据时间片段起始索引start_valid_index和当前时间片段索引cur_index获取当前所有有效的时间片段；S-2、遍历所有有效的时间片段，分别判断时间片段所指向的时间区间与查询的时间区间是否有交集；S-3、遍历所有存在交集的时间片段，对于某时间片段，设交集为，则按下式计算出需要返回的负荷数值所在的存储位置区间：然后根据计算出的存储位置区间返回负荷数值。9.如权利要求1至8任一所述的负荷曲线数据存取方法，其特征在于：时间片段中还包含校验字段check，当时间片段中除校验字段check之外的其它数据被修改时，根据其它数据的当前值重新计算校验值并保存到校验字段check。
说明书desc
技术领域本发明涉及一种存取负荷曲线数据的方法。背景技术负荷曲线记录功能是智能电表的重要功能之一，它可以根据用户预先设定好的数据要求，按照固定的时间间隔保存数据，以统计用户的用电情况。常规的负荷曲线一般是按照时间有序存储的，类似于“，”的存储结构。查找一般采用二分法，由于时间是有序存储的，使用二分法查找，理论的算法复杂度为O，即在存储了n条数据的曲线内查找一条特定的数据，最多需要查找log2n次。这种负荷曲线的存取方式，结构简单，效率高，非常适合智能电表这种小型的嵌入式设备。但是，现有的这种负荷曲线存取方式也有其缺陷，主要在于：1)如果向前修改电表时间，则需要擦除部分负荷曲线记录，否则无法满足时间有序存储的要求。举例说明：假设电表当前时间为T1，后来经过对时后发现时间错误，需要将当前时间向前修改时间为T2，那么修改时间后，T2至T1时间内的负荷曲线记录必须擦除，否则负荷曲线记录的时间就无法满足有序的要求，会导致二分法查找失效。然而，为了保证负荷曲线数据的可追溯，在很多情况下，无论时间是否为有序排列，都需要将所有已经记录的负荷数据保存下来，用于日后查询，这种情况下是不允许擦除已经记录的负荷曲线数据的，记录的查找与完整性之间存在不可调和的矛盾。2)无法高效的剔除无效数据。电表作为一种工业设备，面对的用电工况比较复杂。在电表运行期间，可能会出现频繁的停电上电或者供电电压不足的情况。在这些工况下，负荷曲线的存储可能会失败，出现无效数据。二分法查找过程中如果出现无效数据，也会出现查找错误。受IO交互速度和RAM容量限制，目前无法对每一条负荷曲线数据进行遍历，判断其有效性。因此目前比较通用的解决方法是：依然采用有序存储、二分法查找，同时通过增加备用电源的方案，提升供电不稳时存储器件的电源稳定性。但是，这种方案显著增加了硬件成本。发明内容本发明提出了一种负荷曲线数据存取方法，其目的是：解决需要向前修改时间的情况下，数据记录的查找与完整性之间存在的不可调和的矛盾；避免无效数据影响数据的查找。本发明技术方案如下：一种负荷曲线数据存取方法，负荷曲线数据包括负荷数值以及与负荷数值相对应的捕获时间，主要步骤为：存储时：将捕获时间与负荷数值分别存放在时间存储区和数值存储区；其中，捕获时间按时间片段的结构形式存储，每个时间片段对应一个负荷数值集合，负荷数值集合包含一个负荷数值或者两个以上连续的负荷数值；时间片段中包含与负荷数值集合对应的时间区间数据，还包含指向所对应的负荷数值集合在数值存储区中的存储位置的数值索引数据；查找时：先将查找的时间段与时间片段的时间区间数据比较，定位到时间片段，再根据时间片段的数值索引数据定位到数值存储区中的目标负荷数值。作为本方法的进一步改进：存储时，先存储负荷数值，如果负荷数值存储成功，则存储或更新对应的时间片段，否则直接结束本次存储。作为本方法的进一步改进：所述负荷数值在数值存储区中循环存储，即数值存储区存满之后，返回到数值存储区的起始端覆盖最早的数据记录继续存储。作为本方法的进一步改进：所述时间区间数据包括起始时间start_time和时间间隔interval；起始时间start_time是指该时间片段对应的负荷数值集合中第一条负荷数值对应的捕获时间，时间间隔interval是负荷数值的捕获周期；所述数值索引数据包括区间起始索引start_index，其指向该时间片段对应的负荷数值集合中第一条负荷数值在数值存储区的存储位置；时间片段还包含条数值count，它是指负荷数值集合中负荷数值的数量。作为本方法的进一步改进：所述时间片段在时间存储区中循环存储，即时间存储区存满之后，返回到时间存储区的起始端覆盖最早的数据记录继续存储。作为本方法的进一步改进：使用时间片段起始索引start_valid_index和当前时间片段索引cur_index指向有效的时间片段；其中，时间片段起始索引start_valid_index指向时间存储区中第一条有效的时间片段，当前时间片段索引cur_index指向时间存储区中最新存储的有效的时间片段。作为本方法的进一步改进：新增负荷曲线数据时执行以下步骤：A-1、将负荷数值和捕获时间分开；A-2、将负荷数值保存到数值存储区，如果保存成功，执行步骤A-3，否则结束新增负荷曲线数据的操作；A-3、判断当前新增的负荷数值的捕获时间capture_time与最新的有效的时间片段是否匹配，判断条件为：capture_time＝start_time+interval*式中，start_time、interval和count分别为最新的有效的时间片段的起始时间、时间间隔和条数值；满足该条件则执行步骤A-4，否则执行步骤A-5；A-4、将最新的有效的时间片段的条数值count加1；然后执行步骤A-6；A-5、在时间存储区中新建一条时间片段，该时间片段的起始时间start_time等于新增的负荷数值的捕获时间capture_time，时间间隔interval等于当前的捕获周期，区间起始索引start_index等于新增的负荷数值的存储位置，条数值count等于1；然后执行步骤A-6；A-6、根据间片段起始索引start_valid_index找到第一个有效的时间片段，判断新增的负荷数值的存储位置是否在该时间片段所对应的数值存储区的区间内；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index不等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1；再判断此时的count是否小于0，如果小于0，则将start_valid_index值加1；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1。作为本方法的进一步改进：查询负荷曲线数据时执行以下步骤：S-1、根据时间片段起始索引start_valid_index和当前时间片段索引cur_index获取当前所有有效的时间片段；S-2、遍历所有有效的时间片段，分别判断时间片段所指向的时间区间与查询的时间区间是否有交集；S-3、遍历所有存在交集的时间片段，对于某时间片段，设交集为，则按下式计算出需要返回的负荷数值所在的存储位置区间：然后根据计算出的存储位置区间返回负荷数值。作为本方法的进一步改进：时间片段中还包含校验字段check，当时间片段中除校验字段check之外的其它数据被修改时，根据其它数据的当前值重新计算校验值并保存到校验字段check。相对于现有技术，本发明具有以下有益效果：针对负荷曲线的数据特点，将负荷数值和捕获时间分开存储，并采用时间片段的结构形式对时间进行压缩处理，使用基于压缩时间的遍历查找代替传统的二分法查找，从而向前修改时间时，无需擦除数据也能保证查找的正常进行；负荷数值存储错误时，不更新时间片段，排除了无效数据的影响，且无需增加硬件；针对数据量大、时间片段较多的情景，进一步对时间片段进行分组管理，提高查找效率。附图说明图1为本方法存储过程的流程示意图；图2为本方法查询过程的流程示意图；图3为实施例中存储了3条负荷数值时数值存储区和时间存储区的示意图；图4为实施例中存储了4条负荷数值时数值存储区和时间存储区的示意图；图5为实施例中存储了5条负荷数值时数值存储区和时间存储区的示意图；图6为实施例中存储了6条负荷数值时数值存储区和时间存储区的示意图；图7为实施例中存储了7条负荷数值、且负荷数值出现循环存储时，数值存储区和时间存储区的示意图。具体实施方式下面结合附图详细说明本发明的技术方案：如图1和2，一种负荷曲线数据存取方法，包括存储和查询两个过程。其中：存储时：如图1，将捕获时间与负荷数值分别存放在时间存储区和数值存储区。数值存储区与用户实际需求相关，包含了用户所需要的数据。负荷数值在数值存储区中循环存储，即数值存储区存满之后，返回到数值存储区的起始端覆盖最早的数据记录继续存储。数值存储区中每一条数据对应的捕获时间保存在时间存储区中。所述时间片段在时间存储区中循环存储，即时间存储区存满之后，返回到时间存储区的起始端覆盖最早的数据记录继续存储。由于采用了顺序循环存储的方式，因此在查询时，当发现计算出的目标存储位置超出了存储区的区间，系统自动返回到存储区的起始位置继续查找，也就是对存储位置进行换算，而非越界查询。本领域技术人员知晓如何进行换算，因此涉及到的存储位置换算过程不在本文描述中详细体现，由技术人员实施时自行设置。捕获时间按时间片段的结构形式存储。每个时间片段对应一个负荷数值集合，负荷数值集合包含一个负荷数值或者两个以上连续的负荷数值；时间片段中包含与负荷数值集合对应的时间区间数据，还包含指向所对应的负荷数值集合在数值存储区中的存储位置的数值索引数据。时间片段的数据结构定义为：具体的，所述时间区间数据包括起始时间start_time和时间间隔interval；起始时间start_time是指该时间片段对应的负荷数值集合中第一条负荷数值对应的捕获时间，时间间隔interval是负荷数值的捕获周期。注意：每个时间片段内的负荷曲线时间间隔必须是相同的。所述数值索引数据包括区间起始索引start_index，其指向该时间片段对应的负荷数值集合中第一条负荷数值在数值存储区的存储位置；时间片段还包含条数值count，它是指负荷数值集合中负荷数值的数量。时间片段中还包含校验字段check，当时间片段中除校验字段check之外的其它数据被修改时，根据其它数据的当前值重新计算校验值并保存到校验字段check，保证数据的完整性。可根据实际需求选择合适的校验算法，常用的校验算法为crc16校验。如图1，存储时，先存储负荷数值，如果负荷数值存储成功，则存储或更新对应的时间片段，否则直接结束本次存储。进一步的，建立时间区间索引指针Index_pointer用于指示时间存储区的状态，其结构为：Index_pointer中使用时间片段起始索引start_valid_index和当前时间片段索引cur_index指向有效的时间片段。其中，时间片段起始索引start_valid_index指向时间存储区中第一条有效的时间片段，当前时间片段索引cur_index指向时间存储区中最新存储的有效的时间片段。由于Time_segment对捕获时间的压缩特性，导致时间片段Time_segment在时间存储区中的循环存储速度要慢于数值存储区的循环存储速度。因此，时间存储区中必然有一部分Time_segment是无效的。start_valid_index用于表示第一个有效的时间片段结构Time_segment的在时间存储区中的索引位置。若start_valid_index小于等于cur_index，说明时间存储区还未存满，未发生循环存储，有效的Time_segment索引从start_valid_index开始，到cur_index结束；否则，说明时间存储区已发生循环存储，有效的Time_segment索引包含两个区间，第一个区间从start_valid_index开始，到时间存储区的最后一条结束，第二个区间从时间存储区的第一条开始，到cur_index结束。如图1，新增负荷曲线数据时执行以下步骤：A-1、将负荷数值和捕获时间分开；A-2、将负荷数值保存到数值存储区，如果保存成功，执行步骤A-3，否则结束新增负荷曲线数据的操作；A-3、判断当前新增的负荷数值的捕获时间capture_time与最新的有效的时间片段是否匹配，判断条件为：capture_time＝start_time+interval*式中，start_time、interval和count分别为最新的有效的时间片段的起始时间、时间间隔和条数值；满足该条件则执行步骤A-4，否则执行步骤A-5；A-4、将最新的有效的时间片段的条数值count加1；然后执行步骤A-6；A-5、在时间存储区中新建一条时间片段，该时间片段的起始时间start_time等于新增的负荷数值的捕获时间capture_time，时间间隔interval等于当前的捕获周期，区间起始索引start_index等于新增的负荷数值的存储位置，条数值count等于1；然后执行步骤A-6；A-6、根据间片段起始索引start_valid_index找到第一个有效的时间片段，判断新增的负荷数值的存储位置是否在该时间片段所对应的数值存储区的区间内：；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index不等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1；再判断此时的count是否小于0，如果小于0，则将start_valid_index值加1；如果新增的负荷数值的存储位置在该时间片段所对应的数值存储区的区间内，且start_valid_index等于cur_index，则第一个有效的时间片段中的start_time值增加该片段的interval，start_index值增加1，count值减1。下面结合附图3至7，对上述新增保存步骤进行详细说明：假设负荷曲线的捕获周期为15分钟，数值存储区最大存储的数据条数为6，时间存储区最大存储Time_segment条数为4。需要说明的是，上述存储限制仅用作示例，实际的存储条数远多于此。如图3，最近一条负荷曲线数据存储在数值存储区的第3条上，时间为00:45，时间存储区的最近一条Time_segment中，start_time＝00：45，start_index＝3，interval＝15，count＝1。如图4，新增时间为01：00的一条负荷曲线数据后，新增曲线的数值保存在数值存储区的第4条位置上，根据上述步骤A-3的匹配判断公式可以得出，新增曲线的捕获时间与最近一条时间片段Time_segment相匹配。因此，将最近一条时间片段Time_segment的count字段值加1；Index_pointer无需更新。如图5，再次新增数据，新增时间为01：30的一条负荷曲线，新增曲线的数据保存在数值存储区的第5条位置上，根据上述步骤A-3的匹配判断公式可以得出，新增曲线的捕获时间与最近一条时间片段Time_segment不匹配。因此，在时间存储区新建一条时间片段Time_segment，start_time＝01：30，start_index＝5，interval＝15，count＝1。同时，Index_pointer中的cur_index字段值等于新建的Time_segment的位置索引，值为3。如图6，再次新增数据，最近一条负荷曲线数据存储在数值存储区的第6条上，时间为01:45，此时数值存储区已满。时间存储区的最近一条Time_segment，start_time＝01：30，start_index＝5，interval＝15，count＝2。如图7，再次新增时间为02：00的一条负荷曲线后，新增曲线的数据发生循环存储，覆盖了数值存储区的第1条位置上的数据，根据上述步骤A-3的匹配判断公式可以得出，新增曲线的捕获时间与最近一条Time_segment匹配，因此，最近一条Time_segment的count字段值加1。但是，此时Index_pointer的start_valid_index字段，即第一个有效的Time_segment索引为1，定位到索引为1的Time_segment，其所指向的数值区域已经被覆盖，所以start_time字段值增加interval变为00：15；start_index字段值增加1，值为2；count字段值为2，减1后不为零，因此无需更新Index_pointer，仅将Time_segment的count字段值减1即可。查找时：先将查找的时间段与时间片段的时间区间数据比较，定位到时间片段，再根据时间片段的数值索引数据定位到数值存储区中的目标负荷数值。如图2，查询负荷曲线数据时具体执行以下步骤：S-1、根据时间片段起始索引start_valid_index和当前时间片段索引cur_index获取当前所有有效的时间片段；S-2、遍历所有有效的时间片段，分别判断时间片段所指向的时间区间与查询的时间区间是否有交集；S-3、遍历所有存在交集的时间片段，对于某时间片段，设交集为，则按下式计算出需要返回的负荷数值所在的存储位置区间：然后根据计算出的存储位置区间返回负荷数值。由于时间存储区根据负荷曲线的存储特点，对捕获时间进行了压缩处理。因此，时间存储区占用的存储空间只与停电持续时间超过捕获周期的次数、用户修改时间跨度超过捕获周期的次数、用户修改捕获周期的次数相关。按照经验值，时间存储区存储2000条Time_segment可满足大多数情况下的要求。但在一些极端情况下，比如，要求负荷曲线的存储时间为许多年，或者由于供电质量差导致停电次数过多，会导致时间存储区中Time_segment的存储条数远大于2000条。此时，需要设置分组功能模块，用于对有效的时间片段进行分组管理。所述分组功能模块初始化的步骤如下：GI-1、分别计算各有效的时间片段的起始时间相对值S、结束时间相对值E和时间中心点C：式中，Relative表示将绝对时间转换为从某个预设起始时间的相对时间数值；一般情况下，取相对于1970年1月1日0时0分的相对时间，单位为分钟；GI-2、设当前有效的时间片段的数量为N，分组数量为M，统计所有时间片段的S的最小值和所有时间片段的E的最大值，分别记为Min_N和Max_N；GI-3、在区间中随机选择M个点作为分组中心点，以Gm表示，m＝1，2，3，…，M；GI-4、分别计算各时间片段的时间中心点与每个分组中心点之间的距离D；GI-5、遍历所有时间片段：设当前的时间片段为第n个时间片段，取出其时间中心点Cn与所有分组中心点之间的距离{Dnm}，m＝1，2，3，…，M，按从小到大的顺序排序，将最小的距离D对应的分组记为第n个时间片段所在的分组；GI-6、遍历完成后，计算每个分组的新的时间中心点：Ci表示该分组中第i个时间片段的时间中心点，I表示该分组中当前时间片段的数量；GI-7、重复执行步骤GI-4至GI-6，直到在步骤GI-6中计算出的新的分组的时间中心点与上一次计算出的时间中心点相同；GI-8、对于各分组，分别统计组内所有时间片段的S的最小值和所有时间片段的E的最大值，分别记为时间下限Min_T和时间上限Max_T；GI-9、在时间分组存储区保存分组数据，每个分组的分组数据包含：时间下限Min_T、时间上限Max_T、分组的时间中心点G以及所对应的时间片段在时间存储区中的存储位置。基于所述分组功能模块，在新增负荷曲线数据时，执行完上述步骤A-1至A-6后，还要取出新增的时间片段以及更新的时间片段进行遍历，分别计算时间片段的时间中心点与各分组的时间中心点之间的距离，选择距离最小的分组作为该时间片段的所在分组，并重新计算各发生变动的分组的分组数据。基于所述分组功能模块，查询负荷曲线数据时：先遍历所有分组，判断分组的时间下限Min_T和时间上限Max_T所构成的时间区间与查询的时间区间是否有交集；对存在交集的分组，均需要取出分组内的时间片段进行遍历，分别判断各时间片段所指向的时间区间与查询的时间区间是否有交集；然后参照步骤S-3，遍历所有存在交集的时间片段，对于某时间片段，设交集为，则按下式计算出需要返回的负荷数值所在的存储位置区间：最后根据计算出的存储位置区间返回负荷数值。显然，对于经常出现故障导致出现大量的时间片段的情况，通过分组可以将相对连续的时间片段分到一个分组里，这样在查询时就能提到找到相关时间片段的速度，提高查询效率。

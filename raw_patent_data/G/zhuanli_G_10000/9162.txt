标题title
基于Linux内核的系统休眠内存管理方法及装置
摘要abst
本发明提供一种基于Linux内核的系统休眠内存管理方法及装置。该方法包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以尽可能减小存储到内存交换区域的休眠镜像文件的大小。采用本发明方法，通过内存回收管理功能模块化的方式回收出足够多的空白内存，以尽可能减小休眠镜像的大小，从而提高了系统唤醒时加载休眠镜像到内存中的速度，实现了与内核版本无关的休眠唤醒快速开机机制，同时能够快速适应各种新硬件，避免频繁的内核编译工作，降低了开发工作量。
权利要求书clms
1.一种基于Linux内核的系统休眠内存管理方法，其特征在于，包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。2.根据权利要求1所述的基于Linux内核的系统休眠内存管理方法，其特征在于，所述基于内核调用所述功能模块触发执行相应的内存回收管理操作，具体包括：将所述功能模块动态载入到所述内核；在预设的时间阈值内，基于所述内核调用所述功能模块执行多个内存空间请求循环操作；其中，在每个内存空间请求循环中进行如下步骤：向所述内核发送第一内存空间请求；所述第一内存空间请求所请求分配的内存空间为预设的初始最大值；向所述内核发送第二内存空间请求；所述第二内存空间请求所请求分配的内存空间小于所述初始最大值；循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间；其中，每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值；直至满足所请求分配的内存空间达到预设的初始最小值或者达到所述预设的时间阈值时，停止所述内存空间请求循环操作；释放基于所述内存空间请求循环操作得到的所有内存空间，向所述内核发出休眠请求，进入休眠。3.根据权利要求2所述的基于Linux内核的系统休眠内存管理方法，其特征在于，所述循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间，具体包括：在循环发送所述第二内存空间请求中，每次所述第二内存空间请求所请求分配的内存空间为上一次第二内存空间请求所请求分配的内存空间的一半。4.根据权利要求2所述的基于Linux内核的系统休眠内存管理方法，其特征在于，所述每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值，具体包括：每个内存空间请求循环的第一内存空间请求对应的预设的初始最大值为上一次内存空间请求循环的第一内存空间请求对应的预设的初始最大值的一半。5.根据权利要求1所述的基于Linux内核的系统休眠内存管理方法，其特征在于，所述预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块，具体包括：将所述内存回收管理操作封装为功能模块；通过所述平台设备驱动机制将所述功能模块注册到所述内核。6.根据权利要求1所述的基于Linux内核的系统休眠内存管理方法，其特征在于，还包括：在基于所述内核调用所述功能模块触发执行相应的内存回收管理操作时，通过动态调节相应的交互分区内核参数来控制内存使用的相对权重。7.根据权利要求2所述的基于Linux内核的系统休眠内存管理方法，其特征在于，还包括：在所述第一内存空间请求所请求分配的内存空间时，将相应的交互分区内核参数设置为10；从下一次循环发送所述第二内存空间请求来请求分配的内存空间时开始，分别对应依次减1，直到所述交互分区内核参数减少为1。8.一种基于Linux内核的系统休眠内存管理装置，其特征在于，包括：内核模块化处理单元，用于预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；内存回收管理单元，用于响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。9.一种电子设备，包括存储器、处理器以及存储在存储器上并可在处理器上运行的计算机程序，其特征在于，所述处理器执行所述程序时实现如权利要求1-7任意一项所述基于Linux内核的系统休眠内存管理方法的步骤。10.一种处理器可读存储介质，所述处理器可读存储介质上存储有计算机程序，其特征在于，该计算机程序被处理器执行时实现如权利要求1-7任意一项所述基于Linux内核的系统休眠内存管理方法的步骤。
说明书desc
技术领域本发明涉及计算机应用技术领域，具体涉及一种基于Linux内核的系统休眠内存管理方法及装置。另外，还涉及一种电子设备及处理器可读存储介质。背景技术各种小型智能化电子设备对开关机速度的要求也越来越高。当前操作系统所采用的快速开机方式多种多样，其中较为通用的是休眠-唤醒方式，即通过关机休眠时将内存页面、中央处理器状态等存储在硬盘上的交换分区区域中，在系统唤醒时通过将交换分区区域中的休眠镜像读取至内存中即可实现快速开机。这种方案被称为SBH。发明内容为此，本发明提供一种基于Linux内核的系统休眠内存管理方法，以解决现有技术中存在的Linux系统休眠的内存回收管理方案局限性较高，需要频繁的编译开发，导致工作效率较低的问题。第一方面，本发明提供的基于Linux内核的系统休眠内存管理方法，包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。进一步的，所述基于内核调用所述功能模块触发执行相应的内存回收管理操作，具体包括：将所述功能模块动态载入到所述内核；在预设的时间阈值内，基于所述内核调用所述功能模块执行多个内存空间请求循环操作；其中，在每个内存空间请求循环中进行如下步骤：向所述内核发送第一内存空间请求；所述第一内存空间请求所请求分配的内存空间为预设的初始最大值；向所述内核发送第二内存空间请求；所述第二内存空间请求所请求分配的内存空间小于所述初始最大值；循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间；其中，每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值；直至满足所请求分配的内存空间达到预设的初始最小值或者达到所述预设的时间阈值时，停止内存空间请求循环操作；释放基于所述内存空间请求循环操作得到的所有内存空间，向所述内核发出休眠请求，进入休眠。进一步的，所述循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间，具体包括：在循环发送所述第二内存空间请求中，每次所述第二内存空间请求所请求分配的内存空间为上一次第二内存空间请求所请求分配的内存空间的一半。进一步的，所述每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值，具体包括：每个内存空间请求循环的第一内存空间请求对应的预设的初始最大值为上一次内存空间请求循环的第一内存空间请求对应的预设的初始最大值的一半。进一步的，所述预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块，具体包括：将所述内存回收管理操作封装为功能模块；通过所述平台设备驱动机制将所述功能模块注册到所述内核中。进一步的，所述的基于Linux内核的系统休眠内存管理方法，还包括：在基于所述内核调用所述功能模块触发执行相应的内存回收管理操作时，通过动态调节相应的交互分区内核参数来控制内存使用的相对权重。进一步的，所述的基于Linux内核的系统休眠内存管理方法，还包括：在所述第一内存空间请求所请求分配的内存空间时，将相应的交互分区内核参数设置为10；从下一次循环发送所述第二内存空间请求来请求分配的内存空间时开始，分别对应依次减1，直到所述交互分区内核参数减少为1。第二方面，本发明还提供一种基于Linux内核的系统休眠内存管理装置，包括：内核模块化处理单元，用于预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；内存回收管理单元，用于响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。进一步的，所述内存回收管理单元，具体用于：将所述功能模块动态载入到所述内核；在预设的时间阈值内，基于所述内核调用所述功能模块执行多个内存空间请求循环操作；其中，在每个内存空间请求循环中进行如下步骤：向所述内核发送第一内存空间请求；所述第一内存空间请求所请求分配的内存空间为预设的初始最大值；向所述内核发送第二内存空间请求；所述第二内存空间请求所请求分配的内存空间小于所述初始最大值；循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间；其中，每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值；直至满足所请求分配的内存空间达到预设的初始最小值或者达到所述预设的时间阈值时，停止内存空间请求循环操作；释放基于所述内存空间请求循环操作得到的所有内存空间，向所述内核发出休眠请求，进入休眠。进一步的，所述循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间，具体包括：在循环发送所述第二内存空间请求中，每次所述第二内存空间请求所请求分配的内存空间为上一次第二内存空间请求所请求分配的内存空间的一半。进一步的，所述每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值，包括：每个内存空间请求循环的第一内存空间请求对应的预设的初始最大值为上一次内存空间请求循环的第一内存空间请求对应的预设的初始最大值的一半。进一步的，所述内核模块化处理单元，具体用于：将所述内存回收管理操作封装为功能模块；通过所述平台设备驱动机制将所述功能模块注册到所述内核中。进一步的，所述的基于Linux内核的系统休眠内存管理装置，还包括：内核参数动态调节单元，用于在基于所述内核调用所述功能模块触发执行相应的内存回收管理操作时，通过动态调节相应的交互分区内核参数来控制内存使用的相对权重。进一步的，所述的基于Linux内核的系统休眠内存管理装置，还包括：所述内核参数动态调节单元，具体用于在所述第一内存空间请求所请求分配的内存空间时，将相应的交互分区内核参数设置为10；从下一次循环发送所述第二内存空间请求来请求分配的内存空间时开始，分别对应依次减1，直到所述交互分区内核参数减少为1。第三方面，本发明还提供一种电子设备，包括：存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，所述处理器执行所述程序时实现如上述任意一项所述的基于Linux内核的系统休眠内存管理方法的步骤。第四方面，本发明还提供一种处理器可读存储介质，所述处理器可读存储介质上存储有计算机程序，该计算机程序被处理器执行时实现如上述任意一项所述的基于Linux内核的系统休眠内存管理方法的步骤。采用本发明所述的基于Linux内核的系统休眠内存管理方法，通过内存回收管理功能模块化的方式回收出足够多的空白内存，以尽可能减小休眠镜像的大小，从而提高了系统唤醒时加载休眠镜像到内存中的速度，实现了与内核版本无关的休眠-唤醒快速开机机制，能够快速适应各种新硬件，避免频繁编译工作，降低了开发的工作量。附图说明为了更清楚地说明本发明实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作一简单地介绍，显而易见地，下面描述中的附图是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获取其他的附图。图1为本发明实施例提供的基于Linux内核的系统休眠内存管理方法的流程示意图；图2为本发明实施例提供的Linux系统中平台设备驱动机制对应的示意图；图3为本发明实施例提供的基于Linux内核的系统休眠内存管理装置的结构示意图；图4为本发明实施例提供的电子设备的实体结构示意图。具体实施方式为使本发明实施例的目的、技术方案和优点更加清楚，下面将结合本发明实施例中的附图，对本发明实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例是本发明一部分实施例，而不是全部的实施例。基于本发明中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获取的所有其他实施例，都属于本发明保护的范围。在发明人所知的技术中，SBH提高开机速度的核心在于缩小休眠镜像文件的大小，通常的方式是在系统休眠之前利用Linux kernel的内存清理机制将内存中的空闲内存页面推到硬盘上的交换分区中。内存清理机制是Linux kernel的内存管理机制的一部分，当有新的硬件设备需要支持时，需要重新编译内核才能实现，导致开发负担很大。然而，在Linux系统中，厂商通常不会主动针对Linux提供驱动程序，需要开发者编译Kernel才能使得Kernel的各种功能函数正常使用，具体到与休眠相关的电源管理机制则为内核中的PM Core。当Linux版本更新或者硬件更新时，需要重新编写PM Core才能实现快速开机，导致开发人员需要根据需要频繁的编译开发。下面基于本发明所述的基于Linux内核的系统休眠的内存管理方法，对其实施例进行详细描述。如本领域技术人员所知，基于Linux内核的系统可以是Linux操作系统，如Ubuntu、RedHat等发行版；还可以是Android系统、Tizen系统等，本发明不限制特定的操作系统类型，只要其基于Linux Kernel即可。如图1所示，为本发明实施例提供的基于Linux内核的系统休眠的内存管理方法的流程示意图，具体实现过程包括以下步骤：步骤101：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块。在本发明实施例中，所述平台设备驱动机制是指驱动管理和注册模型。其中，平台设备用Platform_device表示，平台驱动用Platform_driver表示。系统休眠所需的内存回收管理操作的功能模块化设计可使用所述平台设备驱动机制实现。通过平台设备驱动机制能够将设备本身的资源注册进Linux内核，在运行时由Linux内核统一管理，从而提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。如图2所示，以Linux系统为例，User mode的应用通过System call与Kernel mode沟通。Kernel area中System call是User mode的应用与devicedrivers的沟通界面，Kernel mode中的VFS负责文件操作、注册驱动、支持System call等功能。在本步骤中，所述预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块，实现过程具体包括：将所述内存回收管理操作封装为功能模块；通过所述平台设备驱动机制将所述功能模块注册到所述内核。具体的，将系统休眠所需的内存管理操作封装成功能模块，并通过平台设备注册机制向内核中注册一个内存回收设备及其对应的驱动。例如，定义Platform device，然后注册Platform device；定义Platform driver，然后注册platform driver，在基于所述内核调用该功能模块时可以实现原Linux内核中的内存清理机制的内存回收功能。具体地，通过功能模块化的方式无需将本发明描述的内存回收管理操作过程写进Linux Kernel里，而是以Platform平台设备驱动机制的方式处理成一种Kernel module，使得在Kernel调用该部分内存回收管理功能的时候具有Kernel一样的优先级。例如，将Platform device设备定义成SBH Device，初始化其结构变量并存储到相应的Linux/Platform_device.h中。该设备注册时利用Platform_device_register向系统注册设备。在对应的driver部分，主要是用来匹配对应的注册的设备的名称，在driver中定义对应本发明所需要的各种内存回收管理功能，比如Suspend、Resume等。通过将特定的驱动程序从Kernel中分离出来，编译成Kernel module。当Kernel需要使用Kernel module对应的功能时，动态载入到 Kernel 里成为 Kernel的一部分。载入到 Kernel 里的Kernel module具有跟 Kernel 一样的级别，实现与内核版本无关的休眠-唤醒快速开机方法。通过该方式可以避免硬件的快速更新导致需要频繁编译Kernel，从而降低了开发压力。通过本发明的内存管理方法和回收管理操作能够在实施休眠快速唤醒机制时执行对应的内存页面回收和清理。步骤102：响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。在本步骤中，所述基于内核调用所述功能模块触发执行相应的内存回收管理操作，具体实现过程包括：将所述功能模块动态载入到所述内核；在预设的时间阈值内，基于所述内核调用所述功能模块执行多个内存空间请求循环操作；其中，在每个内存空间请求循环中进行如下步骤：首先，向所述内核发送第一内存空间请求；所述第一内存空间请求所请求分配的内存空间为预设的初始最大值；然后，向所述内核发送第二内存空间请求；所述第二内存空间请求所请求分配的内存空间小于所述初始最大值；循环发送所述第二内存空间请求，每次所述第二内存空间请求所请求分配的内存空间均小于上一次第二内存空间请求所请求分配的内存空间。其中，每个内存空间请求循环中第一内存空间请求对应的预设的初始最大值小于上一次内存空间请求循环中第一内存空间请求对应的预设的初始最大值；直至满足所请求分配的内存空间达到预设的初始最小值或者达到所述预设的时间阈值时，停止内存空间请求循环操作，并释放基于所述内存空间请求循环操作得到的所有内存空间，向所述内核发出休眠请求，进入休眠。所述内核即为Linux内核。具体的，当Kernel module被调用时，在预设的时间阈值内，每个内存空间请求循环中，均进行下述操作步骤：向内核提出分配内存的第一内存空间请求，首次请求分配的内存空间为预设初始最大值；然后，继续向内核提出分配内存的第二内存空间请求，第二次请求分配的内存空间为小于预设初始最大值；循环上述操作，以后每次请求分配的内存空间均小于上一次请求分配的内存空间；直到达到请求分配的空间为预设初始最小值或者完整所述预设时间阈值。同时，循环上述内存空间请求，每个内存空间请求循环的预设初始最大值小于上一次内存空间请求循环的预设初始最大值。完成上述循环后，释放请求获得的所有内存空间，向内核发出休眠请求，进入休眠状态。在一些实施例中，运行基于Linux内核的操作系统的设备是X86体系的电子设备，如台式机、笔记本等。在第一个内存空间请求循环中，预设初始最大值不大于4M，预设初始最小值为1K。在所有内存空间请求循环的最后一个内存空间请求循环中，预设初始最大值不大于128K，预设初始最小值为1K。可选的，在每一个内存空间请求循环中，可使得每次内存空间请求分配的内存空间为上一次内存空间请求分配的内存空间的一半。可选的，所有内存空间请求循环中，每个内存空间请求循环的预设初始最大值为上一个内存空间请求循环的预设初始最大值的一半。直到最后一个内存空间请求循环，按照预设初始最大值不大于128K，预设初始最小值为1K的内存请求分配方法重复，直到满足预设的时间阈值，结束循环。可选的，预设的时间阈值为1-1.5s，该预设时间阈值的上限设定需要低于使用该方法导致的开机速度节省时间。在一些实施例中，运行基于Linux内核的操作系统的设备是ARM平台的电子设备，如手机、平板电脑等。在第一个内存空间请求循环中，预设初始最大值不大于128K，预设初始最小值为1K。在所有内存空间请求循环的最后一个内存空间请求循环中，预设初始最大值不大于16K，预设初始最小值为1K。可选的，在每一个内存空间请求循环中，每次内存空间请求所请求分配的内存空间为上一次内存空间请求所请求分配的内存空间的一半。可选的，所有内存空间请求循环中，每个内存空间请求循环的预设初始最大值为上一个内存空间请求循环的预设初始最大值的一半。直到最后一个内存空间请求循环，按照预设初始最大值不大于16K，预设初始最小值为1K的内存空间请求分配方法重复，直到满足预设的时间阈值，结束循环。可选的，预设的时间阈值为0.2-0.5s。在一些实施例中，为了控制将应用从内存Swap到硬盘的Swap area交换分区的速度，可以在功能模块进行内存回收管理操作时，通过动态调节相应的交互分区内核参数来控制内存使用的相对权重。其中，Swappiness参数是指Linux内核参数，能够控制系统在进行Swap时，内存使用的相对权重。具体的，Swappiness参数值越低，会让系统尽量少用交换分区区域，多用内存；Swappiness参数值越高，会使系统更多的去使用Swap area交换分区。比如，设置Swappiness参数为30，当剩余物理内存低于70%时，开始使用Swap area交换分区。在一些实施例中，在所述第一内存空间请求所请求分配的内存空间时，将相应的交互分区内核参数设置为10；从下一次循环发送所述第二内存空间请求来请求分配的内存空间时开始，分别对应依次减1，直到所述交互分区内核参数减少为1。例如，在所有内存空间请求循环的第一个内存空间请求循环中，设置Swappiness参数为10；下一个内存空间请求循环依次减1，直到Swappiness参数为1后，固定为1。。通过上述方式，可以尽可能多的获得空闲内存空间，将原本在内存中的页面移入到Swap area交换分区，最后释放所有所获得的内存空间进入休眠。该种方式显著降低了休眠镜像的大小，从而使得再次开机时显著加快了系统载入休眠镜像的速度。在具体的开发实现上，可以使用Kmalloc函数获取内存，Kmalloc函数分配的内存是物理上连续的，即获得的内存是一块在物理上是连续地址的内存空间。为了避免上述方式完成后，存在物理上不连续的小块空闲内存空间，比如对于X86而言，剩余的不连续内存空间都小于128K 导致Kmalloc函数的最后一个内存空间请求循环不执行获取内存空间的操作，所以在最后一个内存空间请求循环之后，使用Vmalloc函数获取不连续的小块空闲内存空间。需要说明的是，本发明之所以不全程使用Vmalloc函数，是因为Kmalloc函数执行效率和性能远高于Vmalloc函数，只是Kmalloc会导致小块的碎片化空闲内存，所以最后使用Vmalloc函数处理。释放内存空间使用与Kmalloc函数和Vmalloc函数对应的Kfree和Vfree即可。为了说明本发明方法的实施效果，申请人分别在X86、ARM处理器的设备上进行了实验。对于X86平台，选择了一台配置为i5-1135g7，8g内存，256g sata ssd的笔记本电脑，运行的操作系统为Ubuntu 16.04 LTS，原系统休眠开机时间约1min，使用本发明的方法，开机时间为25-35s。采用本发明方法使得休眠镜像文件的大小大约减小了50%左右。对于ARM平台，选择了一台主流配置的平板电脑：高通865，8g内存，256g ROM，自带操作系统ONE UI 3.0，休眠开机时间为10-12s。使用本发明的方法，休眠开机时间约为7-8s。另外，需要说明的是，本发明包括但不限于使用Platform driver注册实现内核模组化。就具体的技术实现而言，使用通用的driver注册或者Platform driver注册都可以实施本发明的技术方案，在此不做具体限定。本发明实施例中，之所以使用Patform driver是因为相对于通常的driver注册方式具有资源上的优势，Platform driver是将本身的资源通过注册到Kernel中由Kernel统一管理和执行，在使用时有通用的界面接口，具有较好的可移植性，使得系统在下一代产品中更新了各种硬件时无需再做这部分的二次编译工作。采用本发明实施例所述的基于Linux内核的系统休眠内存管理方法，可以回收出足够多的空白内存页面，以尽可能减小休眠镜像的大小，从而提高了系统唤醒时加载休眠镜像到内存中的速度，实现了在休眠这个特定应用需求下与内核版本无关的休眠-唤醒快速开机机制，能够快速适应各种新硬件，避免频繁编译工作。与上述提供的一种基于Linux内核的系统休眠内存管理方法相对应，本发明还提供一种基于Linux内核的系统休眠内存管理装置。由于该装置的实施例相似于上述方法实施例，所以描述得比较简单，相关之处请参见上述方法实施例部分的说明即可，下面描述的基于Linux内核的系统休眠内存管理装置的实施例仅是示意性的。请参考图3所示，其为本发明实施例提供的一种基于Linux内核的系统休眠内存管理装置的结构示意图。本发明所述的基于Linux内核的系统休眠内存管理装置具体包括如下部分：内核模块化处理单元301，用于预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；内存回收管理单元302，用于响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。采用本发明实施例所述的基于Linux内核的系统休眠内存管理装置，可以回收出足够多的空白内存页面，以尽可能减小休眠镜像的大小，从而提高了系统唤醒时加载休眠镜像到内存中的速度，实现了在休眠这个特定应用需求下与内核版本无关的休眠-唤醒快速开机机制，能够快速适应各种新硬件，避免频繁编译工作，降低了开发的工作量。与上述提供的基于Linux内核的系统休眠内存管理方法相对应，本发明还提供一种电子设备。由于该电子设备的实施例相似于上述方法实施例，所以描述得比较简单，相关之处请参见上述方法实施例部分的说明即可，下面描述的电子设备仅是示意性的。如图4所示，其为本发明实施例公开的一种电子设备的实体结构示意图。该电子设备可以包括：处理器401、存储器402和通信总线403，其中，处理器401，存储器402通过通信总线403完成相互间的通信，通过通信接口404与外部进行通信。处理器401可以调用存储器402中的逻辑指令，以执行基于Linux内核的系统休眠内存管理方法，该方法包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。此外，上述的存储器402中的逻辑指令可以通过软件功能单元的形式实现并作为独立的产品销售或使用时，可以存储在一个计算机可读取存储介质中。基于这样的理解，本发明的技术方案本质上或者说对现有技术做出贡献的部分或者该技术方案的部分可以以软件产品的形式体现出来，该计算机软件产品存储在一个存储介质中，包括若干指令用以使得一台计算机设备执行本发明各个实施例所述方法的全部或部分步骤。而前述的存储介质包括：存储芯片、U盘、移动硬盘、只读存储器、随机存取存储器、磁碟或者光盘等各种可以存储程序代码的介质。另一方面，本发明实施例还提供一种计算机程序产品，所述计算机程序产品包括存储在处理器可读存储介质上的计算机程序，所述计算机程序包括程序指令，当所述程序指令被计算机执行时，计算机能够执行上述各方法实施例所提供的基于Linux内核的系统休眠内存管理方法，该方法包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。又一方面，本发明实施例还提供一种处理器可读存储介质，所述处理器可读存储介质上存储有计算机程序，该计算机程序被处理器执行时实现以执行上述各实施例提供的基于Linux内核的系统休眠内存管理方法，该方法包括：预先基于平台设备驱动机制将系统休眠所需的内存回收管理操作处理成功能模块；响应于系统接收到进入休眠状态的操作，基于内核调用所述功能模块触发执行相应的内存回收管理操作，以减小存储到内存交换区域的休眠镜像文件的大小。所述处理器可读存储介质可以是处理器能够存取的任何可用介质或数据存储设备，包括但不限于磁性存储器等）、光学存储器、以及半导体存储器、固态硬盘）等。以上所描述的装置实施例仅仅是示意性的，其中所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部模块来实现本实施例方案的目的。本领域普通技术人员在不付出创造性的劳动的情况下，即可以理解并实施。通过以上的实施方式的描述，本领域的技术人员可以清楚地了解到各实施方式可借助软件加必需的通用硬件平台的方式来实现，当然也可以通过硬件。基于这样的理解，上述技术方案本质上或者说对现有技术做出贡献的部分可以以软件产品的形式体现出来，该计算机软件产品可以存储在计算机可读存储介质中，如ROM/RAM、磁碟、光盘等，包括若干指令用以使得一台计算机设备执行各个实施例或者实施例的某些部分所述的方法。最后应说明的是：以上实施例仅用以说明本发明的技术方案，而非对其限制；尽管参照前述实施例对本发明进行了详细的说明，本领域的普通技术人员应当理解：其依然可以对前述各实施例所记载的技术方案进行修改，或者对其中部分技术特征进行等同替换；而这些修改或者替换，并不使相应技术方案的本质脱离本发明各实施例技术方案的精神和范围。

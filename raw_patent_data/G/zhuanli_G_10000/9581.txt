标题title
一种面向私有数据集的安全高效分位数聚合方法及装置
摘要abst
本发明公开了一种面向私有数据集的安全高效分位数聚合方法及装置，首先，两方用户分别基于各自的私有数据集计算本地的Q‑Digest数据结构；其次，设计对输入独立的merge算法，确保算法运行过程不泄漏用户的原始输入信息；然后依据merge操作的全局敏感度，借助差分隐私技术增加适当的无效节点，并将增加了无效节点的树作为改进后merge算法的输入，调用开源的多方计算工具集，实现merge函数的安全计算，最终，两方分别从运行结果中得到聚合后的分位数近似计算结果。本发明能够使两方用户在确保各自私有数据集隐私能得以保护的前提下，安全的进行分位数近似计算的聚合问题，并确保整个分位数近似计算的聚合过程不泄漏除差分隐私允许的信息以外的额外用户私有信息。
权利要求书clms
1.一种面向私有数据集的安全高效分位数聚合方法，其特征在于，包括以下步骤：S1：两方用户分别基于各自的私有数据集计算本地的Q-Digest数据结构，也即更新完成后的树；S2：提出对Q-Digest算法merge操作的改进算法OMerge，使得算法的运行与输入完全独立；S3：分析merge操作的全局敏感度，依据差分隐私来确定为本地计算结果添加元组的数目，根据该数目增加无效节点，并将增加了无效节点的树作为改进后merge算法OMerge的输入，调用开源的多方计算工具集，实现merge函数的安全计算；S4：两方分别从运行结果中得到聚合后的分位数近似计算结果。2.根据权利要求1所述的面向私有数据集的安全高效分位数聚合方法，其特征在于，S2中所述改进算法OMerge包括：S21：定义两个集合作为OMerge的输入，每个集合中每个元组格式为＜id,c,isDummy,isParent＞；其中，id为树从根节点到叶子节点按照从上到下，从左到右的顺序标记的节点id；c为叶子节点所对应的元素在数据集中出现的频率，即该节点的counter值；isDummy是为一个二进制谓词，若该元组是有效的，则isDummy置为0，否则置为1；isParent也为一个二进制谓词，用于解释当前的元组是Q-Digest结构中本身的元组，还是将其父节点进行处理之后的元组，若未经过处理，则该isParent字段为0，否则置为1；S22：将两个经由本地Q-Digest算法计算后得到的数据集进行所有父节点的push操作，即将父节点均向下压到其左孩子，并将压缩的节点元组中isParent字段置为1，处理后的数据集作为算法的输入；S23：将两个输入的集合进行求和操作，对应节点且isParent字段和isDummy字段均相同的元组counter值相加，则得到将两个输入进行汇总的效果；S24：基于求和的集合，并引入判断谓词进行不同情况下的压缩规则判断，以判断是否需要merge操作；S25：当判断需要merge操作时，将当前节点的id置为其父节点的id，将当前节点的counter值置为计算所得的counter值之和，仅有一个节点的情况时，counter值不变；并将涉及该节点压缩判断的其他节点的元组中的isDummy置为1，表明这几个节点的压缩判断均已完成，后续无需再重复判断；当判断无需merge操作时，保留每个节点，恢复父节点的原始元组信息，也即将isParent字段为1的节点的id变换回原来的父节点id；S26：从叶子到根逐层进行上述判断，每层完成后，将所有的节点按压缩之后更新的id大小从大到小重新排序，再进行下一层的压缩操作，直到完成整个树的压缩。3.根据权利要求2所述的面向私有数据集的安全高效分位数聚合方法，其特征在于，所述将其父节点进行处理具体为：将一个父节点的id变为其左孩子的id，为与原先的左孩子元组区分，该父节点的元组中isParent字段被置为1，而原先的左孩子元组中isParent置为0。4.根据权利要求2所述的面向私有数据集的安全高效分位数聚合方法，其特征在于，S24中所述判断谓词包括：1NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均为0时，该节点是否需要压缩；若节点的counter值小于等于压缩门限θ，则该谓词置为1，表示该节点需要merge操作；1NodeRecover：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均为0时，该节点是否需要压缩；若节点的counter值大于压缩门限θ，此时，该谓词置为1，表示该节点无需merge操作；2NodeMerge：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；若该节点与存在的父/兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这两个节点需要merge操作；2NodeRecover：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；若该节点与存在的父/兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这两个节点无需merge操作；3NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均大于0时，该节点是否需要压缩；若该节点与存在的父节点和兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这三个节点需要merge操作；3NodeRecover：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；该节点与其父节点和兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这三个节点无需merge操作。5.根据权利要求2所述的面向私有数据集的安全高效分位数聚合方法，其特征在于，S25中，所述恢复父节点的原始元组信息用Parent函数来实现，即Parent＝id/2。6.根据权利要求3所述的面向私有数据集的安全高效分位数聚合方法，其特征在于，所述分析merge操作的全局敏感度具体为：定义函数L为压缩函数的输出长度，也即完成Q-Digest算法之后的数据结构中元组的数量；同时定义ΔL为函数L的敏感度；根据差分隐私的定义，分析函数L在处理两个邻居数据集时输出的最大差异，该差异即为函数L的敏感度ΔL；根据所述敏感度ΔL，确定基于所述压缩操作应为本地计算结果添加元组的数目。7.一种面向私有数据集的安全高效分位数聚合装置，其特征在于，包括Q-Digest数据结构计算单元、全局敏感度分析单元、改进算法OMerge计算单元和结果输出单元；所述Q-Digest数据结构计算单元用于根据两方用户各自的私有数据集计算本地的Q-Digest数据结构，也即完成的树本地更新；所述全局敏感度分析单元依据merge操作的全局敏感度，基于截断Laplace机制增加适当的无效节点，并将增加了无效节点的树作为改进后OMerge算法的输入；所述改进算法OMerge计算单元设计对输入独立的merge算法，确保算法运行过程不泄漏用户的原始输入信息，并调用开源的多方计算工具集，实现merge函数的安全计算；所述结果输出单元用于使两方分别从运行结果中得到聚合后的分位数近似计算结果。
说明书desc
技术领域本发明涉及数据分析算法在多方进行聚合时的安全性增强技术领域，具体为一种面向私有数据集的安全高效分位数聚合方法及装置。背景技术分位数近似算法Q-Digest：Q-Digest算法是一种非常著名的分位数近似算法，主要用在数据库领域，用以回答分位数询问。该算法基于一个构建在数据集全集U上的完全二叉树进行分位数的近似计算。每个节点由一个二元组表示：＜id，c＞，初始状态下，树从根节点到叶子节点按照从上到下，从左到右的顺序，依次标记为1，2，3等作为节点的id；树的所有非叶子节点代表一个范围，该范围由其子节点所对应的元素决定，因此，根节点对应的范围为，其左孩子对应范围为，右孩子对应范围为，以此类推，可得该树每个节点对应的范围，与此同时，叶子节点的范围恰为一个数，该树即为数据集U中的某个元素；初始状态下，叶子节点所对应的元素在数据集中出现的频率被记作该节点的counter值c，非叶子节点在初始状态下counter值为0。因此，Q-Digest算法本质是基于一定的规则，更新每个节点的counter值c。为了更好的叙述更新规则，首先定义两个参数：压缩参数k和压缩门限θ，它们具有如下关系：其中n为待分析数据集的大小。更新过程按照从叶子节点到根节点的顺序进行，按层逐层更新。因此，更新某个被记为＜id，c＞的节点的counter值c的具体规则为：判断该节点的父节点的counter值cp、其兄弟节点的counter值cs和自身counter值的和是否满足以下不等式：c+cp+cs≤θ，若满足，称压缩条件满足，则将该节点父节点的counter值cp设为c+cp+cs，同时将c和cs设置为0，完成该节点的counter值的更新。若不等式不成立，称压缩条件不满足，则保留原counter值，继续对其他节点进行相同的判断，直至整个树所有节点均完成更新。两个树的更新通常叫做merge，主要用于不同用户之间数据的聚合计算，该过程首先需要将两棵树的结果进行刷新，也即对应节点的counter值相加，再重复执行上述的压缩更新过程。Q-Digest算法的一个具体运行实例如图1-图1所示，图1为将原始数据集频率向量对应到数据集全集并放入二叉树叶子节点对应位置的待处理原始数据结构，图1为依据Q-Digest算法对树的叶子层进行merge操作之后的数据结构，图1为对树的倒数第二层进行merge操作之后的数据结构。从算法叙述可知，Q-Digest算法的执行，依赖于叶子节点上基于待分析数据集初始化的节点counter值，因此，如果涉及两方或者多方实体想基于各自持有的私有数据集进行分位数的近似计算，总是需要一方先将所有的数据汇聚，再执行算法，从而不可避免的导致由私有数据的迁移带来的数据隐私泄漏问题。安全多方计算技术：安全多方计算技术本质是一类密码学领域的安全协议，其主要目的是帮助多个互不信任的参与方完成某个由参与方共同决定的函数的安全计算，安全计算体现在各个参与方的输入均能够由协议保护，从而确保参与计算的各方除了能拿到自己的输出和由输出能够推测到的任何信息以外，不能获得更多关于其他参与方输入与输出的信息。在已有的研究中，安全多方计算技术通常基于待计算函数的电路进行构造，如1986年姚期智提出的混淆电路加不经意传输协议。因此，根据待计算函数的复杂程度，安全多方计算协议的复杂程度也有所不同。故在将安全多方计算技术应用于实际的分布式安全计算场景中时，需要确保以下两点：1)尽可能减少安全多方计算协议的使用，只确保在关键的隐私保护处使用以保证算法整体的效率和性能；2)由安全多方计算协议计算的函数本身需要表达成与输入完全独立的形式，以避免由于函数运行过程造成的对输入信息的泄漏；3)当考虑更强的安全性，即能够抵御恶意敌手攻击的方案设计时，还需要专门设计特定的方法来识别不按协议要求提供不合理输入的检测方法，这也是安全多方计算技术的应用难点。差分隐私技术：差分隐私是数据分析领域的一个安全定义，用来衡量目标数据集在特定的函数计算过程中隐私泄漏的情况。该定义由Dwork和Roth提出，并基于两个被称为邻居的数据集D和D’来定义，邻居是指两个具有相同数据全集U的数据集，在以元素出现频率进行表示的时候，仅在某一个元素上，出现频率相差1。通常定义的差分隐私带有两个参数，分别是∈和δ，其中∈主要用来刻画隐私保护的程度，∈越小则意味着提供更强的隐私保护但也意味着获得更不精确的输出，δ则用来刻画可区分的程度，δ在实际的算法设计中，通常为给定的安全参数。在差分隐私技术的使用中，还有一个非常关键的概念叫全局敏感度，该概念用于定义某个算法在处理邻居数据集时，输出的最大差异。通常，需要根据实际需求，来找到感兴趣的目标函数的全局敏感度，这是因为，作为一种非常常见的提供差分隐私的技术，基于Laplace变换的机制使用最多，而该变换的选取依赖于目标函数的全局敏感度。发明内容针对上述问题，本发明的目的在于提供一种面向私有数据集的安全高效分位数聚合方法及装置，能够使两方用户在确保各自私有数据集隐私能得以保护的前提下，安全的进行分位数近似计算的聚合问题，并确保整个分位数近似计算的聚合过程不泄漏除差分隐私允许的信息以外的额外用户私有信息，且不会降低原始算法的准确率。技术方案如下：一种面向私有数据集的安全高效分位数聚合方法，包括以下步骤：S1：两方用户分别基于各自的私有数据集计算本地的Q-Digest数据结构，也即更新完成后的树；S2：提出对Q-Digest算法merge操作的改进算法OMerge，使得算法的运行与输入完全独立；S3：分析merge操作的全局敏感度，依据差分隐私来确定为本地计算结果添加元组的数目，根据该数目增加无效节点，并将增加了无效节点的树作为改进后merge算法OMerge的输入，调用开源的多方计算工具集，实现merge函数的安全计算；S4：两方分别从运行结果中得到聚合后的分位数近似计算结果。进一步的，所述改进算法OMerge包括：S21：定义两个集合作为OMerge的输入，每个集合中每个元组格式为＜id，c，isDummy，isParent＞；其中，id为树从根节点到叶子节点按照从上到下，从左到右的顺序标记的节点id；c为叶子节点所对应的元素在数据集中出现的频率，即该节点的counter值；isDummy是为一个二进制谓词，若该元组是有效的，则isDummy置为0，否则置为1；isParent也为一个二进制谓词，用于解释当前的元组是Q-Digest结构中本身的元组，还是将其父节点进行处理之后的元组，若未经过处理，则该isParent字段为0，否则置为1；S22：将两个经由本地Q-Digest算法计算后得到的数据集进行所有父节点的push操作，即将父节点均向下压到其左孩子，并将压缩的节点元组中isParent字段置为1，处理后的数据集作为算法的输入；S23：将两个输入的集合进行求和操作，对应节点且isParent字段和isDummy字段均相同的元组counter值相加，则得到将两个输入进行汇总的效果；S24：基于求和的集合，并引入判断谓词进行不同情况下的压缩规则判断，以判断是否需要merge操作；S25：当判断需要merge操作时，将当前节点的id置为其父节点的id，将当前节点的counter值置为计算所得的counter值之和，仅有一个节点的情况时，counter值不变；并将涉及该节点压缩判断的其他节点的元组中的isDummy置为1，表明这几个节点的压缩判断均已完成，后续无需再重复判断；当判断无需merge操作时，保留每个节点，恢复父节点的原始元组信息，也即将isParent字段为1的节点的id变换回原来的父节点id；S26：从叶子到根逐层进行上述判断，每层完成后，将所有的节点按压缩之后更新的id大小从大到小重新排序，再进行下一层的压缩操作，直到完成整个树的压缩。更进一步的，所述将其父节点进行处理具体为：将一个父节点的id变为其左孩子的id，为与原先的左孩子元组区分，该父节点的元组中isParent字段被置为1，而原先的左孩子元组中isParent置为0。更进一步的，S24中所述判断谓词包括：1NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均为0时，该节点是否需要压缩；若节点的counter值小于等于压缩门限θ，则该谓词置为1，表示该节点需要merge操作；1NodeRecover：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均为0时，该节点是否需要压缩；若节点的counter值大于压缩门限θ，此时，该谓词置为1，表示该节点无需merge操作；2NodeMerge：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；若该节点与存在的父/兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这两个节点需要merge操作；2NodeRecover：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；若该节点与存在的父/兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这两个节点无需merge操作；3NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均大于0时，该节点是否需要压缩；若该节点与存在的父节点和兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这三个节点需要merge操作；3NodeRecover：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩；该节点与其父节点和兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这三个节点无需merge操作。更进一步的，所述S25中，所述恢复父节点的原始元组信息用Parent函数来实现，即Parent＝id/2。更进一步的，所述分析merge操作的全局敏感度具体为：定义函数L为压缩函数的输出长度，也即完成Q-Digest算法之后的数据结构中元组的数量；同时定义ΔL为函数L的敏感度；根据差分隐私的定义，分析函数L在处理两个邻居数据集时输出的最大差异，该差异即为函数L的敏感度ΔL；根据所述敏感度ΔL，确定基于所述压缩操作应为本地计算结果添加元组的数目。一种面向私有数据集的安全高效分位数聚合装置，包括Q-Digest数据结构计算单元、全局敏感度分析单元、改进算法OMerge计算单元和结果输出单元；所述Q-Digest数据结构计算单元用于根据两方用户各自的私有数据集计算本地的Q-Digest数据结构，也即完成的树本地更新；所述全局敏感度分析单元依据merge操作的全局敏感度，基于截断Laplace机制增加适当的无效节点，并将增加了无效节点的树作为改进后OMerge算法的输入；所述改进算法OMerge计算单元设计对输入独立的merge算法，确保算法运行过程不泄漏用户的原始输入信息，并调用开源的多方计算工具集，实现merge函数的安全计算；所述结果输出单元用于使两方分别从运行结果中得到聚合后的分位数近似计算结果。本发明的有益效果是：本发明能够使两方用户在确保各自私有数据集隐私能得以保护的前提下，安全的进行分位数近似计算的聚合问题，基于原始Q-Digest算法进行算法的改进设计，利用差分隐私技术来保护用户的输入，以确保整个分位数近似计算的聚合过程不泄漏除差分隐私允许的信息以外的额外用户私有信息，并利用安全多方计算技术来实现算法的安全运行，且改进的算法不会降低原始算法的准确率。附图说明图1为Q-Digest算法运行实例中，将原始数据集频率向量对应到数据集全集并放入二叉树叶子节点对应位置的待处理原始数据结构；其中，虚线框代表节点的counter值不为空，实线框代表节点的counter值为空。图1为Q-Digest算法运行实例中，依据Q-Digest算法对树的叶子层进行merge操作之后的数据结构；其中，虚线框代表节点的counter值不为空，实线框代表节点的counter值为空。图1为Q-Digest算法运行实例中，对树的倒数第二层进行merge操作之后的数据结构；其中，虚线框代表节点的counter值不为空，实线框代表节点的counter值为空。图2为引理1的直观表示中树T的局部视图；其中，虚线框代表节点的counter值不为空，实线框代表节点的counter值为空。图2为引理1的直观表示中树T′的局部视图；其中，虚线框代表节点的counter值不为空，实线框代表节点的counter值为空。图3为人为合成数据集上的性能表现柱状图，数据集全集大小为U＝28。图4为人为合成数据集上的性能表现柱状图，数据集全集大小为U＝216。图5为人为合成数据集上的性能表现柱状图，数据集全集大小为U＝232。具体实施方式下面结合附图和具体实施例对本发明做进一步详细说明。为解决上述问题，本发明采用的技术方案为：首先，两方用户分别基于各自的私有数据集计算本地的Q-Digest数据结构，也即更新完成后的树；其次，设计对输入独立的merge算法，确保算法运行过程不泄漏用户的原始输入信息；然后依据merge操作的全局敏感度，增加适当的无效节点，并将增加了无效节点的树作为改进后merge算法的输入，调用开源的多方计算工具集，实现merge函数的安全计算，最终，两方分别从运行结果中得到聚合后的分位数近似计算结果，且无法从算法执行过程中获得额外信息。下面从以下几个方面来详细介绍本方案：1)对Q-Digest算法的merge操作进行改进，使得算法的运行与输入完全独立，也即在处理不同的输入时，算法的运行步骤完全相同，此过程通过引入一些无效操作来隐藏不同的处理逻辑，改进后的算法记为OMerge。2)分析merge操作的全局敏感度，也即将merge作为待分析函数，分析两棵由邻居数据集构成的Q-Digest树merge结果的最大差异。3)用开源工具集EMP实现算法，并分析改进算法在处理不同规模数据集时的性能表现。第一、对Q-Digest算法merge操作的改进算法OMerge。OMerge算法以两个集合为输入，分别为Q1和Q2，两个集合分别基于本地计算的Q-Digest结构经一定处理所得，为了能够支持额外的操作以隐藏对于不同数据的不同处理方式，定义每个集合中每个元组格式为＜id，c，isDummy，isParent＞，其中id和c与原先Q-Digest算法中的定义相同。新增加的isDummy是一个二进制谓词，如果这个元组是有效的，则isDummy置为0，否则置为1；这个字段的引入是因为需要对本地计算的Q-Digest结构进行一定的扩充，使得本地计算的真实结果的元组数量能够获得一定的隐藏。新增加的isParent也是一个二进制谓词，用于解释当前的元组是Q-Digest结构中本身的元组，还是将其父节点进行处理之后的元组，若未经过处理，则该字段为0，否则置为1；这个字段的引入主要是由于Q-Digest算法本身是从叶子到根结点，逐层往上根据压缩规则进行压缩操作，且每一次压缩操作都依赖于对当前节点的邻居节点和父节点的counter值的访问，而根据算法对id的定义可知，父节点与孩子节点的id不相邻，根据输入的不同，为找到当前节点的父节点需要访问的元组个数也不一定相同，因此，根据访问节点的个数，可能推测出关于原始数据的一些分布信息，从而泄漏数据的分布，为了隐藏这些信息，希望每一个节点的压缩操作都只需对相邻的元组访问即可完成。所以，引入了isParent字段将一个父节点的id变为其左孩子的id，为了与原先的左孩子元组区分，该父节点的元组中isParent字段被置为1，而原先的左孩子元组中isParent置为0。OMerge算法的总体思想：首先，将两个经由本地Q-Digest算法计算后得到的数据集进行所有父节点的push操作，即将父节点均向下压到其左孩子，并将压缩的节点元组中isParent字段置为1，处理后的数据集作为算法的输入。然后，算法先将两个集合进行求和操作，对应节点且isParent字段和isDummy字段均相同的元组counter值相加，则得到将两个输入进行汇总的效果。此后，则基于这个求和的集合进行merge操作，操作的基本原理与原先的Q-Digest算法基本相同，不同之处仅体现在本发明的改进导致的压缩规则判断部分对元组的访问形式。为了让压缩判断更直观，本发明还在算法中引入了一些判断谓词，分别用于处理不同情况下的压缩规则判断，具体使用到的谓词如下：1NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均为0时，该节点是否需要压缩。若节点的counter值小于等于压缩门限θ，则该谓词置为1，表示该节点需要merge操作。1NodeRecover：情况同上，但节点的counter值大于压缩门限θ，此时，该谓词置为1，表示该节点无需merge操作。2NodeMerge：用于辅助判断当前待压缩节点的父亲节点或兄弟节点的counter值有且仅有一个大于0时，该节点是否需要压缩。若该节点与存在的父/兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这两个节点需要merge操作。2NodeRecover：情况同上，但该节点与存在的父/兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这两个节点无需merge操作。3NodeMerge：用于辅助判断当前待压缩节点的父亲节点和兄弟节点的counter值均大于0时，该节点是否需要压缩。若该节点与存在的父节点和兄节点的counter值之和小于等于压缩门限θ，则该谓词置为1，表示这三个节点需要merge操作。3NodeRecover：情况同上，但该节点与其父节点和兄节点的counter值之和大于压缩门限θ，此时，该谓词置为1，表示这三个节点无需merge操作。有了以上谓词的帮助，则只需根据不同的情况进行对应的操作即可，在发生merge操作的情况下，也即1NodeMerge或2NodeMerge或3NodeMerge为1时，需要将当前节点的id置为其父节点的id，将当前节点的counter值置为计算所得的counter值之和，并将涉及该节点压缩判断的其他节点的元组中的isDummy置为1，表明这几个节点的压缩判断均已完成，后续无需再重复判断。类似的，当无merge情况发生时，也即1NodeRecover或2NodeRecover或3NodeRecover为1时，保留每个节点，但由于OMerge算法最开始接受的输入里，父节点已经经过了处理，需要在此时恢复父节点的原始元组信息，也即，需要将isParent字段为1的节点的id变换回原来的父节点id，在算法里，用Parent函数来实现该功能，也即，Parent＝id/2。跟原始Q-Digest算法类似，从叶子到根逐层进行这样的判断，每层完成后，将所有的节点按压缩之后更新的id大小从大到小重新排序，再进行下一层的压缩操作，如此即可完成整个树的压缩，从而实现将两个本地计算的Q-Digest结构merge起来，得到对于两个私有数据集的近似分位数计算结果。但此时，本发明的算法里还需要引入一些无效节点来隐藏双方各自的输入大小。需要添加的无效节点不影响算法运行，但需要依据差分隐私来给出确切数目，从而确保对输入的隐藏有严格的隐私泄漏边界。将在方案第二部分详细叙述如何得到这样的数目。第二、merge操作的全局敏感度分析。首先，为方便叙述，给出对于数据集D的以下符号的定义，邻居数据集D’的定义类似。表1符号定义为了隐藏本地Q-Digest计算结果，希望任何一方都不能获得另一方本地计算结果的确切元组数量。而本地计算结果是对本地私有数据集进行相应的压缩操作得到的。根据差分隐私的定义，需要分析压缩操作的全局敏感度，从而才能确定基于该压缩操作，应该为本地计算结果添加多少数目的元组，使得OMerge的输入可为参与方提供一定程度的差分隐私安全性。为了更好的叙述，定义函数L为压缩函数的输出长度，也即完成Q-Digest算法之后的数据结构中元组的数量；同时定义ΔL为函数L的敏感度。根据差分隐私的定义，需要分析函数L在处理两个邻居数据集时输出的最大差异，该差异即为函数L的敏感度ΔL。通过一些基于对算法的认识获得的事实和一些引理来进行敏感度ΔL的具体分析过程。事实1：首先，观察到对于一个中间节点，如果它存在于最终的本地Q-Digest计算结果中，那么该节点的兄弟节点也一定存在于最终的本地计算结果中。可以通过反证法来说明这个事实：假设该中间节点的标号为id，其兄弟节点标号为ids，如果标号为id的节点在最终计算结果中，而标号为ids的节点不在最终结果中，那意味着，标号为id的节点的counter值已经超过了门限值，然而，对于一个中间节点来说，其counter值来自以其为根的子树上的节点向上merge所得，因此，在到达这个节点之前，这个counter值已经不符合压缩规则，根据算法的定义，本不应该再向上压缩到当前节点，而应该在该节点的孩子层就被保留下来，因此，此时标号为id的节点一定不会出现在最终的计算结果中，这与本发明的假设相反，故，如果标号为id的节点在最终计算结果中，则标号为ids的节点也一定在最终结果中。根据事实1，qS可被标识为两种形式：1)qS＝2+r+s，这里s为集合Q∪S中叶子节点的个数，说明叶子节点被保留，故该层未压缩，因此为m贡献了1个层级；2)qS＝2m+r，此时Q∪S中无叶子节点。对于邻居数据集，可以类似定义q′S。事实2：还可由观察得知，Q与Q’只在S与S’上有所不同。这一事实也可以通过反证法来说明：假设有节点在QS与Q’S’中，且在两个集合中的counter值不同。那么这意味着，以该节点往下回溯到叶子节点，一定存在频数上的差异，也就说明，原先的集合除了在σ处相差1外，还在其他地方也有出现频数上的差异，这与定义的邻居数据集相矛盾，因此，通过邻居数据集D与D’所得的Q-Digest计算结果Q与Q’只可能在S与S’上有所不同，而在其他地方完全相同。基于以上两个事实，可以得到以下引理及推论。引理1：假设集合S中两个相邻层级的非空叶子节点分别处于第li和lj层，且li＞lj，且在集合S’中，相同层级li和lj上的节点均为空节点，那么，在集合S’中，一定存在一个层级le上有非空节点，且一定有li＞le＞lj。该引理的一个更形象的表达见图2和图2。由引理1可以得到3个推论。推论1：压缩条件在两个树中被交替或同时打破，也即，如果集合S中两个相邻层级的非空叶子节点分别处于第li和lj层，且li＞lj，那么在集合S’中，必存在一个层级le上有非空节点，且一定有li≥le＞lj或li＞le≥lj。推论2：假设目前压缩操作进行到树的第lp层，且在S中该层的两个节点的counter值之和为c，类似的，S’中该层的两个节点的counter值之和为c’，如果c＞c’，则下一次压缩条件不被满足这一事件将首先发生在树T中，如果c＝c’，则从该层开始，两棵树都将以相同的方式进行压缩操作。推论3：假设D与D’为两数据集，有∑i∈＝1，且m和m’如表1所定义，则一定有m≥m’。此外，还可以得到以下引理。引理2：假设D与D’为两数据集，有∑i∈＝1，且m和m’如表1所定义，则有0≤m-m’≤1。由以上引理和推论，最终可得定理1，该定理展示了两个为邻居数据集的集合的Q-Digest结果中S集合的大小关系。定理1：给定两个数据集D与D’，有∑i∈＝1，则qS-q′S≤2。根据邻居数据集的定义，当且仅当∑i∈|f-f′|＝1时，两数据集为邻居数据集，则可以得以下推论。推论4：假设D与D’为两数据集，有∑i∈|f-f′|＝1，则|qS-q′S|≤2。推论5：函数L的全局敏感度为2，也即ΔL＝2。推论5即为本部分的分析目标，也即，确定了本地Q-Digest算法运行在两个邻居数据集上能产生的最大输出长度的差别为2。第三、算法的实现与性能表现。为了评估本发明的改进在实现不同安全强度、处理不同规模数据集、不同大小数据全集情况下，对算法性能的影响，基于安全多方计算开源工具包EMP进行了实验。首先，选择了截断的Laplace机制来产生噪声，该机制比一般的Laplace机制在同等隐私保证的情况下，期望值更小，这意味着可以增加的期望噪声更小，也即对于本地计算的Q-Digest结果添加的无效节点数目更少，从而能够减少安全多方计算电路的规模，进而减少由于增强安全性带来的性能损耗。截断的Laplace机制的概率分布函数，以及在不同隐私参数下的期望值如表2所示。表2截断Laplace机制的相关信息实现：OMerge算法用C++实现，并将算法运行在EMP工具集框架下，实验在型号为c5.2xlarge的亚马逊EC2机器上运行。数据集：选取了两种数据集进行实验，其中一种是人为合成的数据集，基于一个均值为0方差为1的高斯分布产生该数据集，并将其按比例转换成特定数据全集上的某一个整数，这种处理方式是因为，Q-Digest算法只能处理整数数据集，且这种处理方式是模拟高斯分布的最常见方式；另外，还在真实的数据集上开展了本发明的实验，从WIDE项目的日常网络通信数据包中保存了某一天的数据包，当天该项目共收集了88937609个数据包，在这些数据包中，提取了TCP/UDP协议包的目的端口信息作为目标数据集，这是因为，分析目的端口分布可以帮助查看网络包通信的大致特点。由于端口号范围为0-65535，因此，数据集全集大小U＝216。在人为合成数据集上的实验结果如图3～图5所示。考虑了不同数据集规模和不同大小数据全集下，1)没有任何安全保证即no padding情况，2)通过第二部分分析的全局敏感度得到的具有特定差分隐私保证的DP padding情况，3)以及为了完全隐藏输入信息而选取的Q-Digest算法输出的最大长度即full padding情况下，在EMP工具集下运行OMerge算法的运行时间对比情况，可以发现，本发明对算法的改进，相较于完全不提供安全保护的原始算法而言，带来的性能损失几乎可以忽略，而与不采用差分隐私技术直接隐藏所有输入信息的做法相比，几乎节省了50％-90％的性能损耗。类似的，在真实网络数据包上的实验结果如表3所示。表3真实数据集上的性能表现安全设置电路大小执行时间No padding1,255,561,82450.53DP padding1,287,095,18451.78Full padding8,746,648,704353.39。

标题title
源码插桩方法、装置、计算机设备和存储介质
摘要abst
本申请涉及一种源码插桩方法、装置、计算机设备和存储介质。所述方法包括：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。基于上述源码插桩方法，在利用编译命令对用户代码编译过程中，读取到编译命令中的插桩编译函数时，则对用户代码所依赖的标准库源代码进行插桩处理，从而生成插桩处理后的更新源码，无需对用户代码进行侵入修改，减少了用户代码的版本数量，简化了用户代码的版本维护操作。
权利要求书clms
1.一种源码插桩方法，其特征在于，所述方法包括：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。2.根据权利要求1所述的方法，其特征在于，所述对待插桩源码进行插桩处理，生成插桩处理后的更新源码，包括：将所述待插桩源码对应的存储目录拷贝至指定临时目录，并将所述存储目录的环境变量值由第一数值修改为第二数值；其中，所述第二数值用于指示所述指定临时目录的环境变量值；在所述指定临时目录中对所述待插桩源码进行插桩处理，生成插桩处理后的更新源码。3.根据权利要求2所述的方法，其特征在于，所述在所述指定临时目录中对所述待插桩源码进行插桩处理，生成插桩处理后的更新源码，包括：获取静态库变量的参数值；按照所述静态库变量的参数值确定对应的桩函数静态库；基于待插桩函数与指定桩函数之间的映射关系表，在所述桩函数静态库中获取与所述待插桩源码中待插桩函数对应的目标桩函数；将所述目标桩函数添加至所述待插桩源码中相应待插桩函数的起始处和/或结尾处，生成所述更新源码。4.根据权利要求3所述的方法，其特征在于，所述获取静态库变量的参数值，包括：读取所述编译命令中的桩函数静态库参数值；将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。5.根据权利要求4所述的方法，其特征在于，所述读取所述编译命令中的桩函数静态库参数值之后，所述方法包括：在所述待插桩源码中添加自动执行函数；所述将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值，包括：在读取到所述自动执行函数时，将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。6.根据权利要求3所述的方法，其特征在于，所述生成所述更新源码之后，所述方法还包括：将所述更新源码相应所述存储目录的环境变量值由所述第二数值修改为所述第一数值。7.根据权利要求2所述的方法，其特征在于，所述将所述待插桩源码对应的存储目录拷贝至指定临时目录之前，所述方法还包括：随机生成所述指定临时目录；对所述指定临时目录添加文件锁；其中，带有所述文件锁的所述指定临时目录用于对不同的所述待插桩源码进行插桩处理。8.一种源码插桩装置，其特征在于，所述装置包括：确定模块，用于在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；插桩模块，用于在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。9.一种计算机设备，包括存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，其特征在于，所述处理器执行所述计算机程序时实现权利要求1至7中任一项所述方法的步骤。10.一种计算机可读存储介质，其上存储有计算机程序，其特征在于，所述计算机程序被处理器执行时实现权利要求1至7中任一项所述方法的步骤。
说明书desc
技术领域本申请涉及计算机技术领域，尤其涉及一种源码插桩方法、装置、计算机设备和存储介质。背景技术编程语言可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。目前行业内，针对编程语言插桩的方式主要是直接修改用户级源码，具体通过修改用户级源码和增加源码的方式，来实现对特定函数的数据流跟踪和分析。但是此方法对用户源码有侵入性，需要修改用户代码，直接导致用户代码需要维护两个版本，一个生产版本一个插桩版本，从而衍生各种版本维护的问题。发明内容为了解决上述技术问题，本申请提供了一种源码插桩方法、装置、计算机设备和存储介质。第一方面，本申请提供了一种源码插桩方法，包括：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。第二方面，本申请提供了一种源码插桩装置，包括：确定模块，用于在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；插桩模块，用于在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。第三方面，本申请提供了一种计算机设备，包括存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，所述处理器执行所述计算机程序时实现以下步骤：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。第四方面，本申请提供了一种计算机可读存储介质，其上存储有计算机程序，所述计算机程序被处理器执行时实现以下步骤：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。上述源码插桩方法、装置、计算机设备和存储介质，所述方法包括：在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。基于上述源码插桩方法，在利用编译命令对用户代码编译过程中，读取到编译命令中的插桩编译函数时，表示需要进行插桩处理，则对用户代码所依赖的标准库源代码进行插桩处理，从而生成插桩处理后的更新源码，无需对用户代码进行侵入修改，减少了用户代码的版本数量，简化了用户代码的版本维护操作。附图说明此处的附图被并入说明书中并构成本说明书的一部分，示出了符合本发明的实施例，并与说明书一起用于解释本发明的原理。为了更清楚地说明本发明实施例或现有技术中的技术方案，下面将对实施例或现有技术描述中所需要使用的附图作简单地介绍，显而易见地，对于本领域普通技术人员而言，在不付出创造性劳动性的前提下，还可以根据这些附图获得其他的附图。图1为一个实施例中源码插桩方法的流程示意图；图2为一个实施例中源码插桩装置的程序模块示意图；图3为一个实施例中计算机设备的结构图。具体实施方式为使本申请实施例的目的、技术方案和优点更加清楚，下面将结合本申请实施例中的附图，对本申请实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例是本申请的一部分实施例，而不是全部的实施例。基于本申请中的实施例，本领域普通技术人员在没有做出创造性劳动的前提下所获得的所有其他实施例，都属于本申请保护的范围。在一个实施例中，图1为一个实施例中一种源码插桩方法的流程示意图，参照图1，提供了一种源码插桩方法。本实施例主要以该方法应用于服务器来举例说明，该源码插桩方法具体包括如下步骤：步骤S110，在接收到待编译的用户代码时，根据编译命令对用户代码进行编译。具体的，用户代码是指用户按照个人逻辑编辑生成的代码，编译命令用于将用户代码编译转换为计算机可识别的机器语言，标准库源代码是指已经提前编辑好可使用、可修改的代码，通常标准库源代码包含了编程人员使用频率较高或较为基础的代码，对于使用频率较高的代码无需反复手动写入，可直接利用标准库源代码进行修改调整，以此加快代码生成效率。即编译命令为在标准库源代码的基础上进行修改后形成的代码。用户代码和标准库源代码都是基于编程语言生成的代码，编译命令也是由编程语言编写而成的，编程语言具体可以为Java语言、C语言、C++语言、PHP语言、Python语言、VB语言或GO语言等，在本实施例中选择GO语言作为编程语言。步骤S120，在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码。其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。具体的，在编译命令中读取到插桩编译参数，表示编译过程需要进行插桩编译操作；对于未读取到插桩编译参数的编译命令，表示该编译过程无需进行插桩编译操作，按照正常编译操作即可。对于需要进行插桩处理的编译命令，对该编译过程中用户代码所依赖的标准库源代码进行插桩处理，不会对用户代码直接进行侵入性修改，而是对其相应的标准库源代码进行修改，从而避免产生与用户代码对应的生产版本代码以及插桩版本代码，即对用户代码的维护仅需要维护其生产版本代码，从而实现减少了用户代码的版本数量，简化了用户代码的版本维护操作，并且仅对标准库源代码进行插桩处理，不会对其他编译工具源码产生改动影响。对用户代码所依赖的标准库源代码进行插桩处理后，生成的更新源码用于形成具备数据流跟踪功能的可执行程序，便于后续实现对可执行程序的数据流跟踪和分析。在一个实施例中，所述对待插桩源码进行插桩处理，生成插桩处理后的更新源码，包括：将所述待插桩源码对应的存储目录拷贝至指定临时目录，并将所述存储目录的环境变量值由第一数值修改为第二数值；在所述指定临时目录中对所述待插桩源码进行插桩处理，生成插桩处理后的更新源码。其中，所述第二数值用于指示所述指定临时目录的环境变量值，第一数值为存储目录原本的环境变量值，环境变量值用于指示目录所在位置，即通过环境变量值可查找到相应目录。具体的，存储目录用于指示待插桩源码的安装路径，存储目录即为GOROOT目录，将存储目录拷贝至指定临时目录中，在指定临时目录中进行插桩处理，对于独立于指定临时目录之外的存储目录并没有任何影响。由于每个目录对应一个环境变量值，将存储目录拷贝至指定临时目录后，还需要将存储目录的环境变量值由第一数值修改为指定临时目录相应环境变量值，即由第一数值修改为第二数值，以此避免出现不同目录对应一个环境变量值的情况，防止不同目录对应同一环境变量值时无法精准查找到目录所在位置。在一个实施例中，所述在所述指定临时目录中对所述待插桩源码进行插桩处理，生成插桩处理后的更新源码，包括：获取静态库变量的参数值；按照所述静态库变量的参数值确定对应的桩函数静态库；基于待插桩函数与指定桩函数之间的映射关系表，在所述桩函数静态库中获取与所述待插桩源码中待插桩函数对应的目标桩函数；将所述目标桩函数添加至所述待插桩源码中相应待插桩函数的起始处和/或结尾处，生成所述更新源码。具体的，静态库变量的参数值用于指示桩函数静态库的接入端口，桩函数静态库即为Plugin库，桩函数静态库包括多个可引用的桩函数，在存在多个桩函数静态库时，每个桩函数静态库对应一个接入端口，也就是不同的桩函数静态库相应静态库变量对应的参数值不同，根据静态库变量的参数值即可调用相应的桩函数静态库。在桩函数逻辑发生变更时，无需重新编译程序代码，只需要替换相应的桩函数静态库即可，提高了插桩效率。待插桩函数用于指示待插桩源码中等待插桩处理的函数，指定桩函数用于指示即将插入待插桩源码中的函数，待插桩函数与指定桩函数之间的映射关系表包括多个函数对，每个函数对包括一个待插桩函数、一个指定桩函数以及两个桩函数之间的映射关系，即仅能利用存在映射关系的指定桩函数对相应待插桩函数进行插桩处理，不存在映射关系的两个桩函数无法实现插桩处理，映射关系表中待插桩函数与指定桩函数之间的映射关系具体可以为一对一、一对多、多对一、或多对多等，即一个待插桩函数可以对应一个指定桩函数，也可以对应多个指定桩函数，一个指定桩函数可以对应多个待插桩函数，亦或者，多个指定桩函数对应多个待插桩函数。对映射关系表进行兼容性设定，使得映射关系表中的映射关系只会发生增加的情况，不会发生修改或删除的情况，即桩函数之间的匹配逻辑不以发生变化，因此在进行后期维护时，仅需要对映射关系表中已有的映射关系以及新增加的映射关系进行维护即可，简化了维护操作量。由于桩函数之间的映射关系固定，基于映射关系表自动对待插桩源码进行插桩处理，无需手动匹配，提高了插桩效率。将桩函数静态库中与待插桩源码中待插桩函数存在映射关系的指定桩函数作为目标桩函数，而桩函数静态库中可能存在一个或多个与待插桩函数存在映射关系的指定桩函数，在桩函数静态库中仅存在一个与待插桩函数存在映射关系的指定桩函数时，将该指定桩函数作为目标桩函数，将目标桩函数添加至待插桩源码中相应待插桩函数的起始处和/或结尾处，便于后续实现对待插桩函数的数据流跟踪。在桩函数静态库中存在多个与待插桩函数存在映射关系的指定桩函数时，在多个指定桩函数中随机选择一个作为目标桩函数，将目标桩函数添加至待插桩源码中相应待插桩函数的起始处和/或结尾处；亦或者是，在多个指定桩函数中随机选择两个作为目标桩函数，将其中一个目标桩函数添加至待插桩源码中相应待插桩函数的起始处，将另一个目标桩函数添加至待插桩源码中相应待插桩函数的结尾处。综上所述，根据映射关系表自动在待插桩源码中添加桩函数，无需手动写入，提高了插桩效率的同时，也避免了手动写入容易出现桩函数引用错误的情况。在一个实施例中，所述获取静态库变量的参数值，包括：读取所述编译命令中的桩函数静态库参数值；将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。具体的，在待插桩源码中添加静态库变量，便于按照静态库变量的参数值访问对应的桩函数静态库，此时刚添加后的静态库变量对应的参数值为空指针值，即不指示任何桩函数静态库，需要对静态库变量进行初始化处理，即将编译命令中的桩函数静态库参数值赋值给静态库变量，由于编译命令需要进行插桩处理，因此编译命令中包含有插桩处理所需桩函数的静态库相应接入端口，也就是上述桩函数静态库参数值，从而确定后续插桩处理过程中，根据静态库变量的参数值从桩函数静态库中获取所需的桩函数。在获取静态库变量的参数值之前，还需要编写桩函数，使用GO命令以及编写好的桩函数生成桩函数静态库。在一个实施例中，所述读取所述编译命令中的桩函数静态库参数值之后，所述方法包括：在所述待插桩源码中添加自动执行函数；所述将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值，包括：在读取到所述自动执行函数时，将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。具体的，自动执行函数即为init函数，在待插桩源码中加入自动执行函数，即可实现在执行到自动执行函数时可自动对静态库变量进行初始化操作，无需手动操作初始化，进一步地优化了插桩处理过程。在一个实施例中，所述生成所述更新源码之后，所述方法还包括：将所述更新源码相应所述存储目录的环境变量值由所述第二数值修改为所述第一数值。具体的，在更新源码生成之后，将其对应的存储目录的环境变量值由第二数值修改为第一数值，即在上述指定临时目录中的存储目录释放出来，以替换独立于指定临时目录之外未发生插桩处理的存储目录，便于后续利用已经过插桩处理的更新源码生成相应的执行命令。在一个实施例中，所述将所述待插桩源码对应的存储目录拷贝至指定临时目录之前，所述方法还包括：随机生成所述指定临时目录；对所述指定临时目录添加文件锁；其中，带有所述文件锁的所述指定临时目录用于对不同的所述待插桩源码进行插桩处理。具体的，利用文件锁机制确保指定临时目录仅生成一次，即锁定指定临时目录，每个需要进行插桩处理的待插桩源码都将依次拷贝至指定临时目录中进行插桩处理，防止每对一个待插桩源码进行插桩处理时都将生成一个临时目录，从而节约内存空间。在一个具体实施例中，用户代码在进行编译前，若需要对用户代码的数据流进行跟踪分析，则在编译命令中添加插桩编译参数和桩函数静态库参数，从而在利用编译命令对用户代码进行编译过程中，将会在编译命令中读取到插桩编译参数，将该用户代码所依赖的标准库源代码作为待插桩源码，则对该用户代码所依赖的标准库源代码进行插桩处理，也就是对待插桩源码进行插桩处理。在插桩过程中，先将待插桩源码对应的存储目录拷贝至指定临时目录中，并将存储目录的环境变量值修改为指定临时目录的环境变量值，在此之前通过文件锁机制生成了一个指定临时目录，该指定临时目录用于为不同的待插桩源码进行插桩处理提供环境，避免拷贝前原本的存储目录受插桩处理的影响。在指定临时目录中，对待插桩源码添加静态库变量和自动执行函数，便于后续在编译过程中执行到自动执行函数时自动通过静态库变量接入相应的桩函数静态库，按照待插桩函数与指定桩函数之间的映射关系表，从桩函数静态库中获取与待插桩函数对应的目标桩函数，将获取到的目标桩函数添加至相应待插桩函数的起始处和/或结尾处，从而完成插桩操作，在插桩结束后将存储目录的环境变量修改为插桩之前的环境变量，从而生成更新源码，经过插桩处理后的更新源码具备数据流跟踪功能，在后续对用户代码的编译过程中可自动完成数据流的跟踪和分析，进而生成相应的可执行程序。上述源码插桩方法，利用源码插桩方法独权的技术特征进行推导，实现能够解决背景技术中所提出技术问题的有益效果。图1为一个实施例中源码插桩方法的流程示意图。应该理解的是，虽然图1的流程图中的各个步骤按照箭头的指示依次显示，但是这些步骤并不是必然按照箭头指示的顺序依次执行。除非本文中有明确的说明，这些步骤的执行并没有严格的顺序限制，这些步骤可以以其它的顺序执行。而且，图1中的至少一部分步骤可以包括多个子步骤或者多个阶段，这些子步骤或者阶段并不必然是在同一时刻执行完成，而是可以在不同的时刻执行，这些子步骤或者阶段的执行顺序也不必然是依次进行，而是可以与其它步骤或者其它步骤的子步骤或者阶段的至少一部分轮流或者交替地执行。在一个实施例中，如图2所示，提供了一种源码插桩装置，包括：确定模块210，用于在接收到待编译的用户代码时，根据编译命令对用户代码进行编译；插桩模块220，用于在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。在一个实施例中，所述插桩模块220还用于：将所述待插桩源码对应的存储目录拷贝至指定临时目录，并将所述存储目录的环境变量值由第一数值修改为第二数值；其中，所述第二数值用于指示所述指定临时目录的环境变量值；在所述指定临时目录中对所述待插桩源码进行插桩处理，生成插桩处理后的更新源码。在一个实施例中，所述插桩模块220还用于：获取静态库变量的参数值；按照所述静态库变量的参数值确定对应的桩函数静态库；基于待插桩函数与指定桩函数之间的映射关系表，在所述桩函数静态库中获取与所述待插桩源码中待插桩函数对应的目标桩函数；将所述目标桩函数添加至所述待插桩源码中相应待插桩函数的起始处和/或结尾处，生成所述更新源码。在一个实施例中，所述插桩模块220还用于：读取所述编译命令中的桩函数静态库参数值；将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。在一个实施例中，所述插桩模块220还用于：在所述待插桩源码中添加自动执行函数；所述将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值，包括：在读取到所述自动执行函数时，将所述编译命令中的桩函数静态库参数值赋值给所述静态库变量，作为所述静态库变量的参数值。在一个实施例中，所述插桩模块220还用于：将所述更新源码相应所述存储目录的环境变量值由所述第二数值修改为所述第一数值。在一个实施例中，所述插桩模块220还用于：随机生成所述指定临时目录；对所述指定临时目录添加文件锁；其中，带有所述文件锁的所述指定临时目录用于对不同的所述待插桩源码进行插桩处理。图3示出了一个实施例中计算机设备的内部结构图。该计算机设备具体可以服务器。如图3所示，该计算机设备包括该计算机设备包括通过系统总线连接的处理器、存储器、网络接口、输入装置和显示屏。其中，存储器包括非易失性存储介质和内存储器。该计算机设备的非易失性存储介质存储有操作系统，还可存储有计算机程序，该计算机程序被处理器执行时，可使得处理器实现源码插桩方法。该内存储器中也可储存有计算机程序，该计算机程序被处理器执行时，可使得处理器执行源码插桩方法。本领域技术人员可以理解，图3中示出的结构，仅仅是与本申请方案相关的部分结构的框图，并不构成对本申请方案所应用于其上的计算机设备的限定，具体的计算机设备可以包括比图中所示更多或更少的部件，或者组合某些部件，或者具有不同的部件布置。在一个实施例中，本申请提供的源码插桩装置可以实现为一种计算机程序的形式，计算机程序可在如图3所示的计算机设备上运行。计算机设备的存储器中可存储组成该源码插桩装置的各个程序模块，比如，图2所示的确定模块210和插桩模块220。各个程序模块构成的计算机程序使得处理器执行本说明书中描述的本申请各个实施例的源码插桩方法中的步骤。图3所示的计算机设备可以通过如图2所示的源码插桩装置中的确定模块210执行在接收到待编译的用户代码时，根据编译命令对用户代码进行编译。计算机设备可通过插桩模块220执行在编译过程中读取到所述编译命令中的插桩编译参数时，对待插桩源码进行插桩处理，生成插桩处理后的更新源码；其中，所述待插桩源码为所述用户代码所依赖的标准库源代码，所述更新源码用于生成具备数据流跟踪功能的可执行程序。在一个实施例中，提供了一种计算机设备，包括存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，处理器执行计算机程序时实现上述任一项实施例所述的方法。在一个实施例中，提供了一种计算机可读存储介质，其上存储有计算机程序，计算机程序被处理器执行时实现上述任一项实施例所述的方法。本领域普通技术人员可以理解实现上述实施例方法中的全部或部分流程，是可以通过计算机程序来指示相关的硬件来完成，所述的程序可存储于一非易失性计算机可读取存储介质中，该程序在执行时，可包括如上述各方法的实施例的流程。其中，本申请所提供的各实施例中所使用的对存储器、存储、数据库或其它介质的任何引用，均可包括非易失性和/或易失性存储器。非易失性存储器可包括只读存储器、可编程ROM、电可编程ROM、电可擦除可编程ROM或闪存。易失性存储器可包括随机存取存储器或者外部高速缓冲存储器。作为说明而非局限，RAM以多种形式可得，诸如静态RAM、动态RAM、同步DRAM、双倍速率SDRAM、增强型SDRAM、同步链路 DRAM、存储器总线直接RAM、直接存储器总线动态RAM、以及存储器总线动态RAM等。需要说明的是，在本文中，诸如“第一”和“第二”等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括所述要素的过程、方法、物品或者设备中还存在另外的相同要素。以上所述仅是本发明的具体实施方式，使本领域技术人员能够理解或实现本发明。对这些实施例的多种修改对本领域的技术人员来说将是显而易见的，本文中所定义的一般原理可以在不脱离本发明的精神或范围的情况下，在其它实施例中实现。因此，本发明将不会被限制于本文所示的这些实施例，而是要符合与本文所申请的原理和新颖特点相一致的最宽的范围。

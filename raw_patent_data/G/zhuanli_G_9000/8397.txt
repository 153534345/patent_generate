标题title
一种基于Linux操作系统的可信TCM软件栈的设计方法及系统
摘要abst
本申请公开了一种基于Linux操作系统的可信TCM软件栈的设计方法及系统，能够实现国产Linux操作系统中上层应用与可信TCM芯片进行通信交互，实现可信计算，保证数据的完整性和真实性、抵抗篡改攻击、能够安全的执行代码、保护敏感数据的机密性等。在Trousers软件栈Tcs层增加对可信TCM芯片的资源管理，更好解决可信TCM芯片资源有限的瓶颈，提高用户对可信TCM芯片资源的利用率。
权利要求书clms
1.一种基于Linux操作系统的可信TCM软件栈的设计方法，可信TCM软件栈包括FeatureAPI接口层和Trousers-TCM软件栈，其特征在于，包括如下步骤：在所述Trousers-TCM软件栈中增加资源管理模块，所述资源管理模块用于在创建主密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源，包括：判断所述可信TCM芯片资源是否已满，若所述可信TCM芯片资源已满，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建主密钥的命令数据包，与可信TCM芯片完成数据交互，之后解析可信TCM芯片返回的数据，获取密钥句柄，将所述密钥句柄转换成虚拟句柄，将所述密钥句柄和所述虚拟句柄保存到链表中；若芯片资源未满，则直接封装创建主密钥的命令数据包并进行后续步骤。2.根据权利要求1所述的基于Linux操作系统的可信TCM软件栈的设计方法，其特征在于，所述资源管理模块还用于在加载子密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源，包括：步骤S1：检测生成所述子密钥的主密钥是否已被加载，若否，则执行步骤S2，若是，则执行步骤S3；步骤S2：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，用ContextSave接口来保存该密钥数据，再通过调用ContextFlush接口清除该密钥数据，之后调用ContextLoad接口重新获取保存在TCMS_CONTEXT结构体中的主密钥，然后进入步骤S3；步骤S3：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建子密钥的命令数据包，与可信TCM芯片完成数据交互，解析可信TCM芯片返回的数据，获取密钥句柄，将所述密钥句柄转换成虚拟句柄，将所述密钥句柄和所述虚拟句柄保存到链表中，若否，则直接封装创建子密钥的命令数据包并进行后续步骤。3.根据权利要求1所述的基于Linux操作系统的可信TCM软件栈的设计方法，其特征在于，所述Trousers-TCM软件栈包括移植并优化后的System API接口。4.根据权利要求3所述的基于Linux操作系统的可信TCM软件栈的设计方法，其特征在于，移植System API接口到所述Trousers-TCM软件栈的步骤为：用所述System API接口修改所述Trousers-TCM软件栈中的源代码重新实现对应功能，所述源代码包括参数格式、数据命令协议、参数的封装和解析代码，所述对应功能包括创建密钥和获取密钥句柄。5.根据权利要求4所述的基于Linux操作系统的可信TCM软件栈的设计方法，其特征在于，优化所述System API接口的步骤为：对System API接口参数进行封装。6.根据权利要求5所述的基于Linux操作系统的可信TCM软件栈的设计方法，其特征在于，所述对System API接口参数进行封装包括：利用XML文件封装System API接口参数，形成XML模块，通过所述XML模块简化所述System API接口参数。7.一种基于Linux操作系统的可信TCM软件栈系统，其特征在于，包括Feature API接口层和Trousers-TCM软件栈，所述Trousers-TCM软件栈包括从上至下设置的System API接口层、资源管理模块和Tddl层，所述System API接口层包括从上至下设置的Tspi层、Tcsd层和Tcs层；其中，所述Feature API接口层用于对输入参数进行封装，简化参数结构；所述Tspi层用于对参数进行字符串转换，将字符串以数据包形式发送给Tcsd层；所述Tcsd层用于完成初始化工作，接收Tspi层发送的数据包，并将数据包发送至Tcs层；所述Tcs层用于接收并解析所述Tcsd层发送的数据包，获取参数信息，再通过底层接口对参数信息进行命令格式封装；所述资源管理模块用于采用最近最少使用算法来动态检测并调度可信TCM芯片资源；所述Tddl层用于通过设备文件与可信TCM芯片完成数据传输。
说明书desc
技术领域本申请涉及可信TCM软件栈领域，尤其涉及一种基于Linux操作系统的可信TCM软件栈的设计方法及系统。背景技术随着计算机应用的不断发展，安全威胁问题越来越严重，传统的单纯依赖软件来抵抗安全威胁往往不能解决问题。传统的信息安全的主要技术是防火墙、入侵检测和杀毒软件。当防火墙越砌越高，入侵检测越做越复杂，病毒库也越来越庞大时，整个信息安全状况依旧存在着日趋复杂和混乱的趋向：误报率增多、安全投入不断增加、维护与管理更加复杂和难以实施、信息系统的使用效率大大降低、对新的攻击入侵毫无防御能力。由“老三样”为主要构成的传统信息安全系统，是以防外为重点，只能在系统外部被动地抵抗攻击，并不能在根本上解决系统的安全问题。单纯被动防御对于计算机系统的安全问题不是很有效的解决方案，那么就促使相关的研究人员主动地从终端方面采取综合措施来应对，因此可信计算理论应运而生。可信计算依托于可信平台模块，TPM是可信计算平台的信任根，建立从硬件到固件，再到操作系统，直至应用程序的完整性信任链关系，为系统的安全存储和认证功能提供了硬件支持，通过保证每台计算机终端的安全性来提升整个计算体系的安全性。TPM本质上是一个嵌入在主板上的存储设备，该存储设备被动工作，在计算机系统引导启动时，TPM紧接BIOS启动之后就开始工作了，TPM对平台信息进行度量，接下来再启动操作系统，直到系统安全地启动起来。为了构建以TPM为核心的可信计算平台，国际可信计算组织推出了基于TPM的一系列工业规范。通常来说，TCG设备驱动程序库用来与TPM通信，一般情况下，TDDL先与内核中的TPM设备驱动程序进行会话通信，然后再由这个设备驱动程序与真实的TPM设备进行交互。棱镜门事件再次敲响信息安全的警钟。我们要建立自主的可信计算密码支撑平台而不是直接采用TCG组织的技术和规范。在可信计算系统中以密码技术为中心，若是在商用密码方面，没有自己的知识产权，用户使用的大部分产品采用的都是国外的技术与解决方案，比如大量地使用应用国外密码算法的TPM模块，则国家的信息安全主导权将难以得到保障。可信密码模块借鉴了TPM的理念和技术，但却采用了我国自主的密码算法，加入了对称密码算法，采用了不同的证书管理体制，简化了授权协议。用户通过利用正式启动计OS之前就先工作TCM芯片，进行系统度量，从而确保数据的完整性不被破坏。目前，中国自主研制的可信计算密码支撑平台主要是由可信密码模块TCM 和TCM服务模块组成的，其功能架构分别对应 TCG组织中可信平台模块的TPM与TSS。因此，实现基于中国国产操作系统与TCM硬件平台上的TSM是一个重要而又有意义的事情。为了使用可信密码模块TCM，用户需要一个与之交互的软件模块，该软件模块是可信软件栈。可信软件栈作为使用可信密码模块TCM的入口，位于用户应用软件与TCM之间，主要提供TCM安全芯片的访问、安全认证、密码服务和资源管理等功能，解决可信TCM芯片自身接口的复杂性和对外服务的不便性。现有的可信软件栈一般直接使用开源软件栈或稍加修改后使用。可信TCM芯片资源空间较小，对应用层使用带来很大限制，需要提高上层软件栈接口对可信TCM芯片资源的访问利用，不能很好适配自主研制的可信计算可信TCM芯片。有些接口参数比较复杂，一般用户很难正确填写参数，而接口对参数的要求非常严格，只要参数稍微有不符要求就会错误，造成调用出错。综上，现有可信软件栈对可信TCM芯片资源的访问利用率较低，且接口参数复杂，容易出错。发明内容本发明的主要目的是提供一种基于Linux操作系统的可信TCM软件栈的设计方法及系统，解决可信软件栈对可信TCM芯片资源的访问利用率较低的问题。为实现上述目的，本发明第一方面提出一种基于Linux操作系统的可信TCM软件栈的设计方法，可信TCM软件栈包括Feature API接口层和Trousers-TCM软件栈，包括如下步骤：在所述Trousers-TCM软件栈中增加资源管理模块，所述资源管理模块用于在创建主密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源，包括：判断所述可信TCM芯片资源是否已满，若所述可信TCM芯片资源已满，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建主密钥的命令数据包，与可信TCM芯片完成数据交互，之后解析可信TCM芯片返回的数据，获取密钥句柄，将所述密钥句柄转换成虚拟句柄，将所述密钥句柄和所述虚拟句柄保存到链表中；若芯片资源未满，则直接封装创建主密钥的命令数据包并进行后续步骤。可选地，所述资源管理模块还用于在加载子密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源，包括：步骤S1：检测生成所述子密钥的主密钥是否已被加载，若否，则执行步骤S2，若是，则执行步骤S3；步骤S2：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，用ContextSave接口来保存该密钥数据，再通过调用ContextFlush接口清除该密钥数据，之后调用ContextLoad接口重新获取保存在TCMS_CONTEXT结构体中的主密钥，然后进入步骤S3；步骤S3：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建子密钥的命令数据包，与可信TCM芯片完成数据交互，解析可信TCM芯片返回的数据，获取密钥句柄，将所述密钥句柄转换成虚拟句柄，将所述密钥句柄和所述虚拟句柄保存到链表中，若否，则直接封装创建子密钥的命令数据包并进行后续步骤。可选地，所述Trousers-TCM软件栈包括移植并优化后的System API接口。可选地，移植System API接口到所述Trousers-TCM软件栈的步骤为：用所述System API接口修改所述Trousers-TCM软件栈中的源代码重新实现对应功能，所述源代码包括参数格式、数据命令协议、参数的封装和解析代码，所述对应功能包括创建密钥和获取密钥句柄。可选地，优化所述System API接口的步骤为：对System API接口参数进行封装。可选地，所述对System API接口参数进行封装包括：利用XML文件封装System API接口参数，形成XML模块，通过所述XML模块简化所述System API接口参数。本发明第二方面提出一种基于Linux操作系统的可信TCM软件栈系统，包括Feature API接口层和Trousers-TCM软件栈，所述Trousers-TCM软件栈包括从上至下设置的System API接口层、资源管理模块和Tddl层，所述System API接口层包括从上至下设置的Tspi层、Tcsd层和Tcs层；其中，所述Feature API接口层用于对输入参数进行封装，简化参数结构；所述Tspi层用于对参数进行字符串转换，将字符串以数据包形式发送给Tcsd层；所述Tcsd层用于完成初始化工作，接收Tspi层发送的数据包，并将数据包发送至Tcs层；所述Tcs层用于接收并解析所述Tcsd层发送的数据包，获取参数信息，再通过底层接口对参数信息进行命令格式封装；所述资源管理模块用于采用最近最少使用算法来动态检测并调度可信TCM芯片资源；所述Tddl层用于通过设备文件与可信TCM芯片完成数据传输。从以上技术方案可以看出，本申请实施例具有以下优点：本申请提供的一种基于Linux操作系统的可信TCM软件栈的设计方法及系统，能够实现国产Linux操作系统中上层应用与可信TCM芯片进行通信交互，实现可信计算，保证数据的完整性和真实性、抵抗篡改攻击、能够安全的执行代码、保护敏感数据的机密性等。在Trousers软件栈Tcs层增加对可信TCM芯片的资源管理，更好解决可信TCM芯片资源有限的瓶颈，提高用户对可信TCM芯片资源的利用率。此外，利用XML文件对接口的层次对象结构体进行封装，形成模板文件，直接对XML文件修改就可以直观且方便地赋值，不易出错，实现对接口参数进行简化和完善。附图说明为了更清楚地表达说明本发明实施例的技术方案，下面将对实施例描述所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。图1是可信计算密码支撑平台功能框架图；图2是可信TCM芯片功能模块框图；图3是TSM的体系结构图；图4是本申请实施例中可信TCM软件栈的设计方法的步骤流程图；图5是本申请实施例中可信TCM软件栈系统的结构框图；图6是本申请实施例中可信TCM软件栈系统的数据处理流程图；图7是本申请实施例中创建主密钥流程图；图8是本申请实施例中加载子密钥流程图。具体实施方式为了使本技术领域的人员更好地理解本申请方案，下面将结合本申请实施例中的附图，对本申请实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例仅是本申请一部分实施例，而不是全部的实施例。基于本申请中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都属于本申请保护的范围。为了使本技术领域的人员更好地理解本申请方案，有必要了解现有国产可信计算密码支撑平台的现状。本申请的目的是为了在国产操作系统上适配自主研制的可信计算可信TCM芯片，上层应用便于和可信TCM芯片进行通信交互，进行可信计算。中国研制的可信计算密码支撑平台主要由可信密码模块和TCM服务模块两大部分组成。请参阅图1，可信计算密码支撑平台以可信密码模块为可信根，通过如下三类机制及平台自身安全管理功能，实现平台安全功能。以可信度量根为起点，计算系统平台完整性度量值，建立计算机系统平台信任链，确保系统平台可信。可信报告根标识平台身份得可信性，具有唯一性，以可信报告根为基础，实现平台身份证明和完整性报告。基于可信存储根，实现密钥管理，平台数据安全保护功能，提供相应的密码服务。可信密码模块是嵌入在计算机中的安全子系统，也是可信计算密码支撑平台必备的关键部件，TCM的核心功能主要是提供硬件级的国产密码算法与密钥保护；唯一性地标识平台身份；度量平台的完整性，提高平台的免疫力。独立的密码算法支撑。TCM是硬件和固件的集合，可以采用独立的封装形式，也可以采用IP核的方式和其他类型芯片集成在一起，提供TCM功能。其基本组成结构参阅图2。TCM的各个模块和功能如下：I/O控制部件：TCM的输入输出硬件接口。I/O负责所有算法引擎、存储区和寄存器与其他接口及应用程序的通讯；SM4引擎：执行SM4对称密码运算单元；SM2引擎：产生SM2密钥对和执行SM2加解密、签名运算的单元;SM3引擎：执行杂凑运算的单元；随机数发生器：生成随机数单元；HMAC引擎：基于SM3引擎的计算消息认证单元；执行引擎：TCM的运算执行单元；非易失性存储器：存储永久数据的存储单元；易失性存储器：TCM运行时临时数据的存储单元。可信密码服务模块TSM作为可信计算平台的软件核心，是可信应用程序访问TCM的主要入口。从总体来看是一种栈式结构，由几个离散的层组成，各层之间具有明确的访问接口。对于TSM的体系结构来说，尽管其模块和组件的特点会随着平台的不同而不同，但是其各模块之间的交互关系是一样的，所以说，TSM的体系结构不会依赖于平台。TSM的体系结构图参见图3。TSM由三个软件模块组成，即TCM应用服务、TCM核心服务和TCM设备驱动库。其中，TDDL与TCS存在于系统服务，TSP存在于用户程序。此外，与TSM相关的TCM设备驱动程序存在于内核层面。TCM服务提供者TSP向应用程序提供TCM服务，使应用程序只关注它本身的特性，通过提供上层的TCM函数接口，使TSP执行TCM提供的可信函数。TSP还提供了一些方便功能操作的辅助函数，这些函数不是由TCM提供，如：签名验证功能。TSP位于应用程序进程中，使每个应用程序看起来拥有一个自己的TSP。TCM核心服务TCS位于TSM服务提供者层和TCM设备驱动库层之间，以系统服务的形式存在，为TSP等上层应用提供TCM使用和密钥管理等功能接口。TCM设备驱动库TDDL位于TCM核心服务层和TCM设备驱动层之前，主要目的是在TDD之上提供一个标准的接口，屏蔽设备I/O控制信息的差异，完成信息在用户软件和内核之间传递。TDDL设计的优点在于：确保任意的TCM能与不同方法实现了的TSM交互；提供给TCM应用程序独立于操作系统的接口。TCM设备驱动程序TDD是内核模式下的模块，是由TCM制造商提供的，并且嵌入能够理解TCM具体行为的代码。因为用户模式的执行不能访问内核模式的执行，制造商也需提供TCM设备驱动库，由TSM打开TCM设备驱动器，除了TSM外，此驱动不允许任何程序与TCM设备连接。为了保证工控系统和应用可以方便的调用到可信TCM芯片的资源，本发明利用现有trousers软件栈的框架进行开发，其中对可信TCM芯片资源管理模块中采用最近最少使用算法来调度可信TCM芯片资源，提高上层接口对可信TCM芯片资源的访问利用率。本申请实施例提出一种基于Linux操作系统的可信TCM软件栈的设计方法，可信TCM软件栈包括Feature API接口层和Trousers-TCM软件栈，参见图4，设计方法包括：在Trousers-TCM软件栈中增加资源管理模块，资源管理模块采用最近最少使用算法检测并调度可信TCM芯片资源。可信TCM芯片资源管理模块能动态检测当前可信TCM芯片资源分配情况，对当前资源进行调配，用户层不用手动调配可信TCM芯片内部资源。在调用资源接口时都会通过资源管理模块对当前可信TCM芯片资源进行重新调配，确保每次调用接口都有足够的资源空间使用。应用层获取的句柄都是虚拟句柄可以直接进行使用，将虚拟句柄传入到资源管理模块后，将自动替换成密钥句柄再进行接口的相关操作，替换的方式采用最近最少使用算法进行自动调配。当检测到芯片资源空间不足时，使用最近最少使用算法从已加载密钥中找出最近最少使用的那个密钥，通过调用ContextSave接口来保存该密钥数据，再通过调用ContextFlush接口清除该密钥数据，这样该密钥数据不占有芯片资源空间，但是该密钥数据并没有丢失，只是被保存在TCMS_CONTEXT结构体中，如果该密钥再次需使用，可以通过调用ContextLoad接口从TCMS_CONTEXT结构体中重新加载到芯片中。可信TCM芯片资源分配的场景有很多，其中创建主密钥和加载子密钥是可信TCM芯片的常用工作场景，下面分别以创建主密钥和加载子密钥流程为例进行具体说明。主密钥是父密钥，是加密生成子密钥的根密钥，通过主密钥去加密生成子密钥，提高子密钥的安全性。只要用到加解密、签名等，初始化就要生成主密钥。应用场景：如果你生成的密钥要对外给别人用的，你不会将主密钥给别人。肯定根据主密钥再去生成相应的子密钥，这样保证你自身密钥管理的安全性，同时，给别人的密钥不能被外界破解，因为主密钥在你手里，只有你可以解密子密钥。请参阅图7，在创建主密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源包括：判断可信TCM芯片资源是否已满，若可信TCM芯片资源已满，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建主密钥的命令数据包，与可信TCM芯片完成数据交互，之后解析可信TCM芯片返回的数据，获取密钥句柄，将密钥句柄转换成虚拟句柄，将密钥句柄和虚拟句柄保存到链表中；若芯片资源未满，则直接封装创建主密钥的命令数据包并进行后续步骤。其中，ContextSave和ContextFlush接口为用C语言实现的函数功能的名称，通过调用这些接口去操作密钥数据，ContextSave功能是保存密钥数据，ContextFlush功能是清除密钥数据；TCMS_CONTEXT是用C语言封装的密钥数据的数据结构的名称，LRU和STATUS为数据结构中的两个数据变量，STATUS表示当前密钥的加载状态，LRU表示密钥最近使用率。请参阅图8，在加载子密钥时，采用最近最少使用算法检测并调度可信TCM芯片资源包括：步骤S1：检测生成子密钥的主密钥是否已被加载，若否，则执行步骤S2，若是，则执行步骤S3；步骤S2：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，用ContextSave接口来保存该密钥数据，再通过调用ContextFlush接口清除该密钥数据，之后调用ContextLoad接口重新获取保存在TCMS_CONTEXT结构体中的主密钥，然后进入步骤S3；步骤S3：判断可信TCM芯片资源是否已满，若是，则选择已加载的密钥中LRU值最小的密钥，调用ContextSave接口将该密钥数据保存到TCMS_CONTEXT结构体，再调用ContextFlush接口清除该密钥数据，然后更新LRU和STATUS，封装创建子密钥的命令数据包，与可信TCM芯片完成数据交互，解析可信TCM芯片返回的数据，获取密钥句柄，将密钥句柄转换成虚拟句柄，将密钥句柄和虚拟句柄保存到链表中，若否，则直接封装创建子密钥的命令数据包并进行后续步骤。能够实现国产操作系统中上层应用与可信TCM芯片进行通信交互，实现可信计算，保证数据的完整性和真实性、抵抗篡改攻击、能够安全的执行代码、保护敏感数据的机密性等。在Trousers软件栈Tcs层增加对可信TCM芯片的资源管理，更好解决可信TCM芯片资源有限的瓶颈，提高用户对可信TCM芯片资源的利用率。在一个改进实施例中，基于Linux操作系统的可信TCM软件栈的设计方法，所述Trousers-TCM软件栈包括移植并优化后的System API接口。System API是系统级API，用C语言实现的比较低层的函数，类似于C语言库函数，且支持ANSI C编译器，便于跨平台移植使用。System API接口可以将来自C语言结构的输入数据封装后发送至命令字节流，并将响应字节流格式的响应解组至C语言结构。System API接口有TCM_CreatePrimaryKey、TCM_XML_CreateKey、TCM_XML_CreatePrimaryKey、Tspi_TCM_Clear、Tspi_TCM_CreatePrimary、check_TCM_chip_resource、handle_TCM_chip_resource等等。用System API接口修改Trousers-TCM软件栈中对应功能的源代码，需要修改参数格式、数据命令协议、参数的封装和解析，去重新实现相应功能，按照此种方式进行移植。进一步，优化System API接口的设计思路如下：1、执行TCM命令：System API函数通常执行一个TCM命令。2、System API将尽可能实现可信TCM芯片命令行的功能和响应布局图，函数输入和输出参数按照命令行参数中显示的方式排序，变量名称尽可能匹配。3、对输入和输出参数的内存要求：A：所有输出参数都需要向System API传递指针。B：为了最小化堆栈内存需求，将作为指针传入非简单数据类型或位字段的输入。C：将输入命令字节流和输出响应字节流的缓冲区作为上下文结构的一部分进行分配，以最小化函数堆栈空间的使用。4、System API实现将为调用者做尽可能多的工作。示例如下：A：所有命令的命令字节大小字段有System API实现动态计算。B：输出参数在返回给调用者之前将被解组到C语言结构中，这样调用者可以直接从它们中读取字段。进一步，本实施例中优化手段为采用对System API接口参数进行封装的方式简化System API接口参数。简化System API接口参数包括对一部分接口利用XML模块简化System API接口参数，XML模块是利用XML文件封装参数，形成模板，进一步简化参数，便于用户使用一些参数较为复杂的接口，是对Feature API接口的一个较好的补充，位于可信TCM软件栈的Feature API接口层中。利用XML模块简化System API接口参数：在所有的接口中参数最为复杂的就是创建密钥接口，其中密钥的公钥参数比较灵活，不同的公钥参数可以创建出不同类型的密钥，如keyedHash类型密钥、AES类型、SM4类型密钥、SM2类型密钥、RSA类型密钥、SIGN类型密钥等。AES加解密密钥的XML模板如下所示。＜frame＞＜title＞AES＜/title＞＜inSensitive＞＜data〉＜size＞0＜/size＞＜buffer/＞＜/data＞＜/inSensitive＞＜inPublic＞＜type＞TCIM_ALG_SYMCIPHER＜/type＞＜nameA1g＞TCM_ALG_SHA1＜/nameAlg＞＜objectAttributes＞＜fixedTCM＞1＜/fixedTCM〉＜stClear＞0＜/stClear＞＜fixedParent＞1＜/fixedParent＞＜sensitiveDataOrigin＞1＜/sensitiveDataOrigin〉＜userWithAuth＞1＜/userWithAuth＞＜adminWithPolicy＞0＜/adminWithPolicy＞＜noDA＞0＜/noDA〉＜encryptedDuplication＞0＜/encryptedDuplication＞＜restricted＞1＜/restricted＞＜decrypt＞1＜/decrypt＞＜sign＞0＜/sign〉＜/objectAttributes＞＜authPolicy＞＜size＞0＜/size＞＜buffer/＞＜/authPolicy＞＜parameters＞＜symDetail＞＜algorithm＞TCM_ALG_AES＜/algorithm＜keyBits＞128＜/keyBits＞＜mode＞TCM_ALG_CBC＜/mode＞＜/symDetai1＞＜/parameters〉＜unique＞＜sym〉＜size＞0＜/size＞＜buffer/〉＜/sym〉＜/unique＞＜/inPublic＞＜outsideInfo＞＜size＞0＜/size＞＜buffer/＞＜/outsideInfo＞＜creationPcr＞＜pcrSelections＞ ＜/pcrSelections＞＜/creationPcr＞＜/frame＞下面举例System API接口中的TCM_CreatePrimaryKey接口说明其简化过程。System API接口如TCM_CreatePrimaryKey接口用于创建主密钥，返回主密钥句柄，该密钥为临时型密钥，芯片重新启动后将被自动清除。接口定义：int TCM_CreatePrimaryKey;输入参数描述：hContext：上下文句柄key：层次对象结构体；其中key结构体：typedef struct {UINT32 objectHandle;Session_Data_In_Detail session_data_in_detail;Sensitive_Detail sensitive_detail;Public_Detail public_detail;Outside_Info_Detail outside_info_detail;TCML_PCR_SELECTION creationPcr;}Key_Detail；objectHandle：指定层次；session_data_in_detail.nonce_data：随机数，一般情况为0；session_data_in_detail.hmac_data：该指定层次的授权数据；session_data_in_detail.sessionAttributes：授权属性，一般为0；session_data_in_detail.sessionHandle：授权方式，一般用password 授权方式；，某些接口需要用到policy授权方式；sensitive_detail.usrAuth_data：自定义对象的授权数据；sensitive_detail.usrData_data：自定义对象的机密数据；public_detail.public_type：指定对象的算法；public_detail.public_nameAlg：指定计算对象名称数据的哈希算法；public_detail.public_auth_policy_detail：指定对象的policy认证数据；public_detail.public_keyedHash_parms：keyedHash类型密钥的参数；public_detail.public_sym_parms：sym类型密钥的参数；public_detail.public_rsa_parms：rsa类型密钥的参数；public_detail.public_ecc_parms：ecc类型密钥的参数；public_detail.public_asym_parms：asym类型密钥的参数；public_detail.public_unique_detail：指定对象的唯一标识符；outside_info_detail：指定对象的永久性数据；creationPcr：指定对象的关联的PCR；输出参数描述:objectHandle：输出创建的密钥句柄；creation_hash_detail：创建数据哈希结果；name_detail：密钥名称数据；outPublic：该密钥的公共部分数据；creationData：创建数据；creationTicket：通过使用TCM_CertifyCreation验证创建数据是由TCM产生的标签；返回参数:==0 succ !=0 error由上面接口定义可知，输入参数key层次对象结构体非常复杂，对数据赋值很容易出错，利用XML文件对层次对象结构体进行封装，形成模板文件，直接对XML文件修改就可以直观且方便赋值，不易出错，实现对接口TCM_CreatePrimaryKey参数进行简化和完善，接口修改为TCM_XML_CreatePrimaryKey，并替换掉Trousers-TCM软件栈中对应的功能接口，新接口定义:int TCM_XML_CreatePrimaryKey;输入参数描述:hContext：上下文句柄pri_auth：指定层次及层次授权数据结构；usr_auth：自定义该生成密钥对象的授权数据结构；xml_patch：指定xml模板的绝对路径名；输出参数描述:objectHandle：输出创建的密钥句柄；outPublic：该密钥的公共部分数据；creationData:创建数据；creationHash：创建数据哈希结果；creationTicket：通过使用TCM_CertifyCreation验证创建数据是由TCM产生的标签；name：密钥名称数据；返回参数:==0 succ !=0 erro现有的可信软件栈一般直接使用开源软件栈或稍加修改后使用。可信TCM芯片资源空间较小，对应用层使用带来很大限制，需要提高上层软件栈接口对可信TCM芯片资源的访问利用。有些接口参数比较复杂，一般用户很难正确填写参数，而接口对参数的要求非常严格，只要参数稍微有不符要求就会错误，造成调用出错。采用本实施例设计方法设计的可信TCM软件栈，使得国产操作系统中上层应用能通过可信TCM软件栈与可信TCM芯片进行通信交互，实现可信计算，保证数据的完整性和真实性、抵抗篡改攻击、能够安全的执行代码、保护敏感数据的机密性等。通过移植SystemAPI接口到Trousers软件栈，实现多用户、多层次化的访问可信TCM芯片。在Trousers软件栈Tcs层增加对可信TCM芯片的资源管理，更好解决可信TCM芯片资源有限的瓶颈，提高用户对可信TCM芯片资源的利用率。在可信TCM芯片资源管理模块中采用最近最少使用算法来调度可信TCM芯片资源，提高上层接口对可信TCM芯片资源的访问利用率。利用XML文件对接口的层次对象结构体进行封装，形成模板文件，直接对XML文件修改就可以直观且方便地赋值，不易出错，实现对接口参数进行简化和完善。参见图5，本申请实施例还提出一种基于Linux操作系统的可信TCM软件栈系统，基于如上所述的设计方法实现，包括Feature API接口层和Trousers-TCM软件栈，Trousers-TCM软件栈包括从上至下设置的System API接口层、资源管理模块和Tddl层，System API接口层包括从上至下设置的Tspi层、Tcsd层和Tcs层；其中，Feature API接口层用于对输入参数进行封装，简化参数结构；Tspi层用于对参数进行字符串转换，将字符串以数据包形式发送给Tcsd层；Tcsd层用于完成初始化工作，接收Tspi层发送的数据包，并将数据包发送至Tcs层；Tcs层用于接收并解析Tcsd层发送的数据包，获取参数信息，再通过底层接口对参数信息进行命令格式封装；资源管理模块用于采用最近最少使用算法来动态检测并调度可信TCM芯片资源；Tddl层用于通过设备文件与可信TCM芯片完成数据传输。参见图6，可信TCM软件栈数据处理流程描述：应用层调用Feature API接口时，完成参数封装后就会调用Trousers-TCM软件栈的Tspi接口，完成对参数的数据转换，并将数据发送给Tcsd层服务程序；Tcsd层服务程序接收到数据之后，通过对数据解析重新获取各个参数；调用Tcs层接口对参数进行重新命令格式转换和封装，在Tcs层中我们增加了对当前可信芯片资源管理模块，在使用可信TCM芯片之前，先对当前可信TCM芯片的资源进行检测与资源的调配，在可信芯片资源满足当前操作要求之后再继续执行当前接口操作，记录处理后的结果。本申请可信TCM软件栈实际安装使用的实施例如下。加载TCM驱动安装TCM驱动模块，加载到内核中，执行命令：# insmod ax99100_spi.ko安装TSM软件包libTCMalg、Trousers-TCM。Trousers-TCM-0.3.4：可信TCM软件栈。libTCMalg-1.0：提供加密、哈希算法，被Trousers-TCM调用。安装测试工具TCM-toolsTCM-tool是用于用户或者应用程序使用TCM的工具包，可以设置可信TCM芯片的使能，包括管理和诊断可信TCM芯片的命令。这些命令是通过可信TCM软件栈与可信TCM芯片进行通信交互的，测试TCM应用管理，包括TCM使能操作、TCM不工作、TCM自身信息的显示、TCM自检与启动等。可信TCM芯片版本信息能够正常显示，如下所示：# TCM_versionTCM Version: 060b0000Manufacturer Info: 4e545a00TCM自检，执行命令TCM_selftest -r，如下所示：# TCM_selftest -rTCM Self Test Results:OK!执行TCM_getpubek，可以查看ek公钥，如下所示：# TCM_getpubekEnter owner password:Public Endorsement Key:Version: 00150000Usage: 0x0002 Flags: 0x00000000AuthUsage: 0x00 Algorithm: 0x0000000b Encryption Scheme: 0x00000006 Signature Scheme:0x00000001 Key Size:520bitsPublic Key:04a915bb 43b77298 140aac59 e388a8b8 bb1006b2 0c894587 b7da21ee17d9722002136342 94924fc4 d379f126 a5960983 9dec1d10 fc1d6182 7e432e4de79cc01635执行TCM_takeownership，可以获取owner，如下所示：# TCM_takeownershipEnter owner password:Confirm password:Enter SRK password:Confirm password:TCM Set Password Successfully。本实施例的可信TCM软件栈使得国产操作系统中上层应用能通过可信TCM软件栈与可信TCM芯片进行通信交互，实现可信计算，保证数据的完整性和真实性、抵抗篡改攻击、能够安全的执行代码、保护敏感数据的机密性等。通过移植System API接口到Trousers软件栈，实现多用户、多层次化的访问可信TCM芯片。在Trousers软件栈Tcs层增加对可信TCM芯片的资源管理，更好解决可信TCM芯片资源有限的瓶颈，提高用户对可信TCM芯片资源的利用率。在可信TCM芯片资源管理模块中采用最近最少使用算法来调度可信TCM芯片资源，提高上层接口对可信TCM芯片资源的访问利用率。利用XML文件对接口参数的层次对象结构体进行封装，形成模板文件，直接对XML文件修改就可以直观且方便地赋值，不易出错，实现对复杂接口进行简化和完善。本发明实施例中涉及的技术用语和简称的解释如下：TPM：可信计算依托于可信平台模块；TCM：可信密码模块；TSM：TCM服务模块，TSM由三个软件模块组成，即TCM应用服务、TCM核心服务和TCM设备驱动库；API：是一些预先定义的接口，或指软件系统不同组成部分衔接的约定；XML：可扩展标记语言，标准通用标记语言的子集，简称XML，是一种用于标记电子文件使其具有结构性的标记语言；Trousers软件栈：IBM实现的一套开源软件栈，是Linux下进行可信计算应用开发的主要接口。应当理解的是，本发明的上述具体实施方式仅仅用于示例性说明或解释本发明的原理，而不构成对本发明的限制。因此，在不偏离本发明的精神和范围的情况下所做的任何修改、等同替换、改进等，均应包含在本发明的保护范围之内。此外，本发明所附权利要求旨在涵盖落入所附权利要求范围和边界、或者这种范围和边界的等同形式内的全部变化和修改例。

标题title
通用验证方法学环境搭建方法、芯片验证方法及验证系统
摘要abst
提供一种通用验证方法学UVM环境的搭建方法、芯片验证方法和验证系统。UVM环境包括第一级UVM环境和第二级UVM环境，第一级UVM环境的层级低于第二级UVM环境的层级，第一级UVM环境包含第一UVM容器，第一UVM容器中封装的UVM组件用于对第一待测设计DUT进行功能验证，第二级UVM环境包括至少一个第一DUT，该方法包括：将第一UVM容器封装在第一检测器中，第一检测器的接口与第一待测设计的接口相同，第一检测器的接口与UVM组件的虚拟接口相互连接；将第一检测器与第二级UVM环境中的第一DUT绑定，使得第一检测器的接口与第一DUT的接口自动连接，有利于简化第一DUT与第一级UVM环境的绑定过程。
权利要求书clms
1.一种通用验证方法学UVM环境的搭建方法，其特征在于，所述UVM环境包括第一级UVM环境和第二级UVM环境，且所述第一级UVM环境的层级低于所述第二级UVM环境的层级，所述第一级UVM环境包含第一UVM容器，所述第一UVM容器中封装的UVM组件用于对第一待测设计进行功能验证，所述第二级UVM环境包括至少一个所述第一待测设计，所述方法包括：将所述第一UVM容器封装在第一检测器中，所述第一检测器的接口与所述第一待测设计的接口相同，且所述第一检测器的接口与所述UVM组件的虚拟接口相互连接；将所述第一检测器与所述第二级UVM环境中的所述第一待测设计绑定，使得所述第一检测器的接口与所述第一待测设计的接口自动连接。2.根据权利要求1所述的方法，其特征在于，所述方法还包括：收集所述第一检测器在例化过程中的层次路径名；根据所述层次路径名，确定所述第一UVM容器在例化时的名称。3.根据权利要求2所述的方法，其特征在于，所述第一检测器中声明了第一变量和第一句柄，所述第一变量为字符串类型的变量，所述第一句柄为预先创建的用于存储所述层次路径名的字符串收集器的句柄；所述第一检测器封装了第二UVM容器，所述第二UVM容器中声明了第二句柄和第三句柄，所述第二句柄为所述字符串收集器的句柄，所述第三句柄为所述第一UVM容器的句柄；所述第一检测器中建立有第一初始块，所述第一初始块用于执行以下操作：将所述层次路径名赋值给所述第一变量；通过所述第一句柄将所述第一变量的值存储至所述字符串收集器中。4.根据权利要求3所述的方法，其特征在于，所述层次路径名是基于层次路径名获取指令和格式调整函数获取的。5.根据权利要求2所述的方法，其特征在于，所述第一检测器在例化过程中的层次路径名为所述第一检测器在被调用的过程中的所述层次路径名，或，所述第一UVM容器在例化时的名称为所述第一UVM容器在被调用时的名称。6.根据权利要求1-5中任一项所述的方法，其特征在于，在所述将所述第一UVM容器封装在所述第一检测器中之前，所述方法还包括：将所述第一UVM容器中的发送端代理的工作模式设置为UVM_PASSIVE模式。7.根据权利要求1-5中任一项所述的方法，其特征在于，所述第一级UVM环境为模块级UVM环境，所述第二级UVM环境为系统级UVM环境。8.一种基于UVM环境的验证系统，其特征在于，所述UVM环境包括第一级UVM环境和第二级UVM环境，且所述第一级UVM环境的层级低于所述第二级UVM环境的层级，所述第一级UVM环境包含第一UVM容器，所述第一UVM容器中封装的UVM组件用于对第一待测设计进行功能验证，所述第二级UVM环境包括至少一个所述第一待测设计，所述验证系统包括：验证顶层，包括至少一个所述第一待测设计；至少一个第一检测器，分别与所述至少一个第一待测设计连接，所述第一检测器的接口与所述第一待测设计的接口相同，且所述第一检测器的接口与所述UVM组件的虚拟接口相互连接。9.根据权利要求8所述的验证系统，其特征在于，所述验证系统还包括：字符串收集器，用于收集所述第一检测器在例化过程中的层次路径名；所述第一检测器，用于根据所述字符串收集器收集的所述层次路径名，确定所述第一UVM容器在例化时的名称。10.根据权利要求9所述的验证系统，其特征在于，所述第一检测器中声明了第一变量和第一句柄，所述第一变量为字符串类型的变量，所述第一句柄为预先创建的用于存储所述层次路径名的字符串收集器的句柄；所述第一检测器封装了第二UVM容器，所述第二UVM容器中声明了第二句柄和第三句柄，所述第二句柄为所述字符串收集器的句柄，所述第三句柄为所述第一UVM容器的句柄；所述第一检测器中建立有第一初始块，所述第一初始块用于执行以下操作：将所述层次路径名赋值给所述第一变量；通过所述第一句柄将所述第一变量的值存储至所述字符串收集器中。11.根据权利要求10所述验证系统，其特征在于，所述层次路径名是基于层次路径名获取指令和格式调整函数获取的。12.根据权利要求9所述的验证系统，其特征在于，所述第一检测器在例化过程中的层次路径名为所述第一检测器在被调用的过程中的所述层次路径名，或，所述第一UVM容器在例化时的名称为所述第一UVM容器在被调用时的名称。13.根据权利要求8-12中任一项所述的验证系统，其特征在于，所述第一UVM容器中的发送端代理的工作模式为UVM_PASSIVE模式。14.根据权利要求8-12中任一项所述的验证系统，其特征在于，所述第一级UVM环境为模块级UVM环境，所述第二级UVM环境为系统级UVM环境。15.一种芯片的验证方法，其特征在于，所述方法应用于根据权利要求1-7中任一项所述方法搭建的UVM环境，所述方法包括：利用所述UVM环境对所述芯片包括的至少一个所述第一待测设计进行功能验证。16.一种芯片的验证系统，其特征在于，所述验证系统包括根据权利要求1-7中任一项所述方法搭建的UVM环境，所述UVM环境用于对所述芯片包括的至少一个所述第一待测设计进行功能验证。
说明书desc
技术领域本申请涉及功能验证技术领域，具体涉及一种通用验证方法学环境搭建方法、芯片验证方法及验证系统。背景技术通常，高层级的待测设计会包含多个功能相同的低层级的第一DUT。由于这些第一DUT的功能相同，因此，在对这些第一DUT进行功能验证时，使用的通用验证方法学环境也是相同的，或者说，第一级UVM环境中包含的UVM组件是相同的。因此，为了提高UVM验证系统的搭建效率，在搭建高层级的UVM环境以对高层次级DUT的进行功能验证时，往往会复用第一级UVM环境，以对上述功能相同的低层级DUT进行功能验证。在传统的UVM验证系统的搭建过程中，为了将高层级的DUT与第二级UVM环境的连接，需要将第一级UVM环境中的UVM组件与第一DUT进行绑定。首先，需要在第二级UVM环境的验证顶层中，将第一DUT的实例接口与第一DUT的接口连接，再将第一DUT的实例接口对应的虚拟接口发送给第一级UVM环境中的各个UVM组件，以便各个UVM组件可以通过虚拟接口与第一DUT通信。这种传统的第一DUT与第一级UVM环境的连接方式较为繁琐，限制了UVM验证系统的验证效率。尤其是在高层级的DUT中包含多个第一DUT情况下，在第二级UVM环境中复用第一级UVM环境，此时，如果依然利用上述高层级的DUT与第二级UVM环境的连接方式，则需要重复执行第一DUT与第一级UVM环境的绑定过程，直到多个第一DUT中的每个第一DUT绑定到对应的第一级UVM环境。并且在上述重复执行第一DUT与第一级UVM环境的绑定过程中，需要将虚拟接口传递到多个第一级UVM环境中的每个UVM组件，这种多次重复性地向多个第一级UVM环境中的UVM组件发送虚拟接口的方式，导致第一DUT与第一级UVM环境的连接过程较为繁琐，限制了UVM验证系统的验证效率。发明内容有鉴于此，本申请实施例致力于提供一种搭建通用验证方法学环境的方法和验证系统，以简化第一DUT与第一级UVM环境的连接过程，有利于提高UVM验证系统的验证效率。第一方面，提供了一种搭建通用验证方法学UVM环境的方法，所述UVM环境包括第一级UVM环境和第二级UVM环境，且所述第一级UVM环境的层级低于所述第二级UVM环境的层级，所述第一级UVM环境包含第一UVM容器，所述第一UVM容器中封装的UVM组件用于对第一待测设计进行功能验证，所述第二级UVM环境包括至少一个所述第一待测设计，所述方法包括：将所述第一UVM容器封装在第一检测器中，所述第一检测器的接口与所述第一待测设计的接口相同，且所述第一检测器的接口与所述UVM组件的虚拟接口相互连接；将所述第一检测器与所述第二级UVM环境中的所述第一待测设计绑定，使得所述第一检测器的接口与所述第一待测设计的接口自动连接。在本申请中，将第一检测器的接口配置为与第一DUT相同的接口，并预先将第一检测器的接口与第一UVM容器中的UVM组件建立连接，这样，在利用第一检测器对第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现第一检测器的接口与第一UVM容器中UVM组件的接口之间的自动连接。避免了传统的第一DUT与第一级UVM环境的绑定过程中，当第一DUT的接口与第一DUT的实例接口连接之后，再将第一DUT的实例接口对应的虚拟接口发送到第一UVM容器中的各个UVM组件，有利于简化第一DUT与第一级UVM环境的绑定过程，提高UVM验证系统的验证效率。尤其是在第二级UVM环境中复用第一级UVM环境的场景中，第二级UVM环境中包含多个第一UVM容器，此时，利用本申请实施例的方法，可以预先将第一检测器的接口与多个第一UVM容器中的UVM组件的接口建立连接，这样，在利用第一检测器对多个第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现多个第一UVM容器中UVM组件的接口与多个第一DUT之间的自动连接。避免了传统的高层级的DUT与第二级UVM环境的连接方式中，需要多次重复性地向多个第一级UVM环境中的UVM组件发送虚拟接口，有利于简化第一DUT与第一级UVM环境的连接过程，提高UVM验证系统的验证效率。在一种可能的实现方式中，所述方法还包括：收集所述第一检测器在例化过程中的层次路径名；根据所述层次路径名，确定所述第一UVM容器在例化时的名称。在本申请中，将第一检测器在例化过程中的层次路径名作为第一UVM容器在例化时的名称，有利于提高第一UVM容器命名的合理性，以便验证工程师在查阅验证结果的过程中，通过层次路径名快速定位到生成验证结果的第一UVM容器。在一种可能的实现方式中，所述第一检测器中声明了第一变量和第一句柄，所述第一变量为字符串类型的变量，所述第一句柄为预先创建的用于存储所述层次路径名的字符串收集器的句柄；所述第一检测器封装了第二UVM容器，所述第二UVM容器中声明了第二句柄和第三句柄，所述第二句柄为所述字符串收集器的句柄，所述第三句柄为所述第一UVM容器的句柄；所述第一检测器中建立有第一初始块，所述第一初始块用于执行以下操作：将所述层次路径名赋值给所述第一变量；通过所述第一句柄将所述第一变量的值存储至所述字符串收集器中。在本申请中，通过创建字符串收集器来存储层次路径名，并通过第一句柄和第二句柄之间的句柄传递将层次路径名传递到第二UVM容器中，以便将第二句柄中的层次路径名作为第二UVM容器中的第三句柄，以实现将层次路径名作为第一容器在例化时的名称。在一种可能的实现方式中，所述层次路径名是基于层次路径名获取指令和格式调整函数获取的。在本申请中，可以使用UVM验证系统提供的层次路径名获取指令和格式调整函数，来获取层次路径名，有利于提高本申请实施例的方法与UVM验证系统之间的兼容性。在一种可能的实现方式中，所述第一检测器在例化过程中的层次路径名为所述第一检测器在被调用的过程中的所述层次路径名，或，所述第一UVM容器在例化时的名称为所述第一UVM容器在被调用时的名称。在一种可能的实现方式中，在所述将所述第一UVM容器封装在所述第一检测器中之前，所述方法还包括：将所述第一UVM容器中的发送端代理的工作模式设置为UVM_PASSIVE模式。在本申请中，通过将发送端代理的工作模式设置为UVM_PASSIVE模式，有利于提高发送端代理的可重用性。在一种可能的实现方式中，所述第一级UVM环境为模块级UVM环境，所述第二级UVM环境为系统级UVM环境。第二方面，提供了一种基于UVM环境的验证系统，所述UVM环境包括第一级UVM环境和第二级UVM环境，且所述第一级UVM环境的层级低于所述第二级UVM环境的层级，，所述第一级UVM环境包含第一UVM容器，所述第一UVM容器中封装的UVM组件用于对第一待测设计进行功能验证，所述第二级UVM环境包括至少一个所述第一待测设计，所述验证系统包括：验证顶层，包括至少一个第一待测设计；至少一个第一检测器，分别与所述至少一个第一待测设计连接，所述第一检测器的接口与所述第一待测设计的接口相同，且所述第一检测器的接口与所述UVM组件的虚拟接口相互连接。在本申请中，将第一检测器的接口配置为与第一DUT相同的接口，并预先将第一检测器的接口与第一UVM容器中的UVM组件建立连接，这样，在利用第一检测器对第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现第一检测器的接口与第一UVM容器中UVM组件的接口之间的自动连接。避免了传统的第一DUT与第一级UVM环境的绑定过程中，当第一DUT的接口与第一DUT的实例接口连接之后，再将第一DUT的实例接口对应的虚拟接口发送到第一UVM容器中的各个UVM组件，有利于简化第一DUT与第一级UVM环境的绑定过程，提高UVM验证系统的验证效率。尤其是在第二级UVM环境中复用第一级UVM环境的场景中，第二级UVM环境中包含多个第一UVM容器，此时，利用本申请实施例的方法，可以预先将第一检测器的接口与多个第一UVM容器中的UVM组件的接口建立连接，这样，在利用第一检测器对多个第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现多个第一UVM容器中UVM组件的接口与多个第一DUT之间的自动连接。避免了传统的高层级的DUT与第二级UVM环境的连接方式中，需要多次重复性地向多个第一级UVM环境中的UVM组件发送虚拟接口，有利于简化第一DUT与第一级UVM环境的连接过程，提高UVM验证系统的验证效率。在一种可能的实现方式中，所述验证系统还包括：字符串收集器，用于收集所述第一检测器在例化过程中的层次路径名；所述第一检测器，用于根据所述字符串收集器收集的所述层次路径名，确定所述第一UVM容器在例化时的名称。在本申请中，将第一检测器在例化过程中的层次路径名作为第一UVM容器在例化时的名称，有利于提高第一UVM容器命名的合理性，以便验证工程师在查阅验证结果的过程中，通过层次路径名快速定位到生成验证结果的第一UVM容器。在一种可能的实现方式中，所述第一检测器中声明了第一变量和第一句柄，所述第一变量为字符串类型的变量，所述第一句柄为预先创建的用于存储所述层次路径名的字符串收集器的句柄；所述第一检测器封装了第二UVM容器，所述第二UVM容器中声明了第二句柄和第三句柄，所述第二句柄为所述字符串收集器的句柄，所述第三句柄为所述第一UVM容器的句柄；所述第一检测器中建立有第一初始块，所述第一初始块用于执行以下操作：将所述层次路径名赋值给所述第一变量；通过所述第一句柄将所述第一变量的值存储至所述字符串收集器中。在本申请中，通过创建字符串收集器来存储层次路径名，并通过第一句柄和第二句柄之间的句柄传递将层次路径名传递到第二UVM容器中，以便将第二句柄中的层次路径名作为第二UVM容器中的第三句柄，以实现将层次路径名作为第一容器在例化时的名称。在一种可能的实现方式中，所述层次路径名是基于层次路径名获取指令和格式调整函数获取的。在本申请中，可以使用UVM验证系统提供的层次路径名获取指令和格式调整函数，来获取层次路径名，有利于提高本申请实施例的方法与UVM验证系统之间的兼容性。在一种可能的实现方式中，所述第一检测器在例化过程中的层次路径名为所述第一检测器在被调用的过程中的所述层次路径名，或，所述第一UVM容器在例化时的名称为所述第一UVM容器在被调用时的名称。在一种可能的实现方式中，所述第一UVM容器中的发送端代理的工作模式为UVM_PASSIVE模式。在一种可能的实现方式中，所述第一级UVM环境为模块级UVM环境，所述第二级UVM环境为系统级UVM环境。在本申请中，通过将发送端代理的工作模式设置为UVM_PASSIVE模式，有利于提高发送端代理的可重用性。第三方面，提供了一种芯片的验证方法，所述方法应用于根据第一方面或第一方面中任一种可能的实现方式搭建的UVM环境，所述方法包括：利用所述UVM环境对所述芯片包括的至少一个所述第一待测设计进行功能验证。第四方面，提供了一种芯片的验证系统，所述验证系统包括根据第一方面或第一方面中任一种可能的实现方式搭建的UVM环境，所述UVM环境用于对所述芯片包括的至少一个所述第一待测设计进行功能验证。第五方面，提供了一种计算设备，所述计算设备具有实现上述第一方面的方法设计中的部分或全部的功能。这些功能可以通过硬件实现，也可以通过硬件执行相应的软件实现。所述硬件或软件包括一个或多个与上述功能相对应的单元。第六方面，提供了一种计算设备，包括输入输出接口、处理器和存储器。该处理器用于控制输入输出接口输入或输出信息，该存储器用于存储计算机程序，该处理器用于从存储器中调用并运行该计算机程序，使得该计算设备执行上述第一方面中的方法。第七方面，提供了一种计算机程序产品，所述计算机程序产品包括：计算机程序代码，当所述计算机程序代码在计算机上运行时，使得计算机执行上述各方面中的方法。第八方面，提供了一种计算机可读介质，所述计算机可读介质存储有程序代码，当所述计算机程序代码在计算机上运行时，使得计算机执行上述各方面中的方法。附图说明图1是功能验证方式的示意图。图2是本申请实施例适用的UVM环境的示意图。图3是本申请实施例适用的UVM树形结构的示意图。图4是基于传统的UVM验证系统的搭建的UVM环境的示意图。图5是传统的UVM验证系统的搭建方式的流程图。图6是本申请实施例的UVM环境的示意图。图7是本申请实施例的搭建UVM环境的流程图。图8是本申请实施例的UVM环境的示意图。图9是本申请实施例的芯片的示意图。图10是本申请实施例的搭建检测器0的方法的流程图。图11是本申请实施例的UVM环境的示意图。图12是本申请实施例的基于UVM环境的验证系统的示意图。图13是本申请实施例的计算设备的示意性框图。具体实施方式下面将结合本申请实施例中的附图，对本申请实施例中的技术方案进行清楚、完整地描述，显然，所描述的实施例仅是本申请一部分实施例，而不是全部的实施例。功能验证用于对DUT的功能进行功能验证。功能验证存在的意义在于不断地给DUT的设计过程提供迭代的关键意见。例如，功能验证过程中发现的性能不满足、设计代码功能bug、集成错误等问题可以反馈到设计过程中，以提高设计过程的效率。图1示例性介绍了功能验证方式。参见图1，在对DUT110进行功能验证过程中，可以将激励信号120作为输入信号输入DUT110，然后观察DUT110对激励信号120的响应，即输出结果130。最终判断输出结果130是否与期望的输出结果相似。若输出结果130与期望的输出结果相似，则可以认为DUT110的功能验证为通过。若输出结果130与期望的输出结果不相似，则可以认为DUT110的功能验证结果为不通过。随着功能验证技术的广泛应用，DUT的种类越来越多，亟需一种通用的验证方法来实现对多种类型的DUT进行功能验证。此时，基于UVM的功能验证系统应运而生。UVM旨在打造通用的验证系统，这样，验证工程师可以利用UVM验证系统来搭建UVM环境以对DUT进行功能验证。为了保证UVM验证系统的通用性，UVM验证系统中将功能验证流程拆分成单独的子流程，不同的子流程可以通过不同的UVM组件实现。这样，验证工程师在搭建验证不同DUT的UVM环境时，可以从UVM验证系统中选择合适的UVM组件即可。其中，常见的UVM组件可以包括驱动器、激励路由器、监测器、代理、参考模型、计分板、UVM容器、验证顶层等。此外，UVM验证系统还提供了各种机制以简化验证工程师的开发过程。例如，reg机制就封装了在硬件开发中读写寄存器的一些操作，验证工程师可以通过调用UVM函数，来迅速的开发读写寄存器的过程。又例如，为了提高UVM环境的封装和复用性，可以通过使用uvm_config_db配置机制在UVM环境中传递接口。当然，UVM验证系统中的机制除了上述机制之外还包括factory机制、objection机制等。为了便于理解，下文结合图2介绍UVM环境。图2是UVM环境的示意图。图2所示的UVM环境200包括验证顶层210，验证顶层 210用于封装UVM验证系统中对DUT进行功能验证的UVM容器，其中，UVM容器220主要用于将UVM组件进行有关联的分层。另外，验证顶层 210中还可以封装例化后的DUT，并且将DUT接口与UVM容器的虚拟接口连接起来，以便UVM容器中的UVM组件与DUT进行交互，例如，数据传输等。上述UVM容器220包含的 UVM组件有发送端代理230、接收端代理240、参考模型250和计分板260。其中，发送端代理230中可以封装有驱动器231和监测器232。接收端代理240中可以封装有监测器241。下文分别介绍各个UVM组件的功能。发送端代理230和/或接收端代理240，用于对一些UVM组件进行分层和连接。对于接收端代理240而言，接收端代理240可以封装监测器241。对于发送端代理230而言，有两种工作模式：主动模式和被动模式。对于处于主动模式的发送端代理230而言，可以封装有激励路由器、驱动器231以及监测器232。对于处于被动模式的发送端代理230而言，可以封装有监测器232，而并不封装驱动器231以及激励路由器。通常，对于不同的DUT进行功能验证时，驱动到不同的DUT上的激励信号通常是不同的，正是由于被动模式的发送端代理230中没有封装驱动器231以及激励路由器，因此，被动模式的发送端代理230的可重用性相对于主动模式的发送端代理230的可重用性较高。驱动器231，用于向激励路由器申请激励信号，并将激励信号按照总线协议规定驱动到DUT的端口上。在一些实现方式中，上述激励信号可以承载在数据包中。监测器232，用于监测驱动在DUT上的激励信号，并将监测到的激励信号发送给参考模型250。参考模型250，用于模仿DUT的功能，或者说，用于完成与DUT相同的功能。在一些实现方式中，DUT可以是用Verilog写成的时序电路，而参考模型250则可以直接使用SV语言的构造，同时还可以通过DPI等接口调用其他语言来完成与DUT相同的功能。计分板260，用于检查DUT的功能是不是符合预期。在一些实现方式中，计分板260可以比较参考模型250和监测器241分别发送来的数据，得到比较结果，并根据比较结果判断DUT是否正确工作。监测器241，用于监测DUT针对激励信号产生的响应信号，并将响应信号发送给计分板260。基于上文对UVM验证系统中各个UVM组件的封装方式可知，UVM组件被划分在不同的层次中，形成UVM树形结构。图3示出了本申请实施例适用的UVM树形结构的示意图。参见图3所示的UVM树形结构300，验证顶层210可以作为UVM树形结构的根，而其他UVM组件之间通过不同的封装方式，可以作为UVM树形结构中不同层次的节点。在这种UVM树形结构中，父节点可以操作管理相连接的子节点，以实现有序地管理UVM组件，避免出现遗漏和错误。应理解，UVM组件之间的封装方式在上文中已详细介绍，为了简洁，下文不再赘述。下文结合上文所示的UVM验证系统，以对DUT1进行功能验证为例，介绍UVM验证系统的验证方式。继续参见图2，在步骤S1中，驱动器231将激励信号驱动到DUT1的接口上。在步骤S2中，监测器232监测驱动到DUT1上的激励信号，并将监测到的激励信号发送给参考模型250。在步骤S3中，参考模型250对监测器232监测的激励信号产生响应信号1，并将产生的响应信号1发送给计分板260。在步骤S4中，监测器241监测DUT1中针对激励信号产生的响应信号2，并将监测到的响应信号2发送给计分板260。在步骤S5中，计分板260将响应信号1和响应信号2进行对比，以确定DUT1是否正确地工作。随着DUT的设计规模与复杂度不断提高，可以按照DUT的设计规模与复杂度划分为多个层级：模块级、部件级、子系统级和系统级，其中，模块级DUT的设计规模和复杂度低于部件级DUT的设计规模和复杂度，部件级DUT的设计规模和复杂度低于子系统级DUT的设计规模和复杂度，子系统级DUT的设计规模和复杂度低于系统级DUT的设计规模和复杂度。通常，高层级的DUT会包含多个功能相同的低层级的第一DUT。由于这些第一DUT的功能相同，因此，在对这些第一DUT进行功能验证时，使用的UVM环境也是相同的，或者说，第一级UVM环境中包含的UVM组件是相同的。因此，为了提高UVM验证系统的搭建效率，在搭建高层级的UVM环境以对高层次级DUT的进行功能验证时，往往会复用第一级UVM环境，以对上述功能相同的低层级DUT进行功能验证。下文结合图4和图5，以对系统级DUT进行功能验证的过程中复用模块级DUT的UVM环境为例，介绍传统的UVM验证系统的搭建方式。假设系统级DUT中包含多个功能相同的模块级DUT，并且对其中一个模块级DUT验证所使用的第一级UVM环境可以封装为图2所示的UVM容器220。由于系统级DUT中包含多个功能相同的模块级DUT，因此在搭建图4所示的第二级UVM环境400时，第二级UVM环境会包含多个UVM容器220，以分别对多个模块级DUT进行功能验证，其中，第二级UVM环境的搭建方法可以参见图5。图5所示的方法包括步骤S510至步骤S530。在步骤S510中，搭建第一级UVM环境。由于第二级UVM环境是对系统级DUT整体进行功能验证，因此，激励信号是施加在系统级DUT上的。也就是说，在第一级UVM环境中不需要单独地为每个模块级DUT单独施加激励信号，因此，可以将第一级UVM环境中的发送端代理230配置为UVM_PASSIVE模式。在步骤S520中，在第二级UVM环境的验证顶层410中，将模块级DUT的实例接口与模块级DUT相连接。在步骤S530中，将模块级DUT的实例接口对应的虚拟接口传送给第二级UVM环境中的UVM容器，使得各个UVM组件可以通过虚拟接口与对应的模块级DUT通信。如上文所述，系统级DUT中会包含多个模块级DUT，相应地，在第二级UVM环境中会包含多个UVM容器，因此，在执行步骤S530的过程中，需要将多个模块级DUT的实例接口对应的多个虚拟接口分别传送给对应的UVM容器，以便将多个UVM容器中的UVM组件可以与对应的模块级DUT通信，以验证模块级DUT的功能。基于图5所介绍的方法可知，在传统的UVM验证系统的搭建过程中，为了将高层级的DUT与第二级UVM环境的连接，需要将第一级UVM环境中的UVM组件与第一DUT进行绑定。首先，需要在第二级UVM环境的验证顶层中，将第一DUT的实例接口与第一DUT相连接，再将第一DUT的实例接口对应的虚拟接口传送给第一级UVM环境中的各个UVM组件，使得各个UVM组件可以通过虚拟接口与第一DUT通信。这种传统的第一DUT与第一级UVM环境的连接方式较为繁琐，限制了UVM验证系统的验证效率。尤其是在高层级的DUT中包含多个第一DUT情况下，第二级UVM环境中会复用第一级UVM环境，此时，如果依然利用上述连接方式，则需要重复执行第一DUT与第一级UVM环境的绑定过程，直到多个第一DUT中的每个第一DUT绑定到对应的第一级UVM环境。并且在上述重复执行第一DUT与第一级UVM环境的绑定过程中，需要将虚拟接口传递到多个第一级UVM环境中的每个UVM组件，这种多次重复性地向多个第一级UVM环境中的UVM组件发送虚拟接口的方式，导致高层级的DUT与第二级UVM环境的连接过程较为繁琐，限制了搭建第二级UVM环境的效率。因此，为了解决上述问题，本申请提供了一种搭建UVM环境的方案，以简化第一DUT与第一级UVM环境的连接过程，提高搭建第二级UVM环境的效率。下文结合图6所示的第二级UVM环境介绍本申请实施例的方案。在一些实现方式中，第二级UVM环境可以理解为被封装在对高层级DUT进行功能验证的验证顶层610中。需要说明的是，第二级UVM环境600与第二UVM环境400中功能相同的UVM组件使用相同的编号，相关介绍请参见上文，为了简洁，下文不再赘述。在第二级UVM环境600中包含一个或多个第一DUT，并且还封装有第一级UVM环境，第一级UVM环境中封装有第一检测器620，第一检测器620中封装有第一UVM容器630，第一UVM容器630中封装的UVM组件用于对第一DUT进行功能验证。在一些实现方式中，上述第一UVM容器630中封装的UVM组件可以参见UVM容器220中封装的UVM组件。当然，第一UVM容器630中还可以封装其他的UVM组件。本申请实施例对此不作具体限定。如上文介绍，通常可以使用SV语言来搭建UVM验证环境，而在SV语言中的基本设计单元可以是模块，这些模块可以实现特定的功能并进行层次的嵌套，因此，在本申请实施例中可以利用模块来构建第一检测器610。图7是本申请实施例的搭建UVM环境的流程图。图7所示的方法可以包括步骤S710和步骤S720。在步骤S710中，将第一UVM容器封装在第一检测器610中。上述第一检测器610的接口与第一DUT的接口相同，且第一检测器的接口与UVM组件的虚拟接口相互连接。或者说，在第一检测器内，第一检测器的接口与UVM组件的虚拟接口之间的连接是预先连接好的。在步骤S720中，将第一检测器610与第二级UVM环境中的第一DUT绑定，使得第一检测器610的接口与第一DUT的接口自动连接。在一些实现方式中，在第二级UVM环境的顶层中，可以将第一DUT的实例接口与第一检测器的接口相连，并将第一DUT的实例接口对应的虚拟接口发送到第一检测器中的UVM组件，以使得第一检测器的UVM组件可以通过虚拟接口与第一DUT通信。其中，可以利用assign语句连接第一检测器的接口与第一DUT的实例接口。目前，UVM验证系统中，提供bind命令可以实现将模块或接口绑定到任意的设计模块或者其特定例化。因此，在本申请实施例中，可以利用bind命令将第一检测器610与第一DUT绑定。在本申请实施例中，将第一检测器的接口配置为与第一DUT相同的接口，并预先将第一检测器的接口与第一UVM容器中的UVM组件建立连接，这样，在利用第一检测器对第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现第一检测器的接口与第一UVM容器中UVM组件的接口之间的自动连接。避免了传统的第一DUT与第一级UVM环境的绑定过程中，当第一DUT的接口与第一DUT的实例接口连接之后，再将第一DUT的实例接口对应的虚拟接口发送到第一UVM容器中的各个UVM组件，有利于简化第一DUT与第一级UVM环境的绑定过程，提高UVM验证系统的验证效率。尤其是在第二级UVM环境中复用第一级UVM环境的场景中，第二级UVM环境中包含多个第一UVM容器，此时，利用本申请实施例的方法，可以预先将第一检测器的接口与多个第一UVM容器中的UVM组件的接口建立连接，这样，在利用第一检测器对多个第一DUT进行功能验证时，仅需将第一检测器与第一DUT绑定，便可以实现多个第一UVM容器中UVM组件的接口与多个第一DUT之间的自动连接。避免了传统的高层级的DUT与第二级UVM环境的连接方式中，需要多次重复性地向多个第一级UVM环境中的UVM组件发送虚拟接口，有利于简化第一DUT与第一级UVM环境的连接过程，提高UVM验证系统的验证效率。如上文介绍，在搭建第二级UVM环境的过程中，第二级UVM环境会复用第一UVM环境，这样，第二级UVM环境中也会包含多个第一UVM容器。通常，为了保证每个第一UVM容器的独立性，需要将不同的第一UVM容器例化为不同的名字，或者说，需要区分上述多个第一UVM容器的命名。在传统的UVM环境搭建过程中，主要依托于验证工程师手动为不同的第一UVM容器命名。然而，这种通过验证工程师手动命名的方式，导致UVM环境搭建的自动化程度较低。因此，为了提高UVM环境搭建的自动化程度，本申请还提供一种搭建UVM环境的方案，在该方案中，可以将第一检测器在例化过程中的层次路径名自动作为第一UVM容器在例化时的名称。即本申请实施例的方法包括收集第一检测器在例化过程中的层次路径名；根据层次路径名，确定第一UVM容器在例化时的名称。参见图3所，各个UVM组件可以构成UVM树形结构，或者说，各个UVM组件之间是具有层级关系的，每个UVM组件会有对应的层级路径名，层级路径名用于指示第一检测器在UVM树形结构中的位置。假设处理器作为系统级DUT中包含三级高速缓存存储单元1和LMU2，也就是说LMU1和LMU2为模块级DUT。在使用本申请实施例的方法通过第一检查器1对LMU1进行功能验证时，第一检查器1中包含的第一UVM容器在例化时的名称可以为“lmu_uvm_checker1”。在使用本申请实施例的方法通过第一检查器2对LMU2进行功能验证时，第一检查器2中包含的第一UVM容器在例化时的名称可以为“lmu_uvm_checker2”。目前，在利用UVM验证系统对第一DUT进行验证后会得到验证结果，在验证结果中会显示对第一DUT进行功能验证的第一UVM容器的名称。在本申请实施例中，将第一检测器在例化过程中的层次路径名作为第一UVM容器在例化时的名称，有利于提高第一UVM容器命名的合理性，以便验证工程师在查阅验证结果的过程中，通过层次路径名快速定位到生成验证结果的第一UVM容器。当然，如果不考虑第一UVM容器命名的合理性，在本申请实施例中，也可以以随机的方式对第一UVM命名，只要保证第一UVM容器可以例化为不同的名称即可保证例化后的第一UVM容器的独立性。在一些实现方式中，上述层次路径名可以通过句柄传递的方式在第一检测器中传递。下文结合图8，以验证顶层610中包含的一个第一检查器620为例介绍句柄传递的过程。参见图8，在第一检测器620中声明了第一变量810和第一句柄820，第一变量810为字符串类型的变量，第一句柄820为预先创建的用于存储层次路径名的字符串收集器的句柄；第一检测器封装了第二UVM容器830，第二UVM容器830中声明了第二句柄831和第三句柄832，第二句柄为字符串收集器的句柄，第三句柄为第一UVM容器的句柄；第一检测器中建立有第一初始块，第一初始块用于执行以下操作：将层次路径名赋值给第一变量；通过第一句柄将第一变量的值存储至字符串收集器中。也就是说，在第一初始块中，可以通过第一句柄将层次路径名存储在字符串收集器中。由于第二UVM容器中声明的第二句柄为字符串收集器的句柄，这样，可以通过第一句柄与第二句柄之间句柄的传递，使得第二句柄指向收集到层次路径名的字符串收集器，此时，在第二UVM容器中可以通过第二句柄获取到字符串收集器中收集的层次路径名。在一些实现方式中，上述第一句柄和第二句柄之间的句柄传递可以通过uvm_config_db机制来实现。另外，由于第二UVM容器中还声明有第一UVM容器的句柄，即第三句柄。因此，可以将第二句柄中的层次路径名作为第三句柄创建对象时的名称。如上文所述，第一UVM容器可能经过多次例化，并且在每次例化时都需要执行将第二句柄指向的层次路径名称作为的第一UVM容器的名称。因此，可以使用循环语句来实现上述将第二句柄指向的层次路径名称作为的第一UVM容器的名称的相关操作。如上文所述，在一些情况下，第一UVM容器会进行多次例化，并且每次例化使用的名称不同，也就是说，字符串收集器中需要存储多个层次路径名，而SV中提供的队列可以存储多个成员，因此，可以利用队列来存储多个层次路径名。在另一些情况下，还可以通过类来构建字符串收集器，即将上述队列封装在类中，或者说，在类中定义的一个成员是队列。在一些实现方式中，上述层次路径名可以是基于层次路径名获取指令和格式调整函数获取的。其中，层次路径名获取指令可以为SV语言中的“%m”，格式调整函数可以为SV语言中的“$sformatf函数”。当然，在另一些实现方式中，上述格式调整函数还可以为SV语言中的“$sformat函数”，本申请实施例对此不作限定。为了便于理解，下文结合图9和图10，以对芯片900进行验证为例介绍本申请实施例的方案。参见图9，芯片900包括信息中心网络910、处理器核920以及多个LMU930，其中，多个LMU分别为LMU0 930、LMU1 930、LMU2 930以及LMU3 930。在对芯片900进行功能验证时，芯片900可以视为上文中的系统级DUT，LMU 930可以视为上文中的模块级DUT。相应地，用于对芯片900进行验证的UVM环境为高层级的UVM环境，即第二级UVM环境，用于对LMU 930进行验证的UVM环境为低层级的UVM环境，即第一级UVM环境。其中，处理器核920，用于执行各种指令操作。通常，处理器核920如果可以正常执行软件测试程序那么可以保证芯片900功能的正确性。ICN 910用于将处理器核920发送的请求转发给不同的LMU 930。假设可以采用图8所示的第一检测器620来对LMU930进行功能验证，那么在第二UVM环境中需要例化4个第一UVM容器630来对LMU0 930、LMU1 930、LMU2 930以及LMU3 930分别进行功能验证，即基于第一UVM容器0用于对LMU0 930进行功能验证，第一UVM容器1用于对LMU1 930进行功能验证，第一UVM容器2用于对LMU2 930进行功能验证，第一UVM容器3用于对LMU3 930进行功能验证。图10是本申请实施例的搭建检测器的方法，图10所示的方法包括步骤S1010至步骤S1040。需要说明的是，为了便于描述，下文结合步骤S1010至步骤S1030描述UVM组件的创建过程时，以UVM树结构中子节点到父节点的顺序介绍，也就是说，按照从第一UVM容器到第二UVM容器再到检测器的顺序介绍。在步骤S1010中，创建第一UVM容器。第一UVM容器中封装的UVM组件用于对LMU0进行功能验证。其中，每个UVM组件的功能可以参见上文结合图2的介绍，为了简洁，在此不再赘述。在步骤S1020中，创建第二UVM容器。在一些实现方式中，可以基于UVM验证系统中UVM_ENV的类来创建第二UVM容器，第二UVM容器的命名可以为multi_lmu_env。如上文所述，可以通过句柄的传递来将字符串收集器中的层次路径名传递到第二UVM容器，因此，在创建第二UVM容器的过程中还需要声明句柄，以完成句柄的传递。即上述步骤S1020还包括步骤S1021和步骤S1022。另外，上述字符串收集器的创建过程可以参见步骤S1030。在步骤S1021中，声明第二句柄和第三句柄。第二句柄为字符串收集器的句柄，可以表示为句柄modc。第三句柄为第一UVM容器的句柄，可以表示为句柄lmu_env_mod。在步骤S1022中，在第二UVM容器中获取字符串收集器中收集的层次路径名。在一些实现方式中，在build_phase函数中利用uvm_config_db机制，将第一句柄指向的存储有层次路径名的字符串收集器传递给第二句柄，使得第二句柄指向字符串收集器。再将第二句柄指向的字符串收集器中的层次路径名作为第三句柄创建对象时的名称，由于第三句柄为第一UVM容器的句柄，因此，第一UVM容器的实例化名则是第二句柄指向的字符串收集器中的层次路径名。需要说明的是，若第一UVM容器需要例化多次，并且字符串收集器中存储有多个层次路径名，可以利用循环语句实现将字符串收集器中收集的每个字符串元素值作为第三句柄lmu_env_mode创建对象时的名称，以作为第一UVM容器的实例化名。在步骤S1030中，创建检测器。在一些实现方式中，可以利用SV中的模块来对第二UVM容器multi_lmu_env进行封装，形成检测器。上述步骤S1030可以包括步骤S1031至步骤S1033。在步骤S1031中，在检测器中创建字符串收集LmuCollector、并声明第一变量以及第一句柄。在一些实现方式中，利用类来创建字符串收集器，并在字符串收集器中定义队列作为成员，来存储检测器在例化过程中的层次路径名，并在检测器中声明第一变量表示为mod_name，其中，第一变量mod_name可以为字符串类型的变量，以便后续过程中，可以通过将层次路径名赋值给第一变量mod_name，再将第一变量mod_name存储到字符串收集器LmuCollector中的队列，来实现将层次路径名存储在字符串收集器中。上述第一句柄为用于存储层次路径名的字符串收集器的句柄，可以表示为mnc。在步骤S1032中，在检测器中建立初始块。在初始块中执行步骤S10321至步骤S10323。在步骤S10321中，将层次路径名赋值给第一变量mod_name；通过第一句柄将第一变量mod_name的值存储至字符串收集器LmuCollector中。在一些实现方式中，可以利用层次路径名获取指令“%m”以及格式调整函数“$sformatf”，将层次路径名赋值给第一变量mod_name。在步骤S10322中，将第一句柄mnc指向的层次路径名传递给第二句柄modc。在一些实现方式中，利用UVM验证系统中的uvm_config_db机制将第一句柄mnc传递给第二句柄modc，使得第二句柄modc指向存储了层级路径名的字符串收集器。在步骤S10323中，将LMU930的实例接口对应的虚拟接口传递到检测器中的各个UVM组件。为了便于说明，下文结合图11介绍检测器中的接口连接过程。参见图11，在一些实现方式中，可以利用uvm_config_db机制将上述虚拟接口传递给各个UVM组件，以完成检测器和各个UVM组件之间的连接。在步骤S1033中，在检测器中声明LMU930实例接口，并将LMU930的实例接口与检测器的接口连接。在一些实现方式中，可以利用assign语句来连接LMU930的实例接口与检测器的接口。继续参见图11，在检测器中可以声明检测器的接口，并且检测器的接口与LMU的接口相同。再将检测器的接口与检测器的虚拟接口连接，以完成检测器的接口与各个UVM组件之间的连接。需要说明的是，由于检测器的接口与LMU的接口相同，当完成检测器的接口与各个UVM组件之间的连接时，也就完成了LMU的接口与各个UVM组件之间的连接，实现了在将LMU与检测器真正连接之前，预先将LMU的接口与各个UVM组件进行连接。经过以上步骤，可以理解为检测器的封装过程结束。下文结合步骤S1040介绍检测器和LMU的绑定过程。在步骤S1040中，将检测器与LMU绑定。在一些实现方式中，可以在系统级验证环境顶层中使用bind语句将LMU0和检测器进行绑定，即完成了LMU和检测器中UVM组件之间的连接。这样，在验证顶层中会基于例化的LMU930的数量，来自动生成相同数量的检测器，也就是说，仅需要一次绑定操作，便可以将多个例化的LMU930与多个检测器相连接。参见图9，在芯片900中包含4个LMU，也即是说，LMU在例化时会例化成LMU0、LMU1、LMU2、 LMU3。在采用上述方法完成LMU和检测器之间的绑定后，并在运行上述UVM验证环境时，也会基于上文封装的检测器例化4个检测器，即，检测器0、检测器1、检测器2、检测器3，并自动完成检测器0与LMU0的接口之间的连接，检测器1与LMU1的接口之间的连接，检测器2与LMU2的接口之间的连接，检测器3与LMU3的接口之间的连接。相应地，采用上述方法还可以自动化生成第一UVM容器例化时的名称。即LMU0对应的第一UVM容器在例化时的命名为lmu_uvm_checker0，LMU1对应的第一UVM容器在例化时的命名为lmu_uvm_checker1，LMU2对应的第一UVM容器在例化时的命名为lmu_uvm_checker2，LMU3对应的第一UVM容器在例化时的命名为lmu_uvm_checker3。上文结合图1至图11，详细描述了本申请的方法实施例，下面详细描述本申请的装置实施例。应理解，方法实施例的描述与装置实施例的描述相互对应，因此，未详细描述的部分可以参见前面方法实施例。图12是本申请实施例的基于UVM环境的验证系统的示意图。其中，UVM环境包括第一级UVM环境和第二级UVM环境，且第一级UVM环境的层级低于第二级UVM环境的层级，所述第一级UVM环境包含第一UVM容器，所述第一UVM容器中封装的UVM组件用于对第一DUT进行功能验证，所述第二级UVM环境包括至少一个所述第一DUT，所述验证系统1200包括：验证顶层1210、第一检测器1220。验证顶层1210，包括至少一个第一DUT。至少一个第一检测器1220，分别与所述至少一个第一DUT连接，所述第一检测器的接口与所述第一DUT的接口相同，且所述第一检测器的接口与所述UVM组件的虚拟接口相互连接。在一种可能的实现方式中，所述验证系统1200还包括：字符串收集器，用于收集所述第一检测器在例化过程中的层次路径名；所述第一检测器1220，用于根据所述字符串收集器收集的所述层次路径名，确定所述第一UVM容器在例化时的名称。在一种可能的实现方式中，所述第一检测器1220中声明了第一变量和第一句柄，所述第一变量为字符串类型的变量，所述第一句柄为预先创建的用于存储所述层次路径名的字符串收集器的句柄；所述第一检测器封装了第二UVM容器，所述第二UVM容器中声明了第二句柄和第三句柄，所述第二句柄为所述字符串收集器的句柄，所述第三句柄为所述第一UVM容器的句柄；所述第一检测器中建立有第一初始块，所述第一初始块用于执行以下操作：将所述层次路径名赋值给所述第一变量；通过所述第一句柄将所述第一变量的值存储至所述字符串收集器中。在一种可能的实现方式中，所述层次路径名是基于层次路径名获取指令和格式调整函数获取的。在一种可能的实现方式中，所述第二级UVM环境包括多个所述第一DUT。在一种可能的实现方式中，所述第一UVM容器中的发送端代理的工作模式为UVM_PASSIVE模式。在一种可能的实现方式中，所述第一级UVM环境为模块级UVM环境，所述第二级UVM环境为系统级UVM环境。在一种可能的实现方式中，所述第一检测器在例化过程中的层次路径名为所述第一检测器在被调用的过程中的所述层次路径名，或，所述第一UVM容器在例化时的名称为所述第一UVM容器在被调用时的名称。在可选的实施例中，上述验证系统1200可以运行在计算设备1300中，其中计算设备1300的结构可以参见图13。图13是本申请实施例的计算设备的示意性框图。图13所示的计算设备1300可以包括：存储器1310、处理器1320、输入/输出接口1330。其中，存储器1310、处理器1320和输入/输出接口1330通过内部连接通路相连。存储器1310用于存储指令和代码，在一些实现方式中，代码可以是用于实现本申请实施例的方法的代码。处理器1320用于执行该存储器1320存储的指令和代码，以控制输入/输出接口1330接收输入的数据和信息，输出操作结果等数据。在一些实现方式中，通过软件或者固件来实现本申请实施例的方案时，用于实现本申请实施例的方案的代码可以被保存在处理器1320中，并由处理器1320来执行。应理解，在本申请实施例中，该处理器1320可以采用通用的中央处理器，微处理器，应用专用集成电路，或者一个或多个集成电路，用于执行相关程序，以实现本申请实施例所提供的技术方案。该存储器1310可以包括只读存储器和随机存取存储器，并向处理器1320提供指令和数据。处理器1320的一部分还可以包括非易失性随机存取存储器。例如，处理器1320还可以存储设备类型的信息。在实现过程中，上述方法的各步骤可以通过处理器1320 中的硬件的集成逻辑电路或者软件形式的指令完成。结合本申请实施例所公开的用于请求上行传输资源的方法可以直接体现为硬件处理器执行完成，或者用处理器中的硬件及软件模块组合执行完成。软件模块可以位于随机存储器，闪存、只读存储器，可编程只读存储器或者电可擦写可编程存储器、寄存器等本领域成熟的存储介质中。该存储介质位于存储器1310，处理器1320 读取存储器1310中的信息，结合其硬件完成上述方法的步骤。为避免重复，这里不再详细描述。应理解，本申请实施例中，该处理器可以为中央处理单元，该处理器还可以是其他通用处理器、数字信号处理器、专用集成电路、现成可编程门阵列或者其他可编程逻辑器件、分立门或者晶体管逻辑器件、分立硬件组件等。通用处理器可以是微处理器或者该处理器也可以是任何常规的处理器等。在一些实现方式中，计算设备1300除了包含上文介绍的硬件单元之外，还可以包括软件模块，其中，软件模块例如可以是操作系统、基本输入输出系统应用软件等。操作系统用于管理计算设备的硬件和/或软件资源，也定计算设备的内核和基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。为了方便用户操作，大多数操作系统会提供一个让用户与系统交互的操作界面。BIOS用于在通电引导阶段运行硬件初始化，以及为操作系统和应用程序提供运行时服务。在一些实现方式中，BIOS还可以监测显示处理器温度以及执行调整温度保护策略等功能。应用软件又称应用程序可以理解为是针对用户的某种特殊应用目的所撰写的软件，作为计算机软件的主要分类之一。例如，应用软件可以是用于实现功率控制、温度管理等目的程序。本申请还提供一种芯片的验证方法，所述方法应用于根据上文结合图1至11介绍的任意一种方法搭建的UVM环境，所述方法包括：利用所述UVM环境对所述芯片包括的至少一个所述第一待测设计进行功能验证。在一些实现方式中，上述验证方法可以基于图13所示的装置执行。在另一些实现方式中，上述验证方法所涉及的UVM环境可以是基于图13所示的装置搭建的。本申请还提供一种芯片的验证系统，所述验证系统包括上文结合图1至11介绍的任意一种方法搭建的UVM环境，所述UVM环境用于对所述芯片包括的至少一个所述第一待测设计进行功能验证。在一些实现方式中，上述UVM环境可以是基于图12或图13所示的装置搭建的。需要说明的是，在本申请中“例化的过程”可以理解为“被调用的过程”。例如，第一检测器在例化过程中可以理解为第一检测器在被调用的过程中。又例如，第一UVM容器在例化时可以理解为第一UVM容器在被调用时。应理解，根据A确定B并不意味着仅仅根据A确定B，还可以根据A和/或其它信息确定B。还应理解，本文中术语“和/或”，仅仅是一种描述关联对象的关联关系，表示可以存在三种关系，例如，A和/或B，可以表示：单独存在A，同时存在A和B，单独存在B这三种情况。另外，本文中字符“/”，一般表示前后关联对象是一种“或”的关系。应理解，在本申请的各种实施例中，上述各过程的序号的大小并不意味着执行顺序的先后，各过程的执行顺序应以其功能和内在逻辑确定，而不应对本申请实施例的实施过程构成任何限定。在本申请所提供的几个实施例中，应该理解到，所揭露的系统、装置和方法，可以通过其它的方式实现。例如，以上所描述的装置实施例仅仅是示意性的，例如，所述单元的划分，仅仅为一种逻辑功能划分，实际实现时可以有另外的划分方式，例如多个单元或组件可以结合或者可以集成到另一个系统，或一些特征可以忽略，或不执行。另一点，所显示或讨论的相互之间的耦合或直接耦合或通信连接可以是通过一些接口，装置或单元的间接耦合或通信连接，可以是电性，机械或其它的形式。所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部单元来实现本实施例方案的目的。另外，在本申请各个实施例中的各功能单元可以集成在一个处理单元中，也可以是各个单元单独物理存在，也可以两个或两个以上单元集成在一个单元中。在上述实施例中，可以全部或部分地通过软件、硬件、固件或者其任意组合来实现。当使用软件实现时，可以全部或部分地以计算机程序产品的形式实现。所述计算机程序产品包括一个或多个计算机指令。在计算机上加载和执行所述计算机程序指令时，全部或部分地产生按照本申请实施例所述的流程或功能。所述计算机可以是通用计算机、专用计算机、计算机网络、或者其他可编程装置。所述计算机指令可以存储在计算机可读存储介质中，或者从一个计算机可读存储介质向另一个计算机可读存储介质传输，例如，所述计算机指令可以从一个网站站点、计算机、服务器或数据中心通过有线）或无线方式向另一个网站站点、计算机、服务器或数据中心进行传输。所述计算机可读存储介质可以是计算机能够读取的任何可用介质或者是包含一个或多个可用介质集成的服务器、数据中心等数据存储设备。所述可用介质可以是磁性介质，、光介质）或者半导体介质）等。以上所述，仅为本申请的具体实施方式，但本申请的保护范围并不局限于此，任何熟悉本技术领域的技术人员在本申请揭露的技术范围内，可轻易想到变化或替换，都应涵盖在本申请的保护范围之内。因此，本申请的保护范围应以所述权利要求的保护范围为准。

标题title
一种多系统共享内存的方法、装置、设备及存储介质
摘要abst
本发明提供了一种多系统共享内存的方法、装置、设备与存储介质，多系统中每个系统运行于同一个处理器上，所述方法包括：把第一虚拟内存设备加入到每个系统各自的设备树文件，第一虚拟内存设备为每个系统的共享内存；每个系统在启动时根据各自的设备树文件，把第一虚拟内存设备注册到各自的系统中；每个系统通过第一虚拟内存设备进行系统间数据交互。本发明实施例的技术方案与微内核操作系统无关，配置和使用简单，易于移植和扩容。
权利要求书clms
1.一种多系统共享内存的方法，其特征在于，所述多系统中每个系统运行于同一个处理器上，所述方法包括：在所述每个系统的设备树文件中添加第一虚拟内存设备，所述第一虚拟内存设备为所述多系统的共享内存在所述每个系统中的虚拟化设备；所述每个系统在启动时根据各自的设备树文件，把所述第一虚拟内存设备注册到各自的系统中；所述每个系统通过所述第一虚拟内存设备进行系统间数据交互。2.根据权利要求1所述方法，其特征在于，把所述第一虚拟内存设备注册到各自的系统中，包括：所述每个系统从各自的所述设备树文件上获取所述第一虚拟内存设备的信息；所述每个系统根据所述第一虚拟内存设备的信息，调用各自的虚拟内存设备驱动程序，将所述共享内存从各自系统中隔离出来，并对其进行初始化；当所述初始化完成后，在所述每个系统中生成所述第一虚拟内存设备的设备文件。3.根据权利要求2所述方法，其特征在于，所述每个系统的虚拟内存设备驱动程序为所述每个系统提供获取所述共享内存的信息的方法和通过所述第一虚拟内存设备名称打开所述第一虚拟内存设备的方法。4.根据权利要求3所述方法，其特征在于，所述每个系统通过第一虚拟内存设备进行系统间数据交互，包括：所述每个系统利用各自的所述第一虚拟内存设备的名称打开其所述第一虚拟内存设备；所述每个系统获取所述共享内存的信息，包括所述共享内存的地址和大小；所述每个系统中的第一系统向所述共享内存的地址写入数据；所述每个系统中的第二系统从所述共享内存的地址读取数据。5.根据权利要求1所述方法，其特征在于，当对所述共享内存地址或大小进行变化时，还包括：修改所述每个系统的所述第一虚拟内存设备的所述共享内存的地址或/和大小；所述每个系统在重启所述第一虚拟内存设备时，把修改后的所述第一虚拟内存设备注册到各自的系统中。6.根据权利要求1至4任一所述方法，其特征在于，所述多系统包括若干个非实时系统和若干个实时系统。7.根据权利要求1至4任一所述方法，其特征在于，所述每个系统的第一虚拟内存设备具有相同的名称。8.一种多系统共享内存的装置，其特征在于，所述多系统中每个系统运行于同一个处理器上，包括：配置模块，用于在所述每个系统的设备树文件中添加第一虚拟内存设备，所述第一虚拟内存设备为所述多系统的共享内存在所述每个系统中的虚拟化设备；注册模块，用于所述每个系统在启动时根据各自的设备树文件，把所述第一虚拟内存设备注册到各自的系统中；交互模块，用于所述每个系统通过所述第一虚拟内存设备进行系统间数据交互。9.一种计算设备，其特征在于，包括：总线；通信接口，其与所述总线连接；至少一个处理器，其与所述总线连接；以及至少一个存储器，其与所述总线连接并存储有程序指令，所述程序指令当被所述至少一个处理器执行时使得所述至少一个处理器执行权利要求1至7任一所述方法。10.一种计算机可读存储介质，其上存储有程序指令，其特征在于，所述程序指令当被计算机执行时使得所述计算机执行权利要求1至7任一所述方法。
说明书desc
技术领域本发明涉及操作系统领域，尤其涉及一种多系统共享内存的方法、装置、设备及存储介质。背景技术现有多系统间共享内存方案都是基于共享内存页实现的，如type1型的虚拟化系统acrn、xen分别基于内页面和授权表进行共享内存，type2型的虚拟化系统kvm-qemu基于共享文件实现内存共享。因此，现有技术都是基于虚拟化hyper实现系统间内存共享。针对部署在一个硬件处理器上基于AMP架构的多系统间内存共享不太适用，且现有共享内存技术与操作系统内存管理相关联，特别是与微内核操作系统耦合较大，且配置使用较复杂，不易进行移植和扩容。发明内容有鉴于此，本发明实施例提供了一种多系统共享内存的方法、装置、设备及存储介质。该多系统中每个系统可以为实时系统或非实时系统，均运行于同一个处理器上，通过在每个系统的设备树文件中定义对应于同一共享内存的虚拟内存设备，从而系统重启时注册虚拟内存设备，多系统中每个系统通过虚拟内存设备实现在共享内存上的系统间数据交互。本发明实施例的技术方案与微内核操作系统无关，配置和使用简单，易于移植和扩容。第一方面，本发明实施例提供了一种多系统共享内存的方法，所述多系统中每个系统运行于同一个处理器上，包括：在所述每个系统的设备树文件中添加第一虚拟内存设备，所述第一虚拟内存设备为所述多系统的共享内存在所述每个系统中的虚拟化设备；所述每个系统在启动时根据各自的设备树文件，把所述第一虚拟内存设备注册到各自的系统中；所述每个系统通过所述第一虚拟内存设备进行系统间数据交互。由上，通过在每个系统的设备树文件中定义对应于同一共享内存的虚拟内存设备，并在系统重启时注册虚拟内存设备，多系统中每个系统通过虚拟内存设备实现在共享内存上的数据交互。本发明实施例的技术方案与微内核操作系统无关，配置和使用简单。在第一个方面的一种可能的实施方式中，把第一虚拟内存设备注册到各自的系统中，包括：每个系统从各自的设备树文件上获取第一虚拟内存设备的信息；每个系统根据第一虚拟内存设备的信息，调用各自的虚拟内存设备驱动程序，将共享内存从各自系统中隔离出来，并对第一虚拟内存设备进行初始化；当该初始化完成后，在每个系统中生成第一虚拟内存设备的设备文件。由上，每个系统通过调用各自的虚拟内存设备驱动程序，将共享内存从各自系统中隔离出来，并对共享内存进行初始化，生成各自的第一虚拟内存设备的设备文件，使共享内存的虚拟内存设备注册与微内核操作系统解耦，注册简单方便。在第一个方面的一种可能的实施方式中，每个系统的虚拟内存设备驱动程序为每个系统提供获取共享内存的信息的方法和通过第一虚拟内存设备名称打开第一虚拟内存设备的方法。由上，通过每个系统各自的虚拟内存设备驱动程序提供打开第一虚拟内存设备的方法和共享内存的信息，从而在每个系统的操作层面与微内核操作系统解耦，使用简单方便。在第一个方面的一种可能的实施方式中，每个系统通过第一虚拟内存设备进行系统间数据交互，包括：每个系统利用各自的所述第一虚拟内存设备的名称打开其所述第一虚拟内存设备；每个系统获取共享内存的信息，包括共享内存的地址和大小；每个系统中的第一系统向该共享内存的地址写入数据；每个系统中的第二系统从共享内存的地址读取数据。由上，通过每个系统各自的虚拟内存设备驱动程序提供打开第一虚拟内存设备的方法和共享内存的信息，从而在每个系统的操作层面与微内核操作系统解耦，使用简单方便。在第一个方面的一种可能的实施方式中，当对共享内存地址或大小进行变化时，还包括：修改每个系统的第一虚拟内存设备的共享内存的地址或/和大小；每个系统在重启第一虚拟内存设备时，把修改后的第一虚拟内存设备注册到各自的系统中。由上，通过每个系统在重启第一虚拟内存设备时，把修改后的第一虚拟内存设备注册到各自的系统中，从而实现共享内存的调整，使共享内存与微内核操作系统解耦，调整简单方便。在第一个方面的一种可能的实施方式中，多系统包括若干个非实时系统和若干个实时系统。由上，本发明的各实施例的方法还可以异构系统的共享内存的系统间数据交互。在第一个方面的一种可能的实施方式中，每个系统的第一虚拟内存设备具有相同的名称。由上，通过每个系统的第一虚拟内存设备具有相同的名称，在使用时简单方便，界面友好。第二方面，本发明实施例提供了一种多系统共享内存的装置，所述多系统中每个系统运行于同一个处理器上，包括：配置模块，用于在所述每个系统的设备树文件中添加第一虚拟内存设备，所述第一虚拟内存设备为所述多系统的共享内存在所述每个系统中的虚拟化设备；注册模块，用于所述每个系统在启动时根据各自的设备树文件，把所述第一虚拟内存设备注册到各自的系统中；交互模块，用于所述每个系统通过所述第一虚拟内存设备进行系统间数据交互。由上，通过在每个系统的设备树文件中定义对应于同一共享内存的虚拟内存设备，并在系统重启时注册虚拟内存设备，多系统中每个系统通过虚拟内存设备实现在共享内存上的数据交互。本发明实施例的技术方案与微内核操作系统无关，配置和使用简单。在第二个方面的一种可能的实施方式中，注册模块具体用于，包括：每个系统从各自的设备树文件上获取第一虚拟内存设备的信息；每个系统根据第一虚拟内存设备的信息，调用各自的虚拟内存设备驱动程序，将共享内存从各自系统中隔离出来，并对第一虚拟内存设备进行初始化；当该初始化完成后，在每个系统中生成第一虚拟内存设备的设备文件。由上，每个系统通过调用各自的虚拟内存设备驱动程序，将共享内存从各自系统中隔离出来，并对共享内存进行初始化，生成各自的第一虚拟内存设备的设备文件，使共享内存的虚拟内存设备注册与微内核操作系统解耦，注册简单方便。在第二个方面的一种可能的实施方式中，每个系统的虚拟内存设备驱动程序为每个系统提供获取共享内存的信息的方法和通过第一虚拟内存设备名称打开第一虚拟内存设备的方法。由上，通过每个系统各自的虚拟内存设备驱动程序提供打开第一虚拟内存设备的方法和共享内存的信息，从而在每个系统的操作层面与微内核操作系统解耦，使用简单方便。在第二个方面的一种可能的实施方式中，交互模块包括：打开模块，用于每个系统利用各自的所述第一虚拟内存设备的名称打开其所述第一虚拟内存设备；打开模块。还用于每个系统获取共享内存的信息，包括共享内存的地址和大小；写入模块，用于每个系统中的第一系统向该共享内存的地址写入数据；读取模块，用于每个系统中的第二系统从共享内存的地址读取数据。由上，通过每个系统各自的虚拟内存设备驱动程序提供打开第一虚拟内存设备的方法和共享内存的信息，从而在每个系统的操作层面与微内核操作系统解耦，使用简单方便。在第二个方面的一种可能的实施方式中，当对共享内存地址或大小进行变化时，配置模块还用于修改每个系统的第一虚拟内存设备的共享内存的地址或/和大小；注册模块还用于每个系统在重启第一虚拟内存设备时，把修改后的第一虚拟内存设备注册到各自的系统中。由上，通过每个系统在重启第一虚拟内存设备时，把修改后的第一虚拟内存设备注册到各自的系统中，从而实现共享内存的调整，使共享内存与微内核操作系统解耦，调整简单方便。在第二个方面的一种可能的实施方式中，多系统包括若干个非实时系统和若干个实时系统。由上，本发明的各实施例的方法还可以异构系统的共享内存的系统间数据交互。在第二个方面的一种可能的实施方式中，每个系统的第一虚拟内存设备具有相同的名称。由上，通过每个系统的第一虚拟内存设备具有相同的名称，在使用时简单方便，界面友好。第三方面，本发明实施例提供了一种计算设备，包括，总线；通信接口，其与所述总线连接；至少一个处理器，其与所述总线连接；以及至少一个存储器，其与所述总线连接并存储有程序指令，所述程序指令当被所述至少一个处理器执行时使得所述至少一个处理器执行本发明第一方面任一所述实施方式。第四方面，本发明实施例提供了一种计算机可读存储介质，其上存储有程序指令，所述程序指令当被计算机执行时使得所述计算机执行申请第一方面任一所述实施方式。附图说明图1为本发明的各实施例的场景的结构示意图；图2A为本发明一种多系统共享内存的配置方法实施例的流程示意图；图2B为本发明的多系统包含共享内存的物理内存的结构示意图；图3为本发明一种多系统共享内存的数据交互方法实施例的流程示意图；图4为本发明一种多系统共享内存的调整方法实施例的流程示意图；图5为本发明的一种多系统共享内存的装置的结构示意图；图6为本发明各实施例的一种计算设备的结构示意图。具体实施方式在以下的描述中，涉及到“一些实施例”，其描述了所有可能实施例的子集，但是可以理解，“一些实施例”可以是所有可能实施例的相同子集或不同子集，并且可以在不冲突的情况下相互结合。在以下的描述中，所涉及的术语“第一第二第三等”或模块A、模块B、模块C等，仅用于区别类似的对象，或用于区别不同的实施例，不代表针对对象的特定排序，可以理解地，在允许的情况下可以互换特定的顺序或先后次序，以使这里描述的本发明实施例能够以除了在这里图示或描述的以外的顺序实施。在以下的描述中，所涉及的表示步骤的标号，如S110、S120……等，并不表示一定会按此步骤执行，在允许的情况下可以互换前后步骤的顺序，或同时执行。除非另有定义，本文所使用的所有的技术和科学术语与属于本发明的技术领域的技术人员通常理解的含义相同。本文中所使用的术语只是为了描述本发明实施例的目的，不是旨在限制本发明。本发明各实施例提供了一种多系统共享内存的方法、装置、设备及存储介质。该多系统中每个系统可以均为实时系统或者均为非实时系统或者实时和非实时系统结合的异构系统，各系统均运行于同一个处理器上，通过在每个系统的设备树文件中定义对应于同一共享内存的虚拟内存设备，从而系统重启时通过虚拟机内存设备驱动程序注册虚拟内存设备，并获取访问虚拟内存设备的方法，多系统中每个系统从而通过虚拟内存设备实现在共享内存上的数据交互。本方法实施例的技术方案与微内核操作系统无关，配置和使用简单，易于移植和扩容。下面结合附图结合本发明的各实施例。首先结合附图1介绍本发明的各实施例的场景。图1示出了本发明实施例的多系统运行的场景环境，示例地，图1中所述多系统组成异构系统，运行一个处理器上，该处理器包括4个处理器核，其中，Core0和Core1支持通过Linux+KVM虚拟机运行环境而运行的非实时操作系统Window和Linux，Core2和Core3支持通过实时虚拟机而运行的实时操作系统RTOS，示例地，该实时虚拟系统包括Intewell的实时虚拟机。在本发明的各实施例的异构系统中，以一个Linux系统代表非实时系统和以为RTOS系统代表实时系统，以这两个系统为例进行说明。实际环境中，非实时系统可以包括多个Linux或Windows系统，实时系统可以包括多个RTOS系统。下面结合图2A至图4介绍本发明的多系统共享内存的各方法实施例。包括：一种多系统共享内存的配置方法实施例、交互方法实施例和扩容方法实施例。【配置方法实施例】在一种多系统共享内存的配置方法实施例中，通过异构系统的IDE分别在Linux系统和RTOS系统的设备树文件中配置共享内存的虚拟内存设备，并在Linux系统和RTOS系统重启时注册该虚拟内存设备。图2A示出了本发明的一种多系统共享内存的配置方法实施例的流程，其包括步骤S110、S120A和S120B。S110：利用异构系统IDE分别在Linux系统和RTOS的设备树文件中创建虚拟内存设备。图2B示出了包括共享内存的物理内存的结构，示例地，其中共享内存分别命名为mem1、mem2、…，对应的虚拟内存设备为device1、device2、…。在本例中，以共享内存mem1为例进行说明。示例地，在Linux系统的设备树文件devicetree1中配置共享内存mem1对应的虚拟内存设备device1，虚拟内存设备device1的信息中包括mem1的物理内存地址。示例地，RTOS系统的设备树文件devicetree2也包含共享内存mem1对应的虚拟内存设备device1，虚拟内存设备device1的信息中包括mem1的物理内存地址。其中，在Linux系统和RTOS的虚拟内存设备使用相同的名字device1，便于在实际使用过程表达为同一共享内存。在另一些实施例中也可以使用不同的名字S120A：Linux系统启动时根据其设备树文件，将虚拟内存设备注册到Linux系统中。示例地，Linux系统启动时根据设备树文件devicetree1，调用该文件上各节点对应的设备驱动程序，把各节点对应的设备分别注册Linux系统中。具体地，以虚拟内存设备device1为例，Linux系统启动时根据设备树文件devicetree1上虚拟内存设备device1的信息，调用Linux系统虚拟内存设备驱动程序，将保留的内存块mem1从Linux系统的虚拟机中隔离出，并对虚拟内存设备device1进行注册，该注册完成后，在Linux系统的dev目录下生成device1设备文件。其中，在该注册完成后，Linux系统虚拟内存设备驱动程序还提供获取虚拟内存设备device1对应应的共享内存的地址和大小等信息的方法以及通过设备名称device1打开该虚拟内存设备device1的方法。S120B：RTOS系统启动时根据其设备树文件，将虚拟内存设备注册到RTOS系统中。示例地，RTOS系统启动时根据设备树文件devicetree2，调用该文件上各节点对应的设备驱动程序，把各节点对应的设备分别注册RTOS系统中。具体地，以虚拟内存设备device1为例，RTOS系统启动时根据设备树文件devicetree2上虚拟内存设备device1的信息，调用RTOS系统虚拟内存设备驱动程序，将保留的内存块mem1从Linux系统的虚拟机中隔离出，并对虚拟内存设备device1进行注册，该注册完成后，在RTOS系统中生成device1设备文件。其中，在该注册完成后，RTOS系统虚拟内存设备驱动程序还提供获取虚拟内存设备device1对应应的共享内存的地址和大小等信息的方法以及通过设备名称device1打开该虚拟内存设备device1的方法。综上，一种多系统共享内存的配置方法实施例通过在每个系统的设备树文件中定义对应于同一共享内存的虚拟内存设备，在每个系统重启时通过虚拟机内存设备驱动程序注册虚拟内存设备，从而使多系统中每个系统通过虚拟内存设备实现在共享内存上的数据交互。本方法实施例的技术方案与操作系统无关，与微内核操作系统解耦，配置简单方便。【数据交互方法实施例】一种多系统共享内存的数据交互方法实施例运行在图1示出的Linux系统和RTOS系统中，Linux系统和RTOS系统分别打开共享内存对应的虚拟内存设备，获取共享内存信息，并通过虚拟内存设备在共享内存上进行数据交互。图3示出了本发明的一种多系统共享内存的数据交互方法实施例的流程，其包括步骤S210A至S240。S210A：Linux系统打开虚拟内存设备文件。本例中，继续以图2B中的共享内存mem1和其对应的虚拟内存设备device1为例进行说明。示例地，Linux系统使用Linux的open函数打开虚拟内存设备文件/dev/device1，该open函数为Linux系统的虚拟内存设备驱动程序提供。S210B：RTOS系统打开虚拟内存设备文件。示例地，RTOS系统也使用RTOS的open函数打开虚拟内存设备文件device1，该open函数为RTOS系统的虚拟内存设备驱动程序提供。S220A：Linux系统获取虚拟内存设备的信息。示例地，Linux系统使用Linux的ioctl方法获取虚拟内存设备device1的信息，包括共享内存mem1的物理地址和大小，该ioctl方法为Linux系统的虚拟内存设备驱动程序提供。S220B：RTOS系统获取虚拟内存设备的信息。示例地，RTOS系统使用RTOS的ioctl方法获取虚拟内存设备device1的信息，包括共享内存mem1的物理地址和大小，该ioctl方法为RTOS系统的虚拟内存设备驱动程序提供。S230：多系统中第一系统向共享内存的物理地址处写入数据data1。其中，在一些实施例中，还通过写信号量和原子操作来以解决写数据时的互斥问题。其中，在一些实施例中，还通过服务中断通知多系统中接收数据的系统共享内存中已有数据写入。其中，所述第一系统可以为Linux系统或RTOS系统。S240：多系统中第二系统从共享内存的物理地址处读取数据data1。其中，在一些实施例中，通过读信号量和原子操作来以解决读数据时的互斥问题。其中，在一些实施例中，通过服务中断获知共享内存中已有数据共享。其中，所述第一系统可以为Linux系统或RTOS系统。需要指出的，本例中，步骤S210A至S240可以实现Linux系统通过共享内存向RTOS系统共享数据，也可以实现RTOS系统通过共享内存向Linux系统共享数据。在实际场景中还可以在Linux系统之间或RTOS系统之间通过共享内存实现系统间的数据交互。综上，一种多系统共享内存的数据交互方法实施例中，每个系统通过打开共享内存对应的虚拟内存设备，获取其对应的共享内存的信息，并通过虚拟内存设备实现在共享内存上的数据交互。本方法实施例的技术方案与操作系统无关，与微内核操作系统解耦，使用简单方便。【调整方法实施例】在一种多系统共享内存的调整方法实施例中，通过异构系统的IDE在Linux系统和RTOS系统的设备树中重新配置虚拟内存设备中的共享内存的信息，并在Linux系统和RTOS系统重启虚拟内存设备，注册修改后的虚拟内存设备，通过修改后的虚拟内存设备可以进行系统间数据交互。图4示出了本发明的一种多系统共享内存的调整方法实施例的流程，其包括步骤S310、S320A和S320B。S310：利用异构系统的IDE分别调整在Linux系统和RTOS的设备树文件中的虚拟内存设备对应的共享内存的信息。本例中，继续以图2B中的共享内存mem1和其对应的虚拟内存设备device1为例进行说明。在实际使用时，可以根据需要修改的多个共享内存。示例地，分别修改在Linux系统和RTOS的设备树文件中虚拟内存设备device1对应共享内存mem1的位置和大小。修改后的共享内存mem1的位置和大小与其他设备保留的物理内存的位置和大小不冲突。S320A：linux系统重启虚拟内存设备，将修改后的虚拟内存设备注册到linux系统中。示例地，Linux系统重启虚拟内存设备device1时，调用linux系统的虚拟内存设备驱动程序，将新修改的内存块mem1从Linux系统的虚拟机中隔离出，并对虚拟内存设备device1进行重注册，该注册完成后，在Linux系统的dev目录下生成新的device1设备文件。S320B：RTOS系统重启虚拟内存设备，将修改后的虚拟内存设备注册到RTOS系统的设备管理中。示例地，RTOS系统重启虚拟内存设备device1时，调用RTOS系统的虚拟内存设备驱动程序，将新修改的内存块mem1从RTOS系统的虚拟机中隔离出，并对虚拟内存设备device1进行重注册，该注册完成后，在RTOS系统中生成新的device1设备文件。当异构系统各系统都重新注册修改后的虚拟内存设备后，利用一种多系统共享内存的数据交互方法实施例中的方法同样进行系统间数据交互。综上，一种多系统共享内存的调整方法实施例通过在每个系统的设备树文件中修改对应于同一共享内存的虚拟内存设备，在每个系统中重启该虚拟机内存设备，重新注册该虚拟内存设备，从而使多系统中每个系统通过修改后的虚拟内存设备实现在共享内存上的数据交互。本方法实施例的技术方案与操作系统无关，与微内核操作系统解耦，移植和扩容简单方便。下面基于图5绍本发明的一种多系统共享内存的装置实施例。【一种多系统共享内存的装置实施例】一种多系统共享内存的装置实施例运行在一种多系统共享内存的各方法实施例。继续以图2B中的共享内存为例进行说明。图5示出了一种多系统共享内存的装置实施例的结构，包括：配置模块510、注册模块520A、注册模块520B、打开模块530A、打开模块530B、写入模块540和读取模块550。其中，配置模块510部署在异构系统的IDE上，注册模块520A和打开模块530A部署在Linux系统中，注册模块520B和打开模块530B部署在RTOS系统中，写入模块540和读取模块550在异构系统的每个系统上均部署。配置模块510用于由异构系统的IDE配置在Linux系统与RTOS的设备树文件中创建虚拟内存设备，其方法和优点参照一种多系统共享内存的配置方法实施例的步骤S110。配置模块510还用于由异构系统的IDE分别调整在Linux系统和RTOS的设备树文件中的虚拟内存设备对应的共享内存的信息，其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S310。注册模块520A用于由异构系统的Linux系统在启动时根据设备树文件，将虚拟内存设备注册到Linux系统中，其方法和优点参照一种多系统共享内存的配置方法实施例的步骤S120A。注册模块520A还用于由异构系统的Linux系统重启虚拟内存设备，将修改后的虚拟内存设备重注册到Linux系统中，其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S320A。注册模块520B用于由异构系统的RTOS系统在启动时根据设备树文件，将虚拟内存设备注册到RTOS系统中，其方法和优点参照一种多系统共享内存的配置方法实施例的步骤S120B。注册模块520B还用于由异构系统的RTOS系统重启虚拟内存设备，将修改后的虚拟内存设备重注册到RTOS系统中，其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S320B。打开模块530A用于由Linux系统打开虚拟内存设备、获取虚拟内存设备的信息。其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S210A和S220A。打开模块530B用于由RTOS系统打开虚拟内存设备、获取虚拟内存设备的信息。其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S210B和S220B。写入模块540用于由每个系统向共享内存的物理地址处写入数据。其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S230。读取模块550用于由每个系统从共享内存的物理地址处读取数据。其方法和优点参照一种多系统共享内存的调整方法实施例的步骤S240。【计算设备】本发明还提供的一种计算设备，下面图6详细介绍。该计算设备600包括，处理器610、存储器620、通信接口630、总线640。应理解，该图所示的计算设备600中的通信接口630可以用于与其他设备之间进行通信。其中，该处理器610可以与存储器620连接。该存储器620可以用于存储该程序代码和数据。因此，该存储器620可以是处理器610内部的存储单元，也可以是与处理器610独立的外部存储单元，还可以是包括处理器610内部的存储单元和与处理器610独立的外部存储单元的部件。可选的，计算设备600还可以包括总线640。其中，存储器620、通信接口630可以通过总线640与处理器610连接。总线640可以是外设部件互连标准总线或扩展工业标准结构总线等。所述总线640可以分为地址总线、数据总线、控制总线等。为便于表示，该图中仅用一条线表示，但并不表示仅有一根总线或一种类型的总线。应理解，在本发明实施例中，该处理器610可以采用中央处理单元。该处理器还可以是其它通用处理器、数字信号处理器、专用集成电路、现成可编程门阵列或者其它可编程逻辑器件、分立门或者晶体管逻辑器件、分立硬件组件等。通用处理器可以是微处理器或者该处理器也可以是任何常规的处理器等。或者该处理器610采用一个或多个集成电路，用于执行相关程序，以实现本发明实施例所提供的技术方案。该存储器620可以包括只读存储器和随机存取存储器，并向处理器610提供指令和数据。处理器610的一部分还可以包括非易失性随机存取存储器。例如，处理器610还可以存储设备类型的信息。在计算设备600运行时，所述处理器610执行所述存储器620中的计算机执行指令执行各方法实施例的操作步骤。应理解，根据本发明实施例的计算设备600可以对应于执行根据本发明各实施例的方法中的相应主体，并且计算设备600中的各个模块的上述和其它操作和/或功能分别为了实现本实施例各方法的相应流程，为了简洁，在此不再赘述。本领域普通技术人员可以意识到，结合本文中所公开的实施例描述的各示例的单元及算法步骤，能够以电子硬件、或者计算机软件和电子硬件的结合来实现。这些功能究竟以硬件还是软件方式来执行，取决于技术方案的特定应用和设计约束条件。专业技术人员可以对每个特定的应用来使用不同方法来实现所描述的功能，但是这种实现不应认为超出本发明的范围。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，上述描述的系统、装置和单元的具体工作过程，可以参考前述方法实施例中的对应过程，在此不再赘述。在本发明所提供的几个实施例中，应该理解到，所揭露的系统、装置和方法，可以通过其它的方式实现。例如，以上所描述的装置实施例仅仅是示意性的，例如，所述单元的划分，仅仅为一种逻辑功能划分，实际实现时可以有另外的划分方式，例如多个单元或组件可以结合或者可以集成到另一个系统，或一些特征可以忽略，或不执行。另一点，所显示或讨论的相互之间的耦合或直接耦合或通信连接可以是通过一些接口，装置或单元的间接耦合或通信连接，可以是电性，机械或其它的形式。所述作为分离部件说明的单元可以是或者也可以不是物理上分开的，作为单元显示的部件可以是或者也可以不是物理单元，即可以位于一个地方，或者也可以分布到多个网络单元上。可以根据实际的需要选择其中的部分或者全部单元来实现本实施例方案的目的。另外，在本发明各个实施例中的各功能单元可以集成在一个处理单元中，也可以是各个单元单独物理存在，也可以两个或两个以上单元集成在一个单元中。所述功能如果以软件功能单元的形式实现并作为独立的产品销售或使用时，可以存储在一个计算机可读取存储介质中。基于这样的理解，本发明的技术方案本质上或者说对现有技术做出贡献的部分或者该技术方案的部分可以以软件产品的形式体现出来，该计算机软件产品存储在一个存储介质中，包括若干指令用以使得一台计算机设备执行本发明各个实施例所述方法的全部或部分步骤。而前述的存储介质包括，U盘、移动硬盘、只读存储器、随机存取存储器、磁碟或者光盘等各种可以存储程序代码的介质。【计算机可读存储介质】本发明实施例还提供了一种计算机可读存储介质，其上存储有计算机程序，该程序被处理器执行时用于执行各方法实施例的操作步骤。本发明实施例的计算机存储介质，可以采用一个或多个计算机可读的介质的任意组合。计算机可读介质可以是计算机可读信号介质或者计算机可读存储介质。计算机可读存储介质例如可以是，但不限于，电、磁、光、电磁、红外线、或半导体的系统、装置或器件，或者任意以上的组合。计算机可读存储介质的更具体的例子包括，具有一个或多个导线的电连接、便携式计算机磁盘、硬盘、随机存取存储器、只读存储器、可擦式可编程只读存储器、光纤、便携式紧凑磁盘只读存储器、光存储器件、磁存储器件、或者上述的任意合适的组合。在本文件中，计算机可读存储介质可以是任何包含或存储程序的有形介质，该程序可以被指令执行系统、装置或者器件使用或者与其结合使用。计算机可读的信号介质可以包括在基带中或者作为载波一部分传播的数据信号，其中承载了计算机可读的程序代码。这种传播的数据信号可以采用多种形式，包括但不限于电磁信号、光信号或上述的任意合适的组合。计算机可读的信号介质还可以是计算机可读存储介质以外的任何计算机可读介质，该计算机可读介质可以发送、传播或者传输用于由指令执行系统、装置或者器件使用或者与其结合使用的程序。计算机可读介质上包含的程序代码可以用任何适当的介质传输，包括、但不限于无线、电线、光缆、RF等等，或者上述的任意合适的组合。可以以一种或多种程序设计语言或其组合来编写用于执行本发明操作的计算机程序代码，所述程序设计语言包括面向对象的程序设计语言—诸如Java、Smalltalk、C++，还包括常规的过程式程序设计语言—诸如“C”语言或类似的程序设计语言。程序代码可以完全地在用户计算机上执行、部分地在用户计算机上执行、作为一个独立的软件包执行、部分在用户计算机上部分在远程计算机上执行、或者完全在远程计算机或服务器上执行。在涉及远程计算机的情形中，远程计算机可以通过任意种类的网络，包括局域网或广域网，连接到用户计算机，或者，可以连接到外部计算机。注意，上述仅为本发明的较佳实施例及所运用技术原理。本领域技术人员会理解，本发明不限于这里所述特定实施例，对本领域技术人员来说能够进行各种明显的变化、重新调整和替代而不会脱离本发明的保护范围。因此，虽然通过以上实施例对本发明进行了较为详细的说明，但是本发明不仅仅限于以上实施例，在不脱离本发明构思的情况下，还可以包括更多其他等效实施例，均属于本发明保护范畴。

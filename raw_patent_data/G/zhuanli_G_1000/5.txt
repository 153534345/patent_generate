标题title
一种荧光微阵列识别分析方法及系统
摘要abst
一种荧光微阵列识别分析方法及系统，涉及荧光信号图像处理领域，解决了现有技术中微阵列实验产生大量数据即存在校正偏差、没有有效的计算方法来处理和分析这些数据，导致定位不准确、荧光信号提取偏差导致无法准确分析，数据处理和分析的难度大的问题。本发明所述的荧光微阵列识别分析方法，包括以下步骤：步骤一：获取微阵列图像，对微阵列图像进行预处理；步骤二：对预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；步骤三：基于得到的荧光数据并结合数学分析方法，完成分析。还适用于荧光信号图像分析过程中。
权利要求书clms
1.一种荧光微阵列识别分析方法，其特征在于，所述识别分析方法包括：步骤一：获取微阵列图像，对所述微阵列图像进行预处理；步骤二：对所述预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；步骤三：基于得到的荧光数据并结合数学分析方法，完成分析。2.根据权利要求1所述的荧光微阵列识别分析方法，其特征在于，所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤。3.根据权利要求2所述的荧光微阵列识别分析方法，其特征在于，所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正的步骤为：使用霍夫圆变换检测微阵列灰度图像中的圆形；对所述圆形进行遍历，并以相同的圆心在微阵列中绘制尺寸相同的圆；计算所有圆心的组成的图像边缘4个角的圆形坐标；比较所述4个角的圆形坐标的横纵坐标；所述圆形坐标最左侧和最右侧的水平距离Lx与的垂直距离Ly；如果水平距离Lx不超过垂直距离Ly，计算所述水平距离Lx的中点，作为旋转的中心点；基于所述旋转的中心点生成旋转矩阵；得到旋转后的图像并保存旋转后的图像，完成校正。4.根据权利要求3所述的荧光微阵列识别分析方法，其特征在于，所述绘制网格图的方法为：基于所述校正后的图像调用Circle方法和PutText方法，绘制网格图。5.根据权利要求1所述的荧光微阵列识别分析方法，其特征在于，对所述圆形进行遍历方法为：采用for循环遍历圆形的外侧识别到的圆形的个数，内侧编历对所述圆形中的坐标值进行判断，如果圆形中的坐标值与圆形的个数相同，则保留；如果圆形中的坐标值与圆形的个数不相同，则舍去。6.一种荧光微阵列识别分析系统，其特征在于，所述系统包括：获取图像模块，用于获取微阵列图像，对所述微阵列图像进行预处理，所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤；识别模块，用于对所述预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；分析模块，用于基于得到的荧光数据并结合数学分析方法，完成分析。7.根据权利要求6所述的荧光微阵列识别分析系统，其特征在于，所述获取图像模块包括：预处理模块，用于对所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤。8.计算机可读存储介质，其特征在于，所述计算机可读存储介质用于储存计算机程序，所述计算机程序执行权利要求1-5任一项所述的荧光微阵列识别分析方法。9.计算机设备，其特征在于，包括存储器和处理器，所述存储器中存储有计算机程序，当所述处理器运行所述存储器存储的计算机程序时，所述处理器执行根据权利要求1-5中任一项中所述的荧光微阵列识别分析方法。
说明书desc
技术领域本发明涉及荧光信号图像处理技术领域。背景技术微阵列技术是一种用于同时分析成千上万个基因表达、蛋白质交互或其他生物分子的技术。在生物学和医学研究中具有重要意义。荧光标记是一种常见的检测方式，在微阵列实验中，通过特定波长的光照射，使芯片上的荧光标记物发光。使用荧光标记来检测特定分子的存在，样本与特定探针结合，结合部位通过荧光标记可视化。目前，微阵列实验产生大量数据，需要有效的计算方法来处理和分析这些数据，校正偏差、定位不准确、荧光信号提取偏差导致无法准确分析，增加了数据处理和分析的难度。发明内容本发明针对现有技术中微阵列实验产生大量数据即存在校正偏差、没有有效的计算方法来处理和分析这些数据，导致定位不准确、荧光信号提取偏差导致无法准确分析，数据处理和分析的难度大的问题，为解决上述技术问题本发明是通过以下技术方案实现的：本发明提供了以下技术方案，包括：方案一、一种荧光微阵列识别分析方法，所述识别分析方法包括：步骤一：获取微阵列图像，对所述微阵列图像进行预处理；步骤二：对所述预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；步骤三：基于得到的荧光数据并结合数学分析方法，完成分析。进一步的，提供一种优选实施方式，对所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤。进一步的，提供一种优选实施方式，所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正的步骤为：使用霍夫圆变换检测微阵列灰度图像中的圆形；对所述圆形进行遍历，并以相同的圆心在微阵列中绘制尺寸相同的圆；计算所有圆心的组成的图像边缘4个角的圆形坐标；比较所述4个角的圆形坐标的横纵坐标；所述圆形坐标最左侧和最右侧的水平距离Lx与的垂直距离Ly；如果水平距离Lx不超过垂直距离Ly，计算所述水平距离Lx的中点，作为旋转的中心点；基于所述旋转的中心点生成旋转矩阵；得到旋转后的图像并保存旋转后的图像，完成校正。进一步的，提供一种优选实施方式，所述绘制网格图的方法为：基于所述校正后的图像调用Circle方法和PutText方法，绘制网格图。进一步的，提供一种优选实施方式，对所述圆形进行遍历方法为：采用for循环遍历圆形的外侧识别到的圆形的个数，内侧编历对所述圆形中的坐标值进行判断，如果圆形中的坐标值与圆形的个数相同，则保留；如果圆形中的坐标值与圆形的个数不相同，则舍去。方案二、一种荧光微阵列识别分析系统，所述系统包括：获取图像模块，用于获取微阵列图像，对所述微阵列图像进行预处理，所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤；识别模块，用于对所述预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；分析模块，用于基于得到的荧光数据并结合数学分析方法，完成分析。进一步的，提供一种优选实施方式，所述获取图像模块包括：预处理模块，用于对所述微阵列图像进行预处理包括定位微阵列图像中阵列位置、方向、校正和孔径定位的步骤。方案三、计算机可读存储介质，所述计算机可读存储介质用于储存计算机程序，所述计算机程序执行方案一种任一项所述的荧光微阵列识别分析方法。方案四、计算机设备，包括存储器和处理器，所述存储器中存储有计算机程序，当所述处理器运行所述存储器存储的计算机程序时，所述处理器执行根据方案一中任一项中所述的荧光微阵列识别分析方法。本发明的有益之处在于：本发明提出了一种荧光微阵列识别分析方法及系统，通过灰度相机获取微阵列的图像，对获取图像进行预处理：包括校正、标记网格、孔径定位等步骤，采用微阵列图像，分析图像的位置和方向，对图像进行校正以调整任何倾斜或畸变。标记网格，有助于后续的定位和分析，并在校正后的图像中定位微阵列的具体阵列位置和坐标。 通过孔径定位的方法识别特定的微阵列特征或元素，应用图像处理算法来提取荧光信息，结合数学过程进行准确分析。本发明还适用于荧光信号图像分析过程中。附图说明图1为实施方式一所述的一种荧光微阵列识别分析方法的示意图。图2为实施方式一所述的一种荧光微阵列识别分析方法的旋转示意图。图3为实施方式一所述的一种荧光微阵列识别分析方法的校正示意图。图4为实施方式一所述的一种荧光微阵列识别分析方法的网格示意图。图5为实施方式一所述的一种荧光微阵列识别分析方法的折线图。图6为实施方式一所述的一种荧光微阵列识别分析方法中每个阵列的荧光数据示意图。具体实施方式为使本申请实施方式的目的、技术方案和优点更加清楚，下面将结合本申请实施方式中的附图，对本申请实施方式中的技术方案进行清楚、完整地描述，显然，所描述的实施方式是本申请一部分实施方式，而不是全部实施方式。实施方式一、本实施方式提供了一种荧光微阵列识别分析方法，所述识别分析方法包括：步骤一：获取微阵列图像，对所述微阵列图像进行预处理；步骤二：对所述预处理的微阵列图像进行标记排序，排序后绘制网格图，基于所述图像处理算法提取网格图中每个阵列的荧光数据，完成识别，所述图像处理算法通过边缘检测和霍夫圆变换来提取荧光数据；步骤三：基于得到的荧光数据并结合数学分析方法，完成分析。实施方式二、本实施方式是对实施方式一所述的一种荧光微阵列识别分析方法的进一步限定，对所述微阵列图像进行预处理包括定位微阵列中阵列位置、方向、校正和孔径定位的步骤。实施方式三、本实施方式是对实施方式二所述的一种荧光微阵列识别分析方法的进一步限定,所述微阵列图像进行预处理包括定位微阵列中阵列位置、方向、校正的步骤为：使用霍夫圆变换检测微阵列图像中的圆形；对所述圆形进行遍历，并以相同的圆心在微阵列中绘制尺寸相同的圆；计算所有圆心的组成的图像边缘4个角的圆形坐标；比较所述4个角的圆形坐标的横纵坐标；所述圆形坐标最左侧和最右侧的水平距离Lx与的垂直距离Ly；如果水平距离Lx不超过垂直距离Ly，计算所述水平距离Lx的中点，作为旋转的中心点；基于所述旋转的中心点生成旋转矩阵；得到旋转后的图像并保存旋转后的图像，完成校正。实施方式四、本实施方式是对实施方式三所述的一种荧光微阵列识别分析方法的进一步限定，所述绘制网格图的方法为：基于所述校正后的图像调用Circle方法和PutText方法，绘制网格图。实施方式五、本实施方式是对实施方式一所述的一种荧光微阵列识别分析方法的进一步限定，对所述圆形进行遍历方法为：采用for循环遍历圆形的外侧识别到的圆形的个数，内层编历对所述圆形中的坐标值进行判断，如果圆形中的坐标值与圆形的个数相同，则保留；如果圆形中的坐标值与圆形的个数不相同，则舍去。实施方式六、本实施方式提供了一种荧光微阵列识别分析系统，所述系统包括：获取图像模块，用于获取微阵列图像，对所述微阵列图像进行预处理；提取模块，用于对所述预处理的微阵列图像进行排序；基于所述图像处理算法提取荧光信息；分析模块，用于基于得到的荧光信息并结合数学分析方法，完成分析。实施方式七、本实施方式是对实施方式六所述的一种荧光微阵列识别分析系统的进一步限定，所述获取图像模块包括：预处理模块，用于对所述微阵列图像进行预处理包括定位微阵列中阵列位置、方向、校正和孔径定位的步骤。实施方式八、参见图1至图6说明本实施方式，本实施方式是对一种荧光微阵列识别分析方法提供的一个具体实施例，同时解释上述实施方式；具体的，步骤一包括以下步骤：步骤1：定义Emgu CV 函数库的 Image 类的一个对象，用oir、img_RO、_sourceImage、_templateImage、_matchImage、_lastImage表示；oir表示一个灰度图像，img_RO同样是一个灰度图像，用于存储特定的区域或经过处理的图像，_sourceImage表示原始图像，_templateImage表示模板图像，_matchImage存储模板匹配操作的结果，_lastImage显示最终的处理结果，Emgu CV 函数库的 Mat类的一个对象，用mapMat1表示，定义Emgu CV 函数库的CircleF数组类的一个对象，用Cir表示。步骤2：调用Emgu CV函数库下的CvInvoke函数，使用GaussianBlur方法，对图像oir 应用高斯模糊来减少噪声。这里使用的核大小是5x5，标准差是3；步骤3：调用Emgu CV函数库下的CvInvoke函数，使用HoughCircles方法；使用霍夫圆变换检测图像 oir 中的圆形。参数包括检测模式、分辨率、最小距离、阈值等。并将HoughCircles方法的返回值赋值给Cir，步骤4：定义System.Collections.Generic命名空间中Point类型的List类对象，用L_ps 表示。调用Foreach函数对Cir数组中的数据进行遍历，L_ps调用Add函数，将将每个圆的中心点添加到列表 L_ps。调用Emgu CV函数库下的CvInvoke函数，使用Circle方法，在_lastImage 图像上绘制每个圆，调用Save函数，保存处理后的图像到指定路径。步骤5：定义4个System.Drawing.Point命名空间中Point类对象，用X_min、X_max、Y_min、Y_max表示。L_ps调用System.Linq类下的IOrderedEnumerable函数，选择OrderBy方法，计；计算出所有圆心中的图像边缘的4个角的圆形坐标。步骤6：定义System.Xml.Linq命名空间中的var类的1个对象，分别用PointS表示，调用Foreach函数对L_ps列表中的数据进行遍历。调用math方法种的Abs函数，参数为PointS.X与X_min.X，检查当前点 PointS 的X 坐标是否与最小 X 坐标点 X_min 的 X 坐标相差小于30个单位。如果 PointS 在水平方向上接近 X_min，则考虑将其作为新的最小 X 坐标点。如果 PointS 的 Y 坐标小于 X_min 的 Y 坐标，说明 PointS 在垂直方向上比X_min 更靠上，将 PointS 更新为新的 X_min。调用math方法种的Abs函数，参数为PointS.X与X_max.X，检查当前点 PointS 的X 坐标是否与最小 X 坐标点 X_max的 X 坐标相差小于30个单位。检查 PointS 是否在水平方向上接近最大 X 坐标点 X_max。如果 PointS 的 Y 坐标大于 X_max 的 Y 坐标，说明 PointS 在垂直方向上比X_max 更靠下，更新 X_max 为 PointS。调用math方法种的Abs函数，参数为PointS.Y与Y_min.Y，检查当前点 PointS 的Y 坐标是否与最小 Y 坐标点 Y _ min的 Y 坐标相差小于30个单位。检查 PointS 是否在垂直方向上接近最小 Y 坐标点 Y_min。如果 PointS 的 X 坐标大于 Y_min 的 X 坐标，说明 PointS 在水平方向上比Y_min 更靠右，更新 Y_min 为 PointS。调用math方法种的Abs函数，参数为PointS.Y与Y_max. Y，检查当前点 PointS 的Y 坐标是否与最小 Y 坐标点 Y _ max的 Y 坐标相差小于30个单位。检查 PointS 是否在垂直方向上接近最大 Y 坐标点 Y_max。如果 PointS 的 X 坐标小于 Y_max 的 X 坐标，说明 PointS 在水平方向上比Y_max 更靠左， Y_max 为 PointS。步骤7：定义3个double类型的了变量，用Lx、Ly、angleOfLine表示。定义System.Drawing.Point类型的变量，用p_center表示。调用distance函数，将返回值赋值给Lx、Ly，定义Emgu CV函数库下Mat对象，用mapMat、srcPic、dstPic表示。步骤8：判断两个点间的水平距离是否大于或等于它们的垂直距离。根据 Lx 和 Ly 的比较结果进行不同的处理:如果 Lx＞= Ly:p_center: 计算 X_min 和 X_max 之间的中点，用作旋转的中心点。计算 X_min 和 X_max 两点形成的直线与水平方向的角度，调用Math函数下的Atan2方法， 将返回值赋值给angleOfLine弧度值，调用ImgRotate_mat函数，定义Emgu CV函数库下Mat对象，用mapMat表示。调用Emgu CV函数库下的CvInvoke函数，使用GetRotationMatrix2D方法，对图像生成一个旋转矩阵；调用Emgu CV函数库下的CvInvoke函数，使用WarpAffine方法，计算旋转矩阵 mapMat 到源图像 srcPic 上，得到旋转后的图像 dstPic。乘以 180 / Math.PI 将其转换为度数，并且减去45度，并保存旋转后的图像。步骤9：p_center: 计算Y_min 和Y_max 之间的中点，用作旋转的中心点。计算 Y_min 和 Y_max 两点形成的直线与水平方向的角度，调用Math函数下的Atan2方法， 将返回值赋值给angleOfLine弧度值，调用ImgRotate_mat函数，定义Emgu CV函数库下Mat对象，用mapMat表示。调用Emgu CV函数库下的CvInvoke函数，使用GetRotationMatrix2D方法，对图像生成一个旋转矩阵；调用Emgu CV函数库下的CvInvoke函数，使用WarpAffine方法，计算旋转矩阵 mapMat 到源图像 srcPic 上，得到旋转后的图像 dstPic。乘以 180 / Math.PI将其转换为度数，并且减去45度，并保存旋转后的图像，否则执行步骤8。进一步地，步骤二包括以下步骤：步骤1：定义System.Collections.Generic命名空间中int类型的List类对象，用list_X、list_Y 表示。定义System.Collections.Generic命名空间中Point类型的List类对象，用p1、p2表示，定义Emgu. CV命名空间中的Mat类的3个对象，用col_show、dstPic_8、dstPic_16表示，定义Emgu CV 函数库的CircleF数组类的一个对象，用Cir表示，调用Emgu CV函数库下的CvInvoke函数，使用HoughCircles方法；使用霍夫圆变换检测图像 oir中的圆形。参数包括检测模式、分辨率、最小距离、阈值等。并将HoughCircles方法的返回值赋值给Cir。步骤2：调用Cir的属性Count， 当Count数量大于3时，表示之别出了三个圆形，即为图像中对角，如图1所示，执行下一步骤。步骤3：调用Foreach函数对Cir数组中的数据进行遍历，对每个识别到的圆形中心点坐标被添加到两个列表 list_X 和 list_Y 中。a.Center.X 和 a.Center.Y 分别表示圆心的X和Y坐标。定义int类型的4个变量，用x_min、x_max、y_min、y_max表示，调用list_X变量的Min属性，计算所有圆心X坐标的最小值。调用list_X变量的Max属性，计算所有圆心X坐标的最大值。调用list_Y变量的Min属性，计算所有圆心Y坐标的最小值。调用list_Y变量的Max属性，计算所有圆心Y坐标的最大值。步骤4：定义System.Collections.Generic命名空间中int类型的List类对象，用L_1 表示。调用list_X变量的where属性，选取那些与 x_min 的差值小于100的X坐标，生成一个新的列表，将其赋值给L_1，调用for循环语句，循环遍历Cir、L_1的个数Count，外层循环遍历所有识别到的圆形，内层循环遍历 L_1 列表中的X坐标。如果圆形的X坐标与 L_1中的某个值相等，则将该圆形的中心点添加到列表 p1 中。定义System.Xml.Linq命名空间中的var类的1个对象，用resultlist表示。调用p1变量的GroupBy属性，从列表中删除重复的点p1，将结果赋值给resultlist。调用Foreach函数对resultlist数组中的数据进行遍历，调用Emgu CV函数库下的CvInvoke函数，使用Circle方法，在图像上的每个点处绘制一个圆，定义2个System.Drawing.Point命名空间中Point类的对象，用A、B表示。调用resultlist变量的GroupBy属性，查找Y 坐标最小的点，该点通常位于图像的顶部，将其值赋值给A。调用resultlist变量的GroupBy属性，查找Y 坐标最大的点，该点通常位于图像的顶部，将其值赋值给B。步骤5：定义System.Collections.Generic命名空间中int类型的List类对象，用L_2 表示。调用list_X变量的where属性，选取那些与 x_max 的差值小于100的X坐标，生成一个新的列表，将其赋值给L_2，调用for循环语句，循环遍历Cir、L_2的个数Count，外层循环遍历所有识别到的圆形，内层循环遍历 L_2 列表中的X坐标。如果圆形的X坐标与 L_2中的某个值相等，则将该圆形的中心点添加到列表 p2 中。System.Xml.Linq命名空间中的var类的1个对象，用resultlist1表示。调用p2变量的GroupBy属性，从列表中删除重复的点p2，将结果赋值给resultlist1。调用Foreach函数对resultlist数组中的数据进行遍历，调用Emgu CV函数库下的CvInvoke函数，使用Circle方法，在图像上的每个点处绘制一个圆，定义2个System.Drawing.Point命名空间中Point类的对象，用C、D表示。调用resultlist1变量的GroupBy属性，查找Y 坐标最小的点，该点通常位于图像的顶部，将其值赋值给C。调用resultlist1变量的GroupBy属性，查找Y 坐标最大的点，该点通常位于图像的顶部，将其值赋值给D。步骤6：调用Emgu CV函数库下的CvInvoke函数，使用Circle方法、PutText方法，绘制出圆圈和文本注释图像，A、B、C、D的位置。定义2个System.Collections.Generic命名空间中double类型对象，用L_AB、L_CD表示。调用Math函数库下的Abs函数，计算点 `A` 和 `B` 之间的绝对垂直距离，计算点`C`和`D`之间的垂直距离。分别赋值给L_AB、L_CD。步骤7：检查线段L_AB的长度是否小于线段L_CD的长度。检查 A 点是否显着高于C 点。如果为真，则意味着 A 点是“凹口”。 保存图像而不进行任何旋转，因为 A 点已位于预期位置。否则，将图像旋转，果确定B点是凹口，则执行该旋转。同样，将图像旋转270度。执行步骤8。步骤8：检查线段L_AB的长度是否大于线段L_CD的长度，检查C明显高于A，则表明C点是凹口，将图像旋转 90 度。否则，D 点是凹口，则图像旋转 180 度。进一步地，步骤三包括以下步骤：步骤1：定义2个System.Collections.Generic命名空间中int类型的List类对象，用list_X 、list_Y表示。定义System.Collections.Generic命名空间中double类型的List类对象，用Pixel_表示，定义Emgu CV 函数库的CircleF数组类的一个对象，用Cir1表示。调用Foreach函数对Cir1数组中的数据进行遍历，list_X调用Add函数，将将每个圆的中心横坐标X点添加到列表list_X中，list_Y调用Add函数，将将每个圆的中心横坐标Y点添加到列表list_Y中，定义int类型的4个对象，用x_min、x_max、y_min、y_max表示，计算网格的水平和垂直间距，其中x_max、x_min、y_max、y_min是圆心的极值坐标，N是网格的大小。通过嵌套for循环，将网格点坐标添加到point_c列表中。步骤2：调用Emgu CV函数库下的CvInvoke函数，使用Rectangle、Circle方法，在图像上绘制矩形和圆形标记；定义double类型的临时变量values1，将调用GetDoubleValue方法的值赋值给values1，调用math函数库下的Round函数，计算每个网格点周围区域的平均像素值，并将像素值赋值给Pixel_中。步骤3：结合数学分析方法，以直线回归为例，结合使用Python的numpy和sklearn库来进行线性回归分析过程进行封装。Python编写过程如下：导入numpy、r2_score、sklearn库，用于数学和科学计算、评估回归模型的拟合度、执行线性回归。根据步骤2得到的Pixel_变量作为输入，创建和拟合线性回归模型，输出模型参数和评估指标，并最终通过散点图绘制出结果。通过标准输入输出与C#可视化界面进行通信。调用 Python脚本的路径，向 Python发送数据，通过标准输出读取 Python返回的结果。本领域技术人员可以理解，本公开的各个实施例和/或权利要求中记载的特征可以进行多种组合或结合，即使这样的组合或结合没有明确记载于本公开中。特别地，在不脱离本公开精神和教导的情况下，本公开的各个实施例和可以进行多种组合。所有这些组合均落入本公开的范围。尽管已描述了本发明的优选实施例，但本领域内的技术人员一旦得知了基本创造性概念， 则可对这些实施例作出另外的变更和修改。所以，所附权利要求意欲解释为包括优选实施例 以及落入本发明范围的所有变更和修改。显然，本领域的技术人员可以对本发明进行各种改 动和变型而不脱离本发明的精神和范围。这样，倘若本发明的这些修改和变型属于本发明权利要求及其等同技术的范围之内，则本发明也意图包含这些改动和变型在内。

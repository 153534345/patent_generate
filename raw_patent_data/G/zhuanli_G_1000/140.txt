标题title
一种CPU与FPGA间循环缓冲通信方法及系统
摘要abst
本发明属于数字信息传输技术领域，尤其涉及一种CPU与FPGA间循环缓冲通信方法及系统，其包括CPU端写入FPGA端：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端，CPU端读取FPGA端：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端，本发明解决了现有技术存在CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差、数据同步性较差、数据互斥及数据覆盖的问题，具有结构封装、统一接口、队列控制，实现了数据封装和同步，有效避免了数据覆盖和互斥的有益技术效果。
权利要求书clms
1.一种CPU与FPGA间循环缓冲通信方法，其特征在于，包括：CPU端写入FPGA端：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端；CPU端读取FPGA端：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端。2.根据权利要求1所述循环缓冲通信方法，其特征在于，所述发起入队操作包括：判断发送队列状态：判断发送循环缓冲队列是否为满，若已满，则标志发送循环缓冲队列满后通知FPGA端，否则，将发送数据写入相应的发送缓冲地址；更新发送队列状态：更新写指针和写计数；写入发送完成状态：标志发送完成状态后通知FPGA端。3.根据权利要求2所述循环缓冲通信方法，其特征在于，所述判断发送队列状态还包括：基于写指针和读指针，通过发送队列状态判断函数，确定发送循环缓冲队列是否为满；所述队列状态判断函数：；所述为写指针；所述为读指针；所述N1为循环缓冲队列长度。4.根据权利要求2所述循环缓冲通信方法，其特征在于，所述判断发送队列状态还包括：基于缓冲区基地址和当前写指针，通过写入地址计算函数，确定相应的内存地址并写入发送数据；所述写入地址计算函数：；所述为发送缓冲区基地址；所述为单位发送缓冲区长度；所述为预写入相应的内存地址；所述wptr为写指针；所述N1为循环缓冲队列长度；所述更新发送队列状态还包括：基于当前写指针值，通过写指针更新函数，更新当前写指针；所述写指针更新函数：；基于当前写计数值，通过写计数更新函数，更新当前写计数；所述写计数更新函数：；所述为当前写计数。5.根据权利要求1所述循环缓冲通信方法，其特征在于，所述发起出队操作包括：中断发起处理：若FPGA端写入完成的中断事件发起，则清除中断标志，并向接收数据线程释放信号量，并结束中断服务；判断接收队列状态：若获取到接收数据线程释放信号量，则读取读指针和读计数，判断接收循环缓冲队列是否为空，若为空，则标志接收循环缓冲队列空后通知FPGA端，否则，从相应的接收缓冲地址读取接收数据；更新接收队列状态：更新读指针和读计数；读取接收完成状态：标志接收完成状态后通知FPGA端。6.根据权利要求5所述循环缓冲通信方法，其特征在于，所述判断接收队列状态还包括：基于写指针和读指针，通过接收队列状态判断函数，确定接收循环缓冲队列是否为空；所述接收队列状态判断函数：；所述wptr为写指针；所述rdptr为读指针。7.根据权利要求5所述循环缓冲通信方法，其特征在于，所述判断接收队列状态还包括：基于缓冲区基地址和当前读指针，通过读取地址计算函数，确定相应的内存地址并读取接收数据；所述读取地址计算函数：；所述为接收缓冲区基地址；所述为单位接收缓冲区长度；所述为预读取相应的内存地址；所述N2为接收循环缓冲队列长度；所述rdptr为读指针；所述更新接收队列状态还包括：基于当前读指针值，通过读指针更新函数，更新当前读指针；所述读指针更新函数：；基于当前读计数值，通过读计数更新函数，更新当前读计数；所述读计数更新函数：；所述rdcount为当前读计数。8.根据权利要求5所述循环缓冲通信方法，其特征在于，所述中断发起处理前还包括判断缓冲区满；所述判断缓冲区满包括判断是否发起异常中断，若发起异常中断，则跳转到中断异常处理，在中断异常处理中，读取异常状态信息，判断接收循环缓冲队列是否已满，若队列已满，则标志和通知接收满异常，并通过初始化函数清空接收循环缓冲队列；所述初始化函数：；所述wptr为写指针；所述rdptr为读指针；所述rdcount为当前读计数。9.根据权利要求5所述循环缓冲通信方法，其特征在于，所述更新接收队列状态后还包括判断中断丢失；所述判断中断丢失包括通过数据包缓存判定标准判断接收循环缓冲队列是否存在数据包缓存，若存在数据包缓存，则主动向接收数据线程释放信号量，并发起下一次发起出队操作；所述数据包缓存判定标准还包括：若且，则当前接收队列存在数据包缓存；所述wptr为写指针；所述rdptr为读指针；所述wcount为当前写计数；所述rdcount为当前读计数。10.一种CPU与FPGA间循环缓冲通信系统，其特征在于，所述通信系统实现如权利要求1～9中任一项所述的循环缓冲通信方法，所述通信系统包括写入模块和读出模块；写入模块用于：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端；读出模块用于：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端。
说明书desc
技术领域本发明属于数字信息传输技术领域，尤其涉及一种CPU与FPGA间循环缓冲通信方法及系统。背景技术现有CPU与FPGA间数据通信多采用Local Bus、PCIe、RapidIO及AXI等总线接口，各总线数据传输时都需要对CPU端进行地址映射，即CPU端需提供一段存储区用于FPGA的读写访问，该存储区多为CPU端的一段DDR空间；由于与FPGA间进行数据收发时采用DDR进行，驱动无统一的设备封装，软件访问直接面对DDR的地址，缺乏便捷性；其次，收发数据采用DDR进行，CPU端难以分辨数据收发结束标识，需单独对内存进行标识，收发双方数据同步困难；另外，涉及对DDR同一地址的读写访问时，数据需要进行互斥访问的特殊处理；最后，当FPGA端数据传输瞬时带宽增大，或CPU端偶发负载增大时，对同一DDR区域的数据可能造成覆盖，导致丢包与错包现象出现；现有技术存在CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差、数据同步性较差、数据互斥及数据覆盖的问题。发明内容本发明提供一种CPU与FPGA间循环缓冲通信方法及系统，以解决上述背景技术中存在的CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差、数据同步性较差、数据互斥及数据覆盖的问题；本发明所解决的技术问题采用以下技术方案来实现：第一方面，本发明提供一种CPU与FPGA间循环缓冲通信方法，包括：CPU端写入FPGA端：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端；CPU端读取FPGA端：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端。进一步地，所述发起入队操作包括：判断发送队列状态：判断发送循环缓冲队列是否为满，若已满，则标志发送循环缓冲队列满后通知FPGA端，否则，将发送数据写入相应的发送缓冲地址；更新发送队列状态：更新写指针和写计数；写入发送完成状态：标志发送完成状态后通知FPGA端。进一步地，所述判断发送队列状态还包括：基于写指针和读指针，通过发送队列状态判断函数，确定发送循环缓冲队列是否为满；所述队列状态判断函数：；所述为写指针；所述为读指针；所述N1为循环缓冲队列长度。进一步地，所述判断发送队列状态还包括：基于缓冲区基地址和当前写指针，通过写入地址计算函数，确定相应的内存地址并写入发送数据；所述写入地址计算函数：；所述为发送缓冲区基地址；所述为单位发送缓冲区长度；所述为预写入相应的内存地址；所述wptr为写指针；所述N1为循环缓冲队列长度；所述更新发送队列状态还包括：基于当前写指针值，通过写指针更新函数，更新当前写指针；所述写指针更新函数：；基于当前写计数值，通过写计数更新函数，更新当前写计数；所述写计数更新函数：；所述为当前写计数。进一步地，所述发起出队操作包括：中断发起处理：若FPGA端写入完成的中断事件发起，则清除中断标志，并向接收数据线程释放信号量，并结束中断服务；判断接收队列状态：若获取到接收数据线程释放信号量，则读取读指针和读计数，判断接收循环缓冲队列是否为空，若为空，则标志接收循环缓冲队列空后通知FPGA端，否则，从相应的接收缓冲地址读取接收数据；更新接收队列状态：更新读指针和读计数；读取接收完成状态：标志接收完成状态后通知FPGA端。进一步地，所述判断接收队列状态还包括：基于写指针和读指针，通过接收队列状态判断函数，确定接收循环缓冲队列是否为空；所述接收队列状态判断函数：；所述wptr为写指针；所述rdptr为读指针；进一步地，所述判断接收队列状态还包括：基于缓冲区基地址和当前读指针，通过读取地址计算函数，确定相应的内存地址并读取接收数据；所述读取地址计算函数：；所述为接收缓冲区基地址；所述为单位接收缓冲区长度；所述为预读取相应的内存地址。所述N2为接收循环缓冲队列长度；所述rdptr为读指针；所述更新接收队列状态还包括：基于当前读指针值，通过读指针更新函数，更新当前读指针；所述读指针更新函数：；基于当前读计数值，通过读计数更新函数，更新当前读计数；所述读计数更新函数：；所述rdcount为当前读计数；进一步地，所述中断发起处理前还包括判断缓冲区满；所述判断缓冲区满包括判断是否发起异常中断，若发起异常中断，则跳转到中断异常处理，在中断异常处理中，读取异常状态信息，判断接收循环缓冲队列是否已满，若队列已满，则标志和通知接收满异常，并通过初始化函数清空接收循环缓冲队列。所述初始化函数：；所述wptr为写指针；所述rdptr为读指针；所述rdcount为当前读计数。进一步地，所述更新接收队列状态后还包括判断中断丢失；所述判断中断丢失包括通过数据包缓存判定标准判断接收循环缓冲队列是否存在数据包缓存，若存在数据包缓存，则主动向接收数据线程释放信号量，并发起下一次发起出队操作。所述数据包缓存判定标准还包括：若且，则当前接收队列存在数据包缓存；所述wptr为写指针；所述rdptr为读指针；所述wcount为当前写计数；所述rdcount为当前读计数。第二方面，基于同一发明构思，本发明还提供一种CPU与FPGA间循环缓冲通信系统，包括：所述通信系统实现第一方面所述的循环缓冲通信方法，所述通信系统包括写入模块和读出模块；写入模块用于：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端；读出模块用于：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端。有益技术效果：本发明所述的一种CPU与FPGA间循环缓冲通信方法及系统，所述方法采用发送循环缓冲队列和接收循环缓冲队列，有效解决了CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差的问题，本方案采用发送和接收均采用循环队列，有效解决了数据同步和避免数据覆盖的问题，本方案采用将各队列控制参数与工作状态以寄存器的方式给出，并挂接在FPGA端接口总线之上，CPU与FPGA端都可进行实时读写访问，因此，高效进行收发队列的参数控制与状态获取；本方案接收中断事件触发数据接收线程，通过合理应用处理，减少了时间的浪费且提高了系统工作效率，综上所述，针对CPU与FPGA端各类总线地址访问的特点及DDR数据通信可能面临的问题，对DDR的读写访问进行抽象，设计循环队列结构并封装为设备，为软件访问提供一致的读写接口，同时留有调试与观测接口，用于观测接口收发状态，有效解决了直接DDR访问的数据同步、互斥及覆盖等问题，因此，本方案通过结构封装、统一接口、队列控制实现了数据封装和同步，有效避免了数据覆盖和互斥。附图说明图1是本发明循环缓冲通信方法的总流程图；图2是本发明循环缓冲通信方法的具体流程图；图3是本发明循环缓冲通信方法的发起入队操作流程图；图4是本发明循环缓冲通信方法的发起出队操作流程图；图5是本发明循环缓冲通信方法的打开设备操作流程图；图6是本发明循环缓冲通信方法的数据出队操作工作流程图；图7是本发明循环缓冲通信方法的数据入队操作工作流程图；图8是本发明循环缓冲通信系统的系统结构图；图9是本发明循环缓冲通信系统的系统模块图。具体实施方式以下结合附图对本发明做进一步描述：图中：S101-CPU端写入FPGA端；S102-CPU端读取FPGA端；S1001-基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端；S1002-基于接收循环缓冲队列，通过触发出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端；S201-判断发送队列状态；S202-更新发送队列状态；S203-写入发送完成状态；S301-中断触发处理；S302-判断接收队列状态；S303-更新接收队列状态；S304-读取接收完成状态。如图1、2所示，一种CPU与FPGA间循环缓冲通信方法，包括：CPU端写入FPGA端S101：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端S1001；CPU端读取FPGA端S102：基于接收循环缓冲队列，通过触发出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端S1002。本方案采用基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端和基于接收循环缓冲队列，通过触发出队操作，将接收数据从FPGA端读取CPU端；由于采用多缓冲存储区设计，即将CPU与FPGA间总线所映射的存储区进行二次划分，根据收发所需缓冲大小与数量划分两段连续存储空间用于收发数据缓存；在CPU基础存储区基础上二次划分，依据收发实际需求，采用多缓存设计，有效提高存储区利用率的同时避免了高速数据收发时的存储区覆盖问题；由于采用收发双队列结构设计，即将二次划分的收发数据存储区以循环队列方式进行管理，以出队与入队操作完成两段连续存储区的循环利用；数据收发采用双队列结构设计，将划分的存储区用队列进行管理，有效解决了收发双方的数据同步与访问互斥等问题；由于采用队列寄存器设计，便于队列参数与状态的管理，在FPGA端设计收发队列的控制与状态寄存器，同时将寄存器地址映射至CPU与FPGA间的总线之上，便于CPU端进行读写访问，同时，标准设备驱动封装，在基础的初始化、入队与出队操作基础上，将队列的参数与状态信息以寄存器的方式存储在FPGA端，并将地址映射至CPU与FPGA间总线之上，寄存器信息包含队列收发包计数、读写指针位置、中断使能与状态等，可供CPU与FPGA端实时访问，便于功能开发与维护；进一步设计封装为标准操作系统设备，对用户层提供标准IO访问接口，屏蔽底层实现细节；实时状态监测设计，设计单独的队列收发状态监测接口，对队列的参数与状态进行实时观测，如：出入队列包数统计、收发指针与中断状态等，从而方便通信故障定位；标准设备接口封装，屏蔽底层实现细节同时提供操作系统下标准设备IO访问能力，方便上层用户移植与使用；提供底层收发队列状态实时监测接口，可随时获取当前队列状态，方便用户使用时故障定位及数据统计。下面针对现有技术和本领域的技术难题进行如下说明：本方案采用发送循环缓冲队列和接收循环缓冲队列，根据实际应用场景下，CPU与FPGA间总线所访问存储空间情况，对存储区进行划分，按收发数据最大长度及缓冲数量需求，分别为收发划分两段连续存储空间，大小满足各自传输最大数据长度与缓冲数量的乘积，解决了CPU与FPGA间进行数据收发时采用DDR进行，由于驱动无统一的设备封装，软件访问直接面对DDR的地址，缺乏便捷性，有效解决了CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差的问题；本方案采用发送和接收均采用循环队列，为满足收发内存数据的同步、避免数据覆盖等问题，为收发方向各建立一个循环缓冲队列，缓冲区的大小与数量依据已划分的存储空间，CPU向FPGA端发送数据时，发起循环缓冲队列的入队操作，CPU读FPGA端接收数据时，发起循环缓冲队列的出队操作，有效解决了数据同步和避免数据覆盖的问题；本方案采用将各队列控制参数与工作状态以寄存器的方式给出，并挂接在FPGA端接口总线之上，CPU与FPGA端都可进行实时读写访问；其中，按收发队列与寄存器种类划分为CPU到FPGA端控制寄存器、CPU到FPGA端状态寄存器、FPGA到CPU端控制寄存器及FPGA到CPU端状态寄存器4种，因此，高效进行收发队列的参数控制与状态获取；本方案采用发起出队操作，由于本方案接收中断事件触发数据接收线程，常规的操作应当是一般不采用中断事件触发的方式，采用查询的方式比较简单实用，但需要浪费大量的查询时间，这样对程序运行中的效率大大降低了，但是中断本身也有问题，那就是当进入中断服务程序时，因为是线性的处理流程，这样就会导致如果在中断中用的时间太长，有可能会形成死机，造成程序运行的瘫痪，因此，本案采用一种折中的处理方法，即先采用中断的方式触发，然后在触发处理时不会浪费太长的时间，而是向接收数据线程释放信号量，通过信号量引发接收数据线程，通过接收数据线程处理相应的接收流程，因此，由于合理和减少了时间的浪费，从而提高了系统处理的工作效率；本方案针对CPU与FPGA端各类总线地址访问的特点及DDR数据通信可能面临的问题，对DDR的读写访问进行抽象，设计循环队列结构并封装为设备，为软件访问提供一致的读写接口，同时留有调试与观测接口，用于观测接口收发状态，有效解决了直接DDR访问的数据同步、互斥及覆盖等问题，同时项目采用C语言进行编码，可实现跨CPU快速移植，加快应用进程，综上所述，本方案通过结构封装、统一接口、队列控制实现了数据封装和同步，有效避免了数据覆盖和互斥。如图3、5、7所示，所述发起入队操作包括：判断发送队列状态S201：判断发送循环缓冲队列是否为满，若已满，则标志发送循环缓冲队列满后通知FPGA端，否则，将发送数据写入相应的发送缓冲地址；更新发送队列状态S202：更新写指针和写计数；写入发送完成状态S203：标志发送完成状态后通知FPGA端。本方案采用判断发送队列状态、更新发送队列状态、写入发送完成状态，其控制流程如下：首先，分别读取CPU向FPGA端写入控制寄存器中的写指针与读指针寄存器，获取当前写指针与读指针的值，进而判定当前队列状态是否为满，即是否满足，其中wptr为写指针，rdptr为读指针，N为循环缓冲区总个数；若队列状态为满，则置位缓冲区满标识，返回给用户，否则，计算当前写入缓冲区内存地址，而将用户数据写入计算得出的内存地址中；其次，更新队列状态，对写指针与写计数寄存器的值进行更新；最后，向CPU到FPGA端控制寄存器类的写入完成标识寄存器中写入0xAAAAAAAA告知FPGA端，当前数据包写入完成；上述流程实现了CPU向FPGA端发送数据时，发起循环缓冲队列的入队操作。所述判断发送队列状态S201还包括：基于写指针和读指针，通过发送队列状态判断函数，确定发送循环缓冲队列是否为满；所述队列状态判断函数：；所述为写指针；所述为读指针；所述N1为循环缓冲队列长度。本方案采用队列状态判断函数，即是否满足，其中wptr为写指针，rdptr为读指针，N为循环缓冲区总个数，若队列状态为满，则置位缓冲区满标识，返回给用户，否则，计算当前写入缓冲区内存地址，通过该函数明确了队列状态已满。所述判断发送队列状态S201还包括：基于缓冲区基地址和当前写指针，通过写入地址计算函数，确定相应的内存地址并写入发送数据；所述写入地址计算函数：；所述为发送缓冲区基地址；所述为单位发送缓冲区长度；所述为预写入相应的内存地址；所述wptr为写指针；所述N1为循环缓冲队列长度；所述更新发送队列状态S202还包括：基于当前写指针值，通过写指针更新函数，更新当前写指针；所述写指针更新函数：；基于当前写计数值，通过写计数更新函数，更新当前写计数；所述写计数更新函数：；所述为当前写计数。本方案采用写入地址计算函数和写指针更新函数以及写计数更新函数，由于当前写入缓冲区内存地址的计算公式为：；对写指针与写计数寄存器的值进行更新，更新规则为：；；上述公式的应用，有效更新队列状态，便于判断发送队列状态和更新发送队列状态。如图4、6所示，所述触发出队操作包括：中断触发处理S301：若FPGA端写入完成的中断事件触发，则清除中断标志，并向接收数据线程释放信号量，并结束中断服务；判断接收队列状态S302：若获取到接收数据线程释放信号量，则读取读指针和读计数，判断接收循环缓冲队列是否为空，若为空，则标志接收循环缓冲队列空后通知FPGA端，否则，从相应的接收缓冲地址读取接收数据；更新接收队列状态S303：更新读指针和读计数；读取接收完成状态S304：标志接收完成状态后通知FPGA端。本方案采用中断触发处理、判断接收队列状态、更新接收队列状态、读取接收完成状态，由于CPU接收FPGA端数据时，采用中断方式，其工作流程包括：首先，等待FPGA端写入完成的中断事件，一旦CPU端接收到FPGA发起的中断，即可执行事先初始化所注册的中断服务程序，在中断服务程序中，CPU操作FPGA到CPU控制寄存器中的中断清除寄存器，清除FPGA侧的中断状态标识，进而向接收数据的线程释放信号量，退出中断服务；其次，阻塞接收FPGA数据的线程在获取到中断所释放的信号量后，发起循环缓冲队列读取操作，读取FPGA到CPU端控制寄存器中的读指针与写指针寄存器，得到当前队列读写指针的值，判定队列是否为空，判定标准为：，若满足，则置位队列为空标识，并返回给用户；将此地址数据写入用户数据缓冲区；然后，更新队列状态信息，对读指针与读计数值进行更新；上述流程实现了CPU取FPGA端接收数据时，发起循环缓冲队列的出队操作。所述判断接收队列状态S302还包括：基于写指针和读指针，通过接收队列状态判断函数，确定接收循环缓冲队列是否为空；所述接收队列状态判断函数：；所述wptr为写指针；所述rdptr为读指针；本方案采用接收队列状态判断函数，由于判定队列是否为空，判定标准为：，若满足，则置位队列为空标识，并返回给用户，该函数实现了判断接收队列状态的功能。所述判断接收队列状态S302还包括：基于缓冲区基地址和当前读指针，通过读取地址计算函数，确定相应的内存地址并读取接收数据；所述读取地址计算函数：；所述为接收缓冲区基地址；所述为单位接收缓冲区长度；所述为预读取相应的内存地址。所述N2为接收循环缓冲队列长度；所述rdptr为读指针；所述更新接收队列状态S303还包括：基于当前读指针值，通过读指针更新函数，更新当前读指针；所述读指针更新函数：；基于当前读计数值，通过读计数更新函数，更新当前读计数；所述读计数更新函数：；所述rdcount为当前读计数；本方案采用读取地址计算函数、读指针更新函数、读计数更新函数，由于计算当前读取数据的内存地址，计算公式为：；将上述地址数据写入用户数据缓冲区；然后，更新队列状态信息，对读指针与读计数值进行更新，更新规则为：；；上述公式的应用，有效更新队列状态，便于判断接收队列状态和更新接收队列状态。所述中断触发处理S301前还包括判断缓冲区满；所述判断缓冲区满包括判断是否触发异常中断，若触发异常中断，则跳转到中断异常处理，在中断异常处理中，读取异常状态信息，判断接收循环缓冲队列是否已满，若队列已满，则标志和通知接收满异常，并通过初始化函数清空接收循环缓冲队列。所述初始化函数：；所述wptr为写指针；所述rdptr为读指针；所述rdcount为当前读计数。本方案采用判断缓冲区满和初始化函数的处理，由于CPU端接收FPGA发送数据导致缓冲区满处理逻辑：在循环缓冲通道初始化阶段，CPU端专门提供一个中断，作为此通道异常处理所用，初始化时注册异常中断服务处理程序，FPGA到CPU端状态寄存器类型中存在异常状态寄存器，异常状态寄存器定义表如表一所示，当FPGA端向CPU端发送数据，发现CPU端缓冲区满时，向CPU发起事先约定的异常中断信号，CPU接收到此中断信号后，即跳转到初始化所注册的中断服务程序中，在中断服务函数内，CPU首先读取FPGA端异常状态信息，判定是否存在Write Buffer异常，若存在，则清空缓冲区，即使收发指针相等rdptr = wptr收发计数相等，同时抛出接收满异常打印信息。表1：异常状态寄存器定义表所述更新接收队列状态S303后还包括判断中断丢失；所述判断中断丢失包括通过数据包缓存判定标准判断接收循环缓冲队列是否存在数据包缓存，若存在数据包缓存，则主动向接收数据线程释放信号量，并触发下一次触发出队操作。所述数据包缓存判定标准还包括：若且，则当前接收队列存在数据包缓存；所述wptr为写指针；所述rdptr为读指针；所述wcount为当前写计数；所述rdcount为当前读计数。本方案采用判断中断丢失和数据包缓存判定标准的处理，由于为解决中断事件丢失问题，完成队列状态更新后，继续判定当前队列内是否仍有数据包缓存，判定规则为：同时，若二者同时满足，则主动释放信号量，触发下一次读取操作。如图8、9所示，同时，本发明还提供一种CPU与FPGA间循环缓冲通信系统，包括：所述通信系统实现上述循环缓冲通信方法，所述通信系统包括写入模块和读出模块；写入模块用于：基于发送循环缓冲队列，通过发起入队操作，将发送数据从CPU端写入FPGA端S1001；读出模块用于：基于接收循环缓冲队列，通过发起出队操作，并由接收中断事件触发数据接收线程，将接收数据从FPGA端读取CPU端。本方案同时提供一种CPU与FPGA间循环缓冲通信系统，包括：所述通信系统实现上述所述循环缓冲通信方法，所述通信系统包括写入模块和读出模块，本方案首先实现了CPU与FPGA间的数据通信，为实现循环缓冲通信方法提供了物理实现的可能性，同时，本方案的具体特点如下：为方便用户使用与移植，对收发双向循环缓冲队列的初始化、出入队操作、状态监测及异常处理等进行封装，作为底层驱动接口；同时，为方便操作系统用户，在基础驱动之上，进一步封装为标准设备访问接口，提供设备输入输出访问能力；本设计共包含4个模块，分别为循环缓冲队列控制、队列寄存器、系统设备接口及通信状态监测模块，下面分别介绍各模块功能及逻辑关系：2.1循环缓冲队列控制循环缓冲队列控制模块为整个CPU与FPGA间通信机制的核心模块，该模块首先完成收发存储空间的划分，确定收发缓冲区的大小及数量，其次，完成缓冲队列的初始化，完成参数配置，最后，完成收发循环队列的操作，如：入队操作、出队操作及异常处理等。2.2队列寄存器队列寄存器模块主要完成队列控制参数及状态信息的记录功能，存储在FPGA端，CPU端可通过总线访问，该模块为循环缓冲队列控制模块提供参数与状态，辅助完成队列的各项操作。2.3系统设备接口系统设备接口模块主要为用户提供标准系统设备访问接口，将循环缓冲队列控制模块的各项功能，如初始化、数据入队与数据出队等进一步封装为操作系统标准设备，为上层用户提供标准IO设备访问能力，屏蔽底层实现细节。2.4通信状态监测通信状态监测模块为整个设计的辅助模块，该模块能够完成收发队列状态的监测，为上层用户提供总线接口状态观测能力，能够将队列寄存器模块关键信息输出，如：收发包数统计、读写指针状态、中断使能与异常等。同时，本系统已在5126、5152等项目接口板、信道控制等板卡，及5158、5162及CSXT-L10等综合数据处理板上应用。实施例一：本方案还包括存储空间划分，存储空间划分包括如下：存储空间划分规则：若CPU侧总存储区大小为S，划分为CPU到FPGA、FPGA到CPU两部分连续存储区S1、S2；若划分存储区满足，则对CPU到FPGA、FPGA到CPU两个循环缓冲区进行内存规划；内存规划的方法：根据使用需求均匀划分为i个大小sizei与j个sizej的缓冲区，则总存储区需满足：i×sizei ≤ S1，j×sizej ≤ S2。实施例二：首先，分别读取CPU向FPGA端写入控制寄存器中的写指针与读指针寄存器，获取当前写指针与读指针的值，进而判定当前队列状态是否为满，即是否满足，其中wptr为写指针，rdptr为读指针，N为循环缓冲区总个数。若队列状态为满，则置位缓冲区满标识，返回给用户，否则，计算当前写入缓冲区内存地址，计算公式为：；而将用户数据写入计算得出的内存地址中；其次，更新队列状态，对写指针与写计数寄存器的值进行更新，更新规则为：；；最后，向CPU到FPGA端控制寄存器类的写入完成标识寄存器中写入0xAAAAAAAA告知FPGA端，当前数据包写入完成。CPU接收FPGA端数据时，采用中断方式，首先，等待FPGA端写入完成的中断事件，一旦CPU端接收到FPGA发起的中断，即可执行事先初始化所注册的中断服务程序，在中断服务程序中，CPU操作FPGA到CPU控制寄存器中的中断清除寄存器，清除FPGA侧的中断状态标识，进而向接收数据的线程释放信号量，退出中断服务；其次，阻塞接收FPGA数据的线程在获取到中断所释放的信号量后，发起循环缓冲队列读取操作，读取FPGA到CPU端控制寄存器中的读指针与写指针寄存器，得到当前队列读写指针的值，判定队列是否为空，判定标准为：，若满足，则置位队列为空标识，并返回给用户；否则，计算当前读取数据的内存地址，计算公式为：；将此地址数据写入用户数据缓冲区；然后，更新队列状态信息，对读指针与读计数值进行更新，更新规则为：；。实施例三：本方案在发起入队操作和触发出队操作中，运用了队列寄存器，该队列寄存器的相关设置如下：一、关于发送循环缓冲队列的控制寄存器：按收发队列与寄存器种类划分为CPU到FPGA端控制寄存器、CPU到FPGA端状态寄存器、约定寄存器位宽为32bit。表2：CPU到FPGA端寄存器列表1、CPU到FPGA端控制寄存器包含：复位控制、缓冲区基地址、缓冲区大小、缓冲深度、写指针、读指针及写完成标识7个，具体功能描述如下：复位控制寄存器该寄存器实现FPGA端接口逻辑复位控制，由CPU端进行写入，FPGA端读出，默认值为0，当需要对FPGA侧进行端口功能复位时置1。FPGA侧监测Reset寄存器值的变化，当Reset寄存器的值为1时，复位相应通信端口逻辑；缓冲区基地址寄存器该寄存器指示CPU端写入，FPGA读取数据循环缓冲域的基地址，由CPU端初始化时写入；缓冲区大小寄存器该寄存器定义CPU到FPGA方向单个循环缓冲区的大小，CPU端初始化时根据实际使用需求设置；缓冲区深度寄存器该寄存器定义CPU到FPGA方向循环缓冲区的个数，CPU端初始化时根据实际使用需求设置；写指针寄存器该寄存器定义CPU到FPGA方向当前队列写指针的值，该寄存器由CPU端写入，FPGA读取，CPU向FPGA端每写入1包数据，写指针+1，默认为0，最大为N-1，当增加到N-1时，下一包写入后，该寄存器值更新为0；读指针寄存器该寄存器定义CPU到FPGA方向当前队列读指针的值，该寄存器由FPGA端写入，CPU端读取，FPGA每从队列中读取1包数据，此寄存器值+1，最大不超过N-1，当增加到N-1时，下一包读取后，该寄存器值更新为0；写完成标识寄存器该寄存器用于同步CPU端向FPGA端写数据操作，CPU每完成一次成功的写操作时，通过写入固定值0xAAAAAAAA通知FPGA端写动作完成，FPGA端监测该寄存器的写入操作，当写入寄存器值为0xAAAAAAAA时，表示CPU端完成该次数据写入操作，FPGA端检测到该寄存器为0xAAAAAAAA后进行清0操作。2、CPU到FPGA端状态寄存器包含：端口Ready、写计数、读计数及异常状态4个，具体功能描述如下：端口Ready寄存器该寄存器指示FPGA端接口逻辑初始化完成状态，当CPU端查询到FPGA侧PortReady后才可以发起读写操作，否则进行等待或Reset复位，该寄存器由FPGA侧进行写入，CPU侧读出，默认值为0，FPGA侧初始化完成后置1；写计数寄存器该寄存器用于统计CPU向FPGA端写入数据包数量，在CPU每次完成一次写操作时，由CPU端对该寄存器的值进行+1写入，递增到最大值0xFFFFFFFF时归零重新开始计数；读计数寄存器该寄存器用于统计FPGA端读取CPU写入数据包数量，在FPGA端每次完成一次读操作时，由FPGA端对该寄存器的值进行+1写入，递增到最大值0xFFFFFFFF时归零重新开始计数；异常状态寄存器该寄存器指示FPGA端接口异常时的状态信息，如FPGA侧FIFO传输异常，循环buffer无法正常读写等。表3：CPU到FPGA端状态寄存器对应状态表二、关于接收循环缓冲队列的控制寄存器：按收发队列与寄存器种类划分为FPGA到CPU端控制寄存器及FPGA到CPU端状态寄存器4种；约定寄存器位宽为32bit。表4：FPGA到CPU端寄存器列表3、FPGA到CPU端控制寄存器包含：复位控制、缓冲区基地址、缓冲区大小、缓冲深度、写指针、读指针、中断使能、中断状态及异常状态清除9个，具体功能描述如下：复位控制寄存器该寄存器实现FPGA端接口逻辑复位控制，由CPU端进行写入，FPGA端读出，默认值为0，当需要对FPGA侧进行端口功能复位时置1。FPGA侧监测Reset寄存器值的变化，当Reset寄存器的值为1时，复位相应通信端口逻辑；缓冲区基地址寄存器该寄存器指示FPGA端写入，CPU读取数据循环缓冲域的基地址，由CPU端初始化时写入；缓冲区大小寄存器该寄存器定义FPGA到CPU方向单个循环缓冲区的大小，CPU端初始化时根据实际使用需求设置；缓冲区深度寄存器该寄存器定义FPGA到CPU方向循环缓冲区的个数，CPU端初始化时根据实际使用需求设置；写指针寄存器该寄存器用于统计FPGA向CPU端写入数据包数量，在FPGA每次完成一次写操作时，由FPGA端对该寄存器的值进行+1写入，递增到最大值0xFFFFFFFF时归零重新开始计数；读指针寄存器该寄存器定义FPGA到CPU方向当前队列读指针的值，该寄存器由CPU端写入，FPGA端读取，CPU每从队列中读取1包数据，此寄存器值+1，最大不超过N-1，当增加到N-1时，下一包读取后，该寄存器值更新为0；中断使能寄存器该寄存器用于使能FPGA向CPU端发起的写完成中断，由CPU端写入，默认值为0，写入0x55555555使能FPGA端中断功能，写入其它值无效；中断状态清除寄存器该寄存器作用为清除Interrupt Status寄存器中当前值，使其恢复默认状态值0。CPU端负责写入，FPGA侧负责读出，写入1有效，其余值无效。当FPGA侧监测到该寄存器被CPU写入1后，将Interrupt Status寄存器清除，恢复默认值；异常状态清除寄存器该寄存器用于清除FPGA端异常状态寄存器所指示的异常信息，对应bit写入1清除，0无效。4、FPGA到CPU端状态寄存器包含：端口Ready、写计数、读计数、中断状态及异常状态5个，具体功能描述如下：端口Ready寄存器该寄存器指示FPGA端接口逻辑初始化完成状态，由FPGA侧进行写入，CPU侧读出，默认值为0，FPGA侧初始化完成后置1；写计数寄存器该寄存器用于统计FPGA向CPU端写入数据包数量，在FPGA每次完成一次写操作时，由FPGA端对该寄存器的值进行+1写入，递增到最大值0xFFFFFFFF时归零重新开始计数；读计数寄存器该寄存器用于统计CPU端读取FPGA写入数据包数量，在CPU端每次完成一次读操作时，由CPU端对该寄存器的值进行+1写入，递增到最大值0xFFFFFFFF时归零重新开始计数；中断状态寄存器该寄存器用于记录FPGA端写入完成状态，每当FPGA侧成功写入1包数据后，对该寄存器写入0xAAAAAAAA标识当前数据写入完成，如果当前中断使能，则向CPU端发起中断；异常状态寄存器该寄存器指示FPGA端接口异常时的状态信息，如FPGA侧FIFO传输异常，循环buffer无法正常读写等。表5：FPGA到CPU端状态寄存器对应状态表工作原理：本方案的工作流程共包括两个主要流程，第一个流程是CPU端写入FPGA端，第二个流程是CPU端读取FPGA端；在第一个流程中，CPU向FPGA端写入控制寄存器中的写指针与读指针寄存器，获取当前写指针与读指针的值，进而判定当前队列状态是否为满，即是否满足，若队列状态为满，则置位缓冲区满标识，返回给用户，否则，计算当前写入缓冲区内存地址；将用户数据写入计算得出的内存地址中；其次，更新队列状态，根据更新规则，对写指针与写计数寄存器的值进行更新，最后，向CPU到FPGA端控制寄存器类的写入完成标识寄存器中写入0xAAAAAAAA告知FPGA端，当前数据包写入完成；在第二个流程中，CPU端读取FPGA端CPU接收FPGA端数据时，采用中断方式，首先，等待FPGA端写入完成的中断事件，一旦CPU端接收到FPGA发起的中断，即可执行事先初始化所注册的中断服务程序，在中断服务程序中，CPU操作FPGA到CPU控制寄存器中的中断清除寄存器，清除FPGA侧的中断状态标识，进而向接收数据的线程释放信号量，退出中断服务；其次，阻塞接收FPGA数据的线程在获取到中断所释放的信号量后，发起循环缓冲队列读取操作，读取FPGA到CPU端控制寄存器中的读指针与写指针寄存器，得到当前队列读写指针的值，判定队列是否为空，判定标准为：，若满足，则置位队列为空标识，并返回给用户；否则，根据计算公式计算当前读取数据的内存地址，将此地址数据写入用户数据缓冲区；然后，更新队列状态信息，根据更新规则对读指针与读计数值进行更新，针对CPU与FPGA端各类总线地址访问的特点及DDR数据通信可能面临的问题，对DDR的读写访问进行抽象，设计循环队列结构并封装为设备，为软件访问提供一致的读写接口，同时留有调试与观测接口，用于观测接口收发状态，有效解决了直接DDR访问的数据同步、互斥及覆盖等问题，本发明解决了现有技术存在CPU与FPGA间直接DDR访问中存在直接访问风险大且直观性差、数据同步性较差、数据互斥及数据覆盖的问题，具有结构封装、统一接口、队列控制实现了数据封装和同步，有效避免了数据覆盖和互斥的有益技术效果。利用本发明的技术方案，或本领域的技术人员在本发明技术方案的启发下，设计出类似的技术方案，而达到上述技术效果的，均视为落入本发明的保护范围。

标题title
一种同态加密计算方法及系统
摘要abst
本发明公开了一种同态加密计算方法及系统，包括有：步骤S1，将多项式f和需要加密的参数进行封装后，传入至预设的分析计算引擎；步骤S2，所述分析计算引擎接收到多项式f后，利用六角深度剖析算法进行拆解和分析，根据分析结果判断：若采用半同态加密计算方案，则执行步骤SA1，若采用全同态加密计算方案，则执行步骤SB1；步骤SA，执行半同态加密计算流程；步骤SB，执行全同态加密计算流程。本发明通过分析多项式和明文数据自动选择半同态或全同态进行求解，无需人为参与，从而降低人员、运维成本，同时能使运算所需的时间和资源接近最优化。
权利要求书clms
1.一种同态加密计算方法，其特征在于，包括有：步骤S1，将多项式f和需要加密的参数进行封装后，传入至预设的分析计算引擎；步骤S2，所述分析计算引擎接收到多项式f后，利用六角深度剖析算法进行拆解和分析，根据分析结果判断：若采用半同态加密计算方案，则执行步骤SA1，若采用全同态加密计算方案，则执行步骤SB1；步骤SA，执行半同态加密计算流程；步骤SB，执行全同态加密计算流程。2.如权利要求1所述的同态加密计算方法，其特征在于，所述步骤SA1中，利用多项式f对数据提供方提供的数据x进行Paillier公钥加密并得到密文对象x_encrypt，对x_encrypt进行序列化，得到x_encrypt_serial，将x_encrypt_serial和f传输至计算方，计算方得到x_encrypt_serial和f,首先对x_encrypt_serial进行反序列化得到x_encrypt，将x_encrypt代入至f中求解得到f密态下的结果f_encrypt，随后计算方将f_encrypt返回至数据提供方，数据提供方接收到f_encrypt，将其进行私钥解密得到明文计算结果f_decrypt。3.如权利要求2所述的同态加密计算方法，其特征在于，所述步骤S2中，六角深度剖析算法包括如下过程：步骤B001：确定单项式数量；对f进行分析拆解成n个单项式，得到f:经分析拆解，得到四个单项式组合monomials，进而得到f为四个单项式数量monomials_count；步骤B002:乘法深度；对f的乘法进行剖析得到乘法深度，对步骤B001得到的monomials进行逐一剖析，根据每个单项式的乘法次数，得到该单项式的乘法深度，结合整个monomials的所有乘法深度集合得到最终的总乘法深度multipe_deepth；步骤B003:函数转换，得到f:步骤B004:浮点数精度，得到f:该f存在大量的浮点数，需要对f的所有的系数w和未知数x进行scale，scale数值的决定因素包括：在对浮点数的同态计算中，scale是不断同态计算迭代调参后得到的最优值；首先要得到f的初始scale，对该f按照步骤B001处理得到monomials，然后分析每一项的系数，得到系数集合ws，同时还得到x的小数点位数X_I，选取ws小数点后面位数最大的一个系数为：0.56458995，获取小数位数P_I为8位，此时对P_I和X_I进行逻辑比较，假设得到是P_I较大，则直接使用P_I进行求的初始scale，对小数位数取log取整再与10相乘，即：scale_i＝int*10；将P_I为8代入得到scale_i＝30，在阈值范围内，则使用该scale值作为初始scale。步骤B005:数据维度；该步骤只关心x的数据形态，f其他系数已是常数，最终同态计算只需将x进行代入，关于x的数据形态划分了以下两种种等级：A级：针对是简单的数据维度如单个数字、一维数组、多行一列的二维数组；B级：多行多列的多维数组和矩阵；步骤B006:复杂程度；将对t_monomials进行分析加法和乘法的次数、total_multipe_deepth、步骤B005得到的数据维度dimension、步骤B001的monomials_count进行深度整合，并利用机器学习算法得出对半同态和全同态加密计算方案的选择；所述步骤B006中，利用大批量经过半同态计算得出的测试数据，根据不同的P_I、total_multipe_deepth、dimension、monomials_count、结果准确率组成特征列和结果列，制作成一份数据集，利用机器学习线性回归算法进行模型训练，得到模型:y＝w1P_I+w2total_multipe_deepth+w3dimension+w4monomials_count+b；其中，y为结果准确率，w1、w2、w3、w4是每个特征列的权重，b是偏置项，训练模型得出这些权重和偏置项，依据此模型，将需要进行同态计算的f经过步骤B004得出当前P_I，记为P_I_C，根据步骤B002得到的当前乘法总深度，记为total_multipe_deepth_c，根据步骤B005得到当前数据维度，记为dimension_c，根据步骤B001得到当前单项式数量，记为monomials_count_c；随后将P_I_C、total_multipe_deepth_c、dimension_c、monomials_count_c代入上述模型中求得结果准确率y，根据上述统计理论准确率分析，如果y在80％-90％之间，则推荐使用半同态加密计算方案，反之则推荐使用全同态加密计算方案，或者根据该y值在准确率之间对f的复杂程度系数complex_level划分判定。4.如权利要求3所述的同态加密计算方法，其特征在于，所述步骤SB包括如下过程：步骤SB1，通过六角深度剖析算法分析得到的六项结果全部传入至全同态加密算法；步骤SB2，根据步骤SB1得出的各单项式分析判断是否包含有浮点数，若不包含浮点数，则执行步骤SBB，若包含浮点数，则执行步骤SBC；步骤SBB，执行BFV方案：对加密整数进行模运算；步骤SBC，执行CKKS方案：对加密的实数或复数进行运算；所述步骤SBB包括如下过程：步骤SBB1，执行BFV方案之前，先前设置加密参数:多项式模数、密文系数模和明文模数；步骤SBBC2，根据六角深度剖析算法分析结果中的复杂程度、单项式数量和乘法深度进一步分析得到多项式模数；步骤SBB3，由多项式模数决定密文系数模；步骤SBB4，根据所述密文系数模、复杂程度、乘法深度分析得出明文模；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBB6，使用编码器对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；步骤SBB7，对各单项式中的常量进行抽取，再用编码器分别进行编码；步骤SBBC8至步骤SBBC11，对所有单项式进行求解；步骤SBB12，对所有单项式进行单项式间运算；步骤SBB13，得到最终的密文结果，记录最终密文大小和最终噪声预算；步骤SBB14，利用解密器、解码器、数据维度对密文结果进行解密输出；步骤SBB15，将计算结果与纯明文计算结果进行比较，若有较大误差，则调整计算参数后重新执行计算，直到误差达到预设的较小范围；所述步骤SBBC2包括:针对BFV和CKKS方案进行多项式模数pmd设置，要求多项式模数pmd是2的正幂，多项式模数pmd包括但不限于1024、2048、4096、8192、16384和32768，利用以下数学公式得到该pmd值：pmd＝2)；其中，int表示取整，0.2、0.3、0.5表示权重值；所述步骤SBB3包括:对BFV进行密文系数模cmd设置，新加密密文的noise_budget由加密参数决定，同态运算以由加密参数决定的速率消耗noise_budget，在同态加法中，cmd的总比特长度的上限由pmd确定：其中，round为四舍五入再经过取整，得到最终的整数位cmd值；所述步骤SBB4包括:对BFV进行明文模数plmd设置，plmd决定明文数据类型的大小和乘法中噪声预算的消耗，新加密密文的noise_budget：在同态乘法的noise_budget消耗为：noise_budget_consume＝log2+w；其中，w为不固定值。5.如权利要求4所述的同态加密计算方法，其特征在于，所述步骤SBBC8至步骤SBBC11包括如下过程：步骤SBBC8，获取加密参数得到的密文初始噪声预算和初始密文大小并进行记录；步骤SBBC9，对单项式组进行遍历同态计算；步骤SBBC10，若单项式中没有其他函数，则直接进行同态计算，否则按照上述步骤中得到的函数转换进行单项式代入；步骤SBBC11，进行单项式求解后，若是乘法求解，则对其进行噪声预算和密文大小记录，然后对其重线性化后，记录噪声预算和密文大小。6.如权利要求5所述的同态加密计算方法，其特征在于，所述步骤SBB6中，使用编码器对需要加密的参数进行编码后得到x_encode，利用加密器、数据维度进行公钥加密过程中，若数据维度是单个数字，则直接加密该数字并生成密文x_encrypted；若数据维度是数组或者矩阵形式，则先将x_encode转换成向量表形式x_vectors，然后再利用加密器加密该x_vectors，得到最终的密文x_encrypted。7.如权利要求6所述的同态加密计算方法，其特征在于，所述步骤SBB14中，进行解密输出过程中，若数据维度是单个数字，则直接解密成单数字明文结果result_plain；若数据维度是数组或者矩阵形式，则解密成向量表形式result_vectors。8.如权利要求7所述的同态加密计算方法，其特征在于，所述步骤SBC包括如下过程：步骤SBC1，执行CKKS方案之前，先设置三种加密参数:多项式模数、密文系数模集合和缩放率；步骤SBBC2，对复杂程度、单项式数量、乘法深度进行分析得到多项式模数；步骤SBC3，对乘法深度、浮点数精度进行分析得到密文系数模集合和缩放率；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBC6，使用编码器和缩放率对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；步骤SBC7，抽取各单项式中的常量，利用编码器和缩放率分别进行编码；步骤SBBC8，获取加密参数得到的密文初始噪声预算和初始密文大小并进行记录；步骤SBBC9，对单项式组进行遍历同态计算；步骤SBBC10，若单项式中没有其他函数，则直接进行同态计算，否则按照上述步骤中得到的函数转换进行单项式代入；步骤SBBC11，进行单项式求解后，若是乘法求解，则对其进行噪声预算和密文大小记录，然后对其重线性化后，记录噪声预算和密文大小；步骤SBC12，记录乘法后的密文scale，利用密文系数模组移除一位，对密文重缩放，此后再记录一次密文scale；步骤SBC13，当重缩放后的密文与其他值等级不一时，将重缩放后的密文与该其他值进行模等级交换，以保持等级一致；步骤SBC14，进行加法时，若各自值的scale不一致，则统一scale，用上述步骤中的缩放率设置scale，之后进行加法求解；步骤SBC15，对所有单项式和单项式间运算求解得到最终的密文结果；所述步骤SBC3包括:密文系数模数组cmds和缩放率scale设置，作为模数切换，该步骤要对cmds进行设置，cmds是一个数组的形式，每一次乘法后的模数切换，将移除cmds最后一个数进行rescale，加入当前密文的scale为s，cmds最后一个数为p，在经过乘法之后，s则变成s2，对密文移除cmds的p进行rescale后得到其scale则为：s2/p，如果cmds中所有的p都接近s，则rescale后的s2/p再次接近s，达到稳定scale扩展，cmds的设置方案为：结合步骤B002，使用数字60作为cmds的第一位和最后一位元素，中间的数量为total_multipe_deepth位，利用B004计算的scale记为init_scale作为中间数字，即最终的cmds为：；在设置完cmds后，随后需要设置缩放率时，直接使用init_scale。9.如权利要求8所述的同态加密计算方法，其特征在于，所述步骤SBC还包括：步骤SBC16，根据最终的密文结果记录最终密文大小和最终噪声预算；步骤SBC17，将密文结果利用解密器、解码器、数据维度进行解密输出；步骤SBC18，将计算结果与纯明文计算结果进行比较，若误差超过预设误差值，则调整计算参数后重新执行计算，直到误差到预设的较小范围。10.一种同态加密计算系统，其特征在于，用于执行权利要求1-9任一项所述的同态加密计算方法。
说明书desc
技术领域本发明涉及加密计算方法，尤其涉及一种同态加密计算方法及用于实现该方法的系统。背景技术目前，用途比较广泛而且相对权威的同态加密算法包含：半同态加密算法Paillier和全同态加密算法Microsoft SEAL。其中：Paillier算法是1999年提出的一种基于合数剩余类问题的公钥加密算法，也是目前最为常用且最具实用性的加法同态加密算法，已在众多具有同态加密需求的应用场景中实现了落地应用，同时也是ISO同态加密国际标准中唯一指定的加法同态加密算法。此外，由于支持加法同态，所以Paillier算法还可支持数乘同态，即支持密文与明文相乘。Microsoft SEAL是一个同态加密库，允许对加密的整数或实数执行加法和乘法。提供了两种不同的同态加密方案，它们具有非常不同的属性。BFV方案允许对加密整数执行模运算。CKKS方案允许对加密的实数或复数进行加法和乘法运算，但只能得到近似的结果。在诸如总结加密实数、评估加密数据的机器学习模型或计算加密位置的距离等应用中，ckks将是目前为止的最佳选择。对于需要精确值的应用，BFV方案是唯一的选择。然而，目前的实现方案基本都是利用已有的同态加密算法进行人为的运算多项式求解，通过人为选择半同态或全同态加密技术如上面提到的Paillier、Microsoft SEAL，人为调整参数进行数据多项式的同态计算。由此导致现有技术存在如下缺陷：Paillier半同态加密算法、Microsoft SEAL全同态加密算法，提供基于密文上的基础运算，但需求的复杂性、数据高精度计算、多项式复杂度等都会影响到最终的运行耗能和成本，而目需要依赖人为不断的去拆解、剖析和调优，这个过程有很大的时间成本，每次的调优并不精准会导致运行时耗能严重，运算后的结果失真严重。发明内容本发明要解决的技术问题在于，针对现有技术的不足，提供一种通过分析多项式和明文数据自动选择半同态或全同态进行求解，无需人为参与，从而降低人员、运维成本，同时能使运算所需的时间和资源接近最优化的同态加密计算方法及系统。为解决上述技术问题，本发明采用如下技术方案。一种同态加密计算方法，其特征在于，包括有：步骤S1，将多项式f和需要加密的参数进行封装后，传入至预设的分析计算引擎；步骤S2，所述分析计算引擎接收到多项式f后，利用六角深度剖析算法进行拆解和分析，根据分析结果判断：若采用半同态加密计算方案，则执行步骤SA1，若采用全同态加密计算方案，则执行步骤SB1；步骤SA，执行半同态加密计算流程；步骤SB，执行全同态加密计算流程。优选地，所述步骤SA1中，利用多项式f对数据提供方提供的数据x进行Paillier公钥加密并得到密文对象x_encrypt，对x_encrypt进行序列化，得到x_encrypt_serial，将x_encrypt_serial和f传输至计算方，计算方得到x_encrypt_serial和f,首先对x_encrypt_serial进行反序列化得到x_encrypt，将x_encrypt代入至f中求解得到f密态下的结果f_encrypt，随后计算方将f_encrypt返回至数据提供方，数据提供方接收到f_encrypt，将其进行私钥解密得到明文计算结果f_decrypt。优选地，所述步骤S2中，六角深度剖析算法包括如下过程：步骤B001：确定单项式数量；对f进行分析拆解成n个单项式，得到f:经分析拆解，得到四个单项式组合monomials，进而得到f为四个单项式数量monomials_count；步骤B002:乘法深度；对f的乘法进行剖析得到乘法深度，对步骤B001得到的monomials进行逐一剖析，根据每个单项式的乘法次数，得到该单项式的乘法深度，结合整个monomials的所有乘法深度集合得到最终的总乘法深度multipe_deepth；步骤B003:函数转换，得到f:步骤B004:浮点数精度，得到f:该f存在大量的浮点数，需要对f的所有的系数w和未知数x进行scale，scale数值的决定因素包括：在对浮点数的同态计算中，scale是不断同态计算迭代调参后得到的最优值；首先要得到f的初始scale，对该f按照步骤B001处理得到monomials，然后分析每一项的系数，得到系数集合ws，同时还得到x的小数点位数X_I，选取ws小数点后面位数最大的一个系数为：0.56458995，获取小数位数P_I为8位，此时对P_I和X_I进行逻辑比较，假设得到是P_I较大，则直接使用P_I进行求的初始scale，对小数位数取log取整再与10相乘，即：scale_i＝int*10；将P_I为8代入得到scale_i＝30，在阈值范围内，则使用该scale值作为初始scale。步骤B005:数据维度；该步骤只关心x的数据形态，f其他系数已是常数，最终同态计算只需将x进行代入，关于x的数据形态划分了以下两种种等级：A级：针对是简单的数据维度如单个数字、一维数组、多行一列的二维数组；B级：多行多列的多维数组和矩阵；步骤B006:复杂程度；将对t_monomials进行分析加法和乘法的次数、total_multipe_deepth、步骤B005得到的数据维度dimension、步骤B001的monomials_count进行深度整合，并利用机器学习算法得出对半同态和全同态加密计算方案的选择；所述步骤B006中，利用大批量经过半同态计算得出的测试数据，根据不同的P_I、total_multipe_deepth、dimension、monomials_count、结果准确率组成特征列和结果列，制作成一份数据集，利用机器学习线性回归算法进行模型训练，得到模型:y＝w1P_I+w2total_multipe_deepth+w3dimension+w4monomials_count+b；其中，y为结果准确率，w1、w2、w3、w4是每个特征列的权重，b是偏置项，训练模型得出这些权重和偏置项，依据此模型，将需要进行同态计算的f经过步骤B004得出当前P_I，记为P_I_C，根据步骤B002得到的当前乘法总深度，记为total_multipe_deepth_c，根据步骤B005得到当前数据维度，记为dimension_c，根据步骤B001得到当前单项式数量，记为monomials_count_c；随后将P_I_C、total_multipe_deepth_c、dimension_c、monomials_count_c代入上述模型中求得结果准确率y，根据上述统计理论准确率分析，如果y在80％-90％之间，则推荐使用半同态加密计算方案，反之则推荐使用全同态加密计算方案，或者根据该y值在准确率之间对f的复杂程度系数complex_level划分判定。优选地，所述步骤SB包括如下过程：步骤SB1，通过六角深度剖析算法分析得到的六项结果全部传入至全同态加密算法；步骤SB2，根据步骤SB1得出的各单项式分析判断是否包含有浮点数，若不包含浮点数，则执行步骤SBB，若包含浮点数，则执行步骤SBC；步骤SBB，执行BFV方案：对加密整数进行模运算；步骤SBC，执行CKKS方案：对加密的实数或复数进行运算；所述步骤SBB包括如下过程：步骤SBB1，执行BFV方案之前，先前设置加密参数:多项式模数、密文系数模和明文模数；步骤SBBC2，根据六角深度剖析算法分析结果中的复杂程度、单项式数量和乘法深度进一步分析得到多项式模数；步骤SBB3，由多项式模数决定密文系数模；步骤SBB4，根据所述密文系数模、复杂程度、乘法深度分析得出明文模；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBB6，使用编码器对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；步骤SBB7，对各单项式中的常量进行抽取，再用编码器分别进行编码；步骤SBBC8至步骤SBBC11，对所有单项式进行求解；步骤SBB12，对所有单项式进行单项式间运算；步骤SBB13，得到最终的密文结果，记录最终密文大小和最终噪声预算；步骤SBB14，利用解密器、解码器、数据维度对密文结果进行解密输出；步骤SBB15，将计算结果与纯明文计算结果进行比较，若有较大误差，则调整计算参数后重新执行计算，直到误差达到预设的较小范围；所述步骤SBBC2包括:针对BFV和CKKS方案进行多项式模数pmd设置，要求多项式模数pmd是2的正幂，多项式模数pmd包括但不限于1024、2048、4096、8192、16384和32768，利用以下数学公式得到该pmd值：pmd＝2)；其中，int表示取整，0.2、0.3、0.5表示权重值；所述步骤SBB3包括:对BFV进行密文系数模cmd设置，新加密密文的noise_budget由加密参数决定，同态运算以由加密参数决定的速率消耗noise_budget，在同态加法中，cmd的总比特长度的上限由pmd确定：cmd＝int-5.25))；其中，round为四舍五入再经过取整，得到最终的整数位cmd值；所述步骤SBB4包括:对BFV进行明文模数plmd设置，plmd决定明文数据类型的大小和乘法中噪声预算的消耗，新加密密文的noise_budget：在同态乘法的noise_budget消耗为：noise_budget_consume＝log2+w；其中，w为不固定值。优选地，所述步骤SBC包括如下过程：步骤SBC1，执行CKKS方案之前，先设置三种加密参数:多项式模数、密文系数模集合和缩放率；步骤SBBC2，对复杂程度、单项式数量、乘法深度进行分析得到多项式模数；步骤SBC3，对乘法深度、浮点数精度进行分析得到密文系数模集合和缩放率；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBC6，使用编码器和缩放率对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；步骤SBC7，抽取各单项式中的常量，利用编码器和缩放率分别进行编码；步骤SBBC8，获取加密参数得到的密文初始噪声预算和初始密文大小并进行记录；步骤SBBC9，对单项式组进行遍历同态计算；步骤SBBC10，若单项式中没有其他函数，则直接进行同态计算，否则按照上述步骤中得到的函数转换进行单项式代入；步骤SBBC11，进行单项式求解后，若是乘法求解，则对其进行噪声预算和密文大小记录，然后对其重线性化后，记录噪声预算和密文大小；步骤SBC12，记录乘法后的密文scale，利用密文系数模组移除一位，对密文重缩放，此后再记录一次密文scale；步骤SBC13，当重缩放后的密文与其他值等级不一时，将重缩放后的密文与该其他值进行模等级交换，以保持等级一致；步骤SBC14，进行加法时，若各自值的scale不一致，则统一scale，用上述步骤中的缩放率设置scale，之后进行加法求解；步骤SBC15，对所有单项式和单项式间运算求解得到最终的密文结果；所述步骤SBC3包括:密文系数模数组cmds和缩放率scale设置，作为模数切换，该步骤要对cmds进行设置，cmds是一个数组的形式，每一次乘法后的模数切换，将移除cmds最后一个数进行rescale，加入当前密文的scale为s，cmds最后一个数为p，在经过乘法之后，s则变成s2，对密文移除cmds的p进行rescale后得到其scale则为：s2/p，如果cmds中所有的p都接近s，则rescale后的s2/p再次接近s，达到稳定scale扩展，cmds的设置方案为：结合步骤B002，使用数字60作为cmds的第一位和最后一位元素，中间的数量为total_multipe_deepth位，利用B004计算的scale记为init_scale作为中间数字，即最终的cmds为：；在设置完cmds后，随后需要设置缩放率时，直接使用init_scale。一种同态加密计算系统，用于执行以上所述的同态加密计算方法。本发明公开的同态加密计算方法及系统，其相比现有技术而言的有益效果在于，本发明通过分析多项式和明文数据而自动选择半同态或全同态进行求解，对多项式进行了深度分析，将多项式里用到的函数自动转化为基础运算，同时若发现分析选择的是全同态加密计算，则会自动根据多项式和数据进行参数调优，以类似机器学习的方式不断寻求最优解的参数，再将最优解参数代入到全同态加密计算中得到多项式最优解，整个过程无需人为参与，研发人员只需传入想要计算的多项式与数据即可，大大降低了研发人员投入的时间成本和运维成本。此外，本发明利用六角深度剖析算法，可以得到参数的最优选择，使运算所需要的时间和资源尽可能接近最优化，避免因人为填写参数造成运算耗时和资源消耗，较好地满足了应用需求。附图说明图1为同态加密技术方案选择流程图；图2为六角深度剖析算法原理示意图；图3为基于Microsoft SEAL全同态加密方案参数调整流程图；图4为本发明同态加密计算方法流程图；图5为步骤SB的流程图；图6为步骤SBB的具体流程图；图7为步骤SBC的具体流程图。具体实施方式下面结合附图和实施例对本发明作更加详细的描述。本发明公开了一种同态加密计算方法，结合图4至图7所示，其包括有：步骤S1，将多项式f和需要加密的参数进行封装后，传入至预设的分析计算引擎；步骤S2，所述分析计算引擎接收到多项式f后，利用六角深度剖析算法进行拆解和分析，根据分析结果判断：若采用半同态加密计算方案，则执行步骤SA1，若采用全同态加密计算方案，则执行步骤SB1；步骤SA，执行半同态加密计算流程；步骤SB，执行全同态加密计算流程。对于半同态加密技术方案，在本发明的所述步骤SA1中，利用多项式f对数据提供方提供的数据x进行Paillier公钥加密并得到密文对象x_encrypt，对x_encrypt进行序列化，得到x_encrypt_serial，将x_encrypt_serial和f传输至计算方，计算方得到x_encrypt_serial和f,首先对x_encrypt_serial进行反序列化得到x_encrypt，将x_encrypt代入至f中求解得到f密态下的结果f_encrypt，随后计算方将f_encrypt返回至数据提供方，数据提供方接收到f_encrypt，将其进行私钥解密得到明文计算结果f_decrypt。关于全同态加密计算方案，请参见图5，所述步骤SB包括如下过程：步骤SB1，通过六角深度剖析算法分析得到的六项结果全部传入至全同态加密算法；步骤SB2，根据步骤SB1得出的各单项式分析判断是否包含有浮点数，若不包含浮点数，则执行步骤SBB，若包含浮点数，则执行步骤SBC；步骤SBB，执行BFV方案：对加密整数进行模运算；步骤SBC，执行CKKS方案：对加密的实数或复数进行运算。在执行BFV方案的过程中，请参见图6，所述步骤SBB包括如下过程：步骤SBB1，执行BFV方案之前，先前设置加密参数:多项式模数、密文系数模和明文模数；步骤SBBC2，根据六角深度剖析算法分析结果中的复杂程度、单项式数量和乘法深度进一步分析得到多项式模数；步骤SBB3，由多项式模数决定密文系数模；步骤SBB4，根据所述密文系数模、复杂程度、乘法深度分析得出明文模；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBB6，使用编码器对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；在本发明的所述步骤SBB6中，使用编码器对需要加密的参数进行编码后得到x_encode，利用加密器、数据维度进行公钥加密过程中，若数据维度是单个数字，则直接加密该数字并生成密文x_encrypted；若数据维度是数组或者矩阵形式，则先将x_encode转换成向量表形式x_vectors，然后再利用加密器加密该x_vectors，得到最终的密文x_encrypted。步骤SBB7，对各单项式中的常量进行抽取，再用编码器分别进行编码；步骤SBBC8至步骤SBBC11，对所有单项式进行求解；具体地：步骤SBBC8，获取加密参数得到的密文初始噪声预算和初始密文大小并进行记录；步骤SBBC9，对单项式组进行遍历同态计算；步骤SBBC10，若单项式中没有其他函数，则直接进行同态计算，否则按照上述步骤中得到的函数转换进行单项式代入；步骤SBBC11，进行单项式求解后，若是乘法求解，则对其进行噪声预算和密文大小记录，然后对其重线性化后，记录噪声预算和密文大小；步骤SBB12，对所有单项式进行单项式间运算；步骤SBB13，得到最终的密文结果，记录最终密文大小和最终噪声预算；步骤SBB14，利用解密器、解码器、数据维度对密文结果进行解密输出；在本发明的所述步骤SBB14中，进行解密输出过程中，若数据维度是单个数字，则直接解密成单数字明文结果result_plain；若数据维度是数组或者矩阵形式，则解密成向量表形式result_vectors；步骤SBB15，将计算结果与纯明文计算结果进行比较，若有较大误差，则调整计算参数后重新执行计算，直到误差达到预设的较小范围。在执行CKKS方案的过程中，请参见图7，所述步骤SBC包括如下过程：步骤SBC1，执行CKKS方案之前，先设置三种加密参数:多项式模数、密文系数模集合和缩放率；步骤SBBC2，对复杂程度、单项式数量、乘法深度进行分析得到多项式模数；步骤SBC3，对乘法深度、浮点数精度进行分析得到密文系数模集合和缩放率；步骤SBBC5，加密算法初始化公私钥、加密器、解密器、计算器、编码器和重线性化密钥；步骤SBC6，使用编码器和缩放率对需要加密的参数进行编码，再利用加密器、数据维度进行公钥加密；步骤SBC7，抽取各单项式中的常量，利用编码器和缩放率分别进行编码；步骤SBBC8，获取加密参数得到的密文初始噪声预算和初始密文大小并进行记录；步骤SBBC9，对单项式组进行遍历同态计算；步骤SBBC10，若单项式中没有其他函数，则直接进行同态计算，否则按照上述步骤中得到的函数转换进行单项式代入；步骤SBBC11，进行单项式求解后，若是乘法求解，则对其进行噪声预算和密文大小记录，然后对其重线性化后，记录噪声预算和密文大小；步骤SBC12，记录乘法后的密文scale，利用密文系数模组移除一位，对密文重缩放，此后再记录一次密文scale；步骤SBC13，当重缩放后的密文与其他值等级不一时，将重缩放后的密文与该其他值进行模等级交换，以保持等级一致；步骤SBC14，进行加法时，若各自值的scale不一致，则统一scale，用上述步骤中的缩放率设置scale，之后进行加法求解；步骤SBC15，对所有单项式和单项式间运算求解得到最终的密文结果；步骤SBC16，根据最终的密文结果记录最终密文大小和最终噪声预算；步骤SBC17，将密文结果利用解密器、解码器、数据维度进行解密输出；步骤SBC18，将计算结果与纯明文计算结果进行比较，若误差超过预设误差值，则调整计算参数后重新执行计算，直到误差到预设的较小范围。本发明公开的同态加密计算方法及系统，其相比现有技术而言的有益效果在于，本发明通过分析多项式和明文数据而自动选择半同态或全同态进行求解，对多项式进行了深度分析，将多项式里用到的函数自动转化为基础运算，同时若发现分析选择的是全同态加密计算，则会自动根据多项式和数据进行参数调优，以类似机器学习的方式不断寻求最优解的参数，再将最优解参数代入到全同态加密计算中得到多项式最优解，整个过程无需人为参与，研发人员只需传入想要计算的多项式与数据即可，大大降低了研发人员投入的时间成本和运维成本。此外，本发明利用六角深度剖析算法，可以得到参数的最优选择，使运算所需要的时间和资源尽可能接近最优化，避免因人为填写参数造成运算耗时和资源消耗，较好地满足了应用需求。为了实现以上所述的同态加密计算方法，本发明可利用一种同态加密计算系统来自动执行上述各步骤。下面提供一个具体的实施例，对本发明所述的同态加密计算方法进行详细说明。实施例一在本实施例中，请参见图1，同态加密技术方案选择方式如下：A100:多项式f分析拆解。f和f所需要的数据由数据提供方提供。f形如：根据此f表达式，f所需要的数据x是由数据提供方提供，下文会对x进行同态加密代入f进行密态下的求解，而其他常数如：0.5、1.23和25，本发明会自动抽取这些常数，常数不需要经过加密，对于全同态来说，会对其进行编码或缩放编码。f经过六角深度剖析算法C001分析拆解会得到单项式B001、乘法深度B002、函数转换B003、浮点数精度B004、数据维度B005、复杂程度B006。；C100:六角深度剖析算法。此处会对A100进行深度剖析得到六个单元B001-B006，六个单元最终会决定f求解走向，即半同态加密计算和全同态加密计算方案。若是选择半同态加密技术方案会直接使用Paillier方案执行；D001-D004:半同态加密计算。f根据上面提供的数学式子，对数据提供方提供的数据x进行Paillier公钥加密得到密文对象x_encrypt。得到的x_encrypt若需要走网络传输至计算方进行计算，则会对其进行序列化，得到x_encrypt_serial，序列化后的数据才能在网络通道上进行传输，将x_encrypt_serial和f传输至计算方。计算方得到x_encrypt_serial和f,首先会对x_encrypt_serial进行反序列化得到x_encrypt，将x_encrypt代入至f中求解得到f密态下的结果f_encrypt，随后计算方将f_encrypt返回至数据提供方，数据提供方接收到f_encrypt，会将其进行私钥解密得到明文计算结果f_decrypt。至此半同态加密计算流程结束，因为同态计算支持的运算一般是加减乘除，上面提及的f相对简单，若遇到形如以下f:该f中包含了各种数学运算符，此时需要利用C100中的B003对数学运算符进行转换，转换成基础运算，即加减乘除的形式，方可执行同态计算，对函数转换详细描述请参见图2；E100:若C100分析得出该f和数据x更适合使用全同态加密计算方案，则会自动调起Microsoft SEAL全同态加密技术方案，将C100得到的B001-B006传至E100中，详细描述请参见图3；请参见图2，六角深度剖析算法原理详解如下：六角深度剖析算法C001在本发明中担任着承上启下的作用，承上作用在于：对数据提供方的f和x做分析拆解和转换，启下作用在于：算法得到的六个单元，对其进行深度分析都会影响同态计算方案选择和全同态加密计算方案的参数调整。具体包括：B001：单项式数量。其中，单项式即由数和字母的积组成的代数式叫做单项式，单独的一个数或一个字母也叫做单项式。在实施例的C001中，有4个决定因素对f进行拆解：1、在同等程度上，减法就是加法，对减法转换成加负数的形式；2、括号式子需要先转换成一个子f，子f再根据另外3个决定因素再次进行拆解；3、在同等程度上，除法就是乘法，对除法转换成乘以分母的倒数；4、根据加号进行拆解成多个单项式组合；根据以上4个决定因素，C001可以对f进行分析拆解成n个单项式，形如f:经分析拆解，得到四个单项式组合monomials，进而得到f为四个单项式数量monomials_count。得到的单项式组合，对于全同态加密技术方案是有作用的，请参见图3和图4。B002:乘法深度。f中会存在多次的乘法运算，每一次的乘法运算对同态计算都会存在一定的影响，比如在全同态Microsoft SEAL中，每进行一次乘法，会改变密文的大小、噪声预算的消耗、浮点数密文的scale会增大等，乘法造成的这些因素，最终都会导致密文结果解密后的明文结果不可信，即与纯明文计算的结果有很大的误差。所以有效的控制每一次的乘法对结果的影响是有必要的，在本发明中的C001对f的乘法进行剖析得到乘法深度。对B001得到的monomials进行逐一剖析，根据每个单项式的乘法次数，得到该单项式的乘法深度，最终结合整个monomials的所有乘法深度集合得到最终的总乘法深度multipe_deepth。如上述f的monomials，乘法深度组合multipe_deepths为，总乘法深度total_multipe_deepth为8。B003:函数转换。形如以下f:对于此类存在多个函数式的f，在同态计算之前，需要对其所有涉及函数的表达式进行转换，转换成基础运算加减乘除，同态计算就可更加方便的对其进行分析运算和调参。在本发明中会对常见数学函数转换如：1、绝对值|x|，意为x的正数，根据数学运算转换，|x|等于对x求平方后再求0.5次方：|x|＝0.5；2、平方根√x运算，根据数学运算转换，√x等于对x求0.5次方：3、Σ求和：4、求模％，根据数学运算转换，形如y＝x％5，y等于x-*5，x/5取int整数位m，再由x减去m*5得到求模后的结果y：5、求积∏：6、avg，求平均值：7、var，即为求方差σ2，μ为avg，N为总数：其中，μ、Σ都可以使用上方的函数转换后的式子进行代入得到原始加减乘除即：8、std，即为求标准差，对方差进行开平方：经上述函数转换代入得：C100提供了以上函数转换的功能，f进入C100之后会对其进行B001，得到monomials，随后对每一个monomials进行函数式转换，转换后的单个monomial可能还会存在新的多项式f，此时继续对该monomial进行B001，最终得到该monomial最原始的加减乘除式子。这样一来，在实施例中，f的单项式数量和乘法深度随着深度的B001会逐渐变大，深度地剖析f，得到最准确的单项式数量和乘法深度有利于后续同态加密计算的参数调整。B004:浮点数精度。形如以下f:该f存在大量的浮点数，浮点数在同态计算上，最容易造成结果精度的失真，如何把控设置一个最优的缩放比scale，是对浮点数计算的一个关键点。缩放比在同态计算中，相当于对浮点数按scale对浮点数进行放大移位，使其得到一个接近整数位的数据，在同态计算中，计算整数的精度值往往都可以达到精确的，在本发明中会对f的所有的系数w和未知数x进行scale。具体scale作用在请参见图3和图4。scale数值的决定因素：在对浮点数的同态计算中，每一次的乘法都会导致计算后的密文scale成倍增大，然而每次乘法计算后的密文scale都不能太接近甚至超过密文系数模总计，所以因为scale会成倍增大，所以初始scale不能设置过大，但反过来如果设置太小，则不能达到精确的整数位计算。即该scale也是不断同态计算迭代调参后得到的最优值。首先需要得到f的初始scale，scale会对浮点数进行放大，因此我们对该f进行B001得到monomials，然后进行分析每一项的系数，得到系数集合ws，同时还需要得到x的小数点位数X_I，选取ws小数点后面位数最大的哪一个系数为：0.56458995，获取小数位数P_I为8位，此时需要对P_I和X_I进行逻辑比较，假设得到是P_I较大，则我们直接使用P_I进行求的初始scale。在本发明中设置的scale阈值为40，即希望得出来的scale接近40，不能超出太多，超出太多则直接使用阈值，因为超出太多在乘法之后造成的密文scale即有可能会超过密文系数模总计，否则会没有空间存储缩放后的结果明文，一般取。因此，对小数位数取log取整再与10相乘，即：scale_i＝int*10；将此时P_I为8代入得到scale_i＝30，在阈值范围内，则可以使用该scale值作为初始scale。B005:数据维度。此处本发明无需关心f,只需关心x的数据形态，f其他系数已是常数，最终同态计算只需将x进行代入即可。x的数据形态一般有多种：单个数字、一维数组、二维数组、矩阵等等，每一种形态对计算所需要的时间和资源都有影响。因此这也是f适合使用哪种同态加密计算方案的决定因素之一。在本发明中我们对数据形态给同态计算划分了以下两种种等级：A级，针对是简单的数据维度如单个数字、一维数组、多行一列的二维数组；B级，多行多列的多维数组和矩阵；由此可见，A级为简单的级别，B级为复杂的级别。按照半同态和全同态的区别，本发明通常指定A级是由半同态来计算，B级由全同态计算，在B级中的全同态计算，本发明会将B级的数据结构，转换为向量表形式，随后对向量表统一进行加密，代入f进行计算。而在A级中，由于半同态的局限性，本发明会基于数据结构进行等份切分进行多密文代入f进行并行运算，已达到更高的计算效能。B006:复杂程度。形如B003的f，经过B003、B001、B002后的转换单项式组t_monomials、total_multipe_deepth，其中必然会存在多次单个的加法和单个乘法、或加法和乘法的组合，由上文得知，半同态仅支持有限次数的加法乘法或单个加法、单个乘法，而全同态则支持无限次，虽然全同态支持无限次，但考虑到成本和性能，可以使用半同态的则不使用全同态。本发明将对t_monomials进行分析加法和乘法的次数、total_multipe_deepth、B005得到的数据维度dimension、B001的monomials_count等进行深度整合并利用机器学习算法得出对半同态和全同态加密计算方案的选择。根据对B004的P_I统计理论，本发明期望从在十分位-万分位数准确率为90％，百分位-万分位数准确率为80％，千分位-万分位后准确率70％，万分后准确率为70％以下。本发明利用了大批量的经过半同态计算得出的测试数据，根据不同的P_I、total_multipe_deepth、dimension、monomials_count、结果准确率组成特征列和结果列，制作成一份数据集，利用机器学习线性回归算法进行模型训练，得到模型:y＝w1P_I+w2total_multipe_deepth+w3dimension+w4monomials_count+b；其中，y为结果准确率，w1、w2、w3、w4是每个特征列的权重，b是偏置项，训练模型会得出这些权重和偏置项。依据此模型，将需要进行同态计算的f经过B004得出当前P_I，名为P_I_C，B002得到的当前乘法总深度记为total_multipe_deepth_c，B005得到的当前数据维度记为dimension_c，B001得到的当前单项式数量记为monomials_count_c。随后将P_I_C、total_multipe_deepth_c、dimension_c、monomials_count_c代入上述模型中求得结果准确率y，根据上面的统计理论准确率分析，即如果y在80％-90％之间可推荐使用半同态加密计算方案，反之则推荐使用全同态加密计算方案。同时可以根据该y值在准确率之间对f的复杂程度系数complex_level划分判定。关于本实施例中的同态加密计算方法，请结合图4至图7所示，具体包含如下步骤：步骤S1-步骤S2:将f和数据x进行封装得到f’，将f’传至分析计算引擎，分析计算引擎请参见图1，可以对其进行选择半同态或全同态加密计算方案。分析引擎得到f’后利用C100进行深度剖析，将f’经过B001-B006处理后得到选择方案，若是半同态加密技术方案，则会由SA处体现，此处流程已由上文的D001-D004详述。若方案是全同态加密技术方案，则会由SB流程线体现。步骤SB1-步骤SB2:C100中经B001-B006得到的各类结果和f’传入至全同态加密算法SEAL中，并从B004得出f’是否包含有浮点数和CKKS，从这里可知，BFV专门用于对整数的同态计算，而CKKS则是对浮点数进行同态计算):不包含浮点数，全是整数则为BFV方案走SBB1-SBB15。否则为CKKS方案走SBC1-SBC18。先针对BFV方案进行描述，请参见步骤SBB1-步骤SBB15：步骤SBB1:加密整数执行模运算BFV。在该方案中，需要先前设置三种加密参数:多项式模数、密文系数模和明文模数；步骤SBBC2:多项式模数pmd设置，这里BFV和CKKS方案都会进行设置，这必须是2的正幂，更大的模数会使密文大小变大，所有的操作会变慢即执行效率会变慢，但是可以进行更加复杂的加密计算，建议值是：1024、2048、4096、8192、16384、32768，但也可能超出此范围。此处可以通过上文的B001、B002、B006决定该模数设置。利用以下数学公式得到该pmd值：pmd＝2)；其中，int表示取整，0.2、0.3、0.5表示权重值；步骤SBB3:密文系数模cmd设置，这里只需要BFV进行设置。较大的cmd意味着更大的噪声预算noise_budget，因此更高的加密计算能力。每个密文都有一个特定的量，称为“不变噪声预算”，简称“噪声预算”，以比特为单位。新加密密文的noise_budget由加密参数决定。同态运算以同样由加密参数决定的速率消耗noise_budget。在同态加法中，通常被认为是不用消耗任何的noise_budget，而乘法则会消耗密文的noise_budget，一旦密文的noise_budget达到0，它将会无法解密。然而，cmd的总比特长度的上限由pmd确定：cmd＝int-5.25))；其中，round即为四舍五入，最后再经过取整，得到最终的整数位cmd值；步骤SBB4:明文模数plmd设置，这里也只需要BFV进行设置。plmd决定明文数据类型的大小和乘法中噪声预算的消耗。因此，为了获得最佳性能，必须尽量保持明文数据类型的小。plmd可以是任何正整数，即使这里认为它是2的幂。新加密密文的noise_budget：而在同态乘法的noise_budget消耗为：noise_budget_consume＝log2+w；其中，w为不固定值，意为其他项，该项会在计算过程中产生的一些能源资源所决定。从以上公式可知，为了获得更高的计算性能、运算中少消耗noise_budget和初始noise_budget更高，需要设置plmd合理的小。通常我们可以设定256、512、1024等值；步骤SBBC5:该步骤中的BFV和CKKS都需要设置。初始化同态计算中所需要的公私钥、编码器、加密器、解密器、计算器、重线性化密钥；步骤SBB6-步骤SBB7:使用上述生成的编码器对f中的x进行编码得到x_encode，随后利用加密器、和B005得到的数据维度进行公钥加密，这里数据维度如果是单个数字，则直接加密该数字成密文x_encrypted；否则如果这里是数组、矩阵形式，则会将x_encode先转换成向量表形式x_vectors，然后再利用加密器加密该x_vectors，得到最终的密文x_encrypted。f中同时会存在多个系数常量w1、w2、w3....，需要对其进行抽取，随后用编码器对这些w1、w2、w3....进行编码，编码得到w1_encode、w2_encode、w3_encode....；步骤SBBC8-步骤SBBC11:这里BFV和CKKS都需要执行。对当前的初始化后得到的x_encrypted，记录其初始noise_budget和初始密文大小分别为init_noise_budget、init_encrypted_size，记录此可以对后续的计算过程、最终的结果明文等有对比作用，可以比较前前后后的noise_budget和encrypted_size，做出相应的计算和参数调整。随后开始对B001和B003得到的t_monomials进行迭代每一个t_monomial，对每一个t_monomial进行x_encrypted和对应的w_encode进行单项式代入数求解，得到该t_monomial的解t_monomial_res。若该t_monomial是乘法求解，则需要记录当前密文的noise_budget和密文的encrypted_size，随用使用重线性化密钥对密文进行重线性化得到x_encrypted_relin；步骤SBB12-步骤SBB13:将步骤SBBC8-步骤SBBC11中得到的所有t_monomial的解t_monomial_res后，就进行t_monomial间的根据f表达式进行两两加法计算减号都会变成加号，所以这里的t_monomial之间的运算都会以加法的形式进行计算)。两两计算后得到最终的密文result_encrypted和记录最终的noise_budget_res。步骤SBB14:利用解密器、解码器和B005数据维度，进行解密解码输出，其中如果数据维度是单个数字，则直接解密解码成单数字明文结果result_plain；否则如果数据维度是数组、矩阵形式，则会解密解码成向量表形式result_vectors；步骤SBB15:使用纯明文的形式进行代入f，得到明文结果result_f，使用上述得到的result_plain或result_vectors与result_f进行比较，以B006的准确率比较为标准，若存在较大误差，即准确率在80％以下，则重新执行SBB1-SBB15真个BFV计算流程，直到计算误差控制稳定在80％以上即可得到接近精确值的结果。关于CKKS方案请参见步骤SBC1-步骤SBC18，请参见图7：步骤SBC1:加密的实数或复算运算CKKS。在该方案中，需要先前设置三种加密参数:多项式模数、密文系数模集合和缩放率；步骤SBBC2:已由上述BFV方案中的步骤SBBC2描述得到pmd；步骤SBC3:密文系数模数组cmds和缩放率scale设置。CKKS中的乘法会导致密文中的scale增长。CKKS方案提供了“重缩放rescale”功能，可以减小scale，并稳定scale扩展。重缩放是一种模数切换操作。作为模数切换，需要对cmds进行设置，cmds是一个数组的形式，每一次乘法后的模数切换，都会移除cmds最后一个数进行rescale，通常需要对scale如何变化有完美的控制，所以需要对cmds进行精心设置选择。即加入当前密文的scale为s，cmds最后一个数为p，在经过乘法之后，s则会变成s2，对密文移除cmds的p进行rescale后得到其scale则为：s2/p，如果cmds中所有的p都接近s，则rescale后的s2/p就可以再次接近s，达到稳定scale扩展。同时对于上面B002的total_multipe_deepth，则需要进行rescale的total_multipe_deepth倍。一旦在cmds中只剩下一个数num_left，num_left必须比s大几位，以保留明文的小数点前的值。最终在本发明中，cmds的设置方案为：结合B002，使用数字60作为cmds的第一位和最后一位元素，中间的数量为total_multipe_deepth位，利用B004计算的scale记为init_scale作为中间数字，即最终的cmds为：；注意：任何密文的scale都不能太接近cmds的总大小，否则密文就没有空间来存储scale后的明文，即如果此时的密文scale记为c_scale是40，则40不能太接近cmds的总大小，即为c_scale＜sum。同时因为与BFV的cmd一样，这里的cmds不能超过pmd的界限，即在CKKS中设置cmds需要结合上述的cmds设置和BFV中cmd的求得公式进行总和设置。在设置完cmds后，随后需要设置缩放率，直接使用init_scale即可；步骤SBBC5:请参见上述BFV方案中关于步骤SBBC5的描述。步骤SBC6-步骤SBC7:使用编码器和init_scale对需要进行加密的数据进行缩放编码，其中缩放过程首先对init_scale进行幂次求解2^init_scale，得到deal_init_scale，随后代入与加密的数据代入到编码器中得到编码缩放后的结果x_encode_scale，随后使用加密器和B005数据维度进行加密，这里数据维度如果是单个数字，则直接加密该数字成密文x_encrypted_scale；否则如果这里是数组、矩阵形式，则会将x_encode_scale先转换成向量表形式x_vectors_scale，然后再利用加密器加密该x_vectors_scale，得到最终的密文x_encrypted_scale。f中同时会存在多个系数常量w1、w2、w3....，需要对其进行抽取，随后用编码器和deal_init_scale对这些w1、w2、w3....进行编码缩放，编码缩放得到w1_encode_scale、w2_encode_scale、w3_encode_scale....。步骤SBBC8-步骤SBBC11:请参考上述BFV方案中步骤SBBC8-步骤SBBC11的描述，此时代入的参数为：x_encrypted_scale和w_encode_scale；步骤SBC12:该步骤不同于上述的BFV方案，CKKS方案同时需要记录乘法之后的密文scale，因为同态乘法后会是的密文的scale扩展，所以需要使用cmds移除一位，移除后的cmds对当前密文进行rescale得到重缩放后的密文x_encrypted_rescale，此后再记录一次x_encrypted_rescale的scale；步骤SBC13:当x_encrypted_rescale与其他值，会发现这两者等级不一，则用x_encrypted_rescale对w3_encode_scale进行模等级交换，即使得w3_encode_scale与x_encrypted_rescale保持等级一致，之前对两者进行计算；步骤SBC14:当需要对B001、B003后得到的t_monomials进行单项式间运算时，即加法运算，会发现各自的scale不一致，因为有一些t_monomial里面存在乘法运算，乘法运算后需要进行密文rescale，所以要进行同态加法，需要将t_monomials中所有的t_monomial统一scale，使用init_scale进行rescale，此时所有的t_monomial的scale达到统一，方可进行加法求解；步骤SBC15-步骤SBC16:以上步骤SBBC8-步骤SBC14执行完后，得到最终的密文结果result_encrypted和记录最终的noise_budget_res和密文大小result_encrypted_size；步骤SBC17-步骤SBC18:该步骤与上述BFV方案的步骤SBB14-步骤SBB15一致，代入result_encrypted进行求解。本发明公开的同态加密计算方法及系统，其充分运用了半同态加密技术和全同态加密技术的优点，结合该两种技术，通过分析多项式和明文数据自动选择半同态或全同态进行求解，对多项式进行深度分析，将多项式里用到的函数自动转化为基础运算，同时若分析选择的是全同态加密计算，会自动根据多项式和数据进行参数的调优，类似机器学习不断寻求最优解的参数，使最优解参数代入到全同态加密计算中得到多项式最优解，整个过程不需要人为参与，人为只需要传入想要计算的多项式与数据即可，大大降低了研发人员的时间成本和运维成本。此外，本发明利用六角深度剖析算法，可以得到参数的最优选择，使得运算所需要的时间和资源尽可能的接近最优化，避免人为填写参数造成运算耗时和耗资源。以上所述只是本发明较佳的实施例，并不用于限制本发明，凡在本发明的技术范围内所做的修改、等同替换或者改进等，均应包含在本发明所保护的范围内。

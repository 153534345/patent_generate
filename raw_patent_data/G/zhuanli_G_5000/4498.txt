标题title
一种基于多方法融合的软件bug定位方法
摘要abst
本发明公开了一种基于多方法融合的软件bug定位方法。本发明首先整理程序相关信息并对源码进行静态分析，再执行测试用例，对源码进行动态分析，之后用切片法、频谱法、结合切片法和频谱法、栈跟踪定位bug。其次收集bug定位数据，构建特征向量，采用排序学习算法结合前文信息对bug定位。最后将bug报告、历史修改记录与bug源码向量化，进行向量相似度比对，定位bug所在源码文件。本发明将多种文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，让bug定位方法的有效范围更广泛，并且得到更高精度的bug定位效果。
权利要求书clms
1.一种基于多方法融合的软件bug定位方法，其特征在于，包括以下步骤：步骤1.针对待定位bug的源码，整理出对应的测试用例、bug报告和代码修改历史记录；步骤2.执行语句级别的细粒度bug定位；步骤3.执行文件级别的粗粒度bug定位；步骤4.将文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，得到最终的软件bug所在位置。2.根据权利要求1所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述的细粒度bug定位采用四种定位方式，分别为切片法、频谱法、混合法以及栈跟踪法。3.根据权利要求2所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述切片法是通过分析源码的AST结构，得到源码函数的输入输出变量信息，创建源码的控制流图，并从中获取源码中的程序路径、分支语句与分支条件；将源码各函数对应的测试用例分别执行，记录每个测试用例走过的路径与执行结果；将执行失败的测试用例所经过的程序语句放在集合中，筛选与异常变量有关的程序语句，构成一个动态切片，依次构建所有的动态切片，与同一个异常变量有关的动态切片中的语句交集即为bug位置。4.根据权利要求2所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述频谱法是将源码各函数对应的测试用例分别执行，记录每个测试用例走过的路径与执行结果；使用频谱法由怀疑度公式计算程序内每一句程序语句的怀疑度，而后降序排列给出怀疑度列表，按照怀疑度将bug定位在某个语句。5.根据权利要求2所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述混合法是先用切片法将bug的位置缩小到一个语句集合中，再采用频谱法计算该集合中语句的怀疑度并排序，最终定位bug。6.根据权利要求2所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述栈跟踪法是将源码各函数对应的测试用例分别执行，记录每个测试用例走过的路径与执行结果；当出现执行崩溃的情况时，堆栈跟踪指示当前活动的函数调用和崩溃发生的点，根据堆栈跟踪的结果追溯bug位置。7.根据权利要求2至6中任一项所述的一种基于多方法融合的软件bug定位方法，其特征在于,通过四种bug定位方法分别对于每个语句得到一个怀疑度分值，这些怀疑度分值构成语句的特征向量，并标注该特征向量的期望值；采用排序学习算法LambdaMart，对得到的特征向量与期望值进行学习，经训练后的模型根据每个语句的特征向量给语句赋一个怀疑度分数，在语句级别定位出bug。8.根据权利要求1或2所述的一种基于多方法融合的软件bug定位方法，其特征在于,所述多种文件级别的粗粒度bug定位方法具体是：首先从bug报告、历史修改记录以及bug源码文件中提取有实际意义的词，构成关键词库；然后统计词库中词汇的词频反文档频率TF-IDF，即权重值，所有词的名称及权重值构成该关键词库的权重向量；最后采用文件关键词库的权重向量间的余弦相似度代表各文件之间的相似度，统计每个bug报告及历史修改记录分别与哪个程序源代码文件的关键词库相似度最高，定位bug在此源代码文件中。9.一种基于多方法融合的软件bug定位装置，其特征在于，包括：预处理模块，用于针对待定位bug的源码，整理出对应的测试用例、bug报告和代码修改历史记录；细粒度bug定位，用于执行语句级别的细粒度bug定位；粗粒度bug定位模块，用于执行文件级别的粗粒度bug定位；定位融合模块，用于将文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，得到最终的软件bug所在位置。10.基于多方法融合的软件bug定位设备，其特征在于，包括存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，其中，所述处理器执行所述程序时实现上述权利要求1-8任一所述的基于多方法融合的软件bug定位方法。
说明书desc
技术领域本发明涉及计算机信息处理软件工程测试自动化领域，具体涉及一种基于多方法融合的软件bug定位方法。背景技术软件测试成本极高，在软件生命周期中占总成本的40%以上。其中，bug定位任务占据了开发人员的大量时间，因此，近年来自动bug定位的研究越来越多，也出现了不少有价值的研究成果。Bug定位的自动化研究，大多是将之前人工定位bug的流程部分或全部替换为自动化执行。例如，出现测试用例执行的结果与预期结果不符时，测试人员常会在本次执行的语句中寻找与异常变量有关的语句，切片法模拟了这个过程以定位bug；出现测试用例执行崩溃时，测试人员会回溯堆栈调用信息，寻找崩溃发生的位置，栈跟踪法模拟了这个过程以定位bug；除此之外，还有采用统计法给出程序语句怀疑度排序的频谱法，以及多方法融合的bug定位法等。多个研究结果表明，多方法融合的自动bug定位法比任意单一方法效果都好。然而现有的多方法融合的bug定位法存在一些缺陷。首先，被融合的多种bug定位方法的定位精度都是语句级别的细粒度，没有文件或函数级别的粗粒度bug定位，应用范围小了许多；其次，前人研究的多方法融合的自动bug定位法中，采用了排序学习中的pointwise类算法进行排序，该算法不能考虑到同一文件中语句之间的关系，本发明中采用了LambdaMart排序学习算法，该算法属于的Listwise类算法，其排序效果比pointwise类算法的效果更优秀。发明内容针对现有软件bug定位精度低，应用范围窄的问题，本发明提出一种基于多方法融合的bug定位方法，目的是扩大bug定位方法的使用范围，提高bug定位精度。本发明的一方面提供了一种基于多方法融合的软件bug定位方法，它包括如下步骤：步骤1.针对待定位bug的源码，整理出对应的测试用例、bug报告和代码修改历史记录；步骤2.执行语句级别的细粒度bug定位；步骤3.执行文件级别的粗粒度bug定位；步骤4.将文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，得到最终的软件bug所在位置。本发明的另一方面提供了一种基于多方法融合的软件bug定位装置，包括：预处理模块，用于针对待定位bug的源码，整理出对应的测试用例、bug报告和代码修改历史记录；细粒度bug定位，用于执行语句级别的细粒度bug定位；粗粒度bug定位模块，用于执行文件级别的粗粒度bug定位；定位融合模块，用于将文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，得到最终的软件bug所在位置。本发明的再一方面：提供了一种基于多方法融合的软件bug定位设备，包括存储器、处理器及存储在存储器上并可在处理器上运行的计算机程序，其中，所述处理器执行所述程序时实现上述基于多方法融合的软件bug定位方法。本发明有益效果：本发明将多种文件级别的粗粒度bug定位方法与语句级别的细粒度bug定位方法相结合，让bug定位方法的有效范围更广泛。并且，采用属于的Listwise类算法的LambdaMart作为方法融合的算法，得到更高精度的定位效果。附图说明图1为多方法融合的bug定位算法流程图。图2为图2为多方法融合的bug定位设备图。具体实施方式下面结合附图和实施方法对本发明做进一步的详细描述。如图1所示，本发明的技术方案为如下几个步骤：1.程序相关信息整理针对待定位bug的源码，整理出对应的测试用例、bug报告、代码修改历史记录等可能与bug位置相关的初始信息。2.对源码进行静态分析通过分析源码的AST结构，创建源码的控制流图，并从中获取源码中的程序路径、分支语句与分支条件；并从源码的AST中分析得到源码函数的输入输出变量等信息。3.执行测试用例，对源码进行动态分析将源码各函数对应的测试用例分别执行，记录每个测试用例走过的路径与执行结果等信息。4.计算程序动态切片，用切片法定位bug取第三步的执行结果信息，将执行失败的测试用例所经过的程序语句放在集合中，筛选与异常变量有关的程序语句，构成一个动态切片。依次构建所有的动态切片，与同一个异常变量有关的动态切片中的语句交集即为bug位置。5.选择频谱公式，用频谱法定位bug频谱法的怀疑度公式由步骤3中动态分析的结果经分类统计后，按一定运算规则构成的。频谱法会根据怀疑度公式计算程序内每一句程序语句的怀疑度，而后降序排列给出怀疑度列表，按照怀疑度将bug定位在某个语句。6.结合切片法，用频谱法定位bug首先用切片法将bug的位置缩小到一个语句集合中，再采用频谱法计算该集合中语句的怀疑度并排序，最终定位bug。7.栈跟踪法定位bug测试用例执行的结果有三类，分别是结果正常、结果异常执行崩溃。堆栈跟踪是程序执行期间的活动堆栈帧的列表，每个堆栈帧对应一个尚未返回的函数调用。当出现执行崩溃的情况时，堆栈跟踪指示当前活动的函数调用和崩溃发生的点。可根据堆栈跟踪的结果追溯bug位置。8.收集bug定位数据，构建特征向量采用以上多种方法定位bug，对每个语句都有怀疑度分值。对于每个语句来说，每一种bug定位方法对其打出的怀疑度分值就是一个特征，所有bug定位的分值构成了一个语句的特征向量。对每个特征向量，都用0或1标注其期望值，其中，0代表此语句内不含bug，1代表此语句含有bug。9.采用排序学习算法结合前文信息对bug定位采用排序学习算法LambdaMart，对步骤八中得到的特征向量与期望值进行学习。经训练后的模型可以根据每个语句的特征向量给语句赋一个怀疑度分数，程序语句怀疑度分数就是该语句中含有bug的可能性，从而在语句级别上定位出bug。10.将bug报告、历史修改记录与bug源码向量化先从bug报告、历史修改记录以及bug源码文件中提取有实际意义的词，构成关键词库；统计词库中词汇的词频反文档频率，所有词的名称及权重值构成了该关键词库的权重向量。11.进行向量相似度比对，定位bug所在源码文件采用文件关键词库的权重向量间的余弦相似度代表各文件之间的相似度，用对比相似度的方式对比各文件的关键词库，统计每个bug报告及历史修改记录分别与哪个程序源代码文件的关键词库相似度最高，即认定该源代码文件与该bug报告的关联度最高，bug最有可能在此源代码文件中。实施例：S1.针对待定位bug的源码，整理出对应的bug报告、测试用例以及代码修改历史记录。S2.首先对测试对象源码进行语法分析，得到程序的抽象语法树；然后遍历AST节点，创建控制流程图。控制流程图中，节点是只能连续运行的语句组成的程序块，边是block之间的控制关系。对控制流图进行遍历，得到程序中的程序路径、分支语句与分支条件对AST分析，可得到源码中函数的输入输出变量等信息。S3.利用gcc工具，对代码进行自动插装。测试用例执行完毕后，可以利用gcc得到代码语句的运行顺序信息、以及源码中代码语句的覆盖信息。S4.针对执行结果与期望结果不符的测试用例，记其变量集合为V，与V中所有异常变量有关的程序语句构成一个语句集合S。记第i个异常的变量v，将该次执行的语句中，与v相关的语句放入一个集合s，s即为一个动态切片，且s为S的子集。依次构建所有的动态切片。与同一个异常变量有关的动态切片中的语句交集即为bug位置。S5.针对频谱法定位bug，本发明选择的频谱公式是Ochiai，公式如下所示：其中，运行覆盖程序某语句且运行结果正常的测试用例数ncs，运行覆盖程序某语句且运行结果错误的测试用例数ncf，运行不覆盖程序某语句且运行结果正常的测试用例数nuf。根据以上公式，可计算出每个程序语句的怀疑度。将程序语句按怀疑度降序排列，即得到了bug位置的怀疑度列表。S6.步骤S4中，切片法将bug定位在一些语句组成的语句集合中。再利用步骤5中的频谱法，对切片法中获得的语句集中的语句计算怀疑度，即可得到融合“切片法”与“频谱法”的bug怀疑度列表，并排序定位bug。S7.针对测试用例执行崩溃的情况，堆栈跟踪指示了当前活动的函数调用和崩溃发生的点。根据堆栈跟踪的结果进行追溯，崩溃发生的语句以及语句中调用的方法，都可能是bug所在的位置，均为栈跟踪法定位bug的结果。S8.采用以上多种方法定位bug，每种方法对每个语句都有一个怀疑度分值。表1为bug源代码中语句与其特征的示例，该表的第三行数据显示了在com.file文件中的Func1函数的第37行存在一个bug，切片法、频谱法、切片+频谱的混合法以及栈跟踪法对该语句的怀疑度打分均如下表所示，因此其特征向量为，该语句中含有bug，对应的期望值为1。表1文件函数行号切片法怀疑度频谱法怀疑度混合法怀疑度栈跟踪怀疑度是否bugcom.fileFunc1150.00.14790.08320.00com.fileFunc1370.00.54860.79790.01com.fileFunc2331.00.11010.34460.01S9.步骤八中得到了特征向量与期望值，本方法采用加入了随机森林版本的LambdaMart算法，对特征向量进行学习，以根据特征向量预测其期望值，即给语句赋一个怀疑度分数。经训练后的模型会将语句按怀疑度分数依次排列，从而在语句级别上定位出bug。与pointwise类算法比，由于LambdaMart在训练时考虑了所有特征向量之间的次序关系，而非仅有特征向量中的特征值与期望值间的关系，因此，其定位效果比pointwise更优。S10.首先，将bug报告、修改历史以及源代码中有意义的词汇提取出来，构成文件的关键词库；其次，统计词库中词汇的词频反文档频率，即该词的权重值；最后，一个文档中所有词的名称及权重值构成了该关键词库的权重向量。TF-IDF计算公式如下所示：公式中，ω为一个术语词汇，d为给定文档，C为语料库，即所有文档的集合，nωd是词汇ω出现在给定文档d中的次数，N是文档d中词的数量总和， 表示C的数量。S11.每个bug报告及历史修改记录分别与哪个程序源代码文件的关键词库相似度最高，即认定该源代码文件与该bug报告的关联度最高，bug最有可能在此源代码文件中。文件相似度采用文件关键词库对应的权重向量值的余弦相似度来表示。向量的余弦相似度计算公式如下所示：。本发明的实施例可以应用在网络设备上,实施例可以通过软件实现，也可以通过硬件或者软硬件结合的方式实现。以软件实现为例，作为一个逻辑意义上的装置，是通过其所在设备的处理器将非易失性存储器中对应的计算机程序指令读取到内存中运行形成的，其中计算机程序用于执行上述步骤所确定的方法。从硬件层面而言，如图2所示，为本发明的基于多方法融合的软件bug定位设备的硬件结构图，除了图2所示的处理器、网络接口、内存以及非易失性存储器之外，所述设备通常还可以包括其他硬件，以便在硬件层面进行的扩展。另一方面，本申请还提供了一种计算机可读存储介质，存储介质存储有计算机程序，计算机程序用于执行上述步骤所确定的基于机会主义路由的流间网络编码方法。对于实施例而言，由于其基本对应于方法实施例，所以相关之处参见方法实施例的部分说明即可。以上所描述的装置实施例仅仅是示意性的，本领域普通技术人员在不付出创造性劳动的情况下，即可以理解并实施。本领域技术人员在考虑说明书及实践这里公开的发明后，将容易想到本申请的其它实施方案。本申请旨在涵盖本申请的任何变型、用途或者适应性变化，这些变型、用途或者适应性变化遵循本申请的一般性原理并包括本申请未公开的本技术领域中的公知常识或惯用技术手段。说明书和实施例仅被视为示例性的。还需要说明的是，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、商品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、商品或者设备所固有的要素。以上所述仅为本申请的较佳实施例而已，并不用以限制本申请，凡在本申请的精神和原则之内，所做的任何修改、等同替换、改进等，均应包含在本申请保护的范围之内。

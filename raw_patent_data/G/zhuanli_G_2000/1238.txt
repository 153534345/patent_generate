标题title
一种内存泄露定位的辅助信息获取方法及电子设备
摘要abst
本申请实施例提供了一种内存泄露定位的辅助信息获取方法及电子设备，涉及计算机技术领域，方法包括：在检测到应用层中的目标函数申请本地内存时，获取目标函数所请求的本地内存的目标地址；基于目标地址和指定地址区间，确定目标函数是否用于实现指定业务功能；在目标函数用于实现指定业务功能时，对目标函数进行回栈处理，得到目标函数的调用信息；调用信息包括目标函数的调用链；调用链指示调用目标函数的上一层函数；基于目标函数的调用信息，确定内存泄露定位的辅助信息。基于此，可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。
权利要求书clms
1.一种内存泄露定位的辅助信息获取方法，其特征在于，所述方法包括：在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址；基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能；在所述目标函数用于实现所述指定业务功能时，对所述目标函数进行回栈处理，得到所述目标函数的调用信息；其中，所述调用信息包括所述目标函数的调用链；所述调用链指示调用所述目标函数的上一层函数；基于所述目标函数的调用信息，确定内存泄露定位的辅助信息。2.根据权利要求1所述的方法，其特征在于，在所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能之前，所述方法还包括：获取在检测周期内申请本地内存的函数中，已进行回栈的且用于实现所述指定业务功能的函数的数目，作为第一数目；所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能，包括：在所述第一数目小于第一阈值时，基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能。3.根据权利要求1所述的方法，其特征在于，所述指定地址区间为：用于实现所述指定业务功能的函数调用的动态链接库对应的地址区间；所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能，包括：在所述目标地址属于所述指定地址区间时，确定所述目标函数用于实现所述指定业务功能；在所述目标地址不属于所述指定地址区间时，确定所述目标函数不是用于所述实现指定业务功能。4.根据权利要求1所述的方法，其特征在于，所述调用信息还包括：所述目标函数的返回地址、名称和源文件信息；所述返回地址指向调用所述目标函数的上一层函数。5.根据权利要求4所述的方法，其特征在于，所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：对所述目标函数的栈帧进行解析，得到所述目标函数的返回地址和符号表；从所述符号表中获取所述返回地址对应的所述目标函数的名称和源文件信息；按照所述目标函数的返回地址，确定调用所述目标函数的上一层函数；对所述目标函数的上一层函数进行回栈处理，直至进行回栈的栈帧的数目大于第二阈值，得到所述目标函数的调用链。6.根据权利要求1所述的方法，其特征在于，所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：采用libunwindstack函数的方式，对所述目标函数进行回栈处理，得到所述目标函数的调用信息。7.根据权利要求6所述的方法，其特征在于，所述采用libunwindstack函数的方式，对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：调用Unwinder对象中的malloc函数，并通过malloc函数的线程执行Unwind方法，以对所述目标函数进行回栈处理，得到所述目标函数的调用信息。8.根据权利要求6所述的方法，其特征在于，在所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息之后，所述方法还包括：将所述目标函数的调用信息存储至FrameData对象；所述基于所述目标函数的调用信息，确定内存泄露定位的辅助信息，包括：针对所述FrameData对象记录的每一函数，如果该函数申请的本地内存未被回收，确定该函数为待分析函数；从所述FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息。9.根据权利要求8所述的方法，其特征在于，在所述从所述FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息之后，所述方法还包括：生成包含内存泄露定位的辅助信息的指定文件。10.根据权利要求1所述的方法，其特征在于，在所述在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址之前，所述方法还包括：当检测到应用层中的应用程序使用的本地内存大于第三阈值时，检测所述应用程序的目标函数是否申请本地内存；在所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息之后，所述方法还包括：当检测到所述应用程序使用的本地内存大于第四阈值时，停止检测所述应用程序的目标函数是否申请本地内存；其中，所述第三阈值小于第四阈值。11.根据权利要求1所述的方法，其特征在于，所述在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址，包括：在检测到应用层的目标函数通过JNI接口申请内存时，确定检测到所述目标函数申请本地内存；其中，所述目标函数为基于Java实现的；获取所述目标函数所请求的本地内存的地址，作为目标地址。12.根据权利要求1-11任一项所述的方法，其特征在于，用于实现所述指定业务功能的函数为：bitmap类型的函数；所述指定地址区间为：bitmap类型的函数调用的libhwui.so库对应的地址区间。13.一种电子设备，其特征在于，包括：一个或多个处理器和存储器；所述存储器与所述一个或多个处理器耦合，所述存储器用于存储计算机程序代码，所述计算机程序代码包括计算机指令，所述一个或多个处理器调用所述计算机指令以使得所述电子设备执行如权利要求1至12中任一项所述的方法。14.一种计算机可读存储介质，其特征在于，包括计算机程序，当所述计算机程序在电子设备上运行时，使得所述电子设备执行如权利要求1至12中任一项所述的方法。15.一种计算机程序产品，其特征在于，所述计算机程序产品包含可执行指令，当所述可执行指令在计算机上执行时，使得计算机执行权利要求1至12中任一项所述的方法。16.一种芯片系统，其特征在于，所述芯片系统应用于电子设备，所述芯片系统包括一个或多个处理器，所述处理器用于调用计算机指令以使得所述电子设备将数据输入芯片系统，并执行权利要求1至12中任一项所述的方法对数据进行处理后输出处理结果。
说明书desc
技术领域本申请涉及计算机技术领域，特别是涉及一种内存泄露定位的辅助信息获取方法及电子设备。背景技术应用程序在终端中运行时，通常使用的是Java堆内存，Java堆内存是指由终端中的Java虚拟机负责分配和管理的内存。由于Java堆内存有限，在应用程序运行的过程中，还可以使用本地内存，本地内存是由终端的操作系统进行分配和管理的内存。然而，应用程序使用的本地内存可能会无法进行释放或回收，会导致内存泄露。内存泄露会导致该应用程序使用的本地内存不断累积，进而导致终端的内存资源耗尽，降低终端的使用性能。发明内容本申请实施例的目的在于提供一种内存泄露定位的辅助信息获取方法及电子设备，以实现通过获取的内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。具体技术方案如下：第一方面，为了达到上述目的，本申请实施例提供了一种内存泄露定位的辅助信息获取方法，所述方法包括：在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址；基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能；在所述目标函数用于实现所述指定业务功能时，对所述目标函数进行回栈处理，得到所述目标函数的调用信息；其中，所述调用信息包括所述目标函数的调用链；所述调用链指示调用所述目标函数的上一层函数；基于所述目标函数的调用信息，确定内存泄露定位的辅助信息。由上可见，本实施例提供的方案中，基于申请本地内存的目标函数的调用信息，确定内存泄露定位的辅助信息。后续，技术人员可以基于内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数，并对本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。本申请的一个实施例中，在所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能之前，所述方法还包括：获取在检测周期内申请本地内存的函数中，已进行回栈的且用于实现所述指定业务功能的函数的数目，作为第一数目；所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能，包括：在所述第一数目小于第一阈值时，基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能。由上可见，本实施例提供的方案中，应用程序中的各个函数申请本地内存的频率较高，在预设的检测周期内对申请本地内存的各个函数进行采样，后续对采样出的用于实现指定业务功能的目标函数进行回栈处理。而不用对各个函数每一次申请本地内存均进行回栈处理，可以节约终端的系统资源，提高终端的使用性能。本申请的一个实施例中，所述指定地址区间为：用于实现所述指定业务功能的函数调用的动态链接库对应的地址区间；所述基于所述目标地址和指定地址区间，确定所述目标函数是否用于实现指定业务功能，包括：在所述目标地址属于所述指定地址区间时，确定所述目标函数用于实现所述指定业务功能；在所述目标地址不属于所述指定地址区间时，确定所述目标函数不是用于所述实现指定业务功能。由上可见，本实施例提供的方案中，确定目标函数是否用于实现指定业务功能。后续，对用于实现指定业务功能的函数进行回栈处理，不用针对应用程序中的每一个申请本地内存的函数均进行回栈处理，可以节约终端的系统资源，提高终端的使用性能。本申请的一个实施例中，所述调用信息还包括：所述目标函数的返回地址、名称和源文件信息；所述返回地址指向调用所述目标函数的上一层函数。本申请的一个实施例中，所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：对所述目标函数的栈帧进行解析，得到所述目标函数的返回地址和符号表；从所述符号表中获取所述返回地址对应的所述目标函数的名称和源文件信息；按照所述目标函数的返回地址，确定调用所述目标函数的上一层函数；对所述目标函数的上一层函数进行回栈处理，直至进行回栈的栈帧的数目大于第二阈值，得到所述目标函数的调用链。由上可见，本实施例提供的方案中，通过对目标函数的栈帧进行解析，得到目标函数的符号表，符号表中包含了目标函数的返回地址、名称和源文件信息，也就是可以利用符号表来获取目标函数的调用信息，基于目标函数的调用信息确定内存泄露定位的辅助信息。后续，可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。本申请的一个实施例中，所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：采用libunwindstack函数的方式，对所述目标函数进行回栈处理，得到所述目标函数的调用信息。由上可见，本实施例提供的方案中，采用libunwindstack函数的方式进行回栈，可以从Native层回栈到Java层。因此，可以获取到申请本地内存的Java层的目标函数的调用信息，并基于目标函数的调用信息，确定内存泄露定位的辅助信息。后续，通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。本申请的一个实施例中，所述采用libunwindstack函数的方式，对所述目标函数进行回栈处理，得到所述目标函数的调用信息，包括：调用Unwinder对象中的malloc函数，并通过malloc函数的线程执行Unwind方法，以对所述目标函数进行回栈处理，得到所述目标函数的调用信息。由上可见，本实施例提供的方案中，通过malloc函数已有的线程执行Unwind方法对目标函数进行回栈，不用创建新的线程，可以节约终端的系统资源，提高终端的使用性能。本申请的一个实施例中，在所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息之后，所述方法还包括：将所述目标函数的调用信息存储至FrameData对象；所述基于所述目标函数的调用信息，确定内存泄露定位的辅助信息，包括：针对所述FrameData对象记录的每一函数，如果该函数申请的本地内存未被回收，确定该函数为待分析函数；从所述FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息。由上可见，本实施例提供的方案中，确定FrameData对象申请的本地内存可能已经被回收的函数，这些函数的调用信息不需要技术人员进行分析，则确定出这些函数外的待分析函数的调用信息为内存泄露定位的辅助信息，降低技术人员对内存泄露定位的辅助信息进行分析的复杂度，提高内存泄露定位的效率。本申请的一个实施例中，在所述从所述FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息之后，所述方法还包括：生成包含内存泄露定位的辅助信息的指定文件。由上可见，本实施例提供的方案中，生成包含内存泄露定位的辅助信息的指定文件。后续，技术人员可以直接查阅指定文件，得到内存泄露定位的辅助信息。而不用从FrameData对象中查阅内存泄露定位的辅助信息，提高内存泄露定位的效率。本申请的一个实施例中，在所述在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址之前，所述方法还包括：当检测到应用层中的应用程序使用的本地内存大于第三阈值时，检测所述应用程序的目标函数是否申请本地内存；在所述对所述目标函数进行回栈处理，得到所述目标函数的调用信息之后，所述方法还包括：当检测到所述应用程序使用的本地内存大于第四阈值时，停止检测所述应用程序的目标函数是否申请本地内存；其中，所述第三阈值小于第四阈值。由上可见，本实施例提供的方案中，对应用程序所使用的本地内存进行检测，并在应用程序所使用的本地内存增大较多时，检测应用程序中的目标函数是否继续申请本地内存。而不用对应用程序中的函数每一次申请本地内存均进行检测，可以节约终端的系统资源，提高终端的使用性能。并且，在检测到应用程序使用的本地内存大于第四阈值时，应用程序使用的本地内存增长较多。获取到的目标函数的调用信息较多，后续基于调用信息确定出的辅助信息能够分析出导致内存泄露的函数，则停止检测应用程序中的目标函数是否申请本地内存，可以节省终端的系统资源，提高终端的使用性能。本申请的一个实施例中，所述在检测到应用层中的目标函数申请本地内存时，获取所述目标函数所请求的本地内存的地址，作为目标地址，包括：在检测到应用层的目标函数通过JNI接口申请内存时，确定检测到所述目标函数申请本地内存；其中，所述目标函数为基于Java实现的；获取所述目标函数所请求的本地内存的地址，作为目标地址。由上可见，本实施例提供的方案中，JNI接口为Java层与Native层进行交互的接口。Java层的应用程序中的目标函数通过JNI接口调用Native层的函数，以及通过JNI接口申请Native层的本地内存。因此，基于目标函数是否通过JNI接口申请内存，可以准确的确定目标函数申请的是否为本地内存。本申请的一个实施例中，用于实现所述指定业务功能的函数为：bitmap类型的函数；所述指定地址区间为：bitmap类型的函数调用的libhwui.so库对应的地址区间。第二方面，本申请实施例还提供了一种电子设备，包括：一个或多个处理器和存储器；所述存储器与所述一个或多个处理器耦合，所述存储器用于存储计算机程序代码，所述计算机程序代码包括计算机指令，所述一个或多个处理器调用所述计算机指令以使得所述电子设备执行上述任一所述的内存泄露定位的辅助信息获取方法。第三方面，本申请实施例还提供了一种计算机可读存储介质，包括计算机程序，当所述计算机程序在电子设备上运行时，使得所述电子设备执行上述任一所述的内存泄露定位的辅助信息获取方法。第四方面，本申请实施例还提供了一种计算机程序产品，所述计算机程序产品包含可执行指令，当所述可执行指令在计算机上执行时，使得计算机执行上述任一所述的内存泄露定位的辅助信息获取方法。第五方面，本申请实施例还提供了一种芯片系统，所述芯片系统应用于电子设备，所述芯片系统包括一个或多个处理器，所述处理器用于调用计算机指令以使得所述电子设备将数据输入芯片系统，并执行上述任一项所述的内存泄露定位的辅助信息获取方法对数据进行处理后输出处理结果。上述第二方面、第三方面、第四方面以及第五方面中各实施例所提供方案的有益效果可参见上述第一方面中各实施例所提供方案的有益效果。附图说明为了更清楚地说明本申请实施例的技术方案，下面将对实施例中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本申请的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动性的前提下，还可以根据这些附图获得其它的附图。图1为本申请实施例提供的一种终端的结构图；图2为本申请实施例提供的一种终端的软件结构框图；图3为本申请实施例提供的一种内存泄露的原理图；图4为本申请实施例提供的第一种内存泄露定位的辅助信息获取方法的流程图；图5为本申请实施例提供的第二种内存泄露定位的辅助信息获取方法的流程图；图6为本申请实施例提供的第三种内存泄露定位的辅助信息获取方法的流程图；图7为本申请实施例提供的第四种内存泄露定位的辅助信息获取方法的流程图；图8为本申请实施例提供的第五种内存泄露定位的辅助信息获取方法的流程图；图9为本申请实施例提供的第六种内存泄露定位的辅助信息获取方法的流程图；图10为本申请实施例提供的一种芯片系统的结构图。具体实施方式为了更好的理解本申请的技术方案，下面结合附图对本申请实施例进行详细描述。为了便于清楚描述本申请实施例的技术方案，在本申请的实施例中，采用了“第一”、“第二”等字样对功能和作用基本相同的相同项或相似项进行区分。例如，第一指令和第二指令是为了区分不同的用户指令，并不对其先后顺序进行限定。本领域技术人员可以理解“第一”、“第二”等字样并不对数量和执行次序进行限定，并且“第一”、“第二”等字样也并不限定一定不同。需要说明的是，本申请中，“示例性地”或者“例如”等词用于表示作例子、例证或说明。本申请中被描述为“示例性地”或者“例如”的任何实施例或设计方案不应被解释为比其他实施例或设计方案更优选或更具优势。确切而言，使用“示例性地”或者“例如”等词旨在以具体方式呈现相关概念。本申请实施例提供的内存泄露定位的辅助信息获取方法可以应用于终端。上述终端可以是手机、平板电脑、笔记本电脑、个人数字助理、智能手表、上网本、可穿戴电子设备、增强现实技术设备、虚拟现实设备、车载设备、智能汽车、机器人、智能眼镜、智能电视等。示例性的，图1示出了终端100的结构图。终端100可以包括处理器110，显示屏120，摄像头130，内部存储器140，用户标识模块卡接口150，通用串行总线接口160，充电管理模块170，电池管理模块171，带有电芯以及电池保护装置的电池172，传感器模块180，移动通信模块190，无线通信模块200，天线1以及天线2等。其中传感器模块180可以包括压力传感器180A，指纹传感器180B，触摸传感器180C，环境光传感器180D等。可以理解的是，本申请实施例示意的结构并不构成对终端100的具体限定。在本申请另一些实施例中，终端100可以包括比图示更多或更少的部件，或者组合某些部件，或者拆分某些部件，或者不同的部件布置。图示的部件可以以硬件，软件或软件和硬件的组合实现。处理器110可以包括一个或多个处理单元，例如：处理器110可以包括中央处理器、应用处理器，调制解调处理器，图形处理器，图像信号处理器，控制器，视频编解码器，数字信号处理器，基带处理器，和/或神经网络处理器等。其中，不同的处理单元可以是独立的部件，也可以集成在一个或多个处理器中。在一些实施例中，终端100也可以包括一个或多个处理器110。其中，控制器可以根据指令操作码和时序信号，产生操作控制信号，完成取指令和执行指令的控制。在其他一些实施例中，处理器110中还可以设置存储器，用于存储指令和数据。示例性地，处理器110中的存储器可以为高速缓冲存储器。该存储器可以保存处理器110刚用过或循环使用的指令或数据。如果处理器110需要再次使用该指令或数据，可从存储器中直接调用。这样就避免了重复存取，减少了处理器110的等待时间，因而提高了终端100处理数据或执行指令的效率。在一些实施例中，处理器110可以包括一个或多个接口。接口可以包括集成电路间接口、集成电路间音频接口、脉冲编码调制接口、通用异步收发传输器接口、移动产业处理器接口、用输入输出接口、SIM卡接口和/或USB接口等。其中，USB接口160是符合USB标准规范的接口，具体可以是Mini USB接口、Micro USB接口、USB Type C接口等。USB接口160可以用于连接充电器为终端100充电，也可以用于终端100与外围设备之间传输数据。该USB接口160也可以用于连接耳机，通过耳机播放音频。可以理解的是，本申请实施例示意的各模块间的接口连接关系，用于示意性说明，并不构成对终端100的结构限定。在本申请另一些实施例中，终端100也可以采用上述实施例中不同的接口连接方式，或多种接口连接方式的组合。终端100的无线通信功能可以通过天线1、天线2、移动通信模块190、无线通信模块200、调制解调处理器以及基带处理器等实现。天线1和天线2用于发射和接收电磁波信号。终端100中的每个天线可用于覆盖单个或多个通信频带。不同的天线还可以复用，以提高天线的利用率。例如：可以将天线1复用为无线局域网的分集天线。在另外一些实施例中，天线可以和调谐开关结合使用。终端100通过GPU，显示屏120，以及应用处理器等实现显示功能。GPU为图像处理的微处理器，连接显示屏120和应用处理器。GPU用于执行数学和几何计算，用于图形渲染。处理器110可包括一个或多个GPU，其执行程序指令以生成或改变显示信息。显示屏120用于显示图像、视频等。显示屏120包括显示面板。显示面板可以采用液晶显示屏、有机发光二极管、有源矩阵有机发光二极体或主动矩阵有机发光二极体、柔性发光二极管、Miniled、MicroLed、Micro-oLed、量子点发光二极管等。在一些实施例中，终端100可以包括1个或多个显示屏120。在本申请的一些实施例中，当显示面板采用OLED、AMOLED、FLED等材料时，上述图1中的显示屏120可以被弯折。这里，上述显示屏120可以被弯折是指显示屏可以在任意部位被弯折到任意角度，并可以在该角度保持，例如，显示屏120可以从中部左右对折。也可以从中部上下对折。终端100的显示屏120可以是一种柔性屏，目前，柔性屏以其独特的特性和巨大的潜力而备受关注。柔性屏相对于传统屏幕而言，具有柔韧性强和可弯曲的特点，可以给用户提供基于可弯折特性的新交互方式，可以满足用户对于终端的更多需求。对于配置有可折叠显示屏的终端而言，终端上的可折叠显示屏可以随时在折叠形态下的小屏和展开形态下大屏之间切换。因此，用户在配置有可折叠显示屏的终端上使用分屏功能，也越来越频繁。终端100可以通过ISP、摄像头130、视频编解码器、GPU、显示屏120以及应用处理器等实现拍摄功能，其中，摄像头130包括前置摄像头和后置摄像头。ISP用于处理摄像头130反馈的数据。例如，拍摄时，打开快门，光线通过镜头被传递到摄像头感光元件上，光信号转换为电信号，摄像头感光元件将电信号传递给ISP处理，转化为肉眼可见的图像。ISP可以对图像的噪点、亮度和色彩进行算法优化，ISP还可以优化拍摄场景的曝光和色温等参数。在一些实施例中，ISP可以设置在摄像头130中。摄像头130用于拍摄照片或视频。物体通过镜头生成光学图像投射到感光元件。感光元件可以是电荷耦合器件或互补金属氧化物半导体光电晶体管。感光元件把光信号转换成电信号，之后将电信号传递给ISP转换成数字图像信号。ISP将数字图像信号输出到DSP加工处理。DSP将数字图像信号转换成标准的红绿蓝，YUV等格式的图像信号。在一些实施例中，终端100可以包括1个或N个摄像头130，N为大于1的正整数。数字信号处理器用于处理数字信号，除了可以处理数字图像信号，还可以处理其他数字信号。例如，当终端100在频点选择时，数字信号处理器用于对频点能量进行傅里叶变换等。视频编解码器用于对数字视频压缩或解压缩。终端100可以支持一种或多种视频编解码器。这样，终端100可以播放或录制多种编码格式的视频，例如：动态图像专家组1、MPEG2、MPEG3和MPEG4。NPU为神经网络计算处理器，通过借鉴生物神经网络结构，例如借鉴人脑神经元之间传递模式，对输入信息快速处理，还可以不断的自学习。通过NPU可以实现终端100的智能认知等应用，例如：图像识别、人脸识别、语音识别、文本理解等。内部存储器140可以用于存储一个或多个计算机程序，该一个或多个计算机程序包括指令。处理器110可以通过运行存储在内部存储器140的上述指令，从而使得终端100执行本申请一些实施例中所提供的内存泄露定位的辅助信息获取方法，以及各种应用以及数据处理等。内部存储器140可以包括存储程序区和存储数据区。其中，存储程序区可存储操作系统；该存储程序区还可以存储一个或多个应用等。存储数据区可存储终端100使用过程中所创建的数据等。此外，内部存储器140可以包括高速随机存取存储器，还可以包括非易失性存储器，例如一个或多个磁盘存储部件，闪存部件，通用闪存存储器等。在一些实施例中，处理器110可以通过运行存储在内部存储器140的指令，和/或存储在设置于处理器110中的存储器的指令，来使得终端100执行本申请实施例中所提供的内存泄露定位的辅助信息获取方法，以及其他应用及数据处理。内部存储器140可以用于存储本申请实施例中提供的内存泄露定位的辅助信息获取方法的相关程序，处理器110可以用于在展示信息时调用内部存储器140中存储的内存泄露定位的辅助信息获取的相关程序，执行本申请实施例的内存泄露定位的辅助信息获取方法。传感器模块180可以包括压力传感器180A、指纹传感器180B、触摸传感器180C、环境光传感器180D等。压力传感器180A用于感受压力信号，可以将压力信号转换成电信号。在一些实施例中，压力传感器180A可以设置于显示屏120。压力传感器180A的种类很多，例如可以是电阻式压力传感器、电感式压力传感器或电容式压力传感器。电容式压力传感器可以是包括至少两个具有导电材料的平行板，当力作用于压力传感器180A，电极之间的电容改变，终端100根据电容的变化确定压力的强度。当触摸操作作用于显示屏120时，终端100根据压力传感器180A检测触摸操作。终端100也可以根据压力传感器180A的检测信号计算触摸的位置。在一些实施例中，作用于相同触摸位置，但不同触摸操作强度的触摸操作，可以对应不同的操作指令。例如：当触摸操作强度小于第一压力阈值的触摸操作作用于短消息应用图标时，执行查看短消息的指令；当触摸操作强度大于或等于第一压力阈值的触摸操作作用于短消息应用图标时，执行新建短消息的指令。指纹传感器180B用于采集指纹。终端100可以利用采集的指纹特性实现解锁、访问应用锁、拍摄和接听来电等功能。触摸传感器180C，也称为触控器件。触摸传感器180C可以设置于显示屏120，由触摸传感器180C与显示屏120组成触摸屏，触摸屏也称为触控屏。触摸传感器180C用于检测作用于其上或其附近的触摸操作。触摸传感器180C可以将检测到的触摸操作传递给应用处理器，以确定触摸事件类型。可以通过显示屏120提供与触摸操作相关的视觉输出。在另一些实施例中，触摸传感器180C也可以设置于终端100的表面，并且与显示屏120设置于不同的位置。环境光传感器180D用于感知环境光亮度。终端100可以根据感知的环境光亮度自适应调节显示屏120亮度。环境光传感器180D也可用于拍摄时自动调节白平衡。环境光传感器180D还可以将设备所处的环境信息传入GPU。环境光传感器180D还用于获取摄像头130采集图像的采集环境的亮度、光比、色温等。图2为本申请实施例适用的终端的一种软件结构框图。终端的软件系统可以采用分层架构，事件驱动架构，微核架构，微服务架构，或云架构。分层架构将终端的软件系统分成若干个层，每一层都有清晰的角色和分工。层与层之间通过软件接口通信。在一些实施例中，可以将软件系统分为五层，分别为应用程序层、应用程序框架层、系统运行层、驱动层和硬件层。应用程序层可以包括一系列应用程序包，应用程序层通过调用应用程序框架层所提供的应用程序接口运行应用程序。如图2所示，应用程序包可以包括多个应用程序，例如，相机、图库、浏览器和音乐等程序。可以理解地，上述的每个应用程序的端口均可以用于接收数据。应用程序框架层为应用程序层的应用程序提供API和编程框架。应用程序框架层包括一些预先定义的函数。如图2所示，应用程序框架层可以包括窗口管理器、内容提供器、视图系统、资源管理器、通知管理器以及动态主机配置协议模块等。应用程序层和应用程序框架层运行在虚拟机中。虚拟机将应用程序层和应用程序框架层的编程文件执行为二进制文件。虚拟机用于执行对象生命周期的管理，堆栈管理，线程管理，安全和异常的管理，以及垃圾回收等功能。系统运行层可以包括多个功能模块。例如：表面管理器，媒体库，三维图形处理库，二维图形引擎等。表面管理器用于对显示子系统进行管理，并且为多个应用程序提供了二维和三维图层的融合。媒体库支持多种常用的音频，视频格式回放和录制，以及静态图像文件等。媒体库可以支持多种音视频编码格式，例如: MPEG4，H.264，MP3，AAC，AMR，JPG，PNG等。三维图形处理库用于实现3D图形绘图，图像渲染，合成，和图层处理等。2D图形引擎是2D绘图的绘图引擎。驱动层是硬件和软件之间的层，用于驱动硬件，使得硬件工作。驱动层中可以安装有多个用于驱动硬件工作的驱动。例如，相机驱动、显示驱动、音频驱动以及传感器驱动等。除此之外，终端还包括硬件层，硬件层可以包括，摄像头、扬声器、CPU和NPU等，硬件层与驱动层连接。在本申请实施例中，参见图3，应用程序层和应用程序框架层可以统称为Java层，Java层包括多个应用程序。各个应用程序均包括多个基于Java实现的函数。这些函数通过Java虚拟机执行。因此，在应用程序运行时使用Java层的Java堆内存。由于Java堆内存有限，该应用程序还可以使用本地层的本地内存。Native通常指的是与特定操作系统密切相关的编程语言和代码，Native层包括系统运行层中的原生的C/C++库，原生的C/C++库可以包括图2中的表面管理器、媒体库、三维图像处理库和二维图像引擎等。通过Native层可以直接访问底层系统资源和硬件。然而，应用程序使用的本地内存可能会无法进行释放或回收，会导致内存泄露。内存泄露会导致该应用程序使用的本地内存不断累积，进而导致终端的内存资源耗尽，降低终端的使用性能。下面对导致内存泄露的应用场景进行举例说明。一种情况下，Java虚拟机负责分配和管理Java堆内存，而本地内存由终端的操作系统分配和管理的。由于Java虚拟机无法直接控制本地内存，因此无法使用Java虚拟机的垃圾回收机制来自动释放本地内存，则需要技术人员手动对本地内存进行分配和释放。如果本地内存没有被正确释放，就会出现内存泄漏。另一种情况下，应用程序中的函数可能会调用Native层的本地资源，例如，文件句柄、数据库连接、网络连接等，这些本地资源占用本地内存。本地资源在使用完后需要及时释放，否则会导致资源泄漏。资源泄漏是指在程序运行过程中，对于已经申请的本地资源没有正确释放或关闭，导致本地资源无法被回收和重新利用的问题。本地资源的泄漏会导致内存泄漏。Java虚拟机提供的一些工具和应用程序接口，用来监控Java堆内存的使用情况，例如，内存分析工具、内存分析器工具）和Java管理扩展等。然而，对于本地内存，应用程序中的函数通过Java本地接口跨语言调用本地函数。由于申请本地内存的函数在Java层，而实际的本地内存等资源分配在Native层。相应的，本地内存的分配和释放发生在Native层，而不是在Java层中。Java层和Native层中间间隔Java虚拟机，Java虚拟机无法直接观察和监控本地内存的使用情况，增加了内存泄露问题的定位难度。需要技术人员依赖操作系统级别的分析工具和技术对本地内存来进行监控和分析，并且需要同时检查Java层的代码和Native层的代码，增加了内存泄露定位的困难和复杂程度，造成内存泄露问题的解决率低等问题。为了解决上述问题，本申请实施例提供了一种内存泄露定位的辅助信息获取方法，可以获取到应用程序中申请本地内存的目标函数的调用信息，基于目标函数的调用信息，确定内存泄露定位的辅助信息。后续，技术人员可以基于内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数，并对本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。接下来，下面通过具体实施例对本申请实施例提供的内存泄露定位的辅助信息获取方案进行详细说明。本申请的一个实施例中，参见图4，图4为本申请实施例提供的一种内存泄露定位的辅助信息获取方法的流程图，该方法包括以下步骤：S401：在检测到应用层中的目标函数申请本地内存时，获取目标函数所请求的本地内存的地址，作为目标地址。S402：基于目标地址和指定地址区间，确定目标函数是否用于实现指定业务功能。S403：在目标函数用于实现指定业务功能时，对目标函数进行回栈处理，得到目标函数的调用信息。其中，调用信息包括目标函数的调用链；调用链指示调用目标函数的上一层函数。S404：基于目标函数的调用信息，确定内存泄露定位的辅助信息。本实施例提供的方案中，基于申请本地内存的目标函数的调用信息，确定内存泄露定位的辅助信息。后续，技术人员可以基于内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数，并对本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。针对步骤S401，终端中安装有多个应用程序，多个应用程序属于应用层。本申请实施例中以应用层为Java层为例进行说明。Java层的应用程序包括：相机、图库、浏览器等。本申请实施例中的应用程序可以为终端中安装的任一个应用程序。应用程序包括多个用于实现不同业务功能的函数，这些函数为使用Java开发实现的。通过终端中的Java虚拟机执行这些函数，以运行该应用程序。在一些实施例中，在步骤S401之前，该方法还可以包括以下步骤：当检测到应用层中的应用程序使用的本地内存大于第三阈值时，检测应用程序的目标函数是否申请本地内存。其中，第三阈值基于应用程序历史运行所使用的本地内存的确定。第三阈值大于应用程序历史运行所使用的本地内存。例如，应用程序历史运行所使用的本地内存为1G，则第三阈值可以设置为2G。当应用程序所使用的本地内存大于第三阈值时，表明应用程序所使用的本地内存相对应用程序历史运行所使用的本地内存增大较多，应用程序中的目标函数所使用的本地内存可能未被回收，可能会导致内存泄露。因此，检测应用程序中的目标函数是否继续申请本地内存。本实施例提供的方案中，对应用程序所使用的本地内存进行检测，并在应用程序所使用的本地内存相对于应用程序历史运行所使用的本地内存增大较多时，检测应用程序中的目标函数是否继续申请本地内存。而不用对应用程序中的函数每一次申请本地内存均进行检测，可以节约终端的系统资源，提高终端的使用性能。在一些实施例中，步骤S401可以包括以下步骤：在检测到应用层的目标函数通过JNI接口申请内存时，确定检测到目标函数申请本地内存；获取目标函数所请求的本地内存的地址，作为目标地址。其中，目标函数为基于Java实现的。JNI接口为Java层与Native层进行交互的接口。例如，Java层的应用程序中的目标函数通过JNI接口调用Native层的函数，以及通过JNI接口申请Native层的本地内存。因此，因此，基于目标函数是否通过JNI接口申请内存，可以准确的确定目标函数申请的是否为本地内存。相应的，当检测到目标函数通过JNI接口申请内存时，则可以确定目标函数申请的是本地内存。并且，目标函数通过内存申请函数申请本地内存。例如，内存申请函数可以为动态内存分配函数。内存申请函数则向目标函数返回所申请的本地内存的目标地址。因此，从malloc函数可以获取到目标函数申请的本地内存的目标地址。针对步骤S402，指定地址区间为：用于实现指定业务功能的函数调用的动态链接库对应的地址区间。针对应用程序使用终端的本地内存的应用场景，指定业务功能为图层功能，指定地址区间为用于实现图层功能的函数所调用的动态链接库。终端的本地内存可以为：直接存储器访问缓存、记忆地图、GPU等处理器的本地内存。在一些实施例中，用于实现指定业务功能的函数为：位图文件类型的函数；指定地址区间为：bitmap类型的函数调用的libhwui.so库对应的地址区间。其中，“libhwui”为共享文件的名称。libhwui.so库为bitmap类型的函数所调用的动态链接库。在一些实施例中，应用程序中包括多个函数，多个函数均可能申请本地内存。如果针对每一个申请本地内存的函数均进行回栈处理，需要使用终端较多的系统资源。为了节约终端的系统资源，可以对用于实现指定业务功能的函数进行回栈处理。相应的，在检测到目标函数申请本地内存时，则需要确定目标函数是否用于实现指定业务功能。如果目标函数申请的本地内存的目标地址属于指定地址区间，表明目标函数调用的动态链接库为用于实现指定业务功能的函数调用的动态链接库，可以确定目标函数用于实现指定业务功能。如果目标函数申请的本地内存的目标地址不属于指定地址区间，表明目标函数调用的动态链接库不是用于实现指定业务功能的函数调用的动态链接库，确定目标函数不是用于实现指定业务功能。在确定目标函数不是用于实现指定业务功能时，可以不进行后续处理。在一些实施例中，应用程序中的各个函数申请本地内存的频率较高，如果对各个函数每一次申请本地内存均进行回栈处理，需要使用终端较多的系统资源。为了节约终端的系统资源，可以在预设的检测周期内对申请本地内存的各个函数进行采样，后续对采样出的用于实现指定业务功能的目标函数进行回栈处理。相应的，在图4的基础上，参见图5，在步骤S402之前，该方法还可以包括以下步骤：S405：获取在检测周期内申请本地内存的函数中，已进行回栈的且用于实现指定业务功能的函数的数目，作为第一数目。相应的，步骤S402可以包括以下步骤：S4021：在第一数目小于第一阈值时，基于目标地址和指定地址区间，确定目标函数是否用于实现指定业务功能。一个检测周期的时长和第一阈值由技术人员根据需求设置。在需要准确的定位出导致内存泄露的函数时，可以将检测周期的时长设置为较小的数值，并将第一阈值设置为较大的数值。例如，检测周期的时长为1秒，第一阈值为3。在需要节约终端的系统资源时，可以将检测周期的时长设置为较大的数值，并将第一阈值设置为较小的数值。例如，检测周期的时长为5秒，第一阈值为1。在一些实施例中，检测周期的时长为1秒，第一阈值为1。在获取到一个检测周期内，申请本地内存的函数中，已进行回栈的且用于实现指定业务功能的函数的第一数目之后，如果第一数目不小于第一阈值，表明获取到的调用信息较多，后续基于调用信息确定出的辅助信息，能够准确的分析出导致内存泄露的函数，则可以不进行后续处理。如果第一数目小于第一阈值，表明获取到的调用信息较少，后续基于调用信息确定出的辅助信息，可能无法准确的分析出导致内存泄露的函数，则继续基于目标地址和指定地址区间，确定目标函数是否用于实现指定业务功能。后续，在确定目标函数用于实现指定业务功能，对目标函数进行回栈处理，以基于回栈得到的目标函数的调用信息，确定内存泄露定位的辅助信息。针对步骤S403，目标函数的调用信息包括：目标函数的调用链、返回地址、名称和源文件信息。调用链表示目标函数与其他函数之间的相互调用关系。返回地址指向调用目标函数的上一层函数。源文件为目标函数的源代码的文件。一种实现方式中，可以采用函数式编程回栈的方式获取目标函数的调用信息。采用FP回栈的方式获取目标函数的调用信息的具体流程如下：在函数调用过程中，针对每一个函数，当该函数被调用时，在栈上创建该函数的栈帧。函数的栈帧也叫过程活动记录，是用来实现过程/函数调用的一种数据结构。栈帧中记录有该函数的参数、返回地址、符号表和局部变量等信息。并且，该函数的栈帧的起始位置为该函数的FP指针，则FP指针能够访问该函数的参数、返回地址、符号表和局部变量等信息。这样，每个函数被调用时都会在栈上创建一个新的栈帧，这样可以形成一个调用栈。当函数调用结束时，会从调用栈上移除该函数的栈帧，则调用栈中的FP指针恢复为上一层函数的FP指针，以便继续执行上一层函数，可以实现函数调用的嵌套和返回的正确性。相应的，采用FP回栈的方式，根据调用栈中目标函数的FP指针，访问目标函数栈帧，得到目标函数的调用信息。另一种实现方式中，采用libunwindstack函数的方式对目标函数进行回栈处理，得到目标函数的调用信息。采用libunwindstack函数的方式进行回栈，可以从Native层回栈到Java层。因此，可以在检测到应用程序出现内存泄露时，获取到目标函数的调用信息，辅助技术人员进行内存泄露定位。通过Hook技术将libunwindstack函数的相关回栈逻辑方法）插入到内存申请函数。Hook技术可以针对内存申请函数在执行前，先执行插入的新函数，插入的新函数也可以称为钩子函数。在一些实施例中，采用libunwindstack函数的方式对目标函数进行回栈处理时，调用Unwinder对象，Unwinder对象包括多个函数。其中，malloc函数为内存申请函数。相应的，调用Unwinder对象中的malloc函数，并通过malloc函数中的线程执行Unwind方法，以对目标函数进行回栈处理，得到目标函数的调用信息。本实施例提供的方案中，通过malloc函数已有的线程执行Unwind方法对目标函数进行回栈，不用创建新的线程，可以节约终端的系统资源，提高终端的使用性能。在一些实施例中，在图4的基础上，参见图6，通过malloc函数中的线程执行Unwind方法包括以下步骤S4031至步骤S4034。S4031：对目标函数的栈帧进行解析，得到目标函数的返回地址和符号表。S4032：从符号表中获取返回地址对应的目标函数的名称和源文件信息。S4033：按照目标函数的返回地址，确定调用目标函数的上一层函数。S4034：对目标函数的上一层函数进行回栈处理，直至进行回栈的栈帧的数目大于第二阈值，得到目标函数的调用链。对目标函数的栈帧进行解析，可以得到目标函数的返回地址和符号表。符号表中记录有返回地址、名称、源文件信息之间的映射关系，则可以从符号表中获取返回地址对应的目标函数的名称和源文件信息。并且，按照目标函数的返回地址可以确定出调用目标函数的上一层函数，并对该上一层函数进行回栈处理，得到该上一层函数的调用信息。然后，对该上一层函数的上一层函数进行回栈处理，以此类推，直至进行回栈的栈帧的数目大于第二阈值，得到目标函数的调用链。第二阈值由技术人员根据需求设置。当需要获取较多的函数的调用信息，提高对内存泄露进行定位的准确性时，第二阈值可以为较大的数值。当需要获取较少的函数的调用信息，节约终端的系统资源时，第二阈值可以为较小的数值。在一些实施例中，通常进行回栈的栈帧的数目达到20时，可以返回至调用目标函数的最上层的函数，因此第二阈值可以为20。本实施例提供的方案中，通过对目标函数的栈帧进行解析，得到目标函数的符号表，符号表中包含了目标函数的返回地址、名称和源文件信息，也就是可以利用符号表来获取目标函数的调用信息，基于目标函数的调用信息确定内存泄露定位的辅助信息。后续，技术人员可以基于内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数，并对本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。在一些实施例中，在图4的基础上，参见图7，在步骤S403之后，该方法还可以包括以下步骤：S406：将目标函数的调用信息存储至FrameData对象。相应的，步骤S404可以包括以下步骤：S4041：针对FrameData对象记录的每一函数，如果该函数申请的本地内存未被回收，确定该函数为待分析函数。S4042：从FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息。采用libunwindstack函数的方式对目标函数进行回栈处理时，得到目标函数的调用信息存储至框架数据对象中。基于FrameData对象中的调用信息，生成内存泄露定位的辅助信息。FrameData对象可以表示为unwindstack::FrameData。一种实现方式中，可以遍历FrameData对象中的调用信息，直接将FrameData对象中的所有调用信息均确定为内存泄露定位的辅助信息。直接将FrameData对象中的所有调用信息均确定为内存泄露定位的辅助信息，会导致增加技术人员对内存泄露定位的辅助信息进行分析的复杂度，降低内存泄露定位的效率。并且，有一些函数申请的本地内存可能已经被回收，不需要技术人员对这些函数的调用信息进行分析。因此，针对FrameData对象记录的每一函数，判断该函数申请的本地内存是否被回收，如果该函数申请的本地内存未被回收，则该函数申请的本地内存可能会造成内存泄露，则确定该函数为待分析函数。进而，从FrameData对象中的调用信息中，获取各待分析函数的调用信息，得到内存泄露定位的辅助信息。本实施例提供的方案中，确定FrameData对象申请的本地内存可能已经被回收的函数，这些函数的调用信息不需要技术人员进行分析，则确定出这些函数外的待分析函数的调用信息为内存泄露定位的辅助信息，降低技术人员对内存泄露定位的辅助信息进行分析的复杂度，提高内存泄露定位的效率。在一些实施例中，为了方便技术人员查阅内存泄露定位的辅助信息，在步骤S4042之后，该方法还可以包括以下步骤：生成包含内存泄露定位的辅助信息的指定文件。后续，技术人员可以直接查阅指定文件，得到内存泄露定位的辅助信息。而不用从FrameData对象中查阅内存泄露定位的辅助信息，提高内存泄露定位的效率。在一些实施例中，在步骤S404之后，该方法还可以包括以下步骤：当检测到应用程序使用的本地内存大于第四阈值时，停止检测应用程序的目标函数是否申请本地内存。其中，第三阈值小于第四阈值。例如，第四阈值可以为第三阈值增长10%后的数值，或者第四阈值可以为第三阈值增长20%后的数值。本实施例中不做具体限定。在检测到应用程序使用的本地内存大于第四阈值时，应用程序使用的本地内存增长较多。获取到的目标函数的调用信息较多，后续基于调用信息确定出的辅助信息能够分析出导致内存泄露的函数，则可以停止检测应用程序中的目标函数是否申请本地内存，可以节省终端的系统资源，提高终端的使用性能。参见图8，图8为本申请实施例提供的一种内存泄露定位的辅助信息获取方法的流程图。应用程序中的目标函数在需要使用本地内存时，调用JNI接口申请Native层的本地内存。Native层的malloc函数确定目标函数申请的本地内存的目标地址。malloc函数中通过Hook技术插入有libunwindstack函数的回栈逻辑。则libunwindstack函数通过目标地址是否落在指定地址区间，判断内存申请是否为Java层的用于实现指定业务功能的目标函数申请的Native内存。如果目标函数申请的本地内存的目标地址属于指定地址区间，确定目标函数用于实现指定业务功能。也就是确定目标函数的本次内存申请为Java-Native内存。如果目标函数的内存申请不是Java-Native内存，则不进行回栈。如果目标函数内存申请是Java-Native内存，通过libunwindstack函数对目标函数进行回栈，回栈的信息为目标函数的调用信息，基于目标函数的调用信息，确定内存泄露定位的辅助信息。进而，将内存泄露定位的辅助信息记录在指定文件中，则回栈结束。后续，技术人员可以基于指定文件中记录的内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数。进而，对导致内存泄露的函数所申请的本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，并进行内存回收，可以避免终端的内存资源耗尽，提高终端的使用性能。参见图9，图9为本申请实施例提供的一种内存泄露定位的辅助信息获取方法的流程图。S901：应用程序中的目标函数通过JNI接口申请本地内存。在本步骤中，Java层的应用程序的目标函数调用JNI接口，向Native层的malloc函数申请本地内存。S902：malloc函数向目标函数返回申请的本地内存的目标地址。在本步骤中，malloc函数确定目标函数申请的本地内存的目标地址，并向目标函数返回其申请的本地内存的目标地址。相应的，后续目标函数使用分配的本地内存。S903：libunwindstack函数从malloc函数获取目标函数申请的本地内存的目标地址。在本步骤中，由于libunwindstack函数的回栈逻辑通过Hook技术插入至malloc函数，则libunwindstack函数可以从malloc函数获取到目标函数申请的本地内存的目标地址。S904：目标地址属于指定地址区间时，确定目标函数用于实现指定业务功能。在本步骤中，用于实现指定业务功能的函数为bitmap类型的函数，指定地址区间为libhwui.so库对应的地址区间。如果目标函数申请的本地内存的目标地址属于指定地址区间，表明目标函数调用的动态链接库为用于实现指定业务功能的函数调用的动态链接库，可以确定目标函数用于实现指定业务功能。S905：对目标函数进行回栈，得到目标函数的调用信息，并基于目标函数的调用信息，确定内存泄露定位的辅助信息。在本步骤中，通过libunwindstack函数对目标函数进行回栈处理，得到目标函数的调用信息。目标函数的调用信息包括：目标函数的调用链、返回地址、名称和源文件信息。本实施例提供的方案中，基于申请本地内存的目标函数的调用信息，确定内存泄露定位的辅助信息。后续，技术人员可以基于内存泄露定位的辅助信息进行分析，确定出导致内存泄露的函数，并对本地内存进行回收。也就是可以通过内存泄露定位的辅助信息，辅助技术人员进行内存泄露定位，避免终端的内存资源耗尽，提高终端的使用性能。具体实现中，本申请还提供一种电子设备，该电子设备包括一个或多个处理器和存储器；存储器与一个或多个处理器耦合，存储器用于存储计算机程序代码，计算机程序代码包括计算机指令，一个或多个处理器调用计算机指令以使得电子设备执行上述方法实施例中的部分或全部步骤。本申请还提供一种计算机可读存储介质，包括计算机程序，当计算机程序在电子设备上运行时，使得电子设备执行上述方法实施例中的部分或全部步骤。上述的存储介质可为磁碟、光盘、只读存储器或随机存储器等。具体实现中，本申请实施例还提供了一种计算机程序产品，上述计算机程序产品包含可执行指令，当可执行指令在计算机上执行时，使得计算机执行上述方法实施例中的部分或全部步骤。如图10所示，本申请还提供了一种芯片系统，该芯片系统应用于电子设备，芯片系统包括一个或多个处理器1001，处理器1001用于调用计算机指令以使得电子设备将待处理的数据输入芯片系统，芯片系统基于本申请实施例提供的内存泄露定位的辅助信息获取方法对数据进行处理后输出处理结果。在一种可能的实现方式中，芯片系统还包括输入和输出接口，用于输入和输出数据。本申请公开的机制的各实施例可以被实现在硬件、软件、固件或这些实现方法的组合中。本申请的实施例可实现为在可编程系统上执行的计算机程序或程序代码，该可编程系统包括至少一个处理器、存储系统、至少一个输入设备以及至少一个输出设备。可将程序代码应用于输入指令，以执行本申请描述的各功能并生成输出信息。可以按已知方式将输出信息应用于一个或多个输出设备。为了本申请的目的，处理系统包括具有诸如例如数字信号处理器、微控制器、专用集成电路或微处理器之类的处理器的任何系统。程序代码可以用高级程序化语言或面向对象的编程语言来实现，以便与处理系统通信。在需要时，也可用汇编语言或机器语言来实现程序代码。事实上，本申请中描述的机制不限于任何特定编程语言的范围。在任一情形下，该语言可以是编译语言或解释语言。在一些情况下，所公开的实施例可以以硬件、固件、软件或其任何组合来实现。所公开的实施例还可以被实现为由一个或多个暂时或非暂时性机器可读存储介质承载或存储在其上的指令，其可以由一个或多个处理器读取和执行。例如，指令可以通过网络或通过其他计算机可读介质分发。因此，机器可读介质可以包括用于以机器可读的形式存储或传输信息的任何机制，包括但不限于，软盘、光盘、光碟、光盘只读存储器、磁光盘、只读存储器、随机存储器、可擦除可编程只读存储器、电可擦除可编程只读存储器、磁卡或光卡、闪存、或用于利用因特网以电、光、声或其他形式的传播信号来传输信息的有形的机器可读存储器。因此，机器可读介质包括适合于以机器可读的形式存储或传输电子指令或信息的任何类型的机器可读介质。在附图中，可以以特定布置和/或顺序示出一些结构或方法特征。然而，应该理解，可能不需要这样的特定布置和/或排序。而是，在一些实施例中，这些特征可以以不同于说明书附图中所示的方式和/或顺序来布置。另外，在特定图中包括结构或方法特征并不意味着暗示在所有实施例中都需要这样的特征，并且在一些实施例中，可以不包括这些特征或者可以与其他特征组合。需要说明的是，本申请各设备实施例中提到的各单元/模块都是逻辑单元/模块，在物理上，一个逻辑单元/模块可以是一个物理单元/模块，也可以是一个物理单元/模块的一部分，还可以以多个物理单元/模块的组合实现，这些逻辑单元/模块本身的物理实现方式并不是最重要的，这些逻辑单元/模块所实现的功能的组合才是解决本申请所提出的技术问题的关键。此外，为了突出本申请的创新部分，本申请上述各设备实施例并没有将与解决本申请所提出的技术问题关系不太密切的单元/模块引入，这并不表明上述设备实施例并不存在其它的单元/模块。需要说明的是，在本专利的示例和说明书中，诸如第一和第二等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个”限定的要素，并不排除在包括所述要素的过程、方法、物品或者设备中还存在另外的相同要素。虽然通过参照本申请的某些优选实施例，已经对本申请进行了图示和描述，但本领域的普通技术人员应该明白，可以在形式上和细节上对其作各种改变，而不偏离本申请的精神和范围。

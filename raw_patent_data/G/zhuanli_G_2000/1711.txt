标题title
基于前后台通信的数据双向映射方法及装置
摘要abst
基于前后台通信的数据双向映射方法及装置，采用声明枚举类型的方式，对待转换的整型数据进行定义；创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。本发明大量降低内存的使用，提高程序执行效率；相对map实现方式，可以降低2～3倍的内存使用；代码量少，管理使用扩展方便。
权利要求书clms
1.基于前后台通信的数据双向映射方法，其特征在于，包括：步骤，采用声明枚举类型的方式，对待转换的整型数据进行定义；步骤，创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；步骤，进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；步骤，定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；步骤，通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。2.根据权利要求1所述的基于前后台通信的数据双向映射方法，其特征在于，步骤中，每增加一组存在映射关系的数据对，增加一个所述映射容器；通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。3.根据权利要求1所述的基于前后台通信的数据双向映射方法，其特征在于，步骤中，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。4.根据权利要求1所述的基于前后台通信的数据双向映射方法，其特征在于，还包括步骤，定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。5.根据权利要求4所述的基于前后台通信的数据双向映射方法，其特征在于，将步骤，步骤，步骤，步骤，步骤和步骤的代码封装进一个类中；采用访问者方式访问类提供的转换方法。6.基于前后台通信的数据双向映射装置，其特征在于，包括：声明枚举模块，用于采用声明枚举类型的方式，对待转换的整型数据进行定义；映射容器创建模块，用于创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；初始化函数定义模块，用于进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；私有调用模块，用于定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；数据对象分析模块，用于通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。7.根据权利要求6所述的基于前后台通信的数据双向映射装置，其特征在于，所述映射容器创建模块中，每增加一组存在映射关系的数据对，增加一个所述映射容器；所述映射容器创建模块中，通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器创建模块中，所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。8.根据权利要求6所述的基于前后台通信的数据双向映射装置，其特征在于，所述私有调用模块中，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。9.根据权利要求6所述的基于前后台通信的数据双向映射装置，其特征在于，还包括公有调用模块，用于定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。10.根据权利要求9所述的基于前后台通信的数据双向映射装置，其特征在于，还包括代码封装模块，用于将所述声明枚举模块，所述映射容器创建模块，所述初始化函数定义模块，所述私有调用模块，所述数据对象分析模块和所述公有调用模块的代码封装进一个类中；采用访问者方式访问类提供的转换方法。
说明书desc
技术领域本发明属于通信技术领域，具体涉及一种基于前后台通信的数据双向映射方法及装置。背景技术整型数值与字符串数据之间的映射是一般软件的基本功能，几乎所有涉及前后台通信的软件都具有这方面的需求；前后台之间的传输数据要求用最少的数据来表示最多的信息，一般使用整型值传输，在前台映射转换后显示。现阶段，数据映射方式一般有两种：一种是在需要展示的地方用if else或switch case判断，然后进行显示；这种方法维护起来非常不方便，一致性也得不到保证；另一种是使用map容器进行映射转换，以整型值作为key，字符串作为值，类似错误码转换成错误提示；这种方式虽然管理起来比上一种方式方便，但由于key值基本是0,1,2、0,1,2；这就导致需要大量的map容器，而且顺序也不能灵活控制。发明内容为此，本发明提供一种基于前后台通信的数据双向映射方法及装置，解决传统技术内存的使用较大，不方便使用和维护的问题。为了实现上述目的，本发明提供如下技术方案：第一方面，提供一种基于前后台通信的数据双向映射方法，包括：步骤，采用声明枚举类型的方式，对待转换的整型数据进行定义；步骤，创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；步骤，进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；步骤，定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；步骤，通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。作为基于前后台通信的数据双向映射方法优选方案，步骤中，每增加一组存在映射关系的数据对，增加一个所述映射容器；通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。作为基于前后台通信的数据双向映射方法优选方案，步骤中，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。作为基于前后台通信的数据双向映射方法优选方案，还包括步骤，定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。作为基于前后台通信的数据双向映射方法优选方案，将步骤，步骤，步骤，步骤，步骤和步骤的代码封装进一个类中；采用访问者方式访问类提供的转换方法。第二方面，提供一种基于前后台通信的数据双向映射装置，包括：声明枚举模块，用于采用声明枚举类型的方式，对待转换的整型数据进行定义；映射容器创建模块，用于创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；初始化函数定义模块，用于进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；私有调用模块，用于定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；数据对象分析模块，用于通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。作为基于前后台通信的数据双向映射装置优选方案，所述映射容器创建模块中，每增加一组存在映射关系的数据对，增加一个所述映射容器；所述映射容器创建模块中，通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器创建模块中，所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。作为基于前后台通信的数据双向映射装置优选方案，所述私有调用模块中，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。作为基于前后台通信的数据双向映射装置优选方案，还包括公有调用模块，用于定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。作为基于前后台通信的数据双向映射装置优选方案，还包括代码封装模块，用于将所述声明枚举模块，所述映射容器创建模块，所述初始化函数定义模块，所述私有调用模块，所述数据对象分析模块和所述公有调用模块的代码封装进一个类中；采用访问者方式访问类提供的转换方法。本发明第三方面提供一种非暂态计算机可读存储介质，所述计算机可读存储介质中存储有基于前后台通信的数据双向映射方法的程序代码，所述程序代码包括用于执行第一方面或其任意可能实现方式的基于前后台通信的数据双向映射方法的指令。本发明第四方面提供一种电子设备，包括：存储器和处理器；所述处理器和所述存储器通过总线完成相互间的通信；所述存储器存储有可被所述处理器执行的程序指令，所述处理器调用所述程序指令能够执行第一方面或其任意可能实现方式的基于前后台通信的数据双向映射方法。本发明的有益效果如下，采用声明枚举类型的方式，对待转换的整型数据进行定义；创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。本发明大量降低内存的使用，提高程序执行效率；相对map的实现方式，可以降低2～3倍的内存使用；代码量少，管理使用方便，扩展方便。附图说明为了更清楚地说明本发明的实施方式或现有技术中的技术方案，下面将对实施方式或现有技术描述中所需要使用的附图作简单地介绍。显而易见地，下面描述中的附图仅仅是示例性的，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据提供的附图引申获得其他的实施附图。本说明书所绘示的结构、比例、大小等，均仅用以配合说明书所揭示的内容，以供熟悉此技术的人士了解与阅读，并非用以限定本发明可实施的限定条件，故不具技术上的实质意义，任何结构的修饰、比例关系的改变或大小的调整，在不影响本发明所能产生的功效及所能达成的目的下，均应仍落在本发明所揭示的技术内容能涵盖的范围内。图1为本发明实施例提供的基于前后台通信的数据双向映射方法流程示意图；图2为本发明实施例提供的基于前后台通信的数据双向映射装置示意图。具体实施方式以下由特定的具体实施例说明本发明的实施方式，熟悉此技术的人士可由本说明书所揭露的内容轻易地了解本发明的其他优点及功效，显然，所描述的实施例是本发明一部分实施例，而不是全部的实施例。基于本发明中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都属于本发明保护的范围。实施例1参见图1，本发明实施例1提供一种基于前后台通信的数据双向映射方法，包括：S1，采用声明枚举类型的方式，对待转换的整型数据进行定义；S2，创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；S3，进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；S4，定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；S5，通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。本实施例中，在步骤S1，将待转换的整型数据以定义枚举类型的方式定义，以日志等级为例，1表示调试日志，2表示一般日志，3表示告警日志，4表示重要日志，5表示紧急日志；将这些日志等级定义成枚举类型，方便管理，具体实现的代码如下：本实施例中，步骤S2，每增加一组存在映射关系的数据对，增加一个所述映射容器；通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。具体的，在步骤S1中，创建用于转换的映射容器，映射容器中存放的是数据对，以后每增加一组存在映射关系的数据对，即增加一个映射容器；如第一映射容器中存放的是日志等级的映射关系，当需要增加一个存放关于用户角色之间的映射关系的第二映射容器时，复制存放日志等级的容器，修改其名称即可，实现代码如下：“std::array＜std::pair＜QString,uint8_t＞,5＞m_log_level；///日志等级std::array＜std::pair＜QString,uint8_t＞,2＞m_user_account；///用户账户”。其中，使用std::array＜std::pair＜std::string,int＞＞代替map做为存放转换数据的映射容器；key是字符串而不是整型数值；大量降低内存的使用，提高程序执行效率；相对map的实现方式，可以降低2～3倍的内存使用。本实施例中，在步骤S3，定义初始化函数，为映射容器的数据赋予初始值，建立整型数值与字符串之间的一一对应关系；具体实现代码如下：本实施例中，在步骤S4，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。具体的，通过定义两个用模板实现的私有调用接口，私有调用接口功能为遍历映射容器中的每一数据对，找到与输入参数相对应的另一个数据；私有调用接口含两个参数，第一参数即映射容器的其中一个数据，第二参数即映射容器；且由于映射容器是模板类型，所以在调用的时候自动匹配。使用模板方法来实现通用的转换函数；所有转换都可以享受到模板转换带来的好处，具体实现代码如下：本实施例中，还包括步骤S6，定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。具体实现代码如下：本实施例中，将步骤S1，步骤S2，步骤S3，步骤S4，步骤S5和步骤S6的代码封装进一个类中；采用访问者方式访问类提供的转换方法。由于所有转换的代码都在同一个文件中，检索和改动起来非常方便。综上所述，本发明实施例采用声明枚举类型的方式，对待转换的整型数据进行定义；创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。其中，每增加一组存在映射关系的数据对，增加一个所述映射容器；通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。将代码封装进一个类中；采用访问者方式访问类提供的转换方法。本发明代码量少，使用模板可以成倍的降低代码量，把工作交给编译器，也可以兼容各种类型；使用方便，根据输入类型的不同，自动转换出对应的数据；相同的函数名，输入整型即输出字符串，输入字符串即输出整型；扩展方便，每次增加新的转换，只需要新增几行相似的代码，稍微改动一下即可，且不会影响到之前的转换，符合增加代码来增加功能的准则。需要说明的是，本公开实施例的方法可以由单个设备执行，例如一台计算机或服务器等。本实施例的方法也可以应用于分布式场景下，由多台设备相互配合来完成。在这种分布式场景的情况下，这多台设备中的一台设备可以只执行本公开实施例的方法中的某一个或多个步骤，这多台设备相互之间会进行交互以完成所述的方法。需要说明的是，上述对本公开的一些实施例进行了描述。其它实施例在所附权利要求书的范围内。在一些情况下，在权利要求书中记载的动作或步骤可以按照不同于上述实施例中的顺序来执行并且仍然可以实现期望的结果。另外，在附图中描绘的过程不一定要求示出的特定顺序或者连续顺序才能实现期望的结果。在某些实施方式中，多任务处理和并行处理也是可以的或者可能是有利的。实施例2参见图2，本发明实施例2提供一种基于前后台通信的数据双向映射装置，包括：声明枚举模块1，用于采用声明枚举类型的方式，对待转换的整型数据进行定义；映射容器创建模块2，用于创建映射容器，所述映射容器中存放有一组存在映射关系的数据对，所述数据对包括整型数值与字符串；初始化函数定义模块3，用于进行初始化函数定义，为所述映射容器的所述数据对赋予初始值，建立整型数值与字符串之间的一一对应关系；私有调用模块4，用于定义私有调用接口，获取输入参数，根据输入参数找到对应的所述私有调用接口；数据对象分析模块5，用于通过所述私有调用接口遍历所述映射容器中的每一数据对，找到与输入参数相对应的数据对象，将与输入参数相对应的数据对象进行输出。本实施例中，所述映射容器创建模块2中，每增加一组存在映射关系的数据对，增加一个所述映射容器；所述映射容器创建模块2中，通过复制创建完毕的存放第一映射关系的第一映射容器，得到存放第二映射关系的第二映射容器；所述映射容器创建模块2中，所述映射容器的定义为：std::array＜std::pair＜std::string,int＞＞。本实施例中，所述私有调用模块4中，所述私有调用接口通过模板实现，所述私有调用接口包括第一参数和第二参数，第一参数为所述映射容器中的一个数据，第二参数为所述映射容器。本实施例中，还包括公有调用模块6，用于定义公有调用接口，所述公有调用接口含有调用所述私有调用接口的代码。本实施例中，还包括代码封装模块7，用于将所述声明枚举模块，所述映射容器创建模块，所述初始化函数定义模块，所述私有调用模块，所述数据对象分析模块和所述公有调用模块的代码封装进一个类中；采用访问者方式访问类提供的转换方法。需要说明的是，上述装置各模块之间的信息交互、执行过程等内容，由于与本申请实施例1中的方法实施例基于同一构思，其带来的技术效果与本申请方法实施例相同，具体内容可参见本申请前述所示的方法实施例中的叙述，此处不再赘述。实施例3本发明实施例3提供一种非暂态计算机可读存储介质，所述计算机可读存储介质中存储有基于前后台通信的数据双向映射方法的程序代码，所述程序代码包括用于执行实施例1或其任意可能实现方式的基于前后台通信的数据双向映射方法的指令。计算机可读存储介质可以是计算机能够存取的任何可用介质或者是包含一个或多个可用介质集成的服务器、数据中心等数据存储设备。所述可用介质可以是磁性介质，、光介质、或者半导体介质)等。实施例4本发明实施例4提供一种电子设备，包括：存储器和处理器；所述处理器和所述存储器通过总线完成相互间的通信；所述存储器存储有可被所述处理器执行的程序指令，所述处理器调用所述程序指令能够执行实施例1或其任意可能实现方式的基于前后台通信的数据双向映射方法。具体的，处理器可以通过硬件来实现也可以通过软件来实现，当通过硬件实现时，该处理器可以是逻辑电路、集成电路等；当通过软件来实现时，该处理器可以是一个通用处理器，通过读取存储器中存储的软件代码来实现，该存储器可以集成在处理器中，可以位于所述处理器之外，独立存在。在上述实施例中，可以全部或部分地通过软件、硬件、固件或者其任意组合来实现。当使用软件实现时，可以全部或部分地以计算机程序产品的形式实现。所述计算机程序产品包括一个或多个计算机指令。在计算机上加载和执行所述计算机程序指令时，全部或部分地产生按照本发明实施例所述的流程或功能。所述计算机可以是通用计算机、专用计算机、计算机网络、或者其他可编程装置。所述计算机指令可以存储在计算机可读存储介质中，或者从一个计算机可读存储介质向另一个计算机可读存储介质传输，例如，所述计算机指令可以从一个网站站点、计算机、服务器或数据中心通过有线)或无线方式向另一个网站站点、计算机、服务器或数据中心进行传输。显然，本领域的技术人员应该明白，上述的本发明的各模块或各步骤可以用通用的计算装置来实现，它们可以集中在单个的计算装置上，或者分布在多个计算装置所组成的网络上，可选地，它们可以用计算装置可执行的程序代码来实现，从而，可以将它们存储在存储装置中由计算装置来执行，并且在某些情况下，可以以不同于此处的顺序执行所示出或描述的步骤，或者将它们分别制作成各个集成电路模块，或者将它们中的多个模块或步骤制作成单个集成电路模块来实现。这样，本发明不限制于任何特定的硬件和软件结合。虽然，上文中已经用一般性说明及具体实施例对本发明作了详尽的描述，但在本发明基础上，可以对之作一些修改或改进，这对本领域技术人员而言是显而易见的。因此，在不偏离本发明精神的基础上所做的这些修改或改进，均属于本发明要求保护的范围。

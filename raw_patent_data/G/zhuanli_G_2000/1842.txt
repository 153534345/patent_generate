标题title
死锁检测方法、装置、设备和存储介质
摘要abst
本申请一个或多个实施例提供一种死锁检测方法、装置、设备和存储介质，该方法应用于任一目标分片管理节点上运行的检测客户端，包括：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；如果锁等待时长达到死锁检测阈值，则生成与第一子事务对应的锁等待关系，并将锁等待关系发送给与检测客户端对应的检测服务端，以使检测服务端响应于接收到的锁等待关系，基于锁等待关系更新本地维护的全局锁等待关系，并基于全局锁等待关系针对第一子事务进行死锁检测，以及返回死锁检测结果；响应于接收到的死锁检测结果，在基于死锁检测结果确定第一子事务触发死锁时，从锁等待队列中删除第一子事务。
权利要求书clms
1.一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述方法应用于任一目标分片管理节点上运行的检测客户端；所述方法包括：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果；响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。2.根据权利要求1所述的方法，所述方法还包括：在基于所述死锁检测结果确定所述第一子事务触发死锁时，输出所述第一子事务触发死锁的提示信息。3.根据权利要求1所述的方法，所述方法还包括：响应于所述第一子事务执行完成，向所述检测服务端发送与所述锁等待关系对应的删除请求，以使所述检测服务端响应于所述删除请求，从所述全局锁等待关系中删除所述锁等待关系。4.根据权利要求1所述的方法，所述方法还包括：检测所述锁等待时长是否达到预设的锁等待超时阈值；如果所述锁等待时长达到所述锁等待超时阈值，则从所述锁等待队列中删除所述第一子事务。5.根据权利要求1或4所述的方法，所述方法还包括：在从所述锁等待队列中删除所述第一子事务后，针对所述写事务进行事务回滚。6.根据权利要求5所述的方法，所述方法还包括：在针对所述写事务进行事务回滚后，确定所述写事务的剩余执行时长是否超过预设的事务重试阈值，如果是，针对所述写事务进行事务重试。7.根据权利要求1所述的方法，所述数据库包括图数据库。8.根据权利要求1所述的方法，所述数据库为分布式数据库；所述目标电子设备为从承载所述分布式数据库的节点设备中选举出的主设备。9.根据权利要求1所述的方法，所述检测服务端运行在所述若干分片管理节点中指定的分片管理节点上。10.根据权利要求9所述的方法，所述指定的分片管理节点为用于管理所述数据库中存储的首个数据分片的分片管理节点。11.一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述方法应用于所述检测服务端；所述方法包括：接收任一目标分片管理节点上运行的检测客户端发送的与第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的所述第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。12.根据权利要求11所述的方法，所述方法还包括：在确定所述第一子事务触发死锁时，从所述全局锁等待关系中删除所述锁等待关系。13.根据权利要求11所述的方法，所述锁等待关系包括所述第一子事务的事务标识和持有锁的第二子事务的事务标识之间的关联关系；所述全局锁等待关系包括基于各个检测客户端发送的锁等待关系构建的有向图；所述有向图中的顶点为子事务的事务标识；所述有向图中的有向边的方向为由等待锁的子事务的事务标识，指向持有锁的子事务的事务标识；所述基于所述全局锁等待关系针对所述第一子事务进行死锁检测，包括：针对所述有向图进行环路检测，以检测所述有向图中是否存在以所述第一子事务的事务标识为起点的环路；如果所述有向图中存在所述环路，则确定所述第一子事务触发死锁。14.根据权利要求13所述的方法，所述针对所述有向图进行环路检测，以确定所述有向图中是否存在以所述第一子事务的事务标识为起点的环路，包括：基于深度优先遍历算法，将所述第一子事务的事务标识作为遍历起点，针对所述有向图进行遍历，以检测所述有向图中是否存在以所述第一子事务的事务标识为起点的环路。15.一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测程序；所述方法应用于任一目标分片管理节点上运行的检测程序；所述方法包括：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系；基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。16.根据权利要求15所述的方法，所述方法还包括：在确定所述第一子事务触发死锁时，删除所述锁等待关系。17.根据权利要求15所述的方法，所述锁等待关系包括所述第一子事务的事务标识和持有锁的第二子事务的事务标识之间的关联关系；所述全局锁等待关系包括基于各个检测客户端发送的锁等待关系构建的有向图；所述有向图中的顶点为子事务的事务标识；所述有向图中的有向边的方向为由等待锁的子事务的事务标识，指向持有锁的子事务的事务标识；所述基于所述全局锁等待关系针对所述第一子事务进行死锁检测，包括：针对所述有向图进行环路检测，以检测所述有向图中是否存在以所述第一子事务的事务标识为起点的环路；如果所述有向图中存在所述环路，则确定所述第一子事务触发死锁。18.根据权利要求17所述的方法，所述针对所述有向图进行环路检测，以确定所述有向图中是否存在以所述第一子事务的事务标识为起点的环路，包括：基于深度优先遍历算法，将所述第一子事务的事务标识作为遍历起点，针对所述有向图进行遍历，以检测所述有向图中是否存在以所述第一子事务的事务标识为起点的环路。19.根据权利要求15所述的方法，所述方法还包括：在确定所述第一子事务触发死锁时，输出所述第一子事务触发死锁的提示信息。20.根据权利要求15所述的方法，所述方法还包括：响应于所述第一子事务执行完成，删除所述锁等待关系。21.根据权利要求15所述的方法，所述方法还包括：检测所述锁等待时长是否达到预设的锁等待超时阈值；如果所述锁等待时长达到所述锁等待超时阈值，则从所述锁等待队列中删除所述第一子事务。22.根据权利要求15或21所述的方法，所述方法还包括：在从所述锁等待队列中删除所述第一子事务后，针对所述写事务进行事务回滚。23.根据权利要求22所述的方法，所述方法还包括：在针对所述写事务进行事务回滚后，确定所述写事务的剩余执行时长是否超过预设的事务重试阈值，如果是，针对所述写事务进行事务重试。24.根据权利要求15所述的方法，所述数据库包括图数据库。25.根据权利要求15所述的方法，所述数据库为分布式数据库；所述目标电子设备为从承载所述分布式数据库的节点设备中选举出的主设备。26.一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于任一目标分片管理节点上运行的检测客户端；所述装置包括：检测模块，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果；删除模块，响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。27.一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于所述检测服务端；所述装置包括：接收模块，接收任一目标分片管理节点上运行的检测客户端发送的与第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的所述第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；检测模块，响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；发送模块，将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。28.一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测程序；所述装置应用于任一目标分片管理节点上运行的检测程序；所述装置包括：时长检测模块，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系；死锁检测模块，基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；删除模块，在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。29.一种电子设备，包括：处理器；用于存储处理器可执行指令的存储器；其中，所述处理器通过运行所述可执行指令以实现如权利要求1至25中任一项所述的方法。30.一种计算机可读存储介质，其上存储有计算机指令，该指令被处理器执行时实现如权利要求1至25中任一项所述的方法。
说明书desc
技术领域本申请一个或多个实施例涉及数据库技术领域，尤其涉及一种死锁检测方法、装置、设备和存储介质。背景技术数据库是指按照数据结构来组织、存储和管理数据的系统，它通常被用来存储有组织的数据。事务是数据库中的一个重要概念，它提供了一种逻辑上的操作单位，以保证数据库操作的正确性和完整性。通过使用事务，可以将一系列的读操作和写操作组合在一起，并将其作为一个整体进行处理。数据库锁是一种用于控制对数据的并发访问的机制，它用于维护数据库操作的一致性和隔离性，防止多个事务之间产生冲突和数据不一致的情况。在并发环境下，多个事务可能同时读取或修改同一数据，如果没有合适的控制机制，就会导致数据丢失、脏读、不可重复读和幻读等问题。数据库锁的作用就是通过对数据进行加锁和解锁的操作，限制事务之间的并发访问，保证数据的正确性。当一个事务修改某一数据时，需要先对该数据进行加锁，并由这个事务持有锁，再在这个事务提交后，对该数据进行解锁，即由这个事务释放锁。当多个事务同时修改同一数据时，如果这些事务无法正确、有序地持有锁和释放锁，就可能导致死锁的发生。在这种情况下，事务的流程会被阻塞，导致系统无法继续正常工作。因此，如何实现死锁检测，也就成为了备受关注的问题。发明内容本申请一个或多个实施例提供技术方案如下：本申请提供一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述方法应用于任一目标分片管理节点上运行的检测客户端；所述方法包括：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果；响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述方法应用于所述检测服务端；所述方法包括：接收任一目标分片管理节点上运行的检测客户端发送的与所述第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种死锁检测方法，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测程序；所述方法应用于任一目标分片管理节点上运行的检测程序；所述方法包括：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系；基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于任一目标分片管理节点上运行的检测客户端；所述装置包括：检测模块，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果；删除模块，响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于所述检测服务端；所述装置包括：接收模块，接收任一目标分片管理节点上运行的检测客户端发送的与所述第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；检测模块，响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；发送模块，将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种死锁检测装置，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测程序；所述装置应用于任一目标分片管理节点上运行的检测程序；所述装置包括：时长检测模块，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系；死锁检测模块，基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；删除模块，在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。本申请还提供一种电子设备，包括：处理器；用于存储处理器可执行指令的存储器；其中，所述处理器通过运行所述可执行指令以实现如上述任一项所述方法的步骤。本申请还提供一种计算机可读存储介质，其上存储有计算机指令，该指令被处理器执行时实现如上述任一项所述方法的步骤。在上述技术方案中，可以由各个分片管理节点上运行的检测客户端检测出锁等待队列中锁等待时长达到死锁检测阈值的子事务，并将生成的与该子事务对应的锁等待关系发送给与检测客户端对应的检测服务端，由该检测服务端基于该锁等待关系更新全局锁等待关系，并基于更新后的全局锁等待关系针对该子事务进行死锁检测，如果检测到该子事务触发死锁，则该检测客户端可以从该锁等待队列中删除该子事务。采用上述方式，在实现死锁检测，避免写事务的流程被阻塞的过程中，可以仅针对锁等待时长达到死锁检测阈值的子事务进行死锁检测，从而可以过滤掉一部分非必要的死锁检测。此外，可以根据实际的死锁检测需求调整死锁检测阈值，以此控制死锁检测的灵敏度。附图说明下面将对示例性实施例的描述中所需要使用的附图进行说明，其中：图1是本申请一示例性实施例示出的一种数据库系统的示意图。图2是本申请一示例性实施例示出的另一种数据库系统的示意图。图3是本申请一示例性实施例示出的一种死锁检测方法的流程图。图4是本申请一示例性实施例示出的一种目标电子设备的示意图。图5是本申请一示例性实施例示出的一种全局锁等待关系的示意图。图6是本申请一示例性实施例示出的另一种死锁检测方法的流程图。图7是本申请一示例性实施例示出的另一种死锁检测方法的流程图。图8是本申请一示例性实施例示出的另一种目标电子设备的示意图。图9是本申请一示例性实施例示出的一种设备的结构示意图。图10是本申请一示例性实施例示出的一种死锁检测装置的框图。图11是本申请一示例性实施例示出的另一种死锁检测装置的框图。图12是本申请一示例性实施例示出的另一种死锁检测装置的框图。具体实施方式这里将详细地对示例性实施例进行说明，其示例表示在附图中。下面的描述涉及附图时，除非另有表示，不同附图中的相同数字表示相同或者相似的要素。以下示例性实施例中所描述的实施方式并不代表与本申请一个或多个实施例相一致的所有实施方式。相反，它们仅是与本申请一个或多个实施例的一些方面相一致的例子。需要说明的是，在其他实施例中并不一定按照本申请示出和描述的顺序来执行相应方法的步骤。在一些其他实施例中，其方法所包括的步骤可以比本申请所描述的更多或者更少。此外，本申请中所描述的单个步骤，在其他实施例中可能被分解为多个步骤进行描述；而本申请中所描述的多个步骤，在其他实施例中也可能被合并为单个步骤进行描述。数据库分片是一种在数据库中将数据分割并存储在多个节点上的技术，它旨在解决单个数据库无法处理大规模数据和高并发访问的问题。在数据库分片中，数据被划分成多个数据分片，每个数据分片包含了数据的一部分；每个数据分片可以被存储在不同的节点上。通常，每个数据分片可以被独立地处理。写事务是指在数据库中执行修改操作的过程。写事务可以包括插入、更新、删除等操作，会对数据进行实际的修改。写事务需要满足原子性、一致性、隔离性、持久性等特性，确保数据的正确性和完整性。在写事务中，数据库系统会将所有写操作作为一个不可分割的单元来处理，要么全部成功，要么全部失败，以确保数据的一致性。事务的提交是指将一个事务中的所有数据库操作永久性地保存到数据库中的过程。在事务执行过程中，所有的操作只是在临时存储区进行的，直到事务提交后才会将这些操作结果写入数据库的永久存储区。当一个事务执行完成并经过验证后，可以选择将其提交，这意味着事务所做的修改将会永久保存到数据库中，并对其他用户可见。提交事务后，数据库的状态将被更新以反映事务所做的更改。事务的提交是确保数据库的一致性和完整性的重要步骤，它保证了一组相关操作要么全部执行成功，要么全部回滚，从而避免了数据的不一致和损坏。针对数据库中存储的数据的写事务，可以被拆分成针对数据库中存储的数据的各个数据分片的子事务。在从一个写事务拆分出的所有子事务均执行完成时，即可认为这个写事务执行完成，在经过验证后，即可提交这个写事务。为了保证数据的正确性和隔离性，对于从一个写事务拆分出的针对一个数据分片的子事务而言，需要先对这个数据分片中的与这个子事务对应的数据进行加锁，并由这个子事务持有锁，再在这个写事务提交后，对该数据进行解锁，即由这个子事务释放锁。当多个写事务并行时，如果从这些写事务拆分出的子事务无法正确、有序地持有锁和释放锁，就可能导致死锁的发生。在这种情况下，写事务的流程会被阻塞，导致系统无法继续正常工作。本申请提供一种死锁检测的技术方案，可以由各个分片管理节点上运行的检测客户端检测出锁等待队列中锁等待时长达到死锁检测阈值的子事务，并将生成的与该子事务对应的锁等待关系发送给与检测客户端对应的检测服务端，由该检测服务端基于该锁等待关系更新全局锁等待关系，并基于更新后的全局锁等待关系针对该子事务进行死锁检测，如果检测到该子事务触发死锁，则该检测客户端可以从该锁等待队列中删除该子事务。采用上述方式，在实现死锁检测，避免写事务的流程被阻塞的过程中，可以仅针对锁等待时长达到死锁检测阈值的子事务进行死锁检测，从而可以过滤掉一部分非必要的死锁检测。此外，可以根据实际的死锁检测需求调整死锁检测阈值，以此控制死锁检测的灵敏度。本申请还提供另一种死锁检测的技术方案，可以由各个分片管理节点上运行的检测程序检测出锁等待队列中锁等待时长达到死锁检测阈值的子事务，并基于生成的与该子事务对应的锁等待关系，以及从其他分片管理节点同步到的锁等待关系，生成全局锁等待关系，并基于该全局锁等待关系针对该子事务进行死锁检测，如果检测到该子事务触发死锁，则该检测程序可以从该锁等待队列中删除该子事务。采用上述方式，一方面，在实现死锁检测，避免写事务的流程被阻塞的过程中，可以仅针对锁等待时长达到死锁检测阈值的子事务进行死锁检测，从而可以过滤掉一部分非必要的死锁检测。另一方面，可以根据实际的死锁检测需求调整死锁检测阈值，以此控制死锁检测的灵敏度，以适应不同的死锁检测环境。例如，如果死锁发生的频率较高，则可以调低死锁检测阈值，以更快地发现死锁。再一方面，通过非中心式的死锁检测方式，由各个分片管理节点上运行的检测程序执行死锁检测，可以避免由于中心式的检测服务端被阻塞而导致的死锁检测不及时。请参考图1和图2，图1是本申请一示例性实施例示出的一种数据库系统的示意图，图2是本申请一示例性实施例示出的另一种数据库系统的示意图。如图1所示，在数据库系统中，可以由一台物理主机承载数据库。其中，在这台物理主机上可以创建若干虚拟主机，基于一个虚拟主机可以创建一个分片管理节点，例如：可以利用一个虚拟主机的资源创建一个分片管理节点，此时这个分片管理节点可以是在这个虚拟主机上创建的一个用于管理数据分片的模块；该数据库中存储的数据可以被划分成若干数据分片；每个数据分片可以被存储在不同的分片管理节点上，由存储了一个数据分片的一个分片管理节点管理这个数据分片。如图2所示，在数据库系统中，可以由一个主机集群承载数据库，这个主机集群可以由若干物理主机组成。其中，基于一台物理主机可以创建一个分片管理节点，例如：可以利用一台物理主机的资源创建一个分片管理节点，此时这个分片管理节点可以是在这台物理主机上创建的一个用于管理数据分片的模块；该数据库中存储的数据可以被划分成若干数据分片；每个数据分片可以被存储在不同的分片管理节点上，由存储了一个数据分片的一个分片管理节点管理这个数据分片。在一些实施例中，上述数据库可以是图数据库。图数据库用于存储和处理图形结构的数据，它将数据表示为节点和边的组合，节点代表实体，边代表实体之间的关系。在图数据库中，每个数据分片可以包含一部分图的节点和边，以及与它们相关的属性和标签等。因此，在图数据库中，经常会出现一个写事务涉及多个数据分片的情况。在一些实施例中，上述数据库可以是分布式数据库。在这种情况下，如图1所示的一台物理主机或者如图2所示的一个主机集群，可以作为承载该分布式数据库的设备集群中的一个节点设备。该节点设备具体可以是从该设备集群包含的节点设备中选举出的主设备。例如，上述数据库可以是基于Raft算法的分布式数据库。Raft算法是一种共识算法，用于在分布式系统中实现一致性，确保多个节点之间的数据一致性和高可用性。Raft算法将分布式系统中的节点划分为领导者、跟随者和候选者。在正常情况下，一个节点被选举为领导者，负责接收和处理客户端的请求，并将日志复制到其他节点。当领导者失效或无法正常工作时，剩余的节点会启动选举过程，选举新的领导者。在这种情况下，如图1所示的一台物理主机或者如图2所示的一个主机集群，可以作为通过Raft算法从承载该分布式数据库的设备集群包含的节点设备中选举出的主设备。请结合图1和图2，参考图3，图3是本申请一示例性实施例示出的一种死锁检测方法的流程图。在本实施例中，可以将如图1所示的物理主机或者如图2所示的主机集群称为目标电子设备。也即，该目标电子设备可以用于承载数据库，该目标电子设备可以包括若干用于管理该数据库中存储的数据的数据分片的分片管理节点。针对上述数据库中存储的数据的写事务，可以被拆分成针对该数据库中存储的数据的各个数据分片的子事务。在这种情况下，一个分片管理节点可以执行从针对该数据库中存储的数据的写事务中，拆分出的针对与这个分片管理节点对应的数据分片的子事务。请参考图4，图4是本申请一示例性实施例示出的一种目标电子设备的示意图。如图4所述，对于上述目标电子设备包含的若干分片管理节点而言，这些分片管理节点上可以分别运行检测客户端，而该目标电子设备上还可以运行与该检测客户端对应的检测服务端。在一些实施例中，上述检测服务端可以运行在上述若干分片管理节点中指定的分片管理节点上。需要说明的是，图4示出的是检测服务端运行在指定的分片管理节点上的情况。在其他情况下，该检测服务端可以独立于上述若干分片管理节点，运行在上述目标电子设备上，例如：该检测服务端可以是在该目标电子设备上创建的独立于这若干分片管理节点的、用于收集检测客户端发送的信息并据此进行死锁检测的其他模块。在一些实施例中，上述指定的分片管理节点可以是用于管理上述数据库中存储的首个数据分片的分片管理节点。上述死锁检测方法可以应用于上述若干分片管理节点中的任一分片管理节点上运行的检测客户端。该死锁检测方法可以包括：步骤302：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务。在本实施例中，上述目标分片管理节点本地可以维护锁等待队列。其中，该锁等待队列中的子事务即为从针对上述数据库中存储的数据的写事务中，拆分出的针对与该目标分片管理节点对应的数据分片的子事务。当多个子事务同时请求与该目标分片管理节点对应的数据分片中的某一数据的锁时，如果该锁已被占用，则会将请求该数据的子事务放入与该锁对应的锁等待队列中，直到该锁可用为止。上述目标分片管理节点上运行的检测客户端可以检测上述锁等待队列中的某一子事务的锁等待时长是否达到预设的死锁检测阈值；锁等待时长是指在锁等待队列中等待锁的时间长度。其中，该死锁检测阈值具体可以由用户根据实际的死锁检测需求进行设置，也可以是系统默认的缺省值，本申请对此不作限制。步骤304：如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果。在本实施例中，上述目标分片管理节点上运行的检测客户端在检测到上述第一子事务的锁等待时长达到上述死锁检测阈值的情况下，可以生成与该第一子事务对应的锁等待关系；锁等待关系描述的是该第一子事务与其他子事务之间的锁等待情况。例如，假设子事务A当前持有锁1，此时如果子事务B需要锁1，则需要等待子事务A释放锁1，因此锁等待关系为子事务B等待子事务A，可以表示为子事务B→子事务A。后续，上述目标分片管理节点上运行的检测客户端可以将与上述第一子事务对应的锁等待关系发送给上述检测服务端，以请求该检测服务端基于该锁等待关系进行死锁检测。具体地，该检测客户端可以生成包含该锁等待关系的检测请求，并将该检测请求发送给该检测服务端。上述检测服务端本地可以维护全局锁等待关系。其中，该全局锁等待关系可以是该检测服务端将各个分片管理节点上运行的检测客户端发送的锁等待关系整合而成的。上述检测服务端在接收到与上述第一子事务对应的锁等待关系的情况下，可以响应于该锁等待关系，基于该锁等待关系更新上述全局锁等待关系，并基于更新后的全局锁等待关系针对上述第一子事务进行死锁检测。后续，该检测服务端可以将针对该第一子事务的死锁检测结果返回给上述目标分片管理节点上运行的检测客户端。在实际应用中，基于上述全局锁等待关系针对上述第一子事务进行死锁检测，具体可以是基于该全局锁等待关系，检测是否存在以该第一子事务为起点，且以该第一子事务为终点的循环的锁等待关系。例如，子事务B→子事务A→子事务B即为以子事务B为起点，且以子事务B为终点的循环的锁等待关系。在一些实施例中，上述锁等待关系可以包括上述第一子事务的事务标识和持有锁的子事务的事务标识之间的关联关系。相应地，上述全局锁等待关系可以包括基于各个分片管理节点上运行的检测客户端发送的锁等待关系构建的有向图。其中，该有向图中的顶点为子事务的事务标识，该有向图中的有向边的方向为由等待锁的子事务的事务标识，指向持有锁的子事务的事务标识。在实际应用中，上述锁等待关系还可以包括上述第一子事务所隶属的数据分片的分片标识，以对上述全局锁等待关系按照数据分片进行划分。请参考图5，图5是本申请一示例性实施例示出的一种全局锁等待关系的示意图。如图5所示，在作为全局锁等待关系的有向图中，顶点A表示子事务A，顶点B表示子事务B，顶点C表示子事务C；顶点C与顶点B之间的有向边的方向为由顶点C指向顶点B，表示子事务C等待子事务B，顶点B与顶点A之间的有向边的方向为由顶点B指向顶点A，表示子事务B等待子事务A。在基于上述全局锁等待关系针对上述第一子事务进行死锁检测时，具体可以针对作为该全局锁等待关系的有向图进行环路检测，以检测该有向图中是否存在以该第一子事务的事务标识为起点的环路。如果该有向图中存在这种环路，则可以确定该第一子事务触发死锁。通过将基于来自各个分片管理节点的锁等待关系构建的有向图作为全局锁等待关系，可以将基于该全局锁等待关系针对一个子事务进行死锁检测，转化为检测该有向图中是否存在以这个子事务为起点的环路，从而可以降低死锁检测的复杂度，提高死锁检测的效率。在一些实施例中，在针对上述有向图进行环路检测，以确定该有向图中是否存在以上述第一子事务的事务标识为起点的环路时，具体可以基于深度优先遍历算法，将该第一子事务的事务标识作为遍历起点，针对该有向图进行遍历，以检测该有向图中是否存在以该第一子事务的事务标识为起点的环路。深度优先遍历是一种用于遍历或搜索树或图的算法，其核心思想是从起始节点开始，沿着一条路径尽可能深入地访问下去，直到到达最深处再返回，然后探索其他未访问的分支。深度优先遍历的特点是以深度为优先，沿着每个路径尽可能深入地探索，直到无法继续深入为止。这使得该算法适合用于解决一些问题，如图的连通性、路径查找等。在一些实施例中，上述检测服务端在基于上述全局锁等待关系针对上述第一子事务进行死锁检测后，如果确定该第一子事务触发死锁，则可以从该全局锁等待关系中删除与该第一子事务对应的锁等待关系，以避免后续重复检测到该第一子事务触发死锁，导致死锁检测出现异常。步骤306：响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。在本实施例中，上述目标分片管理节点上运行的检测客户端在接收到上述检测服务端返回的针对上述第一子事务的死锁检测结果的情况下，可以响应于该死锁检测结果，基于该死锁检测结果确定该第一子事务是否触发死锁。如果该第一子事务触发死锁，则说明包含该第一子事务的写事务的流程被阻塞，可以从上述锁等待队列中删除该第一子事务，以解决阻塞的问题，保证系统后续的正常工作。需要说明的是，上述锁等待队列中放置的具体可以是用于执行子事务的线程。如果一个子事务触发死锁，则可以中断用于执行这个子事务的线程，即可以视为从该锁等待队列中删除这个子事务。在一些实施例中，上述目标分片管理节点上运行的检测客户端在基于上述死锁检测结果确定上述第一子事务触发死锁时，除了可以从上述锁等待队列中删除该第一子事务之外，还可以输出该第一子事务触发死锁的提示信息，以对外提示该第一子事务触发死锁，促使重试包含该第一子事务的写事务，或者对包含该第一子事务的写事务进行检查和更改。在一些实施例中，如果未检测到上述第一子事务触发死锁，则可以在锁可用时执行该第一子事务。上述目标分片管理节点上运行的检测客户端可以响应于该第一子事务执行完成，向上述检测服务端发送与该第一子事务对应的锁等待关系对应的删除请求。而该检测服务端则可以响应于该删除请求，从上述全局锁等待关系中删除该锁等待关系。由此，可以避免在执行完该第一子事务后检测到该第一子事务触发死锁，导致死锁检测出现异常。在一些实施例中，为了避免等待锁可用的时长过长，影响写事务的执行效率，上述目标分片管理节点上运行的检测客户端可以检测上述第一子事务的锁等待时长是否达到预设的锁等待超时阈值。其中，该锁等待超时阈值具体可以由用户根据实际需求进行设置，也可以是系统默认的缺省值，本申请对此不作限制。如果该锁等待时长达到该锁等待超时阈值，则也可以从上述锁等待队列中删除该第一子事务。在实际应用中，可以先检测上述第一子事务的锁等待时长是否达到上述锁等待超时阈值，如果未达到，再检测该第一子事务的锁等待时长是否达到上述死锁检测阈值，这样可以避免由于上述检测服务端繁忙或异常而导致的无法及时执行死锁检测。上述锁等待超时阈值可以大于上述死锁检测阈值。在这种情况下，就算未检测到上述第一子事务触发死锁，如果等待锁可用的时长过长，也会从上述锁等待队列中删除该第一子事务。在一些实施例中，在从上述锁等待队列中删除上述第一子事务后，说明该第一子事务执行失败，因此需要针对包含该第一子事务的写事务进行事务回滚。在一些实施例中，每个事务可以有其事务执行时长，事务需要在该事务执行时长内执行完成。在针对包含该第一子事务的写事务进行事务回滚后，可以进一步地确定该写事务的剩余执行时长是否超过预设的事务重试阈值，如果是，则可以针对该写事务进行事务重试，即重新开始执行该写事务。在上述技术方案中，可以由各个分片管理节点上运行的检测客户端检测出锁等待队列中锁等待时长达到死锁检测阈值的子事务，并将生成的与该子事务对应的锁等待关系发送给与检测客户端对应的检测服务端，由该检测服务端基于该锁等待关系更新全局锁等待关系，并基于更新后的全局锁等待关系针对该子事务进行死锁检测，如果检测到该子事务触发死锁，则该检测客户端可以从该锁等待队列中删除该子事务。采用上述方式，在实现死锁检测，避免写事务的流程被阻塞的过程中，可以仅针对锁等待时长达到死锁检测阈值的子事务进行死锁检测，从而可以过滤掉一部分非必要的死锁检测。此外，可以根据实际的死锁检测需求调整死锁检测阈值，以此控制死锁检测的灵敏度，以适应不同的死锁检测环境。例如，如果死锁发生的频率较高，则可以调低死锁检测阈值，以更快地发现死锁。请结合图1和图2，参考图6，图6是本申请一示例性实施例示出的另一种死锁检测方法的流程图。在本实施例中，可以将如图1所示的物理主机或者如图2所示的主机集群称为目标电子设备。也即，该目标电子设备可以用于承载数据库，该目标电子设备可以包括若干用于管理该数据库中存储的数据的数据分片的分片管理节点。对于上述目标电子设备包含的若干分片管理节点而言，这些分片管理节点上可以分别运行检测客户端，而该目标电子设备上还可以运行与该检测客户端对应的检测服务端。上述死锁检测方法可以应用于上述检测服务端。该死锁检测方法可以包括：步骤602：接收任一目标分片管理节点上运行的检测客户端发送的与所述第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务。步骤604：响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测。步骤606：将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。如图6所示的实施例的具体实现可以参考如图3所示的实施例，本申请对此不再进行赘述。请结合图1和图2，参考图7，图7是本申请一示例性实施例示出的另一种死锁检测方法的流程图。在本实施例中，可以将如图1所示的物理主机或者如图2所示的主机集群称为目标电子设备。也即，该目标电子设备可以用于承载数据库，该目标电子设备可以包括若干用于管理该数据库中存储的数据的数据分片的分片管理节点。针对上述数据库中存储的数据的写事务，可以被拆分成针对该数据库中存储的数据的各个数据分片的子事务。在这种情况下，一个分片管理节点可以执行从针对该数据库中存储的数据的写事务中，拆分出的针对与这个分片管理节点对应的数据分片的子事务。请参考图8，图8是本申请一示例性实施例示出的另一种目标电子设备的示意图。如图8所述，对于上述目标电子设备包含的若干分片管理节点而言，这些分片管理节点上可以分别运行检测程序。上述死锁检测方法可以应用于上述若干分片管理节点中的任一分片管理节点上运行的检测程序。该死锁检测方法可以包括：步骤702：检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务。在本实施例中，上述目标分片管理节点本地可以维护锁等待队列。其中，该锁等待队列中的子事务即为从针对上述数据库中存储的数据的写事务中，拆分出的针对与该目标分片管理节点对应的数据分片的子事务。当多个子事务同时请求与该目标分片管理节点对应的数据分片中的某一数据的锁时，如果该锁已被占用，则会将请求该数据的子事务放入与该锁对应的锁等待队列中，直到该锁可用为止。上述目标分片管理节点上运行的检测程序可以检测上述锁等待队列中的某一子事务的锁等待时长是否达到预设的死锁检测阈值；锁等待时长是指在锁等待队列中等待锁的时间长度。其中，该死锁检测阈值具体可以由用户根据实际的死锁检测需求进行设置，也可以是系统默认的缺省值，本申请对此不作限制。步骤704：如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系。在本实施例中，上述目标分片管理节点上运行的检测程序在检测到上述第一子事务的锁等待时长达到上述死锁检测阈值的情况下，可以生成与该第一子事务对应的锁等待关系；锁等待关系描述的是该第一子事务与其他子事务之间的锁等待情况。例如，假设子事务A当前持有锁1，此时如果子事务B需要锁1，则需要等待子事务A释放锁1，因此锁等待关系为子事务B等待子事务A，可以表示为子事务B→子事务A。除此之外，上述目标分片管理节点上运行的检测程序还可以从其他分片管理节点同步锁等待关系。对于其他任一分片管理节点而言，从这个分片管理节点同步到的锁等待关系，是由这个分片管理节点上运行的检测程序生成的、这个分片管理节点本地当前维护的锁等待关系。步骤706：基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测。在本实施例中，上述目标分片管理节点上运行的检测程序在生成了与上述第一子事务对应的锁等待关系，并从其他分片管理节点同步到锁等待关系的情况下，可以基于与该第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于该全局锁等待关系针对该第一子事务进行死锁检测。其中，该全局锁等待关系可以是该检测程序将所有锁等待关系整合而成的。在实际应用中，基于上述全局锁等待关系针对上述第一子事务进行死锁检测，具体可以是基于该全局锁等待关系，检测是否存在以该第一子事务为起点，且以该第一子事务为终点的循环的锁等待关系。例如，子事务B→子事务A→子事务B即为以子事务B为起点，且以子事务B为终点的循环的锁等待关系。在一些实施例中，上述锁等待关系可以包括上述第一子事务的事务标识和持有锁的子事务的事务标识之间的关联关系。相应地，上述全局锁等待关系可以包括基于各个分片管理节点上运行的检测客户端发送的锁等待关系构建的有向图。其中，该有向图中的顶点为子事务的事务标识，该有向图中的有向边的方向为由等待锁的子事务的事务标识，指向持有锁的子事务的事务标识。在实际应用中，上述锁等待关系还可以包括上述第一子事务所隶属的数据分片的分片标识，以对上述全局锁等待关系按照数据分片进行划分。请参考图5，图5是本申请一示例性实施例示出的一种全局锁等待关系的示意图。如图5所示，在作为全局锁等待关系的有向图中，顶点A表示子事务A，顶点B表示子事务B，顶点C表示子事务C；顶点C与顶点B之间的有向边的方向为由顶点C指向顶点B，表示子事务C等待子事务B，顶点B与顶点A之间的有向边的方向为由顶点B指向顶点A，表示子事务B等待子事务A。在基于上述全局锁等待关系针对上述第一子事务进行死锁检测时，具体可以针对作为该全局锁等待关系的有向图进行环路检测，以检测该有向图中是否存在以该第一子事务的事务标识为起点的环路。如果该有向图中存在这种环路，则可以确定该第一子事务触发死锁。通过将基于来自各个分片管理节点的锁等待关系构建的有向图作为全局锁等待关系，可以将基于该全局锁等待关系针对一个子事务进行死锁检测，转化为检测该有向图中是否存在以这个子事务为起点的环路，从而可以降低死锁检测的复杂度，提高死锁检测的效率。在一些实施例中，在针对上述有向图进行环路检测，以确定该有向图中是否存在以上述第一子事务的事务标识为起点的环路时，具体可以基于深度优先遍历算法，将该第一子事务的事务标识作为遍历起点，针对该有向图进行遍历，以检测该有向图中是否存在以该第一子事务的事务标识为起点的环路。深度优先遍历是一种用于遍历或搜索树或图的算法，其核心思想是从起始节点开始，沿着一条路径尽可能深入地访问下去，直到到达最深处再返回，然后探索其他未访问的分支。深度优先遍历的特点是以深度为优先，沿着每个路径尽可能深入地探索，直到无法继续深入为止。这使得该算法适合用于解决一些问题，如图的连通性、路径查找等。步骤708：在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。在本实施例中，上述目标分片管理节点上运行的检测程序在确定上述第一子事务触发时，可以从上述锁等待队列中删除该第一子事务，以解决包含该第一子事务的写事务的流程被阻塞的问题，保证系统后续的正常工作。需要说明的是，上述锁等待队列中放置的具体可以是用于执行子事务的线程。如果一个子事务触发死锁，则可以中断用于执行这个子事务的线程，即可以视为从该锁等待队列中删除这个子事务。在一些实施例中，上述目标分片管理节点上运行的检测程序在确定上述第一子事务触发死锁时，可以删除与该第一子事务对应的锁等待关系，以避免后续重复检测到该第一子事务触发死锁，导致死锁检测出现异常。在实际应用中，在完成针对上述第一子事务的死锁检测后，不管该第一子事务是否触发死锁，都可以删除上述全局锁等待关系。在一些实施例中，上述目标分片管理节点上运行的检测程序在确定上述第一子事务触发死锁时，除了可以从上述锁等待队列中删除该第一子事务之外，还可以输出该第一子事务触发死锁的提示信息，以对外提示该第一子事务触发死锁，促使重试包含该第一子事务的写事务，或者对包含该第一子事务的写事务进行检查和更改。在一些实施例中，如果未检测到上述第一子事务触发死锁，则可以在锁可用时执行该第一子事务。上述目标分片管理节点上运行的检测客户端可以响应于该第一子事务执行完成，向上述检测服务端发送与该第一子事务对应的锁等待关系对应的删除请求。而该检测服务端则可以响应于该删除请求，从上述全局锁等待关系中删除该锁等待关系。由此，可以避免在执行完该第一子事务后检测到该第一子事务触发死锁，导致死锁检测出现异常。在一些实施例中，为了避免等待锁可用的时长过长，影响写事务的执行效率，上述目标分片管理节点上运行的检测客户端可以检测上述第一子事务的锁等待时长是否达到预设的锁等待超时阈值。其中，该锁等待超时阈值具体可以由用户根据实际需求进行设置，也可以是系统默认的缺省值，本申请对此不作限制。如果该锁等待时长达到该锁等待超时阈值，则也可以从上述锁等待队列中删除该第一子事务。在实际应用中，可以先检测上述第一子事务的锁等待时长是否达到上述锁等待超时阈值，如果未达到，再检测该第一子事务的锁等待时长是否达到上述死锁检测阈值，这样可以避免由于上述检测程序繁忙或异常而导致的无法及时执行死锁检测。上述锁等待超时阈值可以大于上述死锁检测阈值。在这种情况下，就算未检测到上述第一子事务触发死锁，如果等待锁可用的时长过长，也会从上述锁等待队列中删除该第一子事务。在一些实施例中，在从上述锁等待队列中删除上述第一子事务后，说明该第一子事务执行失败，因此需要针对包含该第一子事务的写事务进行事务回滚。在一些实施例中，每个事务可以有其事务执行时长，事务需要在该事务执行时长内执行完成。在针对包含该第一子事务的写事务进行事务回滚后，可以进一步地确定该写事务的剩余执行时长是否超过预设的事务重试阈值，如果是，则可以针对该写事务进行事务重试，即重新开始执行该写事务。在上述技术方案中，可以由各个分片管理节点上运行的检测程序检测出锁等待队列中锁等待时长达到死锁检测阈值的子事务，并基于生成的与该子事务对应的锁等待关系，以及从其他分片管理节点同步到的锁等待关系，生成全局锁等待关系，并基于该全局锁等待关系针对该子事务进行死锁检测，如果检测到该子事务触发死锁，则该检测程序可以从该锁等待队列中删除该子事务。采用上述方式，一方面，在实现死锁检测，避免写事务的流程被阻塞的过程中，可以仅针对锁等待时长达到死锁检测阈值的子事务进行死锁检测，从而可以过滤掉一部分非必要的死锁检测。另一方面，可以根据实际的死锁检测需求调整死锁检测阈值，以此控制死锁检测的灵敏度，以适应不同的死锁检测环境。例如，如果死锁发生的频率较高，则可以调低死锁检测阈值，以更快地发现死锁。再一方面，通过非中心式的死锁检测方式，由各个分片管理节点上运行的检测程序执行死锁检测，可以避免由于中心式的检测服务端被阻塞而导致的死锁检测不及时。与前述死锁检测方法的实施例相对应，本申请还提供了死锁检测装置的实施例。请参考图9，图9是本申请一示例性实施例示出的一种设备的结构示意图。在硬件层面，该设备包括处理器902、内部总线904、网络接口906、内存908以及非易失性存储器910，当然还可能包括所需要的其他硬件。本申请一个或多个实施例可以基于软件方式来实现，比如由处理器902从非易失性存储器910中读取对应的计算机程序到内存908中然后运行。当然，除了软件实现方式之外，本申请一个或多个实施例并不排除其他实现方式，比如逻辑器件或者软硬件结合的方式等等，也就是说以下处理流程的执行主体并不限定于各个逻辑模块，也可以是硬件或者逻辑器件。请参考图10，图10是本申请一示例性实施例示出的一种死锁检测装置的框图。上述死锁检测装置可以应用于图9所示的设备，以实现本申请的技术方案。具体地，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于任一目标分片管理节点上运行的检测客户端。上述死锁检测装置可以包括：检测模块1002，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块1004，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并将所述锁等待关系发送给所述检测服务端，以使所述检测服务端响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测，以及返回死锁检测结果；删除模块1006，响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。请参考图11，图11是本申请一示例性实施例示出的另一种死锁检测装置的框图。上述死锁检测装置可以应用于图9所示的设备，以实现本申请的技术方案。具体地，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据分片；所述若干分片管理节点上分别运行了检测客户端；所述目标电子设备上还运行了与所述检测客户端对应的检测服务端；所述装置应用于所述检测服务端。上述死锁检测装置可以包括：接收模块1102，接收任一目标分片管理节点上运行的检测客户端发送的与所述第一子事务对应的锁等待关系；其中，所述锁等待关系由所述检测客户端在检测到本地维护的锁等待队列中的第一子事务的锁等待时长达到预设的死锁检测阈值时生成；所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；检测模块1104，响应于接收到的所述锁等待关系，基于所述锁等待关系更新本地维护的全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；发送模块1106，将死锁检测结果发送给所述目标分片管理节点上运行的检测客户端，以使所述检测客户端响应于接收到的所述死锁检测结果，在基于所述死锁检测结果确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。请参考图12，图12是本申请一示例性实施例示出的另一种死锁检测装置的框图。上述死锁检测装置可以应用于图9所示的设备，以实现本申请的技术方案。具体地，承载数据库的目标电子设备包括若干分片管理节点；所述分片管理节点用于管理所述数据库中存储的数据的数据分片；所述若干分片管理节点上分别运行了检测程序；所述装置应用于任一目标分片管理节点上运行的检测程序。上述死锁检测装置可以包括：时长检测模块1202，检测本地维护的锁等待队列中的第一子事务的锁等待时长是否达到预设的死锁检测阈值；其中，所述第一子事务为从针对所述数据库中存储的数据的写事务中，拆分出的针对与所述目标分片管理节点对应的数据分片的子事务；生成模块1204，如果所述锁等待时长达到所述死锁检测阈值，则生成与所述第一子事务对应的锁等待关系，并从其他分片管理节点同步锁等待关系；死锁检测模块1206，基于与所述第一子事务对应的锁等待关系，以及同步到的锁等待关系，生成全局锁等待关系，并基于所述全局锁等待关系针对所述第一子事务进行死锁检测；删除模块1208，在确定所述第一子事务触发死锁时，从所述锁等待队列中删除所述第一子事务。对于装置实施例而言，其基本对应于方法实施例，因此相关之处参见方法实施例的部分说明即可。以上所描述的装置实施例仅仅是示意性的，其中所述作为分离部件说明的模块可以是或者也可以不是物理上分开的，作为模块显示的部件可以是或者也可以不是物理模块，即可以位于一个地方，或者也可以分布到多个网络模块上。可以根据实际的需要选择其中的部分或者全部模块来实现本申请的技术方案的目的。上述实施例阐明的系统、装置、模块或者单元，具体可以由计算机芯片或者实体实现，或者由具有某种功能的产品来实现。一种典型的实现设备为计算机，计算机的具体形式可以是个人计算机、膝上型计算机、蜂窝电话、相机电话、智能电话、个人数字助理、媒体播放器、导航设备、电子邮件收发设备、游戏控制台、平板计算机、可穿戴设备或者这些设备中的任意几种设备的组合。在一个典型的配置中，计算机包括一个或多个处理器、输入/输出接口、网络接口和内存。内存可能包括计算机可读介质中的非永久性存储器，随机存取存储器和/或非易失性内存等形式，如只读存储器或者闪存。内存是计算机可读介质的示例。计算机可读介质包括永久性和非永久性、可移动和非可移动媒体可以由任何方法或者技术来实现信息存储。信息可以是计算机可读指令、数据结构、程序的模块或者其他数据。计算机的存储介质的例子包括，但不限于相变内存、静态随机存取存储器、动态随机存取存储器、其他类型的随机存取存储器、只读存储器、电可擦除可编程只读存储器、快闪记忆体或者其他内存技术、只读光盘只读存储器、数字多功能光盘或者其他光学存储、磁盒式磁带、磁盘存储、量子存储器、基于石墨烯的存储介质或者其他磁性存储设备或者任何其他非传输介质，可用于存储可以被计算设备访问的信息。按照本文中的界定，计算机可读介质不包括暂存电脑可读媒体，如调制的数据信号和载波。需要说明的是，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、商品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、商品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括所述要素的过程、方法、商品或者设备中还存在另外的相同要素。上述对本申请特定实施例进行了描述。其他实施例在本申请的范围内。在一些情况下，在本申请中记载的动作或者步骤可以按照不同于实施例中的顺序来执行并且仍然可以实现期望的结果。另外，在附图中描绘的过程不一定要求示出的特定顺序或者连续顺序才能实现期望的结果。在某些实施方式中，多任务处理和并行处理也是可以的或者可能是有利的。在本申请一个或多个实施例中所使用的术语是仅仅出于描述特定实施例的目的，而非旨在限制本申请一个或多个实施例。单数形式的“一种”、“所述”和“该”也旨在包括多数形式，除非上下文清楚地表示其他含义。术语“和/或”是指并包含一个或多个相关联的列出项目的任何或者所有可能组合。在本申请一个或多个实施例中所使用的术语“一个实施例”、“一些实施例”、“示例”、“具体示例”或者“一种实施方式”等的描述意指结合该实施例所描述的具体特征或者特点包含于本申请的至少一个实施例中。对这些术语的示意性描述不必须针对相同的实施例。而且，所描述的具体特征或者特点可以在本申请一个或多个实施例中以合适的方式结合。此外，在不相互矛盾的情况下，可以将不同的实施例以及不同实施例中的具体特征或者特点进行结合。应当理解，尽管在本申请一个或多个实施例可能采用术语第一、第二、第三等来描述各种信息，但这些信息不应限于这些术语。这些术语仅用来将同一类型的信息彼此区分开。例如，在不脱离本申请一个或多个实施例范围的情况下，第一信息也可以被称为第二信息，类似地，第二信息也可以被称为第一信息。取决于语境，如在此所使用的词语“如果”可以被解释成为“在……时”或者“当……时”或者“响应于确定”。以上所述仅为本申请一个或多个实施例的较佳实施例而已，并不用以限制本申请一个或多个实施例，凡在本申请一个或多个实施例的精神和原则之内，所做的任何修改、等同替换、改进等，均应包含在本申请一个或多个实施例保护的范围之内。本申请所涉及的用户信息和数据，均为经用户授权或者经过各方充分授权的信息和数据，并且相关数据的收集、使用和处理需要遵守相关国家和地区的相关法律法规和标准，并提供有相应的操作入口，供用户选择授权或者拒绝。

标题title
用于程序语言转换的方法、编译方法及相关设备
摘要abst
本申请提供一种用于程序语言转换的方法、编译方法及相关设备，通过预设的解析模板，解析目标函数的信息，其中，所述目标函数包括用第一语言编写的调用函数，以根据目标函数的信息生成用于将第二语言编写的指令转换为第一语言的指令，并根据第一语言的指令调用目标函数的包装函数。利用本申请提供的方法，简化了包装函数的编写流程，减轻了程序开发人员的负担。
权利要求书clms
1.一种用于程序语言转换的方法，包括：获取目标函数；其中，所述目标函数包括用第一语言编写的调用函数；利用预设的解析模板，解析所述目标函数，以得到所述目标函数的信息；根据所述目标函数的信息，生成包装函数；其中，所述包装函数用于将第二语言的指令转换为对第一语言目标函数的调用。2.如权利要求1所述的方法，其中，所述预设的解析模板包括第一解析模板、第二解析模板和第三解析模板；所述利用预设的解析模板，解析所述目标函数，以得到所述目标函数的信息进一步包括：利用所述第三解析模板和所述目标函数的静态信息，将所述第一解析模板和所述第二解析模板实例化，以解析所述目标函数，得到所述目标函数的信息。3.如权利要求1所述的方法，其中，所述目标函数的信息包括标识符；所述根据所述目标函数的信息，生成包装函数进一步包括：响应于所述标识符的数量与预设标识符的数量一致，调用第一函数；其中，所述第一函数用于将所述第一语言支持的数据类型转换为所述第二语言支持的数据类型。4.如权利要求1所述的方法，其中，所述目标函数的信息还包括参数的类型；所述方法还包括：根据所述参数的类型调用反射模板；其中，所述反射模板定义了所述第一语言的数据结构和所述第二语言的输入信息的转换规则。5.如权利要求1所述的方法，其中，所述方法还包括：调用第二语言提供的注册接口在程序中注册所述包装函数。6.如权利要求1-5任一项所述的方法，其中，所述第一语言支持的数据类型包括整型、双精度浮点型、浮点型；所述第二语言支持的数据类型包括字符串型。7.如权利要求1-5任一项所述的方法，其中，所述第一语言包括C++语言，所述第二语言包括Tcl语言。8.一种编译方法，包括：获取利用第一语言编写的源代码，所述源代码包括采用如权利要求1-7任一项所述的方法得到的包装函数；将所述源代码编译为目标代码。9.一种计算机设备，包括：一个或者多个处理器、存储器；以及一个或多个程序；其中，所述一个或多个程序被存储在所述存储器中，并且被所述一个或多个处理器执行，所述程序包括用于执行根据权利要求1-8中任一项所述的方法的指令。10.一种包含计算机程序的非易失性计算机可读存储介质，当所述计算机程序被一个或多个处理器执行时，使得所述处理器执行权利要求1-8中任一项所述的方法。
说明书desc
技术领域本申请涉及计算机技术领域，尤其涉及一种用于程序语言转换的方法、编译方法及相关设备。背景技术利用C++语言提供的模板支持，可以在程序编译时，根据给定的模板代码和给定模板实参，编译器会将其实例化，以生成实际代码并编译到二进制程序中。在利用Tcl命令调用C++接口函数的应用场景中，需要利用包装函数，将Tcl命令行中输入的字符串按某种格式一一转化为C++接口函数的参数类型，从而对C++接口函数进行转调用。若输入信息有误，则需要进行相应的报错处理。C++接口函数调用完成后，若有返回值，则需要将其按某种格式转化为相应的字符串，作为Tcl命令的输出结果。然而，包装函数的编写较为繁琐，会增加程序开发人员的负担。如何简化包装函数的编写流程是亟待解决的问题。发明内容有鉴于此，本申请的目的在于提出一种用于程序语言转换的方法、编译方法及相关设备。基于上述目的，本申请第一方面，提供了一种用于程序语言转换的方法，包括：获取目标函数；其中，所述目标函数包括用第一语言编写的调用函数；利用预设的解析模板，解析所述目标函数，以得到所述目标函数的信息；根据所述目标函数的信息，生成包装函数；其中，所述包装函数用于将第二语言的指令转换为对第一语言目标函数的调用。可选地，所述预设的解析模板包括第一解析模板、第二解析模板和第三解析模板；所述利用预设的解析模板，解析所述目标函数，以得到所述目标函数的信息进一步包括：利用所述第三解析模板和所述目标函数的静态信息，将所述第一解析模板和所述第二解析模板实例化，以解析所述目标函数，得到所述目标函数的信息。可选地，所述目标函数的信息包括标识符；所述根据所述目标函数的信息，生成包装函数进一步包括：响应于所述标识符的数量与预设标识符的数量一致，调用第一函数；其中，所述第一函数用于将所述第一语言支持的数据类型转换为所述第二语言支持的数据类型。可选地，所述目标函数的信息还包括参数的类型；所述方法还包括：根据所述参数的类型调用反射模板；其中，所述反射模板定义了所述第一语言的数据结构和所述第二语言的输入信息的转换规则。可选地，所述方法还包括：调用第二语言提供的注册接口在程序中注册所述包装函数。可选地，所述第一语言支持的数据类型包括整型、双精度浮点型、浮点型；所述第二语言支持的数据类型包括字符串型。可选地，所述第一语言包括C++语言，所述第二语言包括Tcl语言。本申请第二方面，提供了一种编译方法，包括：获取利用第一语言编写的源代码，所述源代码包括采用如第一方面所述的方法得到的包装函数；将所述源代码编译为目标代码。本申请第三方面，提供了一种计算机设备，包括：一个或者多个处理器、存储器；以及一个或多个程序；其中，所述一个或多个程序被存储在所述存储器中，并且被所述一个或多个处理器执行，所述程序包括用于执行根据如第一方面所述的方法的指令。本申请第四方面，提供了一种包含计算机程序的非易失性计算机可读存储介质，当所述计算机程序被一个或多个处理器执行时，使得所述处理器执行如第一方面所述的方法。从上面所述可以看出，本申请提供的一种用于程序语言转换的方法、编译方法及相关设备，通过预设的解析模板，解析目标函数的信息，其中，所述目标函数包括用第一语言编写的调用函数，以根据目标函数的信息生成用于将第二语言编写的指令转换为第一语言的指令，并根据第一语言的指令调用目标函数的包装函数。利用本申请提供的方法，简化了包装函数的编写流程，减轻了程序开发人员的负担。附图说明为了更清楚地说明本申请或相关技术中的技术方案，下面将对实施例或相关技术描述中所需要使用的附图作简单地介绍，显而易见地，下面描述中的附图仅仅是本申请的实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。图1示出了本申请实施例所提供的一种电子设备的结构示意图。图2示出了根据本申请实施例的仿真工具的基本结构示意图。图3示出了本申请实施例所提供的用于程序语言转换方法的流程示意图。图4示出了根据本申请实施例的示例性编译器的示意图。图5示出了根据本申请实施例的示例性编译方法的示意图。图6示出了根据本申请实施例的示例性应用场景的示意图。具体实施方式为使本申请的目的、技术方案和优点更加清楚明白，以下结合具体实施例，并参照附图，对本申请进一步详细说明。需要说明的是，除非另外定义，本申请实施例使用的技术术语或者科学术语应当为本申请所属领域内具有一般技能的人士所理解的通常意义。本申请实施例中使用的“第一”、“第二”以及类似的词语并不表示任何顺序、数量或者重要性，而只是用来区分不同的组成部分。“包括”或者“包含”等类似的词语意指出现该词前面的元件或者物件涵盖出现在该词后面列举的元件或者物件及其等同，而不排除其他元件或者物件。“连接”或者“相连”等类似的词语并非限定于物理的或者机械的连接，而是可以包括电性的连接，不管是直接的还是间接的。“上”、“下”、“左”、“右”等仅用于表示相对位置关系，当被描述对象的绝对位置改变后，则该相对位置关系也可能相应地改变。图1示出了本申请实施例所提供的一种电子设备100的结构示意图。电子设备100例如可以是计算机主机。该电子设备100可以包括：处理器102、存储器104、网络接口106、外围接口108和总线110。其中处理器102、存储器104、网络接口106和外围接口108通过总线110实现彼此之间在设备内部的通信连接。处理器102可以是中央处理器、图像处理器、神经网络处理器、微控制器、可编程逻辑器件、数字信号处理器、应用专用集成电路或者一个或多个集成电路。处理器102可以用于执行与本申请描述的技术相关的功能。在一些实施例中，处理器102还可以包括集成为单一逻辑组件的多个处理器。如图1所示，处理器102可以包括多个处理器102a、102b和102c。存储器104可以配置为存储数据。例如，如图1所示，存储的数据可以包括程序指令以及待处理的数据。处理器102也可以访问存储的程序指令和数据，并且执行程序指令以对要处理的数据进行操作。存储器104可以包括易失性存储装置或非易失性存储装置。在一些实施例中，存储器104可以包括随机访问存储器、只读存储器、光盘、磁盘、硬盘、固态硬盘、闪存、存储棒等。网络接口106可以配置为经由网络向电子设备100提供与其他外部设备的通信。该网络可以是能够传输和接收数据的任何有线或无线的网络。例如，该网络可以是有线网络、本地无线网络等）、蜂窝网络、因特网、或上述的组合。可以理解的是，网络的类型不限于上述具体示例。在一些实施例中，网络接口106可以包括任意数量的网络接口控制器、射频模块、接收发器、调制解调器、路由器、网关、适配器、蜂窝网络芯片等的任意组合。外围接口108可以配置为将电子设备100与一个或多个外围装置连接，以实现信息输入及输出。例如，外围装置可以包括键盘、鼠标、触摸板、触摸屏、麦克风、各类传感器等输入设备以及显示器、扬声器、振动器、指示灯等输出设备。总线110可以被配置为在电子设备100的各个组件之间传输信息，诸如内部总线、外部总线等。需要说明的是，尽管上述设备仅示出了处理器102、存储器104、网络接口106、外围接口108和总线110，但是在具体实施过程中，该设备还可以包括实现正常运行所必需的其他组件。此外，本领域的技术人员可以理解的是，上述设备中也可以仅包含实现本申请实施例方案所必需的组件，而不必包含图中所示的全部组件。图2示出了根据本申请实施例的仿真工具200的基本结构示意图。如图2所示，虚线以上为用户部分；虚线以下为仿真工具200，仿真工具200可以由图1所示的设备100实现。仿真工具200可以包括Tcl命令模块204、各计算模块以及数据库系统212。用户202可以通过在Tcl命令模块204中输入相关命令来操作仿真工具200。在一些实施例中，该仿真工具200可以是任意的EDA软件。Tcl命令模块204，主要起着消息传递或命令传递的功能。Tcl命令模块204可以读取用户202向仿真工具200输入的指令，并可以根据指令的具体内容，分配并传递给相应的计算模块去执行具体任务。根据计算任务的不同，各计算模块可以分为，例如，Place计算模块206、Route计算模块208、Optimization计算模块210等。Place计算模块206可以用于为所有元器件计算出一个合理的摆放位置，Route计算模块208可以用于计算出各个元器件之间合理的导线连接方式，Optimization计算模块210则可以用于将各个元器件之间的摆放位置和导线连接方式进行优化。这些计算模块的计算过程可以在，例如，图1的处理器102中进行。数据库系统212可以用于完整全面地记录、存储被仿真或者被设计的芯片的所有信息，例如，存储在图1的存储器104中。其中，数据库系统212可以包括不同角度的数据库系统，例如，如图2所示，数据库系统2122和数据库系统2124。如前所述，仿真工具200通常只能响应Tcl命令并根据Tcl命令去执行相应的操作。但是，在很多情况下，接口函数是用C++编写的，这就需要包装函数来实现Tcl命令对C++接口函数的调用。如背景技术所述，包装函数的编写较为繁琐，会增加程序开发人员的负担。如何简化包装函数的编写流程是亟待解决的问题。C++语言支持的数据类型可以包括整型、双精度浮点型、浮点型。然而，Tcl命令使用的Tcl语言支持的数据类型包括字符串型。利用C++语言编写的函数可以是some_result_type func。可以看到，C++函数可以包括多个数据类型，开发人员在编写包装函数时，需要对C++函数中的数据类型一一识别，并在调用C++函数时，将相关信息在第一语言、第二语言支持的类型之间相互转换，且对于每个接口函数都要重新编写包装函数，并重新处理相关转化逻辑，若某一类型的转化逻辑有修改，维护起来也较难。因此，包装函数的编写以及维护都较为繁琐，这会增加程序开发人员的负担。有鉴于此，本申请提供一种用于程序语言转换的方法、编译方法及相关设备，通过预设的解析模板，解析目标函数的信息，其中，所述目标函数包括用第一语言编写的调用函数，以根据目标函数的信息生成用于将第二语言编写的指令转换为第一语言的指令，并根据第一语言的指令调用目标函数的包装函数。利用本申请提供的方法，简化了包装函数的编写流程，减轻了程序开发人员的负担。本申请实施例提供的一种用于程序语言转换方法，可以应用于终端设备，终端设备可以为下述中的任一项：台式电脑、笔记本电脑、平板电脑、智能手机等等。图3示出了本申请实施例所提供的用于程序语言转换方法300的流程示意图。如图3所示，方法300包括：步骤302：获取目标函数；其中，所述目标函数包括用第一语言编写的调用函数。其中，第一语言可以包括C++语言等。第一语言支持的数据类型可以包括整型、双精度浮点型、浮点型等，本申请对此不作限定。步骤304：利用预设的解析模板，解析所述目标函数，以得到所述目标函数的信息。目标函数的信息可以包括参数的个数、类型和函数的返回类型如上所述，在相关技术中，包装函数的编写需要开发人员识别C++接口函数中的参数类型。为简化开发人员的编写工作，在一些实施例中，可以通过预设的解析模板，对获取的目标函数进行函数信息的解析。在一些实施例中，预设的解析模板可以包括第一解析模板、第二解析模板和第三解析模板。其中，可以利用第三解析模板和目标函数的静态信息，将第一解析模板和第二解析模板实例化，以解析目标函数，得到目标函数的信息。这样通过预设的解析模板自动解析C++函数的参数信息，无需人工进行识别，加快了参数信息的解析速度，减轻了开发人员的负担。例如，可以编写一个第一解析模板type_at，接受一个std::size_t I和一个可变类型模板参数包。输入参数正确时，会生成一个成员类型type，表示参数包中指定位置的参数类型。其中，输入的I用于表示位置的索引。可以编写一个第二解析模板type_sequence，接受一个可变类型模板参数包。内含一个成员模板型type，接受一个std::size_t作为模板参数，调用第一解析模板type_at生成指定位置的参数类型。可以编写一个第三解析模板function_info，接受一个函数类型。内含一个成员类型type，表示输入的函数类型；还包含一个成员类型return_type，表示该函数的返回类型；还包含一个成员类型parameter_sequence，用第二解析模板type_sequence实现，表示该函数的参数类型包；还包含一个成员模板parameter_type，接受一个std::size_t I作为模板参数，用template parameter_sequence::template type＜I＞实现，表示指定位置的参数类型。以上模板型中，第三解析模板function_info可以通过将第一解析模板和第二解析模板实例化，直接用于解析输入函数的参数和返回类型等信息。需要说明的是，本申请实施例所使用的预设解析模板不限于上述第一解析模板、第二解析模板和第三解析模板，本申请对此不作限定。步骤306：根据所述目标函数的信息，生成包装函数；其中，所述包装函数用于将第二语言的指令转换为对第一语言目标函数的调用。其中，第二语言可以是Tcl语言等。第二语言支持的数据类型可以包括字符串型等，本申请对此不作限定。在一些实施例中，为了后续方便注册包装函数，可以使用宏来包裹所有包装函数需要的内容。其中，宏用于根据宏定义，将出现的所有指定的标识符，替换为定义的内容。下面是对宏的简要介绍。宏是C++在预处理阶段对源代码按某种顺序进行的文本替换，它发生在C++语法分析等编译步骤之前。以__LINE__宏为例，在使用__LINE__宏时，由于宏的文本替换的特性，__LINE__会变成用户调用处的行号。这样通过宏根据解析的参数信息生成包装函数，无需开发人员根据参数信息人工编写对应每个参数信息的转换代码，减轻了开发人员的负担。作为一个可选实施例，还可以使用模板函数包裹包装函数需要的内容。在使用模板函数时，由于模板函数是C++的语法内容，__LINE__会变成函数定义处的符号。在一些实施例中，可以提供一个模板用于定义第一语言和第二语言的转换规则。例如，可以定义C++语言支持的参数和返回类型的数据类型与Tcl语言支持的字符串型之间的转化规则。该模板可以是反射模板regist_func::reflect_traits，它接受一个返回类型作为模板参数，视情况定义所需的转化函数。反射模板定义了第一语言的数据结构和第二语言的输入信息的转换规则。例如，宏可以是基础宏 XDA_REGISTER_TCL_COMMAND_VERBOSE，基础宏需要的输入信息为：函数名、函数指针、反射模板的模板名。在一些实施例中，目标函数的信息还包括参数的类型。可以根据参数的类型调用反射模板。在一些实施例中，可以使用基础宏生成包装函数。基础宏会被替换为一个命名空间regist_func::FUNCTION_NAME##_pack，该命名空间内置有一个类型别名 function_info_t和两个函数，其中一个函数是对FUNCTION_PTR进行实际调用的invoker模板函数，另一个是实际的包装函数wrapper。其中，function_info_t用于简化对function_info＜std::remove_cv_t＜std::remove_pointer_t＜std::remove_reference_t＜decltype＞＞＞＞的访问。invoker模板函数用于将第一语言支持的数据类型转换为第二语言支持的数据类型。invoker模板函数的模板参数列表为std::size_t的参数包Ints，参数列表为Tcl_Interp* interp, const char *argv，std::index_sequence＜Ints…＞，其最后一个参数用于对Ints模板参数内容的推断。在一些实施例中，第二语言类型可以是Tcl语言，当第二语言为Tcl语言时，则需要wrapper函数与Tcl_CmdProc类型一致。在一些实施例中，在使用invoker模板函数时，若函数的返回类型与void相同，则调用std::invoke…)；否则，还需要在以上的基础上对返回值result调用REFLECT_TRAITS_TYPE＜function_info_t::return_type＞::encode)。其中，encode和decode为反射模板REFLECT_TRAITS_TYPE约定的字符串与指定类型对象的转化的接口。在一些实施例中，目标函数的信息可以包括标识符，在使用wrapper函数时，可以利用目标函数的标识符生成包装函数。例如，可以定义标识符的数量为 PARAMETER_SIZE。判断标识符的数量是否与预设标识符的数量相一致。若一致则调用invoker函数，否则就报错。需要注意的是，invoker函数的第三个参数需要传std::make_index_sequence＜PARAMETER_SIZE＞，让invoker自动推断其模板参数即可。第一函数用于将第一语言支持的数据类型转换为第二语言支持的数据类型。在基础宏的基础上，可以封装一些简化的包装函数生成宏，例如 XDA_REGISTER_TCL_COMMAND，只需要一个函数名。使用该宏的函数名可以无歧义地得到其函数指针，可以使用regist_func::reflect_traits作为默认的反射模板。生成的包装函数需要在程序中进行注册以使用包装函数。在一些实施例中，可以调用第二语言提供的注册接口在程序中注册所述包装函数。在一些实施例中，可以使用脚本解析指定的头文件，解析带约定注释@REGISTER_TCL_COMMAND的紧邻的函数声明，解析其函数类型等相关信息，在命名空间作用域调用合适的包装函数生成宏，在指定的函数内调用Tcl_CreateCommand注册相应命名空间内的wrapper函数。用户只需要在Tcl初始化代码中调用指定的函数名即可正确注册所有相应的命令。本申请提供的一种用于程序语言转换的方法，通过预设的解析模板，解析目标函数的信息，其中，所述目标函数包括用第一语言编写的调用函数，以根据目标函数的信息生成用于将第二语言编写的指令转换为第一语言的指令，并根据第一语言的指令调用目标函数的包装函数。利用本申请提供的方法，简化了包装函数的编写流程，减轻了程序开发人员的负担。图4示出了根据本申请实施例的示例性编译器410的示意图。编译器410可以运行在仿真工具200上。编译器210可以接收源代码404，并编译为执行代码406。如图4所示，编译器410可以包括前端412、中端414以及后端416。前端412可以用于根据具体的源语言来分析源代码的词法、语法、语义。在源代码的词法、语法、语义分析完成后，中端414可以将源代码转换为中间表示，并可以优化该中间表示。中间语言是一种面向语法，是易于翻译成目标程序的源代码的等效内部表示代码。其可理解性及易于生成执行代码的程度介于源代码和执行代码之间。常用的中间代码有逆波兰表示、四元式、三元式和树表示等。例如，中端414可以移除无用的代码、移除不可访问的代码、清除未使用的变量等。优化可以包括机器相关的优化和机器无关的优化。优化后的中间表示则可以被传递给后端416进行进一步处理。后端416可以根据目标处理器的架构来进一步优化中间表示，并生成执行代码。通常，执行代码是机器码。可以理解的是，编译器410的结构不限于图4的示例。例如，前端412和中端414可以被合称为编译器的前端。图5示出了根据本申请实施例的示例性编译方法500的示意图。编译方法500可以由图2所示的仿真工具200实施，更具体地，由在仿真工具200上运行的编译器实施。编译方法500可以包括如下步骤。步骤502：编译器410可以获取利用第一语言编写的源代码。其中，源代码包括根据方法300生成的包装函数。步骤504：编译器410将所述源代码编译为目标代码。本申请实施例还提供一种计算机设备。该计算机设备可以是图1的电子设备100。该电子设备100可以包括一个或者多个处理器、存储器；以及一个或多个程序；其中，所述一个或多个程序被存储在所述存储器中，并且被所述一个或多个处理器执行，所述程序包括用于执行如上任一实施例所述的方法300的指令。本申请还提供了一种包含计算机程序的非易失性计算机可读存储介质，所述非易失性计算机可读存储介质存储计算机指令，所述计算机指令用于使所述计算机执行如上任一实施例所述的方法300。本实施例的计算机可读介质包括永久性和非永久性、可移动和非可移动媒体，可以由任何方法或技术来实现信息存储。信息可以是计算机可读指令、数据结构、程序的模块或其他数据。计算机的存储介质的例子包括，但不限于相变内存、静态随机存取存储器、动态随机存取存储器、其他类型的随机存取存储器、只读存储器、电可擦除可编程只读存储器、快闪记忆体或其他内存技术、只读光盘只读存储器、数字多功能光盘或其他光学存储、磁盒式磁带，磁带磁盘存储或其他磁性存储设备或任何其他非传输介质，可用于存储可以被计算设备访问的信息。上述实施例的存储介质存储的计算机指令用于使所述计算机执行如上任一实施例所述的方法300，并且具有相应的方法实施例的有益效果，在此不再赘述。图6示出了本申请实施例的示例性应用场景600的示意图。应用场景600可以包括终端设备610和服务器620。其中，终端设备610和服务器620之间可通过有线或无线的通信网络连接。终端设备610包括但不限于桌面计算机、移动电话、移动电脑、平板电脑、媒体播放器、智能可穿戴设备、个人数字助理或其它能够实现上述功能的电子设备等。服务器620可以是独立的物理服务器，也可以是多个物理服务器构成的服务器集群或者分布式系统，还可以是提供云服务、云数据库、云计算、云函数、云存储、网络服务、云通信、中间件服务、域名服务、安全服务、CDN、以及大数据和人工智能平台等基础云计算服务的云服务器。服务器620用于向终端设备610的用户提供用于程序语言转换的服务，终端设备610中安装有与服务器620通信的客户端，用户可通过该客户端输入一段待转换代码，其中，待转换代码采用第二语言编写， 点击输入按钮后，客户端将待转换代码发送给服务器620，服务器620基于待转换代码，调用包装函数，以将第二语言编写的待转换代码转换为对目标函数的调用。其中，目标函数采用第一语言编写。服务器620可以将目标函数发送给客户端，以调用目标函数。在一些实施例中，用户可通过该客户端输入第二语言。在一些实施例中， 用户可通过该客户端输入目标引擎或目标数字内容创作工具，第二语言为目标引擎或目标数字内容创作工具支持的语言。在上述应用场景中，以用于程序语言转换的方法运行于服务器为例进行了说明，但是本公开不限于此，在另一些示例性实施例中，用于程序语言转换的方法还可以运行于本地终端设备，当用于程序语言转换的方法运行于本地终端设备时，用户可通过该本地终端设备输入一段待转换代码，其中，待转换代码采用第二语言编写， 点击输入按钮后，本地终端设备将待转换代码发送给服务器620，服务器620基于待转换代码，调用包装函数，以将第二语言编写的待转换代码转换为对目标函数的调用。其中，目标函数采用第一语言编写。服务器620可以将目标函数发送给本地终端设备，以调用目标函数。需要说明的是，上述应用场景仅为示例性的，本申请的实施方式在此方面不受任何限制。相反，本申请的实施方式可以应用于适用的任何场景所属领域的普通技术人员应当理解：以上任何实施例的讨论仅为示例性的，并非旨在暗示本申请的范围被限于这些例子；在本申请的思路下，以上实施例或者不同实施例中的技术特征之间也可以进行组合，步骤可以以任意顺序实现，并存在如上所述的本申请实施例的不同方面的许多其它变化，为了简明它们没有在细节中提供。另外，为简化说明和讨论，并且为了不会使本申请实施例难以理解，在所提供的附图中可以示出或可以不示出与集成电路芯片和其它部件的公知的电源/接地连接。此外，可以以框图的形式示出装置，以便避免使本申请实施例难以理解，并且这也考虑了以下事实，即关于这些框图装置的实施方式的细节是高度取决于将要实施本申请实施例的平台的。在阐述了具体细节以描述本申请的示例性实施例的情况下，对本领域技术人员来说显而易见的是，可以在没有这些具体细节的情况下或者这些具体细节有变化的情况下实施本申请实施例。因此，这些描述应被认为是说明性的而不是限制性的。尽管已经结合了本申请的具体实施例对本申请进行了描述，但是根据前面的描述，这些实施例的很多替换、修改和变型对本领域普通技术人员来说将是显而易见的。例如，其它存储器架构）可以使用所讨论的实施例。本申请实施例旨在涵盖落入所附权利要求的宽泛范围之内的所有这样的替换、修改和变型。因此，凡在本申请实施例的精神和原则之内，所做的任何省略、修改、等同替换、改进等，均应包含在本申请的保护范围之内。

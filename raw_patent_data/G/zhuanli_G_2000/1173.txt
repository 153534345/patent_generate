标题title
一种基于嵌入式操作系统的虚拟机
摘要abst
本发明公开了一种基于嵌入式操作系统的虚拟机，包括虚拟机运行环境，所述虚拟机运行环境运行在底层操作系统上，所述底层操作系统运行在处理器平台上，还包括运行在虚拟机运行环境之上的虚拟机，在一个虚拟机中独立运行OTA程序，在其他虚拟机应用程序运行的同时升级部分功能代码。通过虚拟机对运行在其中的应用程序提供统一的虚拟OS、虚拟设备等，隔离了底层操作系统的不同，通过虚拟机运行环境为每个虚拟机提供包括但不限于独立的CPU运行时间，内存空间，中断，设备等，提高虚拟机运行时的实时性、安全性和隔离性。
权利要求书clms
1.一种基于嵌入式操作系统的虚拟机，其特征在于，包括虚拟机运行环境，所述虚拟机运行环境运行在底层操作系统上，所述底层操作系统运行在处理器平台上，还包括运行在虚拟机运行环境之上的虚拟机，所述虚拟机运行环境为虚拟机提供运行资源，并对虚拟机内部实现功能所需要的资源进行管理、调度，所述虚拟机为运行在其中的程序提供虚拟OS和虚拟设备的API，虚拟OS将嵌入式操作系统的所必需的功能抽象出来，对程序提供统一的操作系统的接口，建立程序与底层操作系统之间的联系，在一个虚拟机中独立运行OTA程序，在其他虚拟机应用程序运行的同时升级部分功能代码。2.根据权利要求1所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述运行资源包括CPU运行时间、内存空间、中断，虚拟机内部实现功能所需要的资源包括文件系统、网络协议栈、外部设备。3.根据权利要求1所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述虚拟OS对程序提供统一的操作系统的接口，实现嵌入式操作系统应用的功能，嵌入式操作系统应用的功能包括内存管理、中断管理、文件系统、网络协议栈、虚拟内核，所述虚拟内核提供嵌入式操作系统具有的基本功能包括线程管理、线程间通信、线程间同步。4.根据权利要求1或3所述的一种基于嵌入式操作系统的虚拟机，其特征在于， 所述虚拟OS还提供了IPC功能，用于在运行多个虚拟机时，实现不同虚拟机之间的通信。5.根据权利要求1所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述虚拟设备将处理器常用的外设、硬件平台常用的设备抽象出来，适配不同的硬件平台，所抽象出的外设接口包括UART、SPI、IIC，所抽象的设备包括Sensor、Flash、LCD、LED。6.根据权利要求1所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述虚拟机运行环境为虚拟机提供独立的虚拟机管理器、虚拟内核管理器、中断管理器、虚拟文件系统管理器、网络协议栈管理器、虚拟设备管理器，对虚拟机内部所申请、占用的资源进行分配、管理、调度。7.根据权利要求1所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述虚拟机运行环境实现虚拟机中的程序与底层的操作系统之间的隔离，当程序死机时，不会影响底层的操作系统以及其他的运行中的虚拟机。8.根据权利要求1或6所述的一种基于嵌入式操作系统的虚拟机，其特征在于，还包括面向虚拟机中的程序的开发环境，用于对程序进行开发、测试，开发环境提供了一种编译器，用于对虚拟机及其编译、链接，生成用于烧录和调试的固件，底层操作系统、虚拟机运行环境作为基本无需更改的部分，以单独的镜像存在，所创建的每个虚拟机都分别作为一个镜像存在，开发环境所提供的编译器针对每个镜像分别编译，并在最后链接成为一个固件，用于烧录、调试。9.根据权利要求1或3或5所述的一种基于嵌入式操作系统的虚拟机，其特征在于，所述底层操作系统包括RT-Thread、OpenHarmony、FreeRTOS，为虚拟机运行环境及虚拟机提供实际的功能支持。
说明书desc
技术领域本发明涉及虚拟机技术领域，尤其涉及一种基于嵌入式操作系统的虚拟机。背景技术在目前的嵌入式应用开发中，针对硬件资源有限、实时响应要求高的设备都需要嵌入式操作系统。在使用嵌入式操作系统开发程序时，需要使用某种嵌入式操作系统特有的接口函数。不论是一些嵌入式操作系统的基本功能，或者是某些嵌入式操作系统的扩展功能，都需要该嵌入式操作系统的特有的接口函数。目前有一些针对嵌入式领域的虚拟机，实现了程序之间的相互隔离。但是，由于在每个虚拟机中都存在一个操作系统内核，因此，对于嵌入式硬件平台而言，极大地浪费了硬件资源，降低了整个平台运行的效率。并且，由于每个虚拟机中仍存在着不同的操作系统，程序仍需要针对操作系统提供的接口函数进行开发。无论是单独使用嵌入式操作系统开发程序，还是在虚拟机中使用嵌入式操作系统，都存在着程序与操作系统耦合程度高的缺点。额外的，使用虚拟机方式还存在着重复加载操作系统，浪费硬件资源的问题。有资料显示，操作系统调用硬件外设时，针对不同的操作系统，往往提供了专门的外设框架，需要单独针对该框架开发程序。并且使用时，通常需要信号量、互斥量等来管理硬件资源，使用繁琐、开发困难。并且程序与操作系统之间耦合程度大，针对不同的操作系统，往往需要专门开发相应的程序，一旦更换操作系统，修改代码量极大，严重影响开发进度。现有的虚拟机通常在虚拟机内部也运行了一个操作系统，对于嵌入式平台而言，这极大的浪费了硬件资源，降低了软件运行的效率。现有的嵌入式系统程序采用OTA升级有两种方式，分别是全量升级和差分升级。使用全量升级时，需要下载整个程序的升级包，需重启进入bootloader进行升级。使用差分升级时，尽管是升级整个应用程序的某个部分，但在下载差分升级包后，同样需要重启进入bootloader，根据原有的程序和差分升级包合成新的程序，进行升级。升级过程复杂，速度慢。中国专利文献CN114816666B公开了一种“ 嵌入式千字节Java虚拟机KVM虚拟机平台”。由Hardware、LinuxOS、JAVA CALL、phoneME Feature和Main Control Manager构成；phoneME Feature包括PCSL、CLDC和MIDP；Main Control Manager包括KVM_Init、KVM_Install、KVM_Run、KVM_Close、KVM_Remove、KVM_Socket、KVM_Download和KVM_Logic。上述技术方案程序与操作系统之间耦合程度大，可移植性差，同时内部也运行了一个操作系统，浪费硬件资源，降低软件运行效率，并且OTA升级不便。发明内容本发明主要解决程序与操作系统之间耦合程度大，可移植性差，同时内部也运行了一个操作系统，浪费硬件资源，降低软件运行效率，并且OTA升级不便的技术问题，提供一种基于嵌入式操作系统的虚拟机，通过虚拟机对运行在其中的程序提供统一的虚拟OS、虚拟设备等，隔离了底层操作系统的不同，通过虚拟机运行环境为每个虚拟机提供包括但不限于独立的CPU运行时间，内存空间，中断，设备等，提高虚拟机运行时的实时性、安全性和隔离性，可选整体或部分程序升级，并且部分升级某个虚拟机内程序时，不影响其他虚拟机内的程序的运行，提升了程序的可维护性和可升级性。本发明的上述技术问题主要是通过下述技术方案得以解决的：本发明包括虚拟机运行环境，所述虚拟机运行环境运行在底层操作系统上，所述底层操作系统运行在处理器平台上，还包括运行在虚拟机运行环境之上的虚拟机，所述虚拟机运行环境为虚拟机提供运行资源，并对虚拟机内部实现功能所需要的资源进行管理、调度，所述虚拟机为运行在其中的程序提供虚拟OS和虚拟设备的API，虚拟OS将嵌入式操作系统的所必需的功能抽象出来，对程序提供统一的操作系统的接口，建立程序与底层操作系统之间的联系，在一个虚拟机中独立运行OTA程序，在其他虚拟机应用程序运行的同时升级部分功能代码。作为优选，所述的运行资源包括CPU运行时间、内存空间、中断，虚拟机内部实现功能所需要的资源包括文件系统、网络协议栈、外部设备。作为优选，所述的虚拟OS对程序提供统一的操作系统的接口，实现嵌入式操作系统应用的功能，嵌入式操作系统应用的功能包括内存管理、中断管理、文件系统、网络协议栈、虚拟内核，所述虚拟内核提供嵌入式操作系统具有的基本功能包括线程管理、线程间通信、线程间同步。作为优选，所述的虚拟OS还提供了IPC功能，用于在运行多个虚拟机时，实现不同虚拟机之间的通信。作为优选，所述的虚拟设备将处理器常用的外设、硬件平台常用的设备抽象出来，适配不同的硬件平台，所抽象出的外设接口包括UART、SPI、IIC，所抽象的设备包括Sensor、Flash、LCD、LED。作为优选，所述的虚拟机运行环境为虚拟机提供独立的虚拟机管理器、虚拟内核管理器、中断管理器、虚拟文件系统管理器、网络协议栈管理器、虚拟设备管理器，对虚拟机内部所申请、占用的资源进行分配、管理、调度。虚拟机管理器提供对虚拟机的创建、卸载、挂起、运行等操作。虚拟机管理器通过时间片或者优先级的方式为虚拟机分配CPU的运行时间。在虚拟机初始化时，虚拟机管理器分配给虚拟机独立的内存空间、优先级等。如果底层的处理器平台存在多核或者多核异构，虚拟机管理器还可以为某个重要的虚拟机指定使用的核心。并且，虚拟机管理器还为虚拟机中的虚拟OS提供IPC功能，实现了虚拟机之间的通信。虚拟内核管理器为虚拟机中的虚拟OS提供虚拟内核的服务的管理，包括线程管理、线程间通信、线程间同步等嵌入式操作系统具有的基本功能。中断管理器为每个虚拟机提供独立的中断，每个虚拟机可以有自己的中断程序，为每个虚拟机提供独立的中断，提升虚拟机的实时性与安全性。虚拟文件系统管理器为虚拟机的虚拟OS提供虚拟文件系统的管理、调度，由底层操作系统的文件系统提供实际的功能支持。网络协议栈管理器为虚拟机的虚拟OS提供网络协议栈的管理、调度，由底层操作系统的网络协议栈提供实际的功能支持。虚拟设备管理器对虚拟机中抽象出来的虚拟设备进行分配、管理、调度。对于仅有一个虚拟机使用的外设，虚拟设备管理器提供一种直通的方式，将虚拟机与底层的设备直连。对于两个及多个虚拟机共同使用的设备，虚拟设备管理器通过共享的方式，按照虚拟机创建时设定的优先级进行分配、调度。通过调用底层操作系统的文件系统，向虚拟机提供标准的POSIX接口，实现了对虚拟设备的调用。例如打开设备、关闭设备、读数据、写数据、命令控制等。作为优选，所述的虚拟机运行环境实现虚拟机中的程序与底层的操作系统之间的隔离，当程序死机时，不会影响底层的操作系统以及其他的运行中的虚拟机。作为优选，还包括面向虚拟机中的程序的开发环境，用于对程序进行开发、测试，开发环境提供了一种编译器，用于对虚拟机及其编译、链接，生成用于烧录和调试的固件，底层操作系统、虚拟机运行环境作为基本无需更改的部分，以单独的镜像存在，所创建的每个虚拟机都分别作为一个镜像存在，开发环境所提供的编译器针对每个镜像分别编译，并在最后链接成为一个固件，用于烧录、调试。作为优选，所述的底层操作系统包括RT-Thread、OpenHarmony、FreeRTOS，用于为虚拟机运行环境及虚拟机提供实际的功能支持。底层操作系统向虚拟机和虚拟机运行环境提供实际的功能支持。底层操作系统中的文件系统向虚拟文件系统管理器提供实际的文件系统的功能，而且，文件系统还向虚拟设备提供利用POSIX接口操作设备的功能支持。开发环境提供了一种模拟器，模拟器运行在电脑上，提供与虚拟机相同的API和运行环境，可以方便地在电脑上验证程序。使得在开发过程中，硬件平台尚未准备好或者存在问题时，也能测试程序的功能，加快应用的开发进度。本发明的有益效果是：安全：硬件资源相互隔离，虚拟机中的程序出现错误时，不会影响另一个虚拟机。提高了虚拟机运行的隔离性和安全性。实时：运行环境为每个虚拟机提供中断通道，提高了虚拟机运行的实时性。移植方便：程序移植时直接迁移整个虚拟机，可以快速部署到另一个硬件平台或者嵌入式操作系统之上。程序运行在虚拟机之上，用户无需关注外设是否被其余线程中的程序占用。使用方便，减少重复开发：程序独立于底层的操作系统以及硬件。开发程序时，只需要按照虚拟机中的接口开发一次，简化了对应用的开发难度。提高了虚拟机的易用性。运行效率高：由于虚拟机内运行的是虚拟OS，而不是一个完整的操作系统，因此，降低了对硬件平台的资源消耗，提高了虚拟机的运行效率。功能模块化，提升了可升级性和可维护性，简化了开发难度：在使用时，各个服务运行在不同的虚拟机中，相互独立，通过IPC接口进行调用，实现了应用逻辑和应用逻辑所依赖的服务分离的效果。在程序升级时可以分别独立升级，在单独升级虚拟机内的程序的同时，不影响其他虚拟机内的程序的运行，提升了程序的可维护性和可升级性。在程序开发时，可以将应用程序和功能模块分别开发，分别在所提供的开发工具中的模拟器中验证功能，减少了程序之间的耦合，简化了开发难度。附图说明图1是本发明的一种总体架构图。图2是本发明的一种虚拟机内部架构图。图3是本发明的一种虚拟机运行环境内部架构图。图4是本发明的一种使用文件系统的虚拟机结构图。图5是本发明的一种申请存储介质的流程图。图6是本发明的一种程序访问创建的文件系统的流程图。图7是本发明的一种使用外部设备的虚拟机结构图。图8是本发明的一种虚拟机使用虚拟设备前初始化的流程图。图9是本发明的一种虚拟机内的程序访问创建的文件系统的流程图。图10是本发明的一种虚拟机间通信架构图。图11是本发明的一种虚拟机间访问创建的文件系统的流程图。图12是本发明的一种虚拟机启动流程图。图13是本发明的一种并行虚拟机架构图。图14是本发明的一种虚拟机工作流程图。图15是本发明的一种OTA升级流程图。具体实施方式下面通过实施例，并结合附图，对本发明的技术方案作进一步具体的说明。实施例：本实施例的一种基于嵌入式操作系统的虚拟机，如图1所示，包括底层操作系统，虚拟机运行环境和若干个虚拟机，以及配套的开发环境。虚拟机所提供的功能都是虚拟化的，实际功能由底层的操作系统提供功能支持，由虚拟机运行环境进行管理。底层的操作系统运行在处理器平台上，虚拟机运行环境运行在底层操作系统上。每个虚拟机运行在虚拟机运行环境之上，虚拟机内部不需要实际的操作系统。虚拟机为运行在其中的程序提供虚拟OS和虚拟设备的API。图中展示了虚拟机1、虚拟机2和虚拟机n。在实际应用中，可以创建任意个数的虚拟机。虚拟机运行环境为每个虚拟机提供运行资源，并对虚拟机内部实现功能所需要的资源进行管理、调度。上述运行资源包括CPU运行时间、内存空间、中断等，虚拟机内部实现功能所需要的资源包括文件系统、网络协议栈、外部设备等。底层的操作系统为虚拟机运行环境及虚拟机提供实际的功能支持。底层的操作系统可以是RT-Thread、OpenHarmony、FreeRTOS。如图2所示，虚拟机内部只运行一个程序，实现了虚拟机的轻量化。若想运行多个程序，需要创建多个对应的虚拟机，每个虚拟机中的程序相互隔离，但是可以通过统一的IPC接口进行功能调用。虚拟机可以通过虚拟机运行环境提供的IPC接口，实现虚拟机之间的相互通信。程序调用虚拟OS和虚拟设备，基于虚拟机提供的接口进行编译，独立于底层的操作系统，方便了程序的开发和移植。虚拟机为程序提供虚拟OS和虚拟设备。虚拟OS将嵌入式操作系统的所必需的功能抽象出来，适配了不同的嵌入式操作系统。虚拟OS对程序提供统一的操作系统的接口，实现了内存管理、中断管理、文件系统、网络协议栈、虚拟内核等操作系统应用的功能，用于建立程序与底层操作系统之间的联系。虚拟内核提供线程管理、线程间通信、线程间同步等嵌入式操作系统具有的基本功能。并且，虚拟OS还提供了IPC接口，用于在运行多个虚拟机时，实现不同虚拟机之间的通信和功能调用。虚拟设备将处理器常用的外设、硬件平台常用的设备抽象出来，适配了不同的硬件平台。所抽象出的外设包括但不限于UART、SPI、IIC等外设接口，所抽象的设备包括但不限于Sensor、Flash、LCD、LED等。虚拟设备使用了底层操作系统的文件系统提供标准的POSIX接口来操作设备。例如打开设备、关闭设备、读数据、写数据、命令控制等。如图3所示，虚拟机运行环境为虚拟机提供独立的虚拟机管理器、虚拟内核管理器、中断管理器、虚拟文件系统管理器、网络协议栈管理器、虚拟设备管理器等，对虚拟机内部所申请、占用的资源进行分配、管理、调度。其中，虚拟机管理器提供对虚拟机的创建、卸载、挂起、运行等操作。虚拟机管理器通过时间片或者优先级的方式为虚拟机分配CPU的运行时间。在虚拟机初始化时，虚拟机管理器分配给虚拟机独立的内存空间、优先级等。如果底层硬件平台的处理器存在多核或者多核异构，虚拟机管理器会启用内部的多核CPU管理器。多核CPU调度器启用时，会停止使用时间片方式调度虚拟机，改用优先级的方式为虚拟机分配CPU运行时间。多核CPU调度器内部有全局虚拟机调度表和指定CPU虚拟机调度表。如果虚拟机初始化时指定了要使用的某个CPU核心，就会将该虚拟机放置在指定CPU虚拟机调度表中，否则存放在全局虚拟机调度表。在CPU的一个核心运行虚拟机时，会在全局虚拟机调度表和指定CPU虚拟机调度表中运行优先级最高的虚拟机，如果优先级相同，那么先运行指定CPU虚拟机调度表中的虚拟机。虚拟内核管理器为虚拟机中的虚拟OS提供虚拟内核的服务的管理，包括线程管理、线程间通信、线程间同步等嵌入式操作系统具有的基本功能。中断管理器为每个虚拟机提供独立的中断，每个虚拟机可以有自己的中断程序，为每个虚拟机提供独立的中断，提升虚拟机的实时性与安全性。虚拟文件系统管理器为虚拟机的虚拟OS提供虚拟文件系统的管理、调度，由底层操作系统的文件系统提供实际的功能支持。网络协议栈管理器为虚拟机的虚拟OS提供网络协议栈的管理、调度，由底层操作系统的网络协议栈提供实际的功能支持。虚拟机管理器、虚拟内核管理器、中断管理器、虚拟文件系统管理器、网络协议栈管理器共同为虚拟机中的虚拟OS中的功能提供分配、管理、调度等服务。虚拟设备管理器对虚拟机中抽象出来的虚拟设备进行分配、管理、调度。对于仅有一个虚拟机使用的外设，虚拟设备管理器提供一种直通的方式，将虚拟机与底层的设备直连。对于两个及多个虚拟机共同使用的设备，虚拟设备管理器通过共享的方式，按照虚拟机创建时设定的优先级进行分配、调度。虚拟设备管理器通过调用底层操作系统的文件系统，向虚拟机提供标准的POSIX接口，实现了对虚拟设备的调用。例如打开设备、关闭设备、读数据、写数据、命令控制等。虚拟机运行环境实现了虚拟机中的程序与底层的操作系统之间的隔离，当程序死机时，不会影响底层的操作系统以及其他的运行中的虚拟机，实现了虚拟机的安全性与隔离性。底层操作系统向虚拟机和虚拟机运行环境提供实际的功能支持。例如，底层操作系统中的文件系统向虚拟文件系统管理器提供实际的文件系统的功能，而且，文件系统还向虚拟设备提供利用POSIX接口操作设备的功能支持。其中，底层的操作系统使用的可以是RT-Thread、OpenHarmony、FreeRTOS等。本发明还提供一种面向虚拟机中的程序的开发环境，用于对程序进行开发、测试。开发环境提供了一种编译器，用于对虚拟机及其编译、链接，生成用于烧录和调试的固件。在使用时，底层操作系统、虚拟机运行环境作为基本无需更改的部分， 以单独的镜像存在。同时，所创建的每个虚拟机都分别作为一个镜像存在。开发环境所提供的编译器可以针对每个镜像分别编译，并在最后链接成为一个固件，用于烧录、调试。开发环境提供了一种模拟器，模拟器运行在电脑上，提供与虚拟机相同的API和运行环境，可以方便地在电脑上验证程序。使得在开发过程中，硬件平台尚未准备好或者存在问题时，也能测试程序的功能，加快应用的开发进度。实施例1：初始化并访问文件系统如图4所示，表示了一种使用文件系统的虚拟机结构。包括虚拟机、虚拟机运行环境和操作系统，虚拟机建立在虚拟机运行环境上，虚拟机运行环境建立在硬件平台上。虚拟机通过虚拟OS，为程序提供虚拟文件系统；虚拟机运行环境的虚拟文件系统管理器对每个虚拟机中的文件系统进行管理，对硬件平台的存储介质进行分配、调度；底层的操作系统为虚拟机运行环境提供实际的文件系统和存储介质的驱动。其中，底层的操作系统使用的可以是RT-Thread、OpenHarmony、FreeRTOS，本实施例以RT-Thread为例进行说明。底层的操作系统所使用的文件系统可以是FatFS，jffs2，UFFS等。硬件平台所使用的存储介质可以是SD卡、NorFlash、NandFlash。为了方便介绍，这里只使用了一个虚拟机为例进行说明，在实际应用中，每个虚拟机都可以运行虚拟的文件系统。虚拟机使用文件系统，需要先申请一块用于运行文件系统的存储介质。如图5所示，描述了程序向虚拟机申请一块用于运行文件系统的存储介质的过程。1.程序调用虚拟OS中的虚拟文件系统，向虚拟机运行环境发送申请存储介质的请求。2.虚拟文件系统管理器分配给该虚拟机的存储介质的区块，并注册该区块的信息。3.底层操作系统的文件系统调用设备驱动格式化存储介质。如图6所示，描述了虚拟机内的应程序访问上述创建的文件系统的过程。虚拟机向虚拟机运行环境发送访问存储的请求。包括：程序调用虚拟OS中的虚拟文件系统，发送访问存储介质的请求。虚拟文件系统向虚拟机运行环境发送访问存储介质的请求。虚拟机运行环境调用底层操作系统。包括：虚拟文件系统管理器接收到请求，查找分配给该虚拟机的存储介质的区块。虚拟文件系统管理器向底层操作系统发送访问存储介质的区块的请求。底层操作系统访问存储介质。包括：底层操作系统的文件系统调用设备驱动访问存储介质。底层操作系统的设备驱动访问存储介质，获得访问结果。底层操作系统向虚拟机运行环境返回存储介质的访问结果。包括：底层操作系统的设备驱动向文件系统反馈访问结果。文件系统向虚拟机运行环境反馈访问结果。虚拟机运行环境向虚拟机返回存储介质的访问结果。包括：虚拟文件系统管理器获取到访问结果，向虚拟机反馈访问结果。虚拟机中的虚拟文件系统获取到访问结果，最终反馈到程序。实施例2：初始化并访问外部设备如图7所示，表示了一种使用外部设备的虚拟机结构。包括虚拟机、虚拟机运行环境和操作系统，虚拟机建立在虚拟机运行环境上，虚拟机运行环境建立在硬件平台上。虚拟机通过虚拟设备，为程序提供使用外部设备的接口；虚拟机运行环境的虚拟设备管理器对每个虚拟机中的虚拟设备进行管理，对硬件平台中处理器的外设和外接设备进行管理、分配、调度；底层的操作系统为虚拟机运行环境提供硬件平台中处理器的外设和外接设备的设备驱动。其中，虚拟设备可以是GPIO、UART、Sensor、Flash、LCD等。在实际应用中，虚拟设备可以是更多外设，例如SPI、IIC等。底层的操作系统使用的可以是RT-Thread、OpenHarmony、FreeRTOS，本实施例以RT-Thread为例进行说明。硬件平台所使用的物理设备为虚拟设备提供实际的硬件支持。为了方便介绍，这里只使用了一个虚拟机为例进行说明，在实际应用中，每个虚拟机都可以使用虚拟设备。虚拟机使用虚拟设备，需要先初始化该虚拟设备。如图8所示，描述了程序向虚拟机申请虚拟设备的过程。1.程序调用虚拟设备，向虚拟机运行环境发送初始化虚拟设备的请求。2.虚拟设备管理器分配给该虚拟机的虚拟设备，并注册该虚拟设备对应的物理设备的信息。3.底层操作系统的设备驱动初始化该物理设备。如图9所示，描述了虚拟机内的程序访问上述创建的文件系统的过程。1.虚拟机向虚拟机运行环境发送访问虚拟设备的请求。包括：程序调用标准的POSIX接口，发送操作虚拟设备的请求。2.虚拟机运行环境调用底层操作系统。包括：虚拟设备管理器接收到请求，查找分配给该虚拟机的虚拟设备。虚拟设备管理器向底层操作系统发送访问物理设备的请求。3.底层操作系统访问物理设备。包括：底层操作系统的设备驱动访问物理设备，获得访问结果。4.底层操作系统向虚拟机运行环境返回物理设备的访问结果。包括：底层操作系统的设备驱动向虚拟机运行环境反馈访问结果。5.虚拟机运行环境向虚拟机返回物理设备的访问结果。包括：虚拟设备管理器获取到访问结果，向虚拟机反馈访问结果。虚拟机中的虚拟设备获取到访问结果，最终反馈到程序。实施例3：虚拟机间通信虚拟机之间可以通过IPC进行通信。如图10所示，表示了一种虚拟机间通信的结构。包括虚拟机、虚拟机运行环境和操作系统，虚拟机建立在虚拟机运行环境上，虚拟机运行环境建立在硬件平台上。虚拟机通过虚拟OS中的IPC接口，为程序提供跨虚拟机的通信接口；虚拟机运行环境的虚拟机管理器对每个虚拟机进行管理，并提供跨虚拟机之间的访问通道；底层的操作系统为虚拟机运行环境提供实际的功能支持。其中，底层的操作系统使用的可以是RT-Thread、OpenHarmony、FreeRTOS，本实施例以RT-Thread为例进行说明。为了方便介绍，这里只使用了两个虚拟机为例进行说明，在实际应用中，任意个虚拟机之间都可以通信。如图11所示，描述了虚拟机内的程序访问上述创建的文件系统的过程。1.虚拟机1向虚拟机运行环境发送访问虚拟机2的请求。包括：虚拟机1中的程序调用虚拟OS中的IPC接口，向虚拟机运行环境发送访问虚拟机2的请求。2.虚拟机运行环境向虚拟机2发送访问请求。包括：虚拟机管理器接收到请求，查找虚拟机2的信息。虚拟机管理器向虚拟机2发送访问请求。3.虚拟机2接收虚拟运行环境的访问请求。包括：虚拟机2中的虚拟OS中的IPC接口接收到虚拟运行环境的访问请求，并反馈给虚拟机2中的程序。4.虚拟机2向虚拟运行环境返回访问结果。包括：虚拟机2中的程序调用虚拟OS中的IPC接口，向虚拟机运行环境发送访问结果。5.虚拟机运行环境向虚拟机1返回访问结果。包括：虚拟机管理器获取到访问结果，向虚拟机1反馈访问结果。虚拟机1中的虚拟OS中的IPC接口获取到访问结果，最终反馈到程序。实施例：虚拟机启动流程如图12所示，虚拟机流程：1.硬件平台上电2.底层操作系统初始化，调用osKernelInitialize;函数初始化操作系统的内核。3.虚拟运行环境初始化驱动，根据底层所使用的RT-Thread，将外设初始化函数转换为RT-Thread的接口格式并调用rt_device_init;来初始化驱动。4.虚拟机管理器创建虚拟机，调用VMStart;函数初始化虚拟机。包括为虚拟机分配固定的内存空间VMSetMemery;。为虚拟机分配执行的优先级VMSetPriority;。5.启动程序虚拟机初始化完成后，跳转到程序入口。实施例：综合示例如图13所示，在一个较为复杂的示例中，可以为实现逻辑部分的应用程序单独创建一个虚拟机，为其他提供功能支持的服务程序另外创建虚拟机。虚拟机可以通过虚拟OS中的IPC接口调用其他虚拟机提供的服务。上图所示的是一个接收网络消息，点亮LED的示例。包括虚拟机、虚拟机运行环境和操作系统，虚拟机建立在虚拟机运行环境上，虚拟机运行环境建立在硬件平台上。其中，底层的操作系统使用的可以是RT-Thread、OpenHarmony、FreeRTOS，本实施例以RT-Thread为例进行说明。为了方便介绍，这里使用了运行应用程序和运行服务程序的两个虚拟机为例进行说明，在实际应用中，任意虚拟机都可以调用其他虚拟机提供的服务。虚拟机2中的网络服务程序调用虚拟OS中的IPC接口，向其他虚拟机提供服务并等待调用。应用程序如图14所示，虚拟机1中的应用程序的流程图如下1. 应用程序初始化外设虚拟机向虚拟机运行环境中的虚拟设备管理器注册LED外设，并申请外设资源。2. 应用程序调用虚拟OS中的分布式服务接口，发现并调用网络服务。3. 应用程序解析网络信息。4. 如果是无效信息，应用程序返回while起始位置，继续接收网络信息。5. 如果是有效信息，继续解析LED指令。a. 如果是LED亮的指令。应用程序调用ioctrl;来点亮LED。虚拟机运行环境根据底层所使用的RT-Thread，将点亮LED转换为RT-Thread的接口格式并调用rt_device_write;。返回while起始位置，继续接收网络信息。b. 如果是LED灭的指令。应用程序调用ioctrl;来熄灭LED。虚拟机运行环境根据底层所使用的RT-Thread，将熄灭LED转换为RT-Thread的接口格式并调用rt_device_write;。返回while起始位置，继续接收网络信息。OTA升级流程如图15所示：1.OTA服务程序初始化外设2.OTA服务程序调用虚拟OS中的分布式服务接口，发现并调用网络服务。3.OTA服务程序解析网络信息。4.如果是无效信息，应用程序返回while起始位置，继续接收网络信息。5.如果是有效信息，继续解析OTA指令。a. 如果是升级网络的指令。OTA服务程序通过网络服务下载服务程序升级包。OTA服务程序单独升级服务程序并重启其所在的虚拟机2。返回while起始位置，继续接收网络信息。b. 如果是升级应用程序的指令。OTA服务程序通过网络服务下载应用程序升级包OTA服务程序单独升级应用程序并重启其所在的虚拟机1。返回while起始位置，继续接收网络信息。本实施例是为了说明在虚拟机初始化完成后，运行在虚拟机中的应用程序实现了与底层操作系统、硬件的完全隔离，应用程序仅需面向虚拟机中的接口开发，实现了应用程序的通用性。并且，虚拟机运行环境可以在不同的硬件、不同的操作系统上实现虚拟机的初始化，方便整个虚拟机的迁移。本实施例还展示了一种多虚拟机协作的运行方式，用户的应用逻辑代码单独创建一个虚拟机，其余的主要服务分别创建虚拟机，实现各个功能之间的模块化。一旦某个虚拟机内的程序需要升级，可以单独升级这个虚拟机的同时，不影响其他虚拟机内的程序的运行，提高整体程序的可维护性和可升级性。作为对比，现有的OTA升级方式有两种方式，分别是全量升级和差分升级。使用全量升级时，同时升级整个程序，在升级时不能运行。使用差分升级时，尽管是升级整个应用程序的某个部分，但还是需要参考整个应用程序，在升级时同样不能运行。最后，本实施例仅描述了运行单个虚拟机的工作过程。在实际开发中，本发明实现了同时运行多个虚拟机，并且实现了虚拟机之间的隔离。

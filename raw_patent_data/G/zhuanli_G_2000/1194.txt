标题title
一种处理着色语言的方法、装置、存储介质及电子设备
摘要abst
本申请的一些实施例提供了一种处理着色语言的方法、装置、存储介质及电子设备，该方法包括：确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；对所述GLSL文件进行预处理，获取代码字符串；根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；通过所述目标着色语言确定标准着色语言，并进行打包存储。本申请的一些实施例可以实现对GLSL文件的跨平台编译，使得生成的目标着色语言适用于任何类型的目标平台类型，适应性较广。
权利要求书clms
1.一种处理着色语言的方法，其特征在于，包括：确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；对所述GLSL文件进行预处理，获取代码字符串；根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；通过所述目标着色语言确定标准着色语言，并进行打包存储。2.如权利要求1所述的方法，其特征在于，所述对所述GLSL文件进行预处理，获取代码字符串，包括：添加与所述目标平台类型对应的宏定义规则；利用所述宏定义规则对所述GLSL文件进行读取和处理，获得所述代码字符串。3.如权利要求2所述的方法，其特征在于，所述利用所述宏定义规则对所述GLSL文件进行读取和处理，获得所述代码字符串，包括：读取所述GLSL文件中的字符串，将符合所述宏定义规则的字符串添加至所述代码字符串中；对所述GLSL文件中的指定头文件进行整合添加至所述代码字符串中。4.如权利要求1-3中任一项所述的方法，其特征在于，所述根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言，包括：按照GLSL语法对所述代码字符串进行分割，得到分词结果；对所述分词结果进行语法分析，得到初始抽象语法树；将所述初始抽象语法树转译为所述目标平台类型的目标shader类型对应的目标抽象语法树；生成与所述目标抽象语法树对应的所述目标着色语言。5.如权利要求4所述的方法，其特征在于，所述生成与所述目标抽象语法树对应的所述目标着色语言之前，所述方法还包括：将与着色语言主函数相关的函数放在第一集合，将与所述着色语言主函数相关的全局变量放在第二集合。6.如权利要求1-3中任一项所述的方法，其特征在于，所述通过所述目标着色语言确定标准着色语言，并进行打包存储，包括：通过判定所述目标平台类型是否为绘图应用程序接口Vulkan平台，获取所述标准着色语言；将所述标准着色语言转为二进制文件，并打包存储至目标文件中。7.如权利要求6所述的方法，其特征在于，所述通过判定所述目标平台类型是否为绘图应用程序接口Vulkan平台，获取所述标准着色语言，包括：若所述目标平台类型为所述Vulkan平台，则对所述目标着色语言进行处理生成标准着色语言；若所述目标平台类型不是所述Vulkan平台，则将所述目标着色语言作为所述标准着色语言。8.一种处理着色语言的装置，其特征在于，包括：输入模块，用于确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；预处理模块，用于对所述GLSL文件进行预处理，获取代码字符串；生成模块，用于根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；打包存储模块，用于通过所述目标着色语言确定标准着色语言，并进行打包存储。9.一种计算机可读存储介质，其特征在于，所述计算机可读存储介质上存储有计算机程序，其中，所述计算机程序被处理器运行时执行如权利要求1-7中任意一项权利要求所述的方法。10.一种电子设备，其特征在于，包括存储器、处理器以及存储在所述存储器上并在所述处理器上运行的计算机程序，其中，所述计算机程序被所述处理器运行时执行如权利要求1-7中任意一项权利要求所述的方法。
说明书desc
技术领域本申请涉及渲染技术领域，具体而言，涉及一种处理着色语言的方法、装置、存储介质及电子设备。背景技术着色器是一种运行在GPU上的计算机程序，用来实现一些渲染效果。同一渲染效果通常需要适配各种不同类型的机器，然而不同类型的机器通常使用的图形渲染接口不同，且这些图形渲染接口用到的着色语言不同，使得同一渲染效果适配不同类型机器比较困难。目前，一个渲染效果想要在不同的平台的不同版本上实现，需要程序人员针对不同的平台和版本编写不同的shader语言。shader语言间的通用性较差，直接导致了程序人员的工作压力倍增，降低了渲染效果的实现效率。因此，如何提供一种高效且通用的处理着色语言的方法的技术方案成为亟需解决的技术问题。发明内容本申请的一些实施例的目的在于提供一种处理着色语言的方法、装置、存储介质及电子设备，通过本申请的实施例的技术方案可以实现对着色语言文件的转译，使得转译得到的目标着色语言适应于不同的平台和版本，通用性较好，提升了渲染效果的实现效率，降低了程序人员的工作压力。第一方面，本申请的一些实施例提供了一种处理着色语言的方法，包括：确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；对所述GLSL文件进行预处理，获取代码字符串；根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；通过所述目标着色语言确定标准着色语言，并进行打包存储。本申请的一些实施例通过对待处理参数中的GLSL文件进行预处理得到的代码字符串进行转译得到目标shader类型的目标着色语言，最后进行打包存储。本申请的一些实施例以GLSL文件为基础，可以转译为各种不同平台和版本的目标着色语言，实现了只写一种语言既可以翻译到shader各个平台，以及同一平台的不同版本的代码配置，通用性较好，提升了渲染效果的实现效率，降低了程序人员的工作压力。在一些实施例，所述对所述GLSL文件进行预处理，获取代码字符串，包括：添加与所述目标平台类型对应的宏定义规则；利用所述宏定义规则对所述GLSL文件进行读取和处理，获得所述代码字符串。本申请的一些实施例通过添加目标平台类型对应的宏定义规则对GLSL文件进行预处理得到代码字符串，可以实现对GLSL文件有效处理，为后续提供代码支持。在一些实施例，所述利用所述宏定义规则对所述GLSL文件进行读取和处理，获得所述代码字符串，包括：读取所述GLSL文件中的字符串，将符合所述宏定义规则的字符串添加至所述代码字符串中；对所述GLSL文件中的指定头文件进行整合添加至所述代码字符串中。本申请的一些实施例通过宏定义规则对GLSL中的字符串进行分类和整合，得到代码字符串，可以为后续转译提供有效的代码支持。在一些实施例，所述根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言，包括：按照GLSL语法对所述代码字符串进行分割，得到分词结果；对所述分词结果进行语法分析，得到初始抽象语法树；将所述初始抽象语法树转译为所述目标平台类型的目标shader类型对应的目标抽象语法树；生成与所述目标抽象语法树对应的所述目标着色语言。本申请的一些实施例通过对代码字符串进行分割、语法分析、转译后生成对应的目标着色语言，可以实现GLSL文件的跨平台编译。在一些实施例，所述生成与所述目标抽象语法树对应的所述目标着色语言之前，所述方法还包括：将与着色语言主函数相关的函数放在第一集合，将与所述着色语言主函数相关的全局变量放在第二集合。本申请的一些实施例通过对着色语言主函数相关的函数和全局变量进行分类存放，可以后续实现高效转译。在一些实施例，所述通过所述目标着色语言确定标准着色语言，并进行打包存储，包括：通过判定所述目标平台类型是否为绘图应用程序接口Vulkan平台，获取所述标准着色语言；将所述标准着色语言转为二进制文件，并打包存储至目标文件中。本申请的一些实施例通过对目标平台类型进行判定确定标准着色语言，可以确保转译后打包存储的准确性。在一些实施例，所述通过判定所述目标平台类型是否为绘图应用程序接口Vulkan平台，获取所述标准着色语言，包括：若所述目标平台类型为所述Vulkan平台，则对所述目标着色语言进行处理生成标准着色语言；若所述目标平台类型不是所述Vulkan平台，则将所述目标着色语言作为所述标准着色语言。本申请的一些实施例通过确认是否为Vulkan平台可以确认是否对目标着色语言进行处理再存储，可以实现Vulkan平台的针对性处理，适应性较好。第二方面，本申请的一些实施例提供了一种处理着色语言的装置，包括：输入模块，用于确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；预处理模块，用于对所述GLSL文件进行预处理，获取代码字符串；生成模块，用于根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；打包存储模块，用于通过所述目标着色语言确定标准着色语言，并进行打包存储。第三方面，本申请的一些实施例提供一种计算机可读存储介质，其上存储有计算机程序，所述程序被处理器执行时可实现如第一方面任一实施例所述的方法。第四方面，本申请的一些实施例提供一种电子设备，包括存储器、处理器以及存储在所述存储器上并可在所述处理器上运行的计算机程序，其中，所述处理器执行所述程序时可实现如第一方面任一实施例所述的方法。第五方面，本申请的一些实施例提供一种计算机程序产品，所述的计算机程序产品包括计算机程序，其中，所述的计算机程序被处理器执行时可实现如第一方面任一实施例所述的方法。附图说明为了更清楚地说明本申请的一些实施例的技术方案，下面将对本申请的一些实施例中所需要使用的附图作简单地介绍，应当理解，以下附图仅示出了本申请的某些实施例，因此不应被看作是对范围的限定，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他相关的附图。图1为本申请的一些实施例提供的一种处理着色语言的系统图；图2为本申请的一些实施例提供的处理着色语言的方法流程图之一；图3为本申请的一些实施例提供的路径拼接函数处理的方法流程图；图4为本申请的一些实施例提供的处理着色语言的方法流程图之二；图5为本申请的一些实施例提供的一种处理着色语言的装置组成框图；图6为本申请的一些实施例提供的一种电子设备示意图。具体实施方式下面将结合本申请的一些实施例中的附图，对本申请的一些实施例中的技术方案进行描述。应注意到：相似的标号和字母在下面的附图中表示类似项，因此，一旦某一项在一个附图中被定义，则在随后的附图中不需要对其进行进一步定义和解释。同时，在本申请的描述中，术语“第一”、“第二”等仅用于区分描述，而不能理解为指示或暗示相对重要性。相关技术中，程序员较为常写的三种shader语言分别为：基于OpenGL API的GLSL，微软开发的基于DirectX的HLSL，苹果公司开发基于苹果机器的Metal语言。但是，这些shader语言之间是不兼容的，特定平台只能使用特定的shader语言。由于机器配置的不同，支持版本也不一样，游戏中一个渲染效果想要在多个不同的平台的不同版本上实现，就需要写很多份shader语言文件。例如，在嵌入式设备上开发图形渲染程序时，需要写适用于嵌入式设备的Gles着色器代码；在台式设备上开发图形渲染程序时使用GLSL。由于OpenGLES是根据嵌入式设备的特点而在OpenGL的基础上进行了适应性的裁剪和适配；所以，适用于嵌入式设备的着色器代码无法在台式设备上运行；同理，适用于台式设备的着色器代码也无法直接在嵌入式设备上运行。由于设备的配置和系统不同，所需求的shader的版本不一样，同种语言不同版本之间的转换是有限制存在的。为了适用于常用的所有设备，如果要实现同一个渲染效果，所有平台不同版本的shader语言都需要开发者手写一遍，这样大大的降低了开发效率，而且为了需要开发者对所有shader语言的特征都有所了解，这也大大提高了开发门槛。鉴于此，本申请的一些实施例提出了一种高效的处理着色语言的方法，该方法以GLSL文件为基础，通过对GLSL文件进行预处理得到代码字符串后，再基于目标平台类型对代码字符串进行转译，生成适应于目标平台类型的目标着色语言并进行打包存储。本申请的一些实施例可以提升同一个渲染效果的开发效率，实现高效的shader跨平台编译，降低了开发门槛，适应性较广。下面结合附图1示例性阐述本申请的一些实施例提供的处理着色语言的系统的整体组成结构。如图1所示，本申请的一些实施例提供了一种处理着色语言的系统，该系统包括：终端100和处理服务器200。具体的，终端100可以由程序员输入对应的待处理参数以给到处理服务器200。处理服务器200中的shader编译器获取到待处理参数后，可以对GLSL文件进行预处理，得到代码字符串，之后基于目标平台类型对代码字符串进行转译后生成与目标shader类型对应的目标着色语言，并打包存储。在本申请的一些实施例中，终端100可以为移动终端，也可以为非便携的电脑终端，本申请实施例在此不作具体限定。在本申请的另一些实施例中，若终端100具有可以对GLSL文件进行预处理、转译、生成和打包存储的功能，此时可以不设置处理服务器200。具体的可以根据实际情况进行灵活设置，本申请实施例并不局限于此。下面结合附图2示例性阐述本申请的一些实施例提供的由处理服务器200执行的处理着色语言的实现过程。请参见附图2，图2为本申请的一些实施例提供的一种处理着色语言的方法流程图，该处理着色语言的方法包括：S210，确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型。例如，在本申请的一些实施例中，首先确定基础的GLSL文件，然后确定其当前shader类型，并确定需要转换到的目标平台类型和目标shader类型。其中，GLSL中可以将shader的渲染类型根据文件后缀进行区分。具体的，程序员以GLSL语言为基础书写着色器语言，并添加一些必须遵守的GLSL相关的特定书写规则，使用本申请实施例可将特殊书写GLSL文件转为多种平台不同版本的目标着色语言。需要说明的是，因为一般高版本可以支持低版本的特性，低版本大部分都不支持高版本特性，所以程序员需要尽量书写GLSL高版本语言，例如，光追的一些特性支持是需要到GLSL 4.6版本之上的。S220，对所述GLSL文件进行预处理，获取代码字符串。例如，在本申请的一些实施例中，通过对GLSL文件进行代码预处理，可以得到用于下一步处理的代码字符串。在本申请的一些实施例中，S220可以包括：添加与所述目标平台类型对应的宏定义规则；利用所述宏定义规则对所述GLSL文件进行读取和处理，获得所述代码字符串。例如，在本申请的一些实施例中，每个平台有自己专属特性，这些特性是解析时无法判定的，而且如果出现一些专属错误会带来很严重的问题，容易直接导致别的平台渲染效果错误。所以本申请的实施例定义了一种书写规则，是在平台宏定义条件编译下来书写当前平台下于其它平台不同的特征。以metal平台为例，书写方式如下：#if define//这部分书写metal平台和其它平台不同特性#else//其它平台特性#endif上述代码中，METAL_SHADER为metal平台的宏定义，宏定义的添加不需要程序员自己手动添加，shader解析器解析时会根据目标平台类型自动进行添加。通过宏定义可以对GLSL文件进行处理，输出 result_str字符串。在本申请的一些实施例中，S220可以包括：读取所述GLSL文件中的字符串，将符合所述宏定义规则的字符串添加至所述代码字符串中；对所述GLSL文件中的指定头文件进行整合添加至所述代码字符串中。例如，在本申请的一些实施例中，GLSL文件预处理是处理掉与宏定义相关的，并将include的头文件相关代码全部整合到一起，放入一个代码字符串里，以方便下个步骤的处理。例如，设计预处理函数PreprocessFunc，该函数输入公共版本库以及当前版本的函数库所在目录，输入GLSL文件字符串Str，并添加平台的宏定义，输出为 result_str字符串。具体的，对GLSL文件字符串Str挨个词提取，遇到非宏相关以及头文件相关，直接不做处理按照顺序放入result_str中。遇到宏定义相关的需要进行替换解析后放入result_str中，以及根据宏定义去掉一些不需要的代码。遇到关键字“include”时，需要对头文件进行路径拼接函数处理。建立IncludeDirs集合用于存储处理过的头文件绝对路径，根据头文件的当前绝对路径判断是否已经处理过，即判定IncludeDirs中是否存在，如果存在则已经处理过，直接跳到include之后代码进行处理。如果当前绝对路径不存在，则报错退出处理。如果当前绝对路径存在且没有处理过，提取当前路径文件的字符串Str_i 放到 PreprocessFunc函数处理，得到的字符串按顺序放入result_str中，并将当前绝对路径存入IncludeDirs中。通过这样递归处理可以将GLSL文件的字符串Str全部读取结束，此时得到的result_str就是预处理后结果。S230，根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言。例如，在本申请的一些实施例中，通过需要转译适应的目标平台类型，对result_str进行转译，生成对应的目标着色语言。在本申请的一些实施例中，S230可以包括：按照GLSL语法对所述代码字符串进行分割，得到分词结果；对所述分词结果进行语法分析，得到初始抽象语法树；将所述初始抽象语法树转译为所述目标平台类型的目标shader类型对应的目标抽象语法树；生成与所述目标抽象语法树对应的所述目标着色语言。例如，在本申请的一些实施例中，抽象语法树是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构。具体的，将result_str分割成一个个最小的语法单元，其中，语法单元分割是根据GLSL语法处理的。对分割后的语法单元进行分析，建立语法单元之间的关系，得到初始Ast。之后根据初始Ast以及需要翻译的版本，转译得到其它平台版本shader语言的，目标Ast，然后根据目标Ast生成与目标shader类型对应的目标代码。应理解，不同Shader语言之间可转换原因是，Shader语言之间的区别在于关键字和类型名称的不同，以及一些编写规则稍有区别，但是基本都可以找到对应同等级的语法规则，通过语法间的对应关系，可以实现转译。为了降低代码冗余减少内存占用，在本申请的一些实施例中，在执行S220时还可以包括：将与着色语言主函数相关的函数放在第一集合，将与所述着色语言主函数相关的全局变量放在第二集合。例如，在本申请的一些实施例中，在目标代码生成之前，可以收集所有主函数直接或者间接引用到的函数放到set_func中，以及收集主函数直接或者间接引用到的全局变量放入set_var。从代码字符串的主函数开始，收集主函数间接或直接所用到的函数以及全局变量分别放到set_func和set_var中。转译时，只需处理翻译set_func和set_var中的函数和变量。通过这个步骤处理可以去掉冗余的代码，减少物理内存占用量以及GPU占用量。在本申请的一些实施例中，在转译的过程中通常也会面对一些特殊情况，下面示例性对几种特殊情况进行处理的过程进行示例性阐述。在转译时，不同版本的同一词意的书写可能不同，因此可以在代码中保存不同版本的词素间的对应关系，并保存到不同的数组中，将不同的数组放入同一个位置。如果没有词有可以替换的其它书写，这个位置标志为error。一种实施方式中，针对当前需要转译的语义的词在目标平台类型所支持的语言中不存在的情况，则会碰到位置标志error，此时直接报错退出。另一种实施方式中，需要转译的目标着色语言的语言存在不支持的函数时，需要判断是否可用其余函数替换。如果可以则进行替换，否则进行报错处理。例如，textueGather这个函数在GLSL中支持，在gles 3.0中不支持但是支持texture函数，texture可实现textureGather相似功能，在翻译gles 3.0时可以将textureGather函数替换为texture函数进行处理。另一种实施方式中，目标语言需要统一处理的feature，这些feature生成时可以自动写到shader中。例如，高版本GLSL翻译到gles310时，gles需要全局int变为higp的需求，可以直接在版本书写之后添加“precision highp int”。可以理解的是，在转译的过程中除了上述几种特殊情况之外还可能存在其他特殊处理的情况，具体的可以根据实际遇到的情况进行调整，本申请实施例并不局限于此。S240，通过所述目标着色语言确定标准着色语言，并进行打包存储。在本申请的一些实施例中，S240可以包括：通过判定所述目标平台类型是否为绘图应用程序接口Vulkan平台，获取所述标准着色语言；将所述标准着色语言转为二进制文件，并打包存储至目标文件中。例如，在本申请的一些实施例中，针对特殊的Vulkan平台，可以先进行判定再获取标准着色语言，最后对标准着色语言进行打包存储。其中，打包存储的具体方式为：将生成好的shader文件，转为二进制放入pack文件中。在pack的同级目录下会有一个xml文件来记录存入pack文件中的名称、所在pack文件中的位置、大小等信息。使用时根据xml文件信息即可找到需要的pack文件。实际使用过程中一个游戏场景的shader文件数量就有可能达到上万个，放入pack包中使用，就可以大大减少文件的数量，也可以起到文档加密的作用。在本申请的一些实施例中，S240可以包括：若所述目标平台类型为所述Vulkan平台，则对所述目标着色语言进行处理生成标准着色语言；若所述目标平台类型不是所述Vulkan平台，则将所述目标着色语言作为所述标准着色语言。例如，在本申请的一些实施例中，针对特殊的Vulkan平台，获取目标着色语言对应的标准的GLSL格式的shader文件，使用glslangValidator工具对shader文件进行编译生成spv文件。其中glslangValidator工具为OpenGL标准定制官方Khronos Group定制的GLSL参考编译器，使用该工具进行最后的spv编译，可以对GLSL语法进行再次检错。如果编译失败，将退出程序不再进行下一步的打包存储处理，并给用户以错误提示，用户修改后可以继续编译。编译成功则继续下一步打包存储操作。若不是Vulkan平台则目标着色语言就是最终生成好的shader文件。下面结合附图3示例性阐述上述“路径拼接函数处理”的实现过程。在本申请的一些实施例中，在进行路径拼接函数处理之前需要准备好函数库。具体的，用户可以根据需求定制自己的函数库，函数库可以包括不同平台函数库。由于同一个渲染效果的实现函数在不同平台或版本的书写方式不同，因此可以创建不同平台和不同版本的函数库。例如，针对光照效果，如果支持光追就可以用光追实现，光追特性只有高版本语言才能支持，所以低版本时要用其它方式实现。并且，函数库所在文件夹目录可以写入相应的配置文件中，使用时即可调用不同函数。用户如果需要使用这些函数库中的文件，不需要写较为冗长的绝对路径，引用时只需写相对路径即可。例如：在c:AB文件夹下建立名称为ShaderLib#版本号，只需将c:AB文件下ShaderLib文件夹放置在此即可，然后将函数文件放入ShaderLib文件夹下即可。例如，在shader中书写时，采用如下书写方法：#include“ShaderLibshaderFuncTest.h”；include中书写时并不需要写版本号，版本的判定解析由shader解析器完成。文件的后缀不进行限定，为可读文本文件即可。库目录ShaderLib下可以有子文件夹，写以shaderLib文件的相对路径即可。请参见附图3，图3为本申请的一些实施例提供的路径拼接函数处理的方法流程图，该路径拼接函数处理的方法包括：S310，获取头文件的书写路径。例如，作为本申请的一个具体示例，输入头文件Header_str路径。S320，判定书写路径是否在函数库中，若是则执行S350，否则执行S330。例如，作为本申请的一个具体示例，对头文件Header_str路径，判断是否在函数库中。判断方式是：将所有的当前版本号的函数库目录以及公共库目录，挨个和Header_str进行拼接，查找拼接出来的路径是否存在，若存在则输出拼接路径，拼接路径后续作为绝对路径输出。否则继续下面判定。S330，判定书写路径是否为相对路径，若是则执行S350，否则执行S340。例如，作为本申请的一个具体示例，对Header_str进行相对路径的判定，即当前头文件所在文件夹路径和Header_str进行拼接，查询当前拼接的路径是否存在，如果存在后续则输出拼接路径，拼接路径后续作为绝对路径输出。否则继续下一步判定。S340，判定书写路径是否为绝对路径，若是则执行S360，否则输出Error。例如，作为本申请的一个具体示例，对Header_str进行绝对路径判定，直接查询当前对Header_str路径是否存在，如果存在则后续直接输出绝对路径。S350，输出拼接路径。S360，输出绝对路径。下面结合附图4示例性阐述本申请的一些实施例提供的处理着色语言的具体过程。请参见附图4，图4为本申请的一些实施例提供的一种处理着色语言的方法流程图。下面示例性阐述上述过程。S410，获取GLSL文件、GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型。例如，作为本申请的一个具体示例，将按照GLSL规则书写完成的GLSL文件、平台类型及shader类型输入到终端100内，以使得处理服务器200及时获取。S420，添加与目标平台类型对应的宏定义规则。例如，作为本申请的一个具体示例，添加平台类型对应的宏定义规则。S430，利用宏定义规则对GLSL文件进行读取和处理，获得代码字符串。例如，作为本申请的一个具体示例，根据平台宏定义规则对GLSL文件进行预处理，对头文件和宏定义进行处理，得到一个代码字符串。S440，根据目标平台类型，对代码字符串进行转译，生成与目标shader类型对应的目标着色语言。例如，作为本申请的一个具体示例，将这个代码字符串解析出该GLSL代码抽象语法树，根据Ast和平台类型以及shader版本类型通过转译器翻译为目标着色语言。S450，判定目标平台类型是否为Vulkan平台，若是则执行S460，否则执行S470。S460，对目标着色语言进行编译生成标准着色语言。例如，作为本申请的一个具体示例，对于vulkan平台，根据需求shader版本生成对应的版本的GLSL，然后使用glslangvalitor工具生成对应spv文件。S470，将目标着色语言作为标准着色语言。S480，将标准着色语言转为二进制文件，并打包存储至目标文件中。例如，作为本申请的一个具体示例，对标准着色语言进行二进制打包处理存储。可以理解的是，S410~S480的具体实现过程可以参照上文提供的方法实施例，为避免重复，此处适当省略详细描述。由上文提供的方法实施例可知，本申请可以将特殊GLSL语言翻译到其它平台以及版本的可用的shader语言。其中目标语言支持GLSL、HLSL、gles、metal等，以此实现一个渲染效果的跨平台实现，大大节省了开发人力，提升了开发效率。而且，GLSL中函数库的构造使用，使得函数库可以共享使用，实现了同一函数名称不同的兼容性，简化了高到低版本翻译的难度。将生成好的shader文件转为二进制流打包放入pack文件中使用，优化了文件结构，对shader文件进行了一定的加密，提高了安全性。请参考图5，图5示出了本申请的一些实施例提供的处理着色语言的装置的组成框图。应理解，该处理着色语言的装置与上述方法实施例对应，能够执行上述方法实施例涉及的各个步骤，该处理着色语言的装置的具体功能可以参见上文中的描述，为避免重复，此处适当省略详细描述。图5的处理着色语言的装置包括至少一个能以软件或固件的形式存储于存储器中或固化在处理着色语言的装置中的软件功能模块，该处理着色语言的装置包括：输入模块510，用于确定待处理参数，其中，所述待处理参数包括：着色语言GLSL文件、所述GLSL文件对应的当前着色器shader类型、目标平台类型和目标shader类型；预处理模块520，用于对所述GLSL文件进行预处理，获取代码字符串；生成模块530，用于根据所述目标平台类型，对所述代码字符串进行转译，生成与所述目标shader类型对应的目标着色语言；打包存储模块540，用于通过所述目标着色语言确定标准着色语言，并进行打包存储。所属领域的技术人员可以清楚地了解到，为描述的方便和简洁，上述描述的装置的具体工作过程，可以参考前述方法中的对应过程，在此不再过多赘述。本申请的一些实施例还提供了一种计算机可读存储介质，其上存储有计算机程序，所述程序被处理器执行时可实现如上述实施例提供的上述方法中的任意实施例所对应方法的操作。本申请的一些实施例还提供了一种计算机程序产品，所述的计算机程序产品包括计算机程序，其中，所述的计算机程序被处理器执行时可实现如上述实施例提供的上述方法中的任意实施例所对应方法的操作。如图6所示，本申请的一些实施例提供一种电子设备600，该电子设备600包括：存储器610、处理器620以及存储在存储器610上并可在处理器620上运行的计算机程序，其中，处理器620通过总线630从存储器610读取程序并执行所述程序时可实现如上述任意实施例的方法。处理器620可以处理数字信号，可以包括各种计算结构。例如复杂指令集计算机结构、结构精简指令集计算机结构或者一种实行多种指令集组合的结构。在一些示例中，处理器620可以是微处理器。存储器610可以用于存储由处理器620执行的指令或指令执行过程中相关的数据。这些指令和/或数据可以包括代码，用于实现本申请实施例描述的一个或多个模块的一些功能或者全部功能。本公开实施例的处理器620可以用于执行存储器610中的指令以实现上述所示的方法。存储器610包括动态随机存取存储器、静态随机存取存储器、闪存、光存储器或其它本领域技术人员所熟知的存储器。以上所述仅为本申请的实施例而已，并不用于限制本申请的保护范围，对于本领域的技术人员来说，本申请可以有各种更改和变化。凡在本申请的精神和原则之内，所作的任何修改、等同替换、改进等，均应包含在本申请的保护范围之内。应注意到：相似的标号和字母在下面的附图中表示类似项，因此，一旦某一项在一个附图中被定义，则在随后的附图中不需要对其进行进一步定义和解释。以上所述，仅为本申请的具体实施方式，但本申请的保护范围并不局限于此，任何熟悉本技术领域的技术人员在本申请揭露的技术范围内，可轻易想到变化或替换，都应涵盖在本申请的保护范围之内。因此，本申请的保护范围应所述以权利要求的保护范围为准。需要说明的是，在本文中，诸如第一和第二等之类的关系术语仅仅用来将一个实体或者操作与另一个实体或操作区分开来，而不一定要求或者暗示这些实体或操作之间存在任何这种实际的关系或者顺序。而且，术语“包括”、“包含”或者其任何其他变体意在涵盖非排他性的包含，从而使得包括一系列要素的过程、方法、物品或者设备不仅包括那些要素，而且还包括没有明确列出的其他要素，或者是还包括为这种过程、方法、物品或者设备所固有的要素。在没有更多限制的情况下，由语句“包括一个……”限定的要素，并不排除在包括所述要素的过程、方法、物品或者设备中还存在另外的相同要素。

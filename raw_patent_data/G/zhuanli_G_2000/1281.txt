标题title
一种芯片设计阶段的仿真验证方法和装置
摘要abst
本发明涉及芯片仿真验证领域，特别是涉及一种芯片设计阶段的仿真验证方法和装置。包括：对参考模型中行为级模型的输入接口和输出接口进行封装，将封装后的参考模型作为测试模型，并定义测试模型的控制接口；验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，并将行为级模型需使用的数据写入共享内存中，测试模型通过封装后的输入接口从共享内存中获取需使用的数据；测试模型通过封装后的输出接口将行为级模型处理后的数据输出至共享内存中，验证平台从共享内存中获取测试模型输出的数据，通过测试模型的输出数据对相应的待验证模块进行验证结果分析。本发明避免了功能函数的重构，并提高了仿真验证的效率。
权利要求书clms
1.一种芯片设计阶段的仿真验证方法，其特征在于，包括：对参考模型中行为级模型的输入接口和输出接口进行封装，将封装后的参考模型作为测试模型，并定义测试模型的控制接口；验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，并将行为级模型需使用的数据写入共享内存中，测试模型通过封装后的输入接口从共享内存中获取需使用的数据；测试模型通过封装后的输出接口将行为级模型处理后的数据输出至共享内存中，验证平台从共享内存中获取测试模型输出的数据，通过测试模型的输出数据对相应的待验证模块进行验证结果分析。2.根据权利要求1所述的芯片设计阶段的仿真验证方法，其特征在于，所述对参考模型中行为级模型的输入接口和输出接口进行封装包括：获取和待验证模块相应的行为级模型，在参考模型中例化相应的行为级模型；将行为级模型的输入接口与参考模型相应的输入接口绑定，将行为级模型的输出接口与参考模型相应的输出接口绑定。3.根据权利要求2所述的芯片设计阶段的仿真验证方法，其特征在于，所述将行为级模型的输入接口与参考模型相应的输入接口绑定，将行为级模型的输出接口与参考模型相应的输出接口绑定包括：参考模型的输入接口将形参输入的数据存入指定的共享内存地址，并将输入数据由验证平台的数据格式转换为行为级模型的数据格式，行为级模型的输入接口将转换后的输入数据输入行为级模型中；行为级模型的输出接口将输出数据的形参指针指向存放输出数据的共享内存地址，参考模块的输出接口将输出数据由行为级模型的数据格式转换为验证平台的数据格式，并将转换后的输出数据进行输出。4.根据权利要求1所述的芯片设计阶段的仿真验证方法，其特征在于，所述验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型包括：通过控制接口创建独立线程，在线程中例化所有需验证的行为级模型；启动行为级模型的内核，通过行为级模型的内核启动测试模型。5.根据权利要求1所述的芯片设计阶段的仿真验证方法，其特征在于，所述验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型包括：将行为级模型的停止命令存入共享内存中，当测试模型轮询到停止命令后，停止行为级模型的内核，并结束线程；等待线程结束后，返回线程的停止信号。6.根据权利要求1所述的芯片设计阶段的仿真验证方法，其特征在于，所述测试模型通过封装后的输入接口从共享内存中获取需使用的数据包括：在测试模型的线程中，创建用于轮询共享内存中输入数据的第一协程，使用第一协程轮询共享内存中用于存放输入数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输入数据，当地址中存在输入数据时，通过相应行为级模型的输入接口获取该地址中的输入数据。7.根据权利要求1至6中任一项所述的芯片设计阶段的仿真验证方法，其特征在于，所述验证平台从共享内存中获取测试模型输出的数据包括：在测试模型的线程中，创建用于轮询共享内存中输出数据的第二协程，使用第二协程轮询共享内存中用于存放输出数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输出数据，当地址中存在输出数据时，通过测试模型的相应输出接口将输出数据输出至验证平台。8.根据权利要求1所述的芯片设计阶段的仿真验证方法，其特征在于，所述对参考模型中行为级模型的输入接口和输出接口进行封装包括：当待验证模块变化时，获取与待验证模块相应的行为级模型，将参考模型的行为级模型更换为获取的行为级模型，并对更换后的行为级模型的输入接口和输出接口进行封装。9.根据权利要求1至6中任一项所述的芯片设计阶段的仿真验证方法，其特征在于，所述通过测试模型的输出数据对相应的待验证模块进行验证结果分析包括：在验证平台中定义待验证模块的数据接口，以建立验证平台和待验证模块之间的同步通信连接；验证平台在独立的线程中启动待验证模块，获取待验证模块的输出数据；将待验证模块的输出数据与相应行为级模型处理后的输出数据进行比对，根据比对结果确定待验证模块的正确性。10.一种芯片设计阶段的仿真验证装置，其特征在于：包括至少一个处理器和存储器，所述至少一个处理器和存储器之间通过数据总线连接，所述存储器存储能被所述至少一个处理器执行的指令，所述指令在被所述处理器执行后，用于完成权利要求1至9中任一项所述的芯片设计阶段的仿真验证方法。
说明书desc
技术领域本发明涉及芯片仿真验证领域，特别是涉及一种芯片设计阶段的仿真验证方法和装置。背景技术随着技术的发展，当前芯片验证技术逐渐跟不上芯片设计的发展速度，在完整的芯片研发中，验证环节往往要占据整个研发周期的三分之二以上。由此可见，在保证验证质量的情况下，减少验证时间可以有效地缩短芯片研发周期。统一验证方法学提供了标准化的验证平台开发框架，是目前主流的芯片验证方法。UVM的架构中包含：待验证模块、激励模块、驱动模块、监测模块和参考模型等组件。其中，DUT是用硬件编程语言设计的寄存器传输级模型，参考模型是由SystemC语言等高级语言设计的行为级模型。由于SystemC语言可以用来搭建事务级、高抽象级的虚拟原型，因此通常使用该语言来构建行为级模型。因此，在对图形处理器芯片的RTL模型进行验证时，需将SystemC语言搭建的行为级模型转为参考模型。转换方法通常是将的各项功能重构成为相应功能的函数，通过直接编程接口在system verilog语言构建的UVM平台中调用。然而，GPU芯片的仿真模型十分复杂，包含众多子模块，通常将子模块单独取出进行验证。每验证一个子模块时，都需要将其行为级模型重构为参考模型，过程繁琐，另外，传统转换方法将子模块各个功能转为一个功能函数，在UVM平台中调用时是同步进行的，仿真效率低。鉴于此，如何克服现有技术所存在的缺陷，解决现有的仿真验证方法效率较低的现象，是本技术领域待解决的问题。发明内容针对现有技术的以上缺陷或改进需求，本发明解决了现有的仿真验证方法效率较低的问题。本发明实施例采用如下技术方案：第一方面，本发明提供了一种芯片设计阶段的仿真验证方法，具体为：对参考模型中行为级模型的输入接口和输出接口进行封装，将封装后的参考模型作为测试模型，并定义测试模型的控制接口；验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，并将行为级模型需使用的数据写入共享内存中，测试模型通过封装后的输入接口从共享内存中获取需使用的数据；测试模型通过封装后的输出接口将行为级模型处理后的数据输出至共享内存中，验证平台从共享内存中获取测试模型输出的数据，通过测试模型的输出数据对相应的待验证模块进行验证结果分析。优选的，所述对参考模型中行为级模型的输入接口和输出接口进行封装，具体包括：获取和待验证模块相应的行为级模型，在参考模型中例化相应的行为级模型；将行为级模型的输入接口与参考模型相应的输入接口绑定，将行为级模型的输出接口与参考模型相应的输出接口绑定。优选的，所述将行为级模型的输入接口与参考模型相应的输入接口绑定，将行为级模型的输出接口与参考模型相应的输出接口绑定，具体包括：参考模型的输入接口将形参输入的数据存入指定的共享内存地址，并将输入数据由验证平台的数据格式转换为行为级模型的数据格式，行为级模型的输入接口将转换后的输入数据输入行为级模型中；行为级模型的输出接口将输出数据的形参指针指向存放输出数据的共享内存地址，参考模块的输出接口将输出数据由行为级模型的数据格式转换为验证平台的数据格式，并将转换后的输出数据进行输出。优选的，所述验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，具体包括：通过控制接口创建独立线程，在线程中例化所有需验证的行为级模型；启动行为级模型的内核，通过行为级模型的内核启动测试模型。优选的，所述验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，还包括：将行为级模型的停止命令存入共享内存中，当测试模型轮询到停止命令后，停止行为级模型的内核，并结束线程；等待线程结束后，返回线程的停止信号。优选的，所述测试模型通过封装后的输入接口从共享内存中获取需使用的数据，具体包括：在测试模型的线程中，创建用于轮询共享内存中输入数据的第一协程，使用第一协程轮询共享内存中用于存放输入数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输入数据，当地址中存在输入数据时，通过相应行为级模型的输入接口获取该地址中的输入数据。优选的，所述验证平台从共享内存中获取测试模型输出的数据，具体包括：在测试模型的线程中，创建用于轮询共享内存中输出数据的第二协程，使用第二协程轮询共享内存中用于存放输出数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输出数据，当地址中存在输出数据时，通过测试模型的相应输出接口将输出数据输出至验证平台。优选的，所述对参考模型中行为级模型的输入接口和输出接口进行封装，还包括：当待验证模块变化时，获取与待验证模块相应的行为级模型，将参考模型的行为级模型更换为获取的行为级模型，并对更换后的行为级模型的输入接口和输出接口进行封装。优选的，所述通过测试模型的输出数据对相应的待验证模块进行验证结果分析，具体包括：在验证平台中定义待验证模块的数据接口，以建立验证平台和待验证模块之间的同步通信连接；验证平台在独立的线程中启动待验证模块，获取待验证模块的输出数据；将待验证模块的输出数据与相应行为级模型处理后的输出数据进行比对，根据比对结果确定待验证模块的正确性。另一方面，本发明提供了一种芯片设计阶段的仿真验证装置，具体为：包括至少一个处理器和存储器，至少一个处理器和存储器之间通过数据总线连接，存储器存储能被至少一个处理器执行的指令，指令在被处理器执行后，用于完成第一方面中的芯片设计阶段的仿真验证方法。与现有技术相比，本发明的有益效果在于：提供了一种芯片设计阶段的仿真验证方法和装置，构建参考模型时，不直接将芯片中的GPU单模块等行为级模型重构为功能函数，而是直接将使用SystemC语言编写的行为级模型进行复用，仅将每个行为级模型的输入接口和输出接口进行封装，将封装后的行为级模型加入参考模型中，将加入了行为级模型并完成输入输出接口封装后的参考模型作为验证时的测试模型使用，使用行为级模型原有的逻辑进行数据处理，避免了功能函数的重构。并且，使用独立的线程执行封装后的测试模型，使参考模型和待验证模块能够并行执行仿真和验证过程，并使用共享内存实现不同线程间数据的并行存取，达到加速验证的效果。附图说明为了更清楚地说明本发明实施例的技术方案，下面将对本发明实施例中所需要使用的附图作简单地介绍。显而易见地，下面所描述的附图仅仅是本发明的一些实施例，对于本领域普通技术人员来讲，在不付出创造性劳动的前提下，还可以根据这些附图获得其他的附图。图1为现有技术中仿真验证平台的架构示意图；图2为传统技术中参考模型的构建过程示意图；图3为本发明实施例提供的一种芯片设计阶段的仿真验证方法流程图；图4为本发明实施例提供的方法中测试模型的架构示意图；图5为本发明实施例提供的另一种芯片设计阶段的仿真验证方法流程图；图6为本发明实施例提供的另一种芯片设计阶段的仿真验证方法流程图；图7为本发明实施例提供的另一种芯片设计阶段的仿真验证方法流程图；图8为本发明实施例提供的方法中仿真验证平台的架构示意图；图9为本发明实施例提供的一种芯片设计阶段的仿真验证装置结构示意图；其中，附图标记如下：11：处理器；12：存储器。具体实施方式为了使本发明的目的、技术方案及优点更加清楚明白，以下结合附图及实施例，对本发明进行进一步详细说明。应当理解，此处所描述的具体实施例仅用以解释本发明，并不用于限定本发明。本发明是一种特定功能系统的体系结构，因此在具体实施例中主要说明各结构模组的功能逻辑关系，并不对具体软件和硬件实施方式做限定。此外，下面所描述的本发明各个实施方式中所涉及到的技术特征只要彼此之间未构成冲突就可以相互组合。下面就参考附图和实施例结合来详细说明本发明。在现有技术中，UVM验证平台主要包括待验证模块DUT、激励模块sequencer、驱动模块driver、监测模块monitor和参考模型等组件，各组件之间使用代理模式进行组织，层次结构如图1所示。待验证模块是使用硬件编程语言构建的硬件设计模型，在芯片设计阶段进行仿真验证的目的是确认DUT的代码设计是否正确，验证工程师知晓DUT应该具备的功能，通过给DUT指定的数据触发相应的功能，然后DUT会得到相应的输出。同样地，给DUT输入的数据同时也会输入给参考模型，也会触发参考模型相应的功能，并得到参考模型相应的输出。在实际的芯片设计过程中，通常先用高级语言设计参考模型，再用RTL设计DUT。输入代理是验证平台的输入监测模块，负责监控采集DUT的输入数据，并将该数据输入给参考模型；输出代理是验证平台的输出监测模块，负责监控采集DUT的输出数据，并将该数据输入给计分板。计分板中的数据来自参考模型和待验证模块的输出，将两者的输出进行对比。进行验证时，输入代理中的驱动模块，将需要DUT处理的数据通过输入接口发送给DUT，同时，输入代理中的监测模块监控输入接口所接收到的数据，并将与DUT处理的数据相同的数据发送给参考模型，以便DUT和参考模型分别对同样的数据进行处理。DUT和参考模型分别完成数据处理后，输出代理中的输出监测组件通过输出接口监控待验证模块的输出数据，并将输出数据转发给计分板组件。理论上，参考模型的代码设计仅需能够体现设计意图即可，并且会经过软件层面的测试验证，因此可以被视为一定正确。但是，DUT的代码为未验证过的硬件模型，因此不一定正确。在DUT设计正确的情况下，对同样的输入数据进行处理后，DUT和参考模型应该会得到相应的输出。因此，可以通过计分板组件接收到的参考模型的返回数据和待验证模块的输出数据进行对比，根据对比结果判断待验证模块设计是否正确。如果DUT的输出和参考模型一致，说明DUT的设计是正确的，反之，DUT的设计就不正确。在上述过程中，输入代理中的监测模块给参考模型传入数据，输出代码中的输出监测组件接收返回数据，原理是调用参考模型不同的功能函数，传入函数参数，再接收返回值。这种方式主要存在两点不足：参考模型的不同功能函数由GPU单模块的行为级模型转换而来，GPU单模块的行为级模型基于SystemC语言编写，是一种模块化设计，模块输入输出通过SystemC内置的接口实现。所以，要将SystemC模型转换成不同的功能函数，需要梳理GPU单模块的各项功能，对原有的GPU单模块原理有较为深刻的理解，再重构代码，将这些功能逐个编写成函数形式，过程如图2所示。由SystemC语言的GPU单模块转换为参考模型的工作较为繁琐，尤其是面向GPU这种复杂模型，而且，不同的GPU单模块功能都不一样，每次切换一个GPU单模块进行单模块验证时，都需要在参考模型中重构相应单模块的SystemC模型，人工成本较高。UVM平台各个组件的运行是同步的，所以，当输入代理中的监测模块通过相应的函数传入参数，各函数串行执行。因此，当调用参考模型的功能函数时，待验证模块的仿真过程和UVM其它组件的任务处于暂停状态，只有当参考模型的功能函数执行完，UVM获取到返回值后，才会轮到待验证模块的仿真过程继续执行。这时，对于输入代理中的驱动模块下发一笔交易数据，到计分板组件获得待验证模块和参考模型的输出数据，总耗时为：由于待验证模块和参考模型在执行过程中需要互相等待，因此这种方式仿真效率较低。本实施例提供了一种芯片设计阶段的仿真验证方法，旨在简化GPU单模块验证时参考模型搭建过程，加快仿真速度，提升验证环境效率。如图3所示，本发明实施例提供的芯片设计阶段的仿真验证方法具体步骤如下。步骤101：对参考模型中行为级模型的输入接口和输出接口进行封装，将封装后的参考模型作为测试模型，并定义测试模型的控制接口。本实施例提供的方法中，构建参考模型时，不直接将芯片中的GPU单模块等行为级模型重构为功能函数，而是直接将使用SystemC语言编写的行为级模型进行复用，仅将每个行为级模型的输入接口和输出接口进行封装，将封装后的行为级模型加入参考模型中，将加入了行为级模型并完成输入输出接口封装后的参考模型作为验证时的测试模型使用，使用行为级模型原有的逻辑进行数据处理，避免了功能函数的重构。步骤102：验证平台通过控制接口在独立的线程中启动测试模型中的行为级模型，并将行为级模型需使用的数据写入共享内存中，测试模型通过封装后的输入接口从共享内存中获取需使用的数据。本实施例通过独立的线程运行测试模型，使得测试模型和待验证模块能够在不同的线程中并行执行，而无需像现有技术中一样互相等待。为了使独立线程中的测试模型能够获取到所需使用的数据，本实施例中使用共享内存对输入数据和输出数据进行统一管理。进行仿真验证时，验证平台将行为级模型需要使用的数据通过测试模型的输入接口写入共享内存中，行为级模型通过封装后的输入接口从共享内存中获取需输入的数据。步骤103：测试模型通过封装后的输出接口将行为级模型处理后的数据输出至共享内存中，验证平台从共享内存中获取测试模型输出的数据，通过测试模型的输出数据对相应的待验证模块进行验证结果分析。输入测试模型中的数据，在复用的行为级模型中进行数据处理，再通过封装后的输出接口将处理后的数据输出至共享内存中，测试模型通过输出接口将共享内存中的数据输出至验证平台。再将测试模型输出的数据与待验证模块的输出数据进行对比，根据对比结果判断待验证模块设计是否正确。经过本实施例中提供的步骤101至步骤103后，即可实现行为级模型的复用，以及参考模型和待验证模块的并行执行，从而提高仿真验证的效率。在具体实施中，上述仿真验证可以应用于所有支持多线程并行执行和共享内存的验证平台中，测试模型的具体封装方式和调度方式根据验证平台的要求确定。以下使用异步验证平台testbench框架为例，说明本实施例提供的方法在实际场景中的具体使用过程。可以理解的是，以下具体实施方式仅作为实际场景中的实施过程说明，不作为保护范围的限制。本实施例异步验证平台testbench框架主要包括：DUT、UVM和参考模型。该验证平台中使用的行为级模型为GPU单模块SystemC模型。为了便于在验证平台中对测试模型进行调用，还可以在参考模型定义不同接口函数，再在验证平台中对参考模型的接口函数进行声明，使得UVM可以调用参考模型的接口函数。如图4所示，常用的接口函数如下：启动接口函数：对应GPU单模块通用的启动接口函数，函数内部创建测试模型的运行线程，线程中例化需要验证的测试模型，即：在参考模型中引用行为级模型，并对参考模型和行为级模型的接口进行相关连接。完成参考模型的构建阶段后，再启动SystemC内核，从而启动测试模型，进而启动测试模型中的行为级模型。寄存器接口函数：对应GPU单模块通用的寄存器接口函数，函数内部根据函数输入形参数据设置GPU寄存器，首先拿到全局GPU寄存器对象的指针，再将输入形参的指定数据输入给指定的寄存器地址。进行数据输入时，可以调用寄存器接口函数，根据输入地址和数据配置GPU单模块相应的寄存器。停止接口函数：对应GPU单模块通用的停止接口函数，函数内部将stop命令存入共享内存，测试模型的协程轮询到stop命令就会停止SystemC内核，从而结束测试模型的运行线程，然后停止接口函数等待参考模型线程结束，返回正常停止信号。输入接口：用于将验证平台的提供的数据输入至共享内存中。输出接口：用于将共享内存中的数据输出至验证平台。如图5所示，可以使用以下方式对每个行为级模型的输入接口和输出接口进行封装，以获得相应的测试模型。步骤201：获取和待验证模块相应的行为级模型，在参考模型中例化相应的行为级模型。在验证平台中，搭建如图4所示的参考模型，在参考模型中封装与待验证模型对应行为级模型，将封装后的参考模型定义为测试模型，再在测试模型里面例化行为级模型。具体的，将测试模型中引用行为级模型，再将参考模型的输入输出接口与行为级模型的输入输出接口进行绑定，以实现行为级模型和参考模型的每个输入输出接口之间的相关连接。步骤202：将行为级模型的输入接口与参考模型相应的输入接口绑定，将行为级模型的输出接口与参考模型相应的输出接口绑定。进行封装时，每个测试模型复用的行为级模型需要通过测试模型的输入输出接口进行数据读写，因此需要将行为级模型的每个输入接口或输出接口与测试模型相同功能的接口进行绑定，使用测试模型的接口作为行为级模型相应接口与验证平台之间的数据转换接口，在验证平台中完成行为级模型的数据输入和输出。经过本实施例中提供的步骤201至步骤202后，即可完成测试模型中输入接口和输出接口的封装，实现行为级模型的复用。在具体实施中，为了使用共享内存进行不同线程间的数据交互，需要将输入输出的共享内存地址与测试模型的不同接口进行绑定，使得行为级模型能够读取共享内存相应地址中的数据。测试模型的输入接口函数将输入形参的数据放在指定的共享内存空间中，行为级模型由共享内存中获取所需的数据；测试模型的输出接口函数将输出形参的指针指向输出共享内存空间，从而获得行为级模型的输出数据。另一方面，验证平台和行为级模型的数据格式可能不同，因此还需要通过封装后的输入输出接口进行数据转换，以实现行为级模型和验证平台之间的数据交互。具体的：参考模型的输入接口将形参输入的数据存入指定的共享内存地址，并将输入数据由验证平台的数据格式转换为行为级模型的数据格式，行为级模型的输入接口将转换后的输入数据输入行为级模型中；行为级模型的输出接口将输出数据的形参指针指向存放输出数据的共享内存地址，参考模块的输出接口将输出数据由行为级模型的数据格式转换为验证平台的数据格式，并将转换后的输出数据进行输出。完成行为级模型的封装后，即可在验证平台的不同线程中并行运行参考模型和待验证模块，以提高仿真验证的效率。如图6所示，验证平台可以使用以下方式在独立的线程中启动需验证的测试模型。步骤301：通过控制接口创建独立线程，在线程中例化所有需验证的行为级模型。UVM调用测试模型的启动接口函数，启动接口函数创建一个用于控制测试模型的线程，并在线程中例化需要验证的行为级模型。步骤302：启动行为级模型的内核，通过行为级模型的内核启动测试模型。线程创建后，首先在线程中完成测试模型的构建阶段，再启动SystemC内核，从而启动参考模型中的行为级模型。经过本实施例中提供的步骤301至步骤302后，即可在独立的线程中启动测试模型。当仿真过程需要停止或暂停时，还可以通过停止接口函数停止线程的运行，以停止测试模型的运行。具体的：将行为级模型的停止命令存入共享内存中，当测试模型轮询到停止命令后，停止行为级模型的内核，并结束线程；等待线程结束后，返回线程的停止信号。另一方面，为了实现参考模型和待验证模块的并行执行，也需要在独立的线程中运行待验证模块。如图7所示，可以使用以下方式启动待验证模块的仿真过程。步骤401：在验证平台中定义待验证模块的数据接口，以建立验证平台和待验证模块之间的同步通信连接。在UVM中定义接口，建立testbench和待验证模块的同步通信连接。步骤402：验证平台在独立的线程中启动待验证模块，获取待验证模块的输出数据。为了实现参考模型和待验证模块的并行执行，验证平台和待验证模块的同步通信连接建立后，也可以在独立的线程中执行待验证模块，从而进一步提高仿真验证时不同模块间的并行度，并获取到待验证模块的输出数据。步骤403：将待验证模块的输出数据与相应行为级模型处理后的输出数据进行比对，根据比对结果确定待验证模块的正确性。由于行为级模型和待验证模块的功能一致，因此理论上的输出结果应一致。因此，可以通过将两者的输出数据进行比对，通过比对结果确定待验证模块的正确性。若输出数据一致，则表明待验证模块的处理结果正确；若不一致，则表明待验证模块的处理结果错误。经过本实施例中提供的步骤401至步骤403后，即可同步启动待验证模块的仿真过程。由上述测试模型和待验证模块的启动过程可见，由于测试模型运行在新的独立线程中，UVM将数据输入至共享内存后，即可继续执行后续代码，无需等待返回值，由测试模型内部轮询共享内存，再采用相应逻辑处理，从而实现测试模型与待验证模块并行执行。为了进一步提高仿真效率，测试模型还可以通过不同的SystemC协程分别进行共享内存中的数据输入和数据输出。协程是一种比线程更加轻量级的存在，可以理解为一个特殊的函数，这个函数可以在某个地方挂起去执行别的函数，并且可以返回挂起处继续执行。本实施例中，可以定义两个SystemC协程，一个负责轮询全局共享内存中的输入数据，一个负责轮询全局共享内存中的输出数据，轮询时间间隔为GPU单模块的最小时间粒度1个时钟周期，这样可以保证每个时刻的输入输出数据都被监控到。为了进行测试模型的数据输入，在测试模型的线程中，创建用于轮询共享内存中输入数据的第一协程，使用第一协程轮询共享内存中用于存放输入数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输入数据，当地址中存在输入数据时，通过相应行为级模型的输入接口获取该地址中的输入数据。为了进行测试模型的数据输出，在测试模型的线程中，创建用于轮询共享内存中输出数据的第二协程，使用第二协程轮询共享内存中用于存放输出数据的每个地址，轮询时间间隔为行为级模型的单位时间粒度；判断地址中是否存在输出数据，当地址中存在输出数据时，通过测试模型的相应输出接口将输出数据输出至验证平台。具体实施中，上述过程可以使用如图8所示的平台具体架构实现，在该架构中进行待验证模块和参考模型并行仿真，通过共享内存进行数据交互，实现异步验证。进一步的，当待验证模块变化时，获取与待验证模块相应的行为级模型，将参考模型的行为级模型更换为获取的行为级模型，并对更换后的行为级模型的输入接口和输出接口进行封装。具体的：如果更换不同的GPU单模块进行验证，只需将测试模型中例化的行为级模型更换为与变化后的GPU单模块对应的行为级模型，再对更换后的行为级模型输入输出接口进行封装，而无需重构测试模型内部处理逻辑的代码。本实施例提供的芯片设计阶段的仿真验证方法，相对于现有技术具有以下优势：本实施例提供的方法直接复用GPU单模块的SystemC模型代码，不需要将模块各项功能重构成函数形式，而是直接将SystemC模型的输入输出接口进行封装，只要UVM输入接口的数据与原有SystemC模型一致，由于中间代码一致，处理逻辑也一致，UVM再通过输出接口获得的数据也和原有SystemC模型输出的数据一致，这样即可快速搭建参考模型。本实施例提供的方法将待验证模块和参考模型并行执行，当UVM平台给待验证模块和测试模型输入激励数据时，待验证模块和测试模型中间处理过程同步进行，由于待验证模块是RTL语言编写，其执行时间往往大于参考模型，故每当代理中的驱动模块下发一笔交易数据，到计分板组件获得待验证模块和参考模型的输出数据，总耗时可仅考虑待验证模块耗时，为：可见传统技术需要将参考模型重构成不同功能函数，本发实施例提供的方法中，仅需直接例化现有的参考模型，并封装相应的输入输出接口和功能函数接口即可。并且，由于，可知本实施例提供的方式可加快仿真速度，提升验证效率。在上述实施例提供的芯片设计阶段的仿真验证方法的基础上，本发明还提供了一种可用于实现上述方法的芯片设计阶段的仿真验证装置，如图9所示，是本发明实施例的装置架构示意图。本实施例的芯片设计阶段的仿真验证装置包括一个或多个处理器11以及存储器12。其中，图9中以一个处理器11为例。处理器11和存储器12可以通过总线或者其他方式连接，图9中以通过总线连接为例。存储器12作为一种芯片设计阶段的仿真验证方法非易失性计算机可读存储介质，可用于存储非易失性软件程序、非易失性计算机可执行程序以及模块，如实施例中的芯片设计阶段的仿真验证方法。处理器11通过运行存储在存储器12中的非易失性软件程序、指令以及模块，从而执行芯片设计阶段的仿真验证装置的各种功能应用以及数据处理，即实现实施例的芯片设计阶段的仿真验证方法。存储器12可以包括高速随机存取存储器，还可以包括非易失性存储器，例如至少一个磁盘存储器件、闪存器件、或其他非易失性固态存储器件。在一些实施例中，存储器12可选包括相对于处理器11远程设置的存储器，这些远程存储器可以通过网络连接至处理器11。上述网络的实例包括但不限于互联网、企业内部网、局域网、移动通信网及其组合。程序指令/模块存储在存储器12中，当被一个或者多个处理器11执行时，执行上述实施例中的芯片设计阶段的仿真验证方法，例如，执行以上描述的图3、图5、图6和图7所示的各个步骤。本领域普通技术人员可以理解实施例的各种方法中的全部或部分步骤是可以通过程序来指令相关的硬件来完成，该程序可以存储于一计算机可读存储介质中，存储介质可以包括：只读存储器、随机存取存储器、磁盘或光盘等。以上所述仅为本发明的较佳实施例而已，并不用以限制本发明，凡在本发明的精神和原则之内所作的任何修改、等同替换和改进等，均应包含在本发明的保护范围之内。

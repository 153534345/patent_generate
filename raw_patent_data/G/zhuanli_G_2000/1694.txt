标题title
一种智能合约安全漏洞检测方法和系统
摘要abst
本发明涉及网络安全技术领域，具体为一种智能合约安全漏洞检测方法和系统，将智能合约字节码反编译处理为三地址码形式的中间语言，并构建智能合约的控制流图，提取控制流图的语义信息并存储为Datalog事实，以更好地表示智能合约的数据和控制流依赖关系，基于Datalog事实定义前提条件，获得Datalog规则，提供漏洞分析框架，分析智能合约的经典漏洞特征，定义漏洞检测逻辑，将漏洞检测逻辑和Datalog规则结合，检测智能合约，输出漏洞检测结果，该检测方法采用静态程序分析，能够无需执行合约就可以达到比较高的覆盖率，从而检测更多的漏洞，具有低漏报率和高准确率的效果。
权利要求书clms
1.一种智能合约安全漏洞检测方法，其特征在于，包括如下操作：S1:将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将所述中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；S2:提取所述控制流图中的合约信息，将所述合约信息以逻辑关系形式进行存储，获得Datalog事实；S3:基于所述Datalog事实，定义前提条件，获得Datalog规则，所述Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。2.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述反编译的操作具体为：将所述智能合约字节码转换成对应的EVM指令，基于所述EVM指令，生成三地址码指令，将所述三地址码指令添加到三地址码序列中，经过堆栈处理，得到所述三地址码形式的中间语言。3.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中定义前提条件包括定义指令条件和变量条件；所述指令条件包括：指令的功能条件、指令执行顺序条件、指令间相互控制条件，指令执行的变量条件、指令检查条件，指令更改合约条件；所述变量条件包括：变量的取值条件、变量之间的相互关系、变量可被外部操控的条件。4.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在不受gas限制的用于传输虚拟货币的CALL指令的外部调用，所述外部调用之前没有使用布尔锁进行保护，也没有更新存储变量；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的重入漏洞。5.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在用于传输虚拟货币的CALL指令的外部调用，所述外部调用的结果能被JUMPI指令检查，且所述智能合约的状态变量的更新依赖所述外部调用的结果；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的拒绝服务漏洞。6.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在SELFDESTRUCT指令，所述SELFDESTRUCT指令的参数是外部可操纵的，且SELFDESTRUCT指令的执行不受保护；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的自毁漏洞。7.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在DELEGATECALL调用，所述DELEGATECALL调用的目标地址是外部可操纵的，或DELEGATECALL调用的目标函数是外部可操纵的；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的委托调用漏洞。8.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在TIMESTAMP操作码，所述TIMESTAMP操作码与JUMPI指令存在依赖关系；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的时间戳依赖漏洞。9.根据权利要求1所述的智能合约安全漏洞检测方法，其特征在于，所述S3中的漏洞检测逻辑为：所述智能合约中存在用于传输虚拟货币的CALL指令的外部调用，所述外部调用发送的金额依赖存储变量的值，且所述存储变量的值可以被其它函数更改；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的交易顺序依赖漏洞。10.一种智能合约安全漏洞检测系统，其特征在于，包括：控制流图生成模块：用于将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将所述中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；Datalog事实生成模块：用于提取所述控制流图中的合约信息，将所述合约信息以逻辑关系形式进行存储，获得Datalog事实；检测智能合约安全漏洞模块：基于所述Datalog事实，定义前提条件，获得Datalog规则，所述Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。
说明书desc
技术领域本发明涉及网络安全技术领域，具体为一种智能合约安全漏洞检测方法和系统。背景技术以太坊是一种广泛持有的加密货币，均基于区块链技术实现去中心化。以太坊内置图灵完备的编程语言，允许创建任意的应用程序，这些程序被称为智能合约。以太坊的图灵完备性使智能合约的应用场景逐渐丰富，在金融领域，智能合约控制数字资产，使智能合约的安全性不可避免地成为人们重点关注的对象。此外，智能合约永久地部署在区块链上，并且一旦部署便不可更改，再加上编写智能合约语言的不稳定性以及合约自身功能逻辑的复杂性，因此不可避免的存在软件漏洞。智能合约漏洞一旦被利用，就可能造成巨大的经济损失。为防止今后发生攻击事件，越来越多的研究人员参与到优化和检测智能合约的研究中，开发了各种工具和框架检测智能合约漏洞。现有技术中，使用基于符号执行技术设计了第一个检测智能合约漏洞的工具——Oyente，能够很好地发现合约中的漏洞，但是该技术存在路径爆炸的问题，并且不易扩展，漏报率较高；基于逻辑驱动的静态安全分析框架——Vandal，虽然能够对合约的数据、控制流进行分析，但是并没有检测时间戳依赖、委托调用以及交易顺序依赖等重要安全漏洞问题，而且还存在漏报率高，检测准确度低的问题。发明内容本发明的目的是提供了一种智能合约安全漏洞检测方法和系统。本发明技术方案如下：一种智能合约安全漏洞检测方法，包括如下操作：S1:将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将所述中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；S2:提取所述控制流图中的合约信息，将所述合约信息以逻辑关系形式进行存储，获得Datalog事实；S3:基于所述Datalog事实，定义前提条件，获得Datalog规则，所述Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。如上所述的智能合约安全漏洞检测方法，所述反编译的操作具体为：将所述智能合约字节码转换成对应的EVM指令，基于所述EVM指令，生成三地址码指令，将所述三地址码指令添加到三地址码序列中，经过堆栈处理，得到所述三地址码形式的中间语言。如上所述的智能合约安全漏洞检测方法，所述S3中定义前提条件包括定义指令条件和变量条件；所述指令条件包括：指令的功能条件、指令执行顺序条件、指令间相互控制条件，指令执行的变量条件、指令检查条件，指令更改合约条件；所述变量条件包括：变量的取值条件、变量之间的相互关系、变量可被外部操控的条件。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在不受gas限制的用于传输虚拟货币的CALL指令的外部调用，所述外部调用之前没有使用布尔锁进行保护，也没有更新存储变量；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的重入漏洞。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在用于传输虚拟货币的CALL指令的外部调用，所述外部调用的结果能被JUMPI指令检查，且所述智能合约的状态变量的更新依赖所述外部调用的结果；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的拒绝服务漏洞。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在SELFDESTRUCT指令，所述SELFDESTRUCT指令的参数是外部可操纵的，且SELFDESTRUCT指令的执行不受保护；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的自毁漏洞。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在DELEGATECALL调用，所述DELEGATECALL调用的目标地址是外部可操纵的，或DELEGATECALL调用的目标函数是外部可操纵的；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的委托调用漏洞。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在TIMESTAMP操作码，所述TIMESTAMP操作码与JUMPI指令存在依赖关系；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的时间戳依赖漏洞。如上所述的智能合约安全漏洞检测方法，所述S3中的漏洞检测逻辑为：所述智能合约中存在用于传输虚拟货币的CALL指令的外部调用，所述外部调用发送的金额依赖存储变量的值，且所述存储变量的值可以被其它函数更改；所述漏洞检测逻辑结合所述Datalog规则，分析所述智能合约，检测所述智能合约中的交易顺序依赖漏洞。一种智能合约安全漏洞检测系统，包括：控制流图生成模块：用于将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将所述中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；Datalog事实生成模块：用于提取所述控制流图中的合约信息，将所述合约信息以逻辑关系形式进行存储，获得Datalog事实；检测智能合约安全漏洞模块：基于所述Datalog事实，定义前提条件，获得Datalog规则，所述Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。本发明的有益效果在于：本发明提供了一种智能合约安全漏洞检测方法，将智能合约字节码反编译处理为三地址码形式的中间语言，并构建智能合约的控制流图，提取控制流图的语义信息并存储为Datalog事实，以更好地表示智能合约的数据和控制流依赖关系，基于Datalog事实定义前提条件，获得Datalog规则，提供漏洞分析框架，分析智能合约的经典漏洞特征，定义漏洞检测逻辑，将漏洞检测逻辑和Datalog规则结合，检测智能合约，输出漏洞结果，该检测方法采用静态程序分析，能够无需执行合约就可以达到比较高的覆盖率，从而检测更多的漏洞，具有低漏报率和高准确率的效果。附图说明通过阅读下文优选实施方式的详细描述，本申请的方案和优点对于本领域普通技术人员将变得清楚明了。附图仅用于示出优选实施方式的目的，而并不认为是对本发明的限制。在附图中：图1为实施例中漏洞检测方法的流程示意图；图2为实施例中中间语言转换示例图；图3为实施例中合约控制流图示例；图4为实施例中Dalalog程序分析模型示意图；图5为实施例中重入攻击示例图；图6为实施例中拒绝服务攻击示例图；图7为实施例中自毁漏洞示例图；图8为实施例中委托调用漏洞示例图；图9为实施例中时间戳依赖漏洞示例图；图10为交易顺序依赖漏洞示例图；图11为检测系统的结构示意。具体实施方式下面将结合附图更详细地描述本公开的示例性实施方式。本实施例提供了一种智能合约安全漏洞检测方法，参见图1，包括如下操作：S1:将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将所述中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；S2:提取所述控制流图中的合约信息，将所述合约信息以逻辑关系形式进行存储，获得Datalog事实；S3:基于所述Datalog事实，定义前提条件，获得Datalog规则，所述Datalog规则结合漏洞检测逻辑，分析所述智能合约，检测智能合约安全漏洞。S1将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图。反编译的操作为：将智能合约字节码转换成对应的EVM指令，基于EVM指令，生成三地址码指令，将三地址码指令添加到三地址码序列中，经过堆栈处理，得到三地址码形式的中间语言。中间语言能够展现出字节码的数据流和控制流信息。反编译的操作是通过模拟以太坊虚拟机的堆栈操作来实现的。具体为：首先将EVM指令转换成相应的三地址码指令，然后将其附加到三地址码序列中执行堆栈操作。该三地址码指令包括一个定义其功能的操作码，一个参数变量列表，以及它对应的指令的程序计数器地址。EVM指令集中大部分指令直接映射为三地址码操作，但EVM指令中的POP、DUP以及SWAP指令只执行堆栈操作，不产生三地址码指令，而PUSH指令则产生一个赋值操作。如图2所示，左边为合约的EVM指令，经过转换后得到右边的中间表示形式，其中Vn表示变量，其值可以读取或写入。例如0x0 PUSH10x80指令对应的三地址码指令为0x0:V0＝0x80；0x8 LT指令执行比较操作，对应的三地址码指令为0x8:V4＝LTV30x4，符号变量V4表示比较的结果。得到控制流图的过程具体为：首先确定中间语言的一组基本块，基本块从JUMPDEST指令或其他非跳转指令开始，并以跳转指令、终止指令或其他指令结束。其次，创建一个具有符号值的符号堆栈，符号执行每个基本块来模拟EVM的堆栈操作。在符号执行过程中，一些变量可能指向由先前基本块产生的值的堆栈位置，因此为堆栈位置引入符号标签用于表示基本块之间的数据依赖性。最后，在符号执行期间解析块之间的跳转关系。根据跳转指令，将跳转类型分为conditionaljump、unconditional jump和fall execution，以JUMPI指令结束的块，产生两种跳转类型分别为conditionaljump和fall execution；以JUMP指令结束的块其跳转类型为unconditionaljump；以非跳转指令和非终止指令结束的块为fall execution。图3是合约的控制流图示例，其中基本块1中的指令表示代码if，若满足该条件，则执行路径为基本块1-＞基本块2，此路径的跳转类型为fall execution。否则，执行路径为基本块1-＞基本块3，此路径的跳转类型为conditional jump。当执行到基本块4时，基本块2到基本块4的跳转类型为unconditional jump，基本块3到基本块4的跳转类型为fall execution。其中，基本块4中的GT指令用于判断a是否大于0，该指令对应的三地址码指令为V40＝GT S00x0，表示从符号堆栈的顶部读取S0和0x0作为GT指令的参数，并将产生的符号结果V40推入符号堆栈。其中S0：{0x78.0x7b，0x81.0x85}，即S0有两个可能值，第一个是基本块2中0x7b位置对应的V35，第二是基本块3中0x85位置对应的V38，分别代表a的两种不同结果，引入该符号标签S0可以表示基本块之间的数据依赖性。常用的EVM指令只能获得基本块，但是无法解析它们之间的跳转关系，因为EVM只提供带有间接跳转的控制流指令，JUMP和JUMPI指令都是从最顶层的堆栈元素读取跳转目标。在生成中间表示的时候，它是符号执行每一条EVM指令，将指令中的参数记录下来，这样JUMP和JUMPI指令的跳转地址就可以清晰地找到。S2提取控制流图中的合约信息，将合约信息以逻辑关系形式进行存储，获得Datalog事实。具体为，利用提取器遍历智能合约的控制流图，同时根据预先定义的谓词从控制流图中提取智能合约的相关信息，并将提取到的信息以逻辑关系的形式存储到数据库中，逻辑关系是用逗号分隔的文件，数据库中的每条记录为Datalog事实。Datalog事实如表1所示，以分析智能合约中的相关信息。其中，O是EVM中的一组操作码，V是程序变量。表1 Datalog事实S3基于Datalog事实，定义前提条件，获得Datalog规则，Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。定义前提条件包括定义指令条件和变量条件。指令条件包括：指令的功能条件、指令执行顺序条件、指令间相互控制条件，指令执行的变量条件、指令检查条件，指令更改合约条件；指令的功能包括检测、修改、转移以及指令的使用范围。变量条件包括：变量的取值条件、变量之间的相互关系、变量可被外部操控的条件。Datalog规则可为漏洞检测提供逻辑框架，Datalog规则是一阶谓词逻辑中Horm子句的受限形式，其格式如下：h＜-b1,b2,...,bn，其中，h是规则头，表示结论，b1，b2，...，bn是规则体，表示前提条件。规则表示的逻辑含义为：b1∧b2∧...∧bn-＞h。每个规则体即形式为b的原子，其中t1,t2,...,tn是变量、常量或字符串。定义的Datalog规则如表2所示。表2 Datalog规则在表2中，谓词depends表示变量v1的值取决于变量v2的值。该谓词由两条Datalog规则定义，第一条规则的含义为：如果位于pc的指令使用了变量v2作为参数，并且该指令的结果被定义为变量v1，则v1的值取决于v2的值；第二条规则的含义为：如果v1的值取决于于v3的值，并且v3的值取决于v2的值，那么v1的值取决于v2的值。谓词reaches表示在控制流图中位于pc1的指令能够到达位于pc2的指令。即若pc1和pc2在同一基本块中，则pc2在pc1的后面执行，或者pc1的基本块到pc2的基本块存在一条路径。该谓词由两条规则定义，第一条规则的含义为：如果follow成立，即存在于Datalog数据库中，则推理出谓词reaches；第二条规则的含义为：如果follow和reaches都成立，则推理出谓词reaches。谓词control表示位于pc2的指令的执行取决于pc1对应的指令,其定义的规则的含义为：若pc1到x和y都是连续的，并且x能够到达位于pc2，但y不能到达pc2，则pc1控制pc2的执行。谓词control_with表示位于pc2的指令的执行取决于变量v的值，其中v是位于pc1的JUMPI指令的条件变量。谓词jumpi_dep表示位于pc的JUMPI指令的条件变量v1依赖于变量v。谓词manipulable_var表示变量v是外部可操纵的变量，例如CALLER、ORIGIN以及函数参数等。该谓词由两条Datalog规则定义，第一条规则的含义为：若变量v的值依赖于运行时已知值的操作码的结果变量，则变量v是可以被外部可操纵的变量；第二条规则的含义为：若变量v的值依赖于CALLDATALOAD指令的结果v1，则变量v是可以被外部可操纵的变量。谓词check_caller表示位于pc的指令的执行取决于JUMPI指令的条件变量，其中该条件变量依赖于CALLER指令的结果v，即在执行位于pc的指令之前对调用者身份进行检查。谓词sstorefront_call表示在执行位于pc的CALL指令之前，使用SSTORE指令更改合约的状态变量。谓词same_val表示变量v1的值c1与变量v2的值c2相等。谓词same_func表示基本块b1与基本块b2属于同一函数，其定义的规则的含义为：基本块b1所在的函数标签i1与基本块b2所在的函数标签i2相等。谓词money_call表示位于pc的CALL指令是用于转移虚拟货币的调用指令，即表示转账金额的变量v的值不等于0。谓词limitedgas_call表示位于pc的CALL指令有最大gas限制。其定义的规则的含义为：位于pc的CALL指令的第一个参数变量v1依赖于GAS指令的结果v2。谓词bool_lock表示对位于pc的指令有布尔锁保护。其定义的规则的含义为：在执行位于pc的指令之前，先通过位于pc2的JUMPI指令检查布尔变量v2的值，其次使用位于pc3的SSTORE指令修改v2的值，以达到防护作用。例如，若pc的指令为CALL指令，在执行该指令之前修改布尔变量的值，能够防止重入攻击。分析智能合约。采用Dalalog程序分析模型以数据驱动推导的方式静态分析智能合约中的Datalog事实，检测智能合约漏洞。具体过程参见图4，将智能合约的控制流图中的信息提取出来，并将其编码为Datalog事实存储到外延数据库中，然后将EDB中的Datalog事实作为Datalog引擎的输入，Datalog规则定义了检测的前提条件，将Datalog规则与漏洞检测逻辑结合，Datalog引擎运行时从智能合约中已有的Datalog事实中推导出新的事实，当无法再推出新的事实时，Datalog引擎运行结束。最后可以将推导出的事实输出到内涵数据库中，从而输出漏洞报告。重入漏洞检测。重入漏洞本质上是一种循环调用，当合约向外部用户地址转账时，若没有限制其使用的Gas量，则外部用户地址可以利用提供的Gas递归调用合约中的函数。在Solidity中有个特殊的回调函数，该函数没有函数名以及函数参数，并且在向合约进行转账时fallback函数会自动执行，因此攻击者可以通过特殊的fallback函数再一次调用调用者合约中的函数，导致调用者合约资金多次转移。例如，图5显示了一个重入攻击的示例，其中包含受害者合约和攻击者合约。在受害者合约中，用户可以通过调用withdraw函数来提取资金。首先检查用户余额是否大于0，如果大于0则向用户发起转账，并且在转账后将用户余额置为0。在攻击者合约中，攻击者可以通过调用reentrancy函数来调用受害者合约中的withdraw函数，执行到第6行受害者合约向攻击者合约进行转账，触发了攻击者合约中的fallback函数，在fallback函数中再次调用受害者合约中的withdraw函数。由于在第6行转账之前没有将用户余额重置为0，所以满足第5行的判断条件，受害者合约再次向攻击者合约转账，直到受害者合约的余额为0或Gas耗尽。在字节码级别，send、transfer、call函数均对应于CALL指令。send和transfer函数将最大gas消耗限制在2300，不足以导致重入，而call函数在默认情况下将所有可用的gas提供给被调用者合约使用，使得攻击者有足够的gas发起攻击。为了区分CALL指令，将有gas限制的CALL指令称为Limited-Gas-CALL，将用于传输虚拟货币的CALL指令称为Money-CALL，将没有gas限制的Money-CALL称为UnLimited-Gas-Money-CALL。因此，防止重入攻击有两种方法，其一是在外部调用之前更新余额，即使攻击者发起重入攻击也只能取回自己存入的金额；其二是使用锁机制，在外部调用之前进行判断使得攻击者重入攻击失败。为检测智能合约中的重入漏洞，漏洞检测逻辑为：智能合约中存在不受gas限制的Money-CALL的外部调用，外部调用之前没有使用布尔锁进行保护，也没有更新存储变量；将漏洞检测逻辑结合Datalog规则，分析智能合约，便可检测出智能合约中的重入漏洞。重入漏洞检测过程参见表3，首先使用money_call检测规则获取智能合约中所有的Money-CALL指令，并通过limitedgas_call检测规则判断该调用中是否存在不受gas限制的Money-CALL的外部调用，即是否存在UnLimited-Gas-Money-CALL，若存在，则继续判断UnLimited-Gas-Money-CALL之前，是否使用布尔锁保护或者通过SSTORE指令来更新存储变量的值，若没有使用布尔锁进行保护，也没有更新存储变量，则智能合约中存在重入漏洞。表3智能合约中重入漏洞的检测算法拒绝服务漏洞检测。在智能合约执行过程中，如果检测到异常则回滚交易。当合约执行外部调用时，若没有对交易失败的情况做出处理，则攻击者可以利用该特点致使交易失败，导致合约自身逻辑无法正常执行，使其永久无法操作。例如，图6是一个简单的KotET合约，该合约设置了一个“王位”，玩家通过发送ether参与王位的竞选。若玩家想要竞争王位，需要向合约转账比现有竞标价更高的金额，然后合约将现有竞标价返回给当前的王位拥有者，最后将王位转移给竞标者，并更新竞标价。如果存在一个攻击者合约，攻击者首先通过attack函数调用bid函数参与竞选，成为当前的“国王”，并更新竞标价。当其他玩家向合约发送大于当前竞标价的金额来竞选王位时，合约调用第6行的send函数将金额退还给攻击者，由此触发了攻击者合约中的fallback函数，而该函数中只有revert函数，导致交易回滚。无论其他玩家出价多少金额，都不会更新合约中的王位，因为第6行外部函数调用一直失败，无法执行第7行更新王位。攻击者之所以能攻击成功是因为合约的状态改变依赖于外部调用的结果，并且没有对调用失败的情况进行处理，导致合约状态一直无法更改。为检测智能合约中的拒绝服务漏洞，漏洞检测逻辑为：智能合约中存在Money-CALL外部调用，Money-CALL外部调用的结果能被JUMPI指令检查，且智能合约的状态变量的更新依赖Money-CALL外部调用的结果，漏洞检测逻辑结合Datalog规则，分析智能合约，检测智能合约中的拒绝服务漏洞。拒绝服务漏洞的检测过程参见表4，首先判断智能合约中是否存在Money-CALL外部调用，若存在，判断是否能使用JUMPI指令检查Money-CALL外部调用的返回值，若能，代表智能合约中没有对Money-CALL外部调用进行处理，即失败则回滚交易，接着分别使用block_edge和control_with检测规则检查通过JUMPI指令产生的两条路径中，是否存在一条与REVERT指令相连的路径，以及是否存在另一条包含SSTORE指令的路径，若存在一条与REVERT指令相连的路径，也存在另一条包含SSTORE指令的路径，则代表智能合约的状态变量的更新依赖Money-CALL外部调用的结果，则智能合约中存在拒绝服务漏洞。表4智能合约中拒绝服务漏洞的检测算法自毁漏洞检测。在智能合约中，自毁函数是一个敏感操作，因为执行自毁可以使区块链上的合约销毁，并将合约账户上的所有余额发送到指定的目标地址。如果没有对自毁操作进行访问控制，则攻击者可以随意将合约销毁，并获取合约的余额。例如，图7是一个简单的自毁漏洞。攻击者可以通过调用第3行sudicideAnyone函数传入一个地址类型参数作为第4行selfdestruct函数的参数，从而销毁合约并将合约余额发送到其指定的地址。攻击者之所以能攻击成功是因为该合约并没有对selfdestruct函数进行权限保护，导致任何人都可以执行自毁操作，盗取合约余额。为检测智能合约中的自毁漏洞，漏洞检测逻辑为：智能合约中存在SELFDESTRUCT指令，SELFDESTRUCT指令的参数是外部可操纵的，且SELFDESTRUCT指令的执行不受保护；漏洞检测逻辑结合Datalog规则，分析智能合约，检测智能合约中的自毁漏洞。自毁漏洞的检测过程参见表5，判断智能合约中是否存在SELFDESTRUCT指令，若存在，使用manipulable_var检测规则检查SELFDESTRUCT指令的参数变量addrVar是否是外部可操纵的变量，若addrVar是外部可操纵的变量，则使用check_caller检测规则检查是否对msg.sender进行检查，若不检查，证明SELFDESTRUCT指令的执行是不受保护的，则智能合约中存在自毁漏洞。表5智能合约中自毁漏洞的检测算法委托调用漏洞检测。在智能合约中，可以使用call和delegatecall函数调用其他合约。与call不同的是，delegatecall调用其他合约时，不会改变上下文的执行环境，将其他合约的代码片段放在当前执行环境中来执行。如果合约使用delegatecall函数调用不受信任的其他合约，那么攻击者可以调用该函数向合约注入任意一段代码，从而修改合约的状态变量影响合约的状态。例如，图8是一个简单的delegatecall合约，攻击者可以通过调用第6行forward函数传入一个地址类型参数作为第7行delegatecall函数的目标地址，并且通过msg.data指定要调用的目标函数，使合约执行恶意的代码片段，改变合约的重要状态变量。为检测智能合约中的委托调用漏洞，漏洞检测逻辑为：智能合约中存在DELEGATECALL调用，DELEGATECALL调用的目标地址是外部可操纵的，或DELEGATECALL调用的目标函数是外部可操纵的；漏洞检测逻辑结合Datalog规则，分析智能合约，检测智能合约中的委托调用漏洞。委托调用漏洞的检测过程参见表6，首先判断智能合约中是否存在DELEGATECALL调用，若存在，使用manipulable_var检测规则检查DELEGATCALL调用的目标地址addrVar是否是外部可操纵的变量，是则智能合约存在委托调用漏洞，若不是，检查DELEGATCALL调用的目标函数argVar是否是外部可操纵的变量，若是，则意味着可以执行被调用者合约中的任何函数，智能合约存在委托调用漏洞。表6智能合约中委托调用漏洞的检测算法时间戳依赖漏洞检测。开发人员可以利用区块的时间戳作为判断条件来影响程序的执行。然而，部分节点可以在一定范围内改变时间戳，从而影响合约的执行。例如，图9是一个游戏合约，该合约可能会被部分节点操纵。玩家调用第4行play函数押注2个虚拟货币就有机会获得合约的余额。当区块时间戳取30的模等于0时，合约将余额发送给当前调用者。然而，部分节点为了获得奖励，可以选择符合条件的时间戳，并发起交易调用play函数，从而成为赢家获取合约余额。为检测智能合约中的时间戳依赖漏洞，漏洞检测逻辑为：智能合约中存在TIMESTAMP操作码，TIMESTAMP操作码与JUMPI指令存在依赖关系；漏洞检测逻辑结合Datalog规则，分析智能合约，检测智能合约中的时间戳依赖漏洞。时间戳依赖漏洞的检测过程参见表7，首先判断智能合约中是否存在TIMESTAMP操作码，若存在，通过jumpi_dep检测规则检查TIMESTAMP操作码和JUMPI指令之间是否存在依赖关系，即JUMPI指令的条件变量是否依赖于TIMESTAMP操作码的结果resVar，若存在，则表明时间戳会影响智能合约的控制流决策，则智能合约存在时间戳依赖漏洞。表7智能合约中时间戳依赖漏洞的检测算法交易顺序依赖漏洞检测。以太坊中的交易，从提交上链到区块确认，需要经历多个过程。在打包与执行阶段，部分节点通常从自身利益出发，将交易池中Gas费用较高的交易打包到区块中，即部分节点可以选择要打包的交易或改变交易的执行顺序。用户在提交交易的过程中，合约状态可能被更改，导致用户提交的交易是在更改后的状态下执行合约。例如，图10是一个简单提交解决方案换取奖励的合约。假设用户发起交易调用claimReward函数提交解决方案来获取奖励，在用户提交交易到区块确认的这段时间间隔内，owner以更高的Gas费用发起交易调用setReward函数，更改reward变量的值。部分节点根据Gas费用优先打包owner提交的交易，使得owner提交的交易优先执行，导致用户获得的奖励被owner更改。为检测智能合约中的交易顺序依赖漏洞，漏洞检测逻辑为：智能合约中存在Money-CALL外部调用，Money-CALL外部调用发送的金额依赖存储变量的值，且存储变量的值可以被其它函数更改；漏洞检测逻辑结合Datalog规则，分析智能合约，检测智能合约中的交易顺序依赖漏洞。交易顺序依赖漏洞的检测过程参见表8，首先判断智能合约中是否存在Money-CALL外部调用，若存在，检查发送的金额是否依赖于SLOAD指令加载的值sloadVar，sloadVar对应的地址为slAddr，若是，则Money-CALL外部调用发送的金额依赖存储变量的值，接着检查SSTORE指令是否更改ssAddr的存储变量的值，若存在，则通过same_func检测规则检查SSTORE指令与SLOAD指令是否在同一个函数内，若不在同一个函数内，存储变量的值可以在其他函数内进行更改，改变函数的调用顺序会影响Money-CALL调用发送的金额，则智能合约中中存在交易顺序依赖漏洞。表8智能合约中的交易顺序依赖漏洞检测算法为验证本实施例提供的检测方法的可靠性，对检测方法进行了相关实验。实验环境。该实验在运行在VMware Workstation Pro虚拟机上的64位Ubuntu20.04.3系统中进行，该虚拟机配置有2GB内存和4个处理器内核。数据集。使用两个智能合约数据集来评估本实施例。第一个数据集采用Thomas等人公开的数据集，从中选取了200个具有Solidity源代码的智能合约，涵盖了上述所有类型的漏洞，并对其进行手动检查。第二个数据集从Etherscan中获取10323份已验证的真实智能合约，并对其部分合约进行人工验证。评估方法和指标。从实验中获得五个测量值：真阳性、假阳性、假阴性、精确度和召回率。其中，TP表示正确检测出智能合约漏洞，FP表示错误地检测出智能合约漏洞，FN表示未能检测出智能合约漏洞。通过这三个测量值，可以得出精确度和召回率，其计算公式如下：Precision＝TP/Recall＝TP/检测能力结果。本实施例提供的检测方法针对较为高频的漏洞类型，与Oyente、Mythril以及Vandal进行比较。表9显示了每种工具方法的检测能力，从表中可以看出，本实施例提供的检测方法和Mythril能够检测较多的漏洞类型，涵盖了大多数高频率出现的安全问题。在下文中，针对表3中的漏洞类型对工具进行实验以评估其检测效率。表9漏洞检测能力的比较小数据集测试结果。将本实施例提供的检测方法在第一个数据集上进行测试，并对其进行手动检查，具体漏洞合约数量如表10所示。统计每种工具检测到的漏洞的真阳性、假阳性和假阴性的数量，并计算相应的精确度和召回率，结果如表11、表12所示。表10漏洞合约数量表11评估数据集上不同工具的精确度/＞表11显示了本实施例的精确度以及其他工具的结果。从表中可以看出，与其他工具相比，本实施例提供的检测方法检测每种漏洞的精确度均比其他工具高。其中，Vandal和Mythril检测重入漏洞的精确度分别只有7.6％和17.1％，这是因为Vandal将任何有足够gas且没有锁的调用标记为可重入，而Mythril通过检测调用外部合约后的状态更改来检测可重入，并且将对外部合约的调用作为重入警告，因此产生较多的误报。Oyente将具有两个不同ether流的合约标记为交易顺序依赖漏洞，这是一个较为宽松的标准，例如合约所有者提取合约余额或指定金额，Oyente将此类合约也标记为交易顺序依赖漏洞，因此造成较多的误报。表12评估数据集上不同工具的召回率表12显示了本实施例提供的检测方法的召回率以及其他工具的结果。从表中可以看出，本实施例提供的检测方法的召回率最高。大数据集评估结果。为了验证本实施例提供的检测方法在大数据集中的性能，从Etherscan中获取了10323份真实世界合约进行测试，检测结果如表13所示。表13大数据集检测的漏洞合约数并对已检测出的自毁漏洞以及委托调用漏洞进行了人工验证，在该数据集中成功检测出36个合约具有委托调用漏洞，其中32个合约为真阳性，而Mythril仅能检测出9个合约具有该漏洞。delegatecall函数是一个较为危险的函数，使用msg.data作为其参数意味着攻击者可以调用代理合约的任意函数，从而使用或修改存储变量达到覆盖相关变量的目的，因此使用msg.data作为delegatecall函数的参数存在较大的风险。对于自毁漏洞，共检测出17个合约具有该漏洞，其中11个合约为真阳性，而Mythril以及Vandal仅能检测出少数合约，如表14所示。自毁指令是一个非常敏感的指令，执行该指令之前应该对调用者身份验证，否则将会造成严重的后果。表14自毁漏洞统计结果本实施例还提供了一种智能合约安全漏洞检测系统，参见图11，包括：控制流图生成模块：用于将智能合约字节码经过反编译处理，得到三地址码形式的中间语言，将中间语言分割成若干基本块，根据跳转指令解析若干基本块之间的跳转关系，基于所述跳转关系，创建每个基本块的前继列表和后继列表，将每个基本块连接起来，得到控制流图；Datalog事实生成模块：用于提取控制流图中的合约信息，将合约信息以逻辑关系形式进行存储，获得Datalog事实；检测智能合约安全漏洞模块：基于Datalog事实中，定义前提条件，获得Datalog规则，Datalog规则结合漏洞检测逻辑，分析智能合约，检测智能合约安全漏洞。本实施例还提供一种智能合约安全漏洞检测设备，包括处理器和存储器，其中，所述处理器执行所述存储器中保存的计算机程序时实现上述的一种智能合约安全漏洞检测方法。本实施例还提供一种计算机可读存储介质，用于存储计算机程序，其中，所述计算机程序被处理器执行时实现上述的一种智能合约安全漏洞检测方法。本实施例提供的一种智能合约安全漏洞检测方法，将智能合约字节码反编译处理为三地址码形式的中间语言，并构建智能合约的控制流图，提取控制流图的语义信息并存储为Datalog事实，以更好地表示智能合约的数据和控制流依赖关系，基于Datalog事实定义前提条件，获得Datalog规则，提供漏洞分析框架，分析智能合约的经典漏洞特征，定义漏洞检测逻辑，将漏洞检测逻辑和Datalog规则结合，检测智能合约，输出漏洞结果，该检测方法采用静态程序分析，能够无需执行合约就可以达到比较高的覆盖率，从而检测更多的漏洞，具有低漏报率和高准确率的效果。

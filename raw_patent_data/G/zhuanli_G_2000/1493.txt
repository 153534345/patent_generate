标题title
一种基于脚本语言的安全基线的运行方法和装置
摘要abst
本申请实施例提供了一种基于脚本语言的安全基线的创建方法和装置，该方法包括：改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；所述自定义安全基线代码经编译后，生成编译函数；使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。
权利要求书clms
1.一种基于脚本语言的安全基线的运行方法，其特征在于，所述方法包括：改变沙箱函数内部操作的作用域，将所述作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；所述自定义安全基线代码经编译后，生成编译函数；使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。2.如权利要求1所述的运行方法，其特征在于，所述安全操作子集的形成过程包括：阉割脚本语言的直接访问主机环境的能力，在探针上提供安全函数并进行封装，以形成所述安全操作子集。3.如权利要求2所述的运行方法，其特征在于，所述阉割脚本语言的直接访问主机环境的能力，在探针上提供安全函数并进行封装，以形成所述安全操作子集，具体包括：所述探针对风险操作进行处理，并在所述探针上封装所述安全函数，以形成所述安全操作子集。4.如权利要求1所述的运行方法，其特征在于，所述安全操作子集的基本操作包括访问系统资源的常见操作及对数据的常见操作，其中，所述访问系统资源的常见操作包括读取文件、执行命令、判断字符串及读取注册表；所述对数据的常见操作为功能性需求的操作；所述安全API接口为文件监控、网络连接监控及读取内核参数。5.如权利要求1所述的运行方法，其特征在于，所述预定义沙箱函数还包括约束条件，所述约束条件至少包括：最大运行时间、内存使用量及禁止访问敏感信息。6.如权利要求1所述的运行方法，其特征在于，所述脚本语言为Lua时，所述预定义沙箱函数是通过setfenv函数，将沙箱函数的环境设置为包含所述安全操作子集。7.如权利要求1所述的运行方法，其特征在于，所述自定义安全基线代码经编译后，生成编译函数，具体包括：确定所述自定义安全基线代码是否为二进制字节码；若所述自定义安全基线代码不是二进制字节码，则使用loadstring函数编译所述自定义安全基线代码，生成编译函数。8.如权利要求1所述的运行方法，其特征在于，所述调用函数为pcall函数，所述使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码，具体包括：使用所述pcall函数运行所述编译函数，捕获所述编译函数运行时的错误或异常情况后，运行所述自定义安全基线代码。9.如权利要求1所述的运行方法，其特征在于，所述错误和异常情况包括：记录错误信息、终止程序及输出错误信息。10.一种基于脚本语言的安全基线的运行装置，其特征在于，所述运行装置包括：预定义模块，用于改变沙箱函数内部操作的作用域，将所述作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；代码执行模块，用于基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；编译模块，用于所述自定义安全基线代码经编译后，生成编译函数；执行模块，用于使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。
说明书desc
技术领域本申请各实施例属于网络安全领域，尤其涉及一种基于脚本语言的安全基线的运行方法和装置。背景技术在计算机科学和信息安全领域，系统的安全性至关重要。安全基线是一个定义了系统安全性能的基准值，该基准值包括安全实践、安全配置和安全限制等。为了保证系统的安全性，需要确定适当的安全基线，以帮助保护计算机系统的重要资源和数据。安全基线的运行需要考虑诸多因素，例如系统的复杂性、业务需求、安全实践等，使得安全基线的运行是一个非常复杂且繁琐的工作。传统的安全基线方法往往是预先定义的，因此，传统的安全基线运行方法并不能满足个性化的安全基线的需求。基于此，需要一种新的安全基线的运行方法，以解决现有技术中的问题。发明内容本说明书实施例提供一种基于脚本语言的安全基线的运行方法和装置，以解决部分或者全部问题：传统的安全基线方法往往是预先定义的，因此，传统的安全基线运行方法并不能满足个性化的安全基线的需求。为解决上述技术问题，本说明书实施例是这样实现的：本说明书实施例提供一种基于脚本语言的安全基线的运行方法，所述方法包括：改变沙箱函数内部操作的作用域，将所述作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；所述自定义安全基线代码经编译后，生成编译函数；使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。本说明书实施例还提供一种基于脚本语言的安全基线的运行装置，所述装置包括：预定义模块，用于改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；代码执行模块，用于基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；编译模块，用于所述自定义安全基线代码经编译后，生成编译函数；执行模块，用于使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。本说明书实施例采用的上述至少一个技术方案能够达到以下有益效果：改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数；基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口；所述自定义安全基线代码经编译后，生成编译函数；使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码，能够支持用户自定义安全基线，且能够在高度安全的执行环境中运行，保证待核查项的运行安全，有效防止恶意代码执行危险操作，操作简单、方便。附图说明此处所说明的附图用来提供对本申请的进一步理解，构成本申请的一部分，本申请的示意性实施例及其说明用于解释本申请，并不构成对本申请的不当限定。后文将参照附图以示例性而非限制性的方式详细描述本申请的一些具体实施例。附图中相同的附图标记标示了相同或类似的部件或部分，本领域技术人员应该理解的是，这些附图未必是按比例绘制的，在附图中：图1为本说明书实施例提供的一种系统架构示意图；图2本说明书实施例提供的一种基于脚本语言的安全基线的运行方法示意图；图3为本说明书实施例提供的一种基于脚本语言的安全基线的运行装置的示意图。具体实施方式为了使本技术领域的人员更好地理解本申请方案，下面将结合本申请实施例中的附图，对本申请实施例中的技术方案进行清楚、完整地描述。显然，所描述的实施例仅仅是本申请一部分的实施例，而不是全部的实施例。基于本申请中的实施例，本领域普通技术人员在没有做出创造性劳动前提下所获得的所有其他实施例，都应当属于本申请保护的范围。图1为本说明书实施例提供的一种系统架构示意图。如图1所示，系统架构100可以包括终端设备101、102、103，网络104和服务器105。网络104用以在终端设备101、102、103和服务器105之间提供通信链路的介质。网络104可以包括各种连接类型，例如有线、无线通信链路或者光纤电缆等等。终端设备101、102、103通过网络104与服务器105交互，以接收或发送消息等。终端设备101、102、103上可以安装有各种客户端应用。例如进行基于脚本语言的安全基线运行等专用程序。终端设备101、102、103可以是硬件，也可以是软件。当终端设备101、102、103为硬件时，可以是各种专用或通用的电子设备，包括但不限于智能手机、平板电脑、膝上型便携计算机和台式计算机等等。当终端设备101、102、103为软件时，可以安装在上述所列举的电子设备中。其可以实现成多个软件或软件模块，也可以实现成单个软件或软件模块。服务器105可以是提供各种服务的服务器，例如为终端设备101、102、103上所安装的客户端应用提供服务的后端服务器。例如，服务器可以进行安全基线创建及运行，以便将安全基线运行结果显示在终端设备服务器101、102、103上，服务器也可以进行执行创建的安全基线，以便将执行结果显示在终端设备101、102、103上。服务器105可以是硬件，也可以是软件。当服务器105为硬件时，可以实现为多个服务器组成的分布式服务器集群，也可以实现为单个服务器。当服务器105为软件时，可以实现成多个软件或软件模块，也可以实现成单个软件或软件模块。基于此，本说明书实施例提供一种基于脚本语言的安全基线的创建方法，如图2所示，图2为本说明书实施例提供的一种基于脚本语言的安全基线的运行方法的示意图，该方法包括如下步骤：步骤S201：改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数。沙箱是一个可以限制脚本访问资源的隔离环境，以确保资源安全。沙箱可以限制脚本的访问权限，提高自定义代码的便捷性和出现意外错误时的稳定性，以及提高编写复杂操作的易用性，减少恶意脚本的威胁。基于此，本说明书实施例预定义沙箱函数，以用于后续自定义安全基线代码的编写。在本说明书的一个实施例中，脚本语言为Lua，所述改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境向所述上下文环境中注入安全操作子集，作为预定义沙箱函数，具体包括：将沙箱函数的顶层table替换为空table，向所述空table中注入安全操作子集，作为预定义沙箱函数。在本说明书实施例中，脚本函数为Lua语言时，所述预定义沙箱函数是通过setfenv函数，将沙箱函数的环境设置为包含所述安全操作子集。setfenv函数用于设置函数环境，其表达式为setfenv，其中，当第一个参数为一个函数时，表示设置该函数的环境，当第一个参数为一个数字时，为1代表当前函数，2代表调用自己的函数，3代表调用自己的函数，以此类推。在本说明书实施例中，脚本函数为Lua语言时，函数的环境，其实一个环境就是一个表，该函数被限定为只能访问该表中的域，或在函数体内自己定义的变量。在本说明书实施例中，预定义沙箱函数在设置的安全环境中注入安全操作子集，预定义沙箱函数还包括约束条件，所述约束条件至少包括：最大运行时间，内存使用量，禁止访问敏感信息。在本说明书实施例中，最大运行时间为1小时，内存使用量为小于等于200M，禁止访问敏感信息是指禁止直接访问敏感信息，只能通过安全API接口访问敏感信息。在本说明书实施例中，所述安全操作子集的形成过程包括：阉割脚本语言的直接访问主机环境的能力，在探针上提供安全函数并进行封装，以形成所述安全操作子集。脚本语言一种编写脚本的语言，用于定义和实现自定义基线。脚本语言具有可编程能力，可以用于实现复杂和多样的自定义基线。在本说明书实施例中，脚本语言为Lua语言。阉割脚本语言的直接访问主机环境的能力是指去除脚本语言的一些不支持的操作。在本说明书实施例中，所述阉割脚本语言的直接访问主机环境的能力，在探针上提供安全函数并进行封装，以形成所述安全操作子集，具体包括：所述探针的风险操作进行处理，并在所述探针上封装所述安全函数，以形成所述安全操作子集。在本说明书实施例中，风险操作为不安全函数，具体的，不安全函数可以为：collectgarbage、dofile、_G等。不安全函数可以根据业务场景而定，且不安全函数可以为动态变化的。步骤S203：基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口。在本说明书实施例中，所述安全操作子集的基本操作包括访问系统资源的常见操作及对数据的常见操作。具体而言，常见操作包括读取文件，执行命令，判断字符串，读取注册表；对数据的常见操作，例如编解码等功能性需求。在本说明书实施例中，安全API接口为文件监控、网络连接监控、读取内核参数等强安全相关的高级操作。在本说明书实施例中，基于预定义沙箱函数，自定义安全基线代码，其实是指基于预定义沙箱函数的环境函数及安全操作子集，编写待核查项对应的安全基线代码。由于预定义沙箱函数限定了环境函数及安全操作子集，能够保证安全基线代码的安全性及可操作性。需要特别说明的是，自定义安全基线代码的具体内容，需要根据待核查项而定。在本说明书的一个实施例中，使用Lua编写自定义基线核查项函数，例如：--检查操作系统版本是否符合要求function check_os_versionlocal os_version = os.versionif os_version ~= "Windows 10" and os_version ~= "Windows Server 2019"thenreturn "OS version does not meet the requirements"endend在该示例中，代码片段中的os.version取操作系统版本的操作和通过引入socket使用tcp连接能力都是探针提供的安全操作子集中能力，对使用方式和接口能力范围有严格的限制，不同于编程语言标准库或一般性的第三方库。再例如：--检查端口是否开放function check_port_openlocal socket = requirelocal tcp = socket.tcptcp:settimeoutlocal result, err = tcp:connectif result == nil thenreturn "Port " .. port .. " is closed"endend用户将编写好的Lua代码上传到前端，前端将代码存储到后端数据库中。后端数据库中存储了所有用户上传的自定义安全基线代码，同时存储了与这些代码相关的一些元数据，例如代码的名称、描述、作者、上传时间等信息。步骤S205：所述自定义安全基线代码经编译后，生成编译函数。在本说明书实施例中，所述自定义安全基线代码经编译后，生成编译函数，具体包括：确定所述自定义安全基线代码是否为二进制字节码；若所述自定义安全基线代码不是二进制字节码，则使用loadstring函数编译所述自定义安全基线代码，生成编译函数。在本说明书实施例中，若自定义安全基线代码是二进制字节码，则禁止执行该自定义安全基线代码。loadstring函数是指资源里加载字符串到CString对象。loadstring函数的作用在于将自定义安全基线代码编译成可执行的函数，并返回该可执行函数，该编译函数可以被调用执行，从而实现动态加载代码的功能。在本说明书实施例中，生成编译函数后，进一步包括：采用setfenv函数，将所述编译函数的环境设置为所述预定义沙箱函数，从而保证编译函数具备相应的安全能力的同时，确保该编译函数不被恶意破坏。步骤S207：使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。在本说明书实施例中，所述调用函数为pcall函数，所述使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码，具体包括：使用所述pcall函数运行所述编译函数，捕获所述编译函数运行时的错误或异常情况后，运行所述自定义安全基线代码。在本说明书实施例中，所述错误和异常情况包括：记录错误信息，终止程序，输出错误信息。pcall函数是一种特殊的调用函数，用于捕获运行时的错误和异常情况，能够实现在程序崩溃之前，记录错误和异常情况，以便更好地排查问题。在本说明书实施例中，使用pcall函数包装编译函数，在运行时，出现错误或异常情况，pcall函数则会返回false和错误信息，否则会返回true和函数返回值。在获得pcall函数返回的false和错误信息后，能够根据返回结果进行错误或异常处理，例如记录错误信息、终止程序、输出错误信息。在进行待核查项核查时，后端从数据库中获取待核查项对应的自定义安全基线代码，并将代码发送给探针。探针使用loadstring函数，将接收到待核查项对应的自定义安全基线代码编译成编译函数，随后使用setfenv函数将编译函数的环境设置为注入了安全操作子集的table。注入了安全操作子集的table是通过如下方法实现的：创建一个沙箱函数，将该函数的顶层table替换为空table，为该空table注入安全操作子集，以完成运行环境的设置。在该实施例中，创建了一个空的table sandbox，并将其作为沙箱的运行环境。然后，通过剔除不安全的函数并封装安全的函数成一个table的方式创建了一个安全操作子集safe_funcs，并将其注入到沙箱环境中。随后，使用loadstring函数将用户提供的代码编译成一个函数，并使用setfenv函数将其环境设置为sandbox。最后，使用pcall函数运行编译后的函数，以捕获运行时的错误和异常情况，从而实现使用Lua编写并安全地执行用户自定义代码。采用本说明书实施例提供的方法，能够支持用户自定义安全基线，且能够在高度安全的执行环境中运行，保证待核查项的运行安全，提高自定义代码的便捷性和出现意外错误时的稳定性，以及提高编写复杂操作的易用性。本说明书实施例提供了一种基于脚本语言的安全基线的运行方法，基于同样的思路，本说明书实施例提供一种基于脚本语言的安全基线的运行装置。图3为本说明书实施例提供的一种基于脚本语言的安全基线的运行装置的示意图，如图3所示，该装置包括：预定义模块301，用于改变沙箱函数内部操作的作用域，将所述沙箱操作的作用域变更为一个空的上下文环境，向所述上下文环境中注入安全操作子集，作为预定义沙箱函数。代码执行模块303，用于基于所述预定义沙箱函数，自定义安全基线代码，所述预定义沙箱函数包含安全操作子集，所述安全操作子集至少包括：基本操作及探针提供的安全API接口。编译模块305，用于所述自定义安全基线代码经编译后，生成编译函数。执行模块307，用于使用调用函数运行所述编译函数，捕获运行时的错误或异常情况后，运行所述自定义安全基线代码。最后应说明的是：以上各实施例仅用以说明本申请的技术方案，而非对其限制；尽管参照前述各实施例对本申请进行了详细的说明，本领域的普通技术人员应当理解：其依然可以对前述各实施例所记载的技术方案进行修改，或者对其中部分或者全部技术特征进行等同替换；而这些修改或者替换，并不使相应技术方案的本质脱离本申请各实施例技术方案的范围。
